
btbr.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000a230  00004000  00004000  00004000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  0000e230  0000e230  0000e230  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .persistent   00000020  10000000  10000000  00020000  2**0
                  ALLOC
  3 .data         00000161  10000020  0000e238  00010020  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          00002464  10000188  0000e399  00010188  2**3
                  ALLOC
  5 .ARM.attributes 00000029  00000000  00000000  00010181  2**0
                  CONTENTS, READONLY
  6 .comment      000000a7  00000000  00000000  000101aa  2**0
                  CONTENTS, READONLY
  7 .debug_info   00028e30  00000000  00000000  00010251  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_abbrev 000085f2  00000000  00000000  00039081  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_loc    00013097  00000000  00000000  00041673  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_aranges 00000c08  00000000  00000000  00054710  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_line   000102f8  00000000  00000000  00055318  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_str    0000539f  00000000  00000000  00065610  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_frame  00001fec  00000000  00000000  0006a9b0  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_ranges 00003430  00000000  00000000  0006c99c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00004000 <_NVIC_Handler_Functions>:
    4000:	e0 3f 00 10 b1 97 00 00 05 98 00 00 5d 80 00 00     .?..........]...
    4010:	85 80 00 00 ad 80 00 00 d5 80 00 00 00 00 00 00     ................
    4020:	00 00 00 00 00 00 00 00 00 00 00 00 05 98 00 00     ................
    4030:	05 98 00 00 00 00 00 00 05 98 00 00 05 98 00 00     ................
    4040:	05 98 00 00 a1 5a 00 00 05 98 00 00 05 98 00 00     .....Z..........
    4050:	05 98 00 00 05 98 00 00 05 98 00 00 05 98 00 00     ................
    4060:	05 98 00 00 05 98 00 00 05 98 00 00 05 98 00 00     ................
    4070:	05 98 00 00 05 98 00 00 05 98 00 00 05 98 00 00     ................
    4080:	05 98 00 00 05 98 00 00 05 98 00 00 05 98 00 00     ................
    4090:	05 98 00 00 7d 7a 00 00 05 98 00 00 05 98 00 00     ....}z..........
    40a0:	ad 97 00 00 05 98 00 00 fd 95 00 00 05 98 00 00     ................
    40b0:	05 98 00 00 05 98 00 00 05 98 00 00 05 98 00 00     ................
    40c0:	05 98 00 00 05 98 00 00 05 98 00 00                 ............

000040cc <deregister_tm_clones>:
    40cc:	4803      	ldr	r0, [pc, #12]	; (40dc <deregister_tm_clones+0x10>)
    40ce:	4b04      	ldr	r3, [pc, #16]	; (40e0 <deregister_tm_clones+0x14>)
    40d0:	4283      	cmp	r3, r0
    40d2:	d002      	beq.n	40da <deregister_tm_clones+0xe>
    40d4:	4b03      	ldr	r3, [pc, #12]	; (40e4 <deregister_tm_clones+0x18>)
    40d6:	b103      	cbz	r3, 40da <deregister_tm_clones+0xe>
    40d8:	4718      	bx	r3
    40da:	4770      	bx	lr
    40dc:	10000184 	.word	0x10000184
    40e0:	10000184 	.word	0x10000184
    40e4:	00000000 	.word	0x00000000

000040e8 <register_tm_clones>:
    40e8:	4805      	ldr	r0, [pc, #20]	; (4100 <register_tm_clones+0x18>)
    40ea:	4906      	ldr	r1, [pc, #24]	; (4104 <register_tm_clones+0x1c>)
    40ec:	1a0b      	subs	r3, r1, r0
    40ee:	0fd9      	lsrs	r1, r3, #31
    40f0:	eb01 01a3 	add.w	r1, r1, r3, asr #2
    40f4:	1049      	asrs	r1, r1, #1
    40f6:	d002      	beq.n	40fe <register_tm_clones+0x16>
    40f8:	4b03      	ldr	r3, [pc, #12]	; (4108 <register_tm_clones+0x20>)
    40fa:	b103      	cbz	r3, 40fe <register_tm_clones+0x16>
    40fc:	4718      	bx	r3
    40fe:	4770      	bx	lr
    4100:	10000184 	.word	0x10000184
    4104:	10000184 	.word	0x10000184
    4108:	00000000 	.word	0x00000000

0000410c <__do_global_dtors_aux>:
    410c:	b510      	push	{r4, lr}
    410e:	4c06      	ldr	r4, [pc, #24]	; (4128 <__do_global_dtors_aux+0x1c>)
    4110:	7823      	ldrb	r3, [r4, #0]
    4112:	b943      	cbnz	r3, 4126 <__do_global_dtors_aux+0x1a>
    4114:	f7ff ffda 	bl	40cc <deregister_tm_clones>
    4118:	4b04      	ldr	r3, [pc, #16]	; (412c <__do_global_dtors_aux+0x20>)
    411a:	b113      	cbz	r3, 4122 <__do_global_dtors_aux+0x16>
    411c:	4804      	ldr	r0, [pc, #16]	; (4130 <__do_global_dtors_aux+0x24>)
    411e:	f3af 8000 	nop.w
    4122:	2301      	movs	r3, #1
    4124:	7023      	strb	r3, [r4, #0]
    4126:	bd10      	pop	{r4, pc}
    4128:	10000188 	.word	0x10000188
    412c:	00000000 	.word	0x00000000
    4130:	0000e210 	.word	0x0000e210

00004134 <frame_dummy>:
    4134:	b508      	push	{r3, lr}
    4136:	4b04      	ldr	r3, [pc, #16]	; (4148 <frame_dummy+0x14>)
    4138:	b11b      	cbz	r3, 4142 <frame_dummy+0xe>
    413a:	4904      	ldr	r1, [pc, #16]	; (414c <frame_dummy+0x18>)
    413c:	4804      	ldr	r0, [pc, #16]	; (4150 <frame_dummy+0x1c>)
    413e:	f3af 8000 	nop.w
    4142:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    4146:	e7cf      	b.n	40e8 <register_tm_clones>
    4148:	00000000 	.word	0x00000000
    414c:	1000018c 	.word	0x1000018c
    4150:	0000e210 	.word	0x0000e210

00004154 <__libc_init_array>:
    4154:	b570      	push	{r4, r5, r6, lr}
    4156:	4e0d      	ldr	r6, [pc, #52]	; (418c <__libc_init_array+0x38>)
    4158:	4d0d      	ldr	r5, [pc, #52]	; (4190 <__libc_init_array+0x3c>)
    415a:	1b76      	subs	r6, r6, r5
    415c:	10b6      	asrs	r6, r6, #2
    415e:	d006      	beq.n	416e <__libc_init_array+0x1a>
    4160:	2400      	movs	r4, #0
    4162:	3401      	adds	r4, #1
    4164:	f855 3b04 	ldr.w	r3, [r5], #4
    4168:	4798      	blx	r3
    416a:	42a6      	cmp	r6, r4
    416c:	d1f9      	bne.n	4162 <__libc_init_array+0xe>
    416e:	4e09      	ldr	r6, [pc, #36]	; (4194 <__libc_init_array+0x40>)
    4170:	4d09      	ldr	r5, [pc, #36]	; (4198 <__libc_init_array+0x44>)
    4172:	f00a f84d 	bl	e210 <_init>
    4176:	1b76      	subs	r6, r6, r5
    4178:	10b6      	asrs	r6, r6, #2
    417a:	d006      	beq.n	418a <__libc_init_array+0x36>
    417c:	2400      	movs	r4, #0
    417e:	3401      	adds	r4, #1
    4180:	f855 3b04 	ldr.w	r3, [r5], #4
    4184:	4798      	blx	r3
    4186:	42a6      	cmp	r6, r4
    4188:	d1f9      	bne.n	417e <__libc_init_array+0x2a>
    418a:	bd70      	pop	{r4, r5, r6, pc}
    418c:	0000e21c 	.word	0x0000e21c
    4190:	0000e21c 	.word	0x0000e21c
    4194:	0000e220 	.word	0x0000e220
    4198:	0000e21c 	.word	0x0000e21c

0000419c <memset>:
    419c:	b4f0      	push	{r4, r5, r6, r7}
    419e:	0786      	lsls	r6, r0, #30
    41a0:	d046      	beq.n	4230 <memset+0x94>
    41a2:	1e54      	subs	r4, r2, #1
    41a4:	2a00      	cmp	r2, #0
    41a6:	d03c      	beq.n	4222 <memset+0x86>
    41a8:	b2ca      	uxtb	r2, r1
    41aa:	4603      	mov	r3, r0
    41ac:	e002      	b.n	41b4 <memset+0x18>
    41ae:	f114 34ff 	adds.w	r4, r4, #4294967295	; 0xffffffff
    41b2:	d336      	bcc.n	4222 <memset+0x86>
    41b4:	f803 2b01 	strb.w	r2, [r3], #1
    41b8:	079d      	lsls	r5, r3, #30
    41ba:	d1f8      	bne.n	41ae <memset+0x12>
    41bc:	2c03      	cmp	r4, #3
    41be:	d929      	bls.n	4214 <memset+0x78>
    41c0:	b2cd      	uxtb	r5, r1
    41c2:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    41c6:	2c0f      	cmp	r4, #15
    41c8:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    41cc:	d933      	bls.n	4236 <memset+0x9a>
    41ce:	f1a4 0610 	sub.w	r6, r4, #16
    41d2:	0936      	lsrs	r6, r6, #4
    41d4:	f103 0720 	add.w	r7, r3, #32
    41d8:	eb07 1706 	add.w	r7, r7, r6, lsl #4
    41dc:	f103 0210 	add.w	r2, r3, #16
    41e0:	e942 5504 	strd	r5, r5, [r2, #-16]
    41e4:	e942 5502 	strd	r5, r5, [r2, #-8]
    41e8:	3210      	adds	r2, #16
    41ea:	42ba      	cmp	r2, r7
    41ec:	d1f8      	bne.n	41e0 <memset+0x44>
    41ee:	1c72      	adds	r2, r6, #1
    41f0:	f014 0f0c 	tst.w	r4, #12
    41f4:	eb03 1202 	add.w	r2, r3, r2, lsl #4
    41f8:	f004 060f 	and.w	r6, r4, #15
    41fc:	d013      	beq.n	4226 <memset+0x8a>
    41fe:	1f33      	subs	r3, r6, #4
    4200:	f023 0303 	bic.w	r3, r3, #3
    4204:	3304      	adds	r3, #4
    4206:	4413      	add	r3, r2
    4208:	f842 5b04 	str.w	r5, [r2], #4
    420c:	4293      	cmp	r3, r2
    420e:	d1fb      	bne.n	4208 <memset+0x6c>
    4210:	f006 0403 	and.w	r4, r6, #3
    4214:	b12c      	cbz	r4, 4222 <memset+0x86>
    4216:	b2c9      	uxtb	r1, r1
    4218:	441c      	add	r4, r3
    421a:	f803 1b01 	strb.w	r1, [r3], #1
    421e:	429c      	cmp	r4, r3
    4220:	d1fb      	bne.n	421a <memset+0x7e>
    4222:	bcf0      	pop	{r4, r5, r6, r7}
    4224:	4770      	bx	lr
    4226:	4634      	mov	r4, r6
    4228:	4613      	mov	r3, r2
    422a:	2c00      	cmp	r4, #0
    422c:	d1f3      	bne.n	4216 <memset+0x7a>
    422e:	e7f8      	b.n	4222 <memset+0x86>
    4230:	4614      	mov	r4, r2
    4232:	4603      	mov	r3, r0
    4234:	e7c2      	b.n	41bc <memset+0x20>
    4236:	461a      	mov	r2, r3
    4238:	4626      	mov	r6, r4
    423a:	e7e0      	b.n	41fe <memset+0x62>

0000423c <bbpkt_fhs_prepare_payload>:

/* Encode static fields of fhs payload */
void bbpkt_fhs_prepare_payload(
	uint8_t *data, uint64_t parity, uint32_t lap, uint8_t uap, 
	uint16_t nap, uint32_t cls, uint8_t ltaddr, uint8_t has_eir)
{
    423c:	b470      	push	{r4, r5, r6}
    423e:	f89d 4020 	ldrb.w	r4, [sp, #32]
    4242:	9903      	ldr	r1, [sp, #12]
	data[3] = 0xff & (parity>>24);
	data[4] = (0x3 & (parity>>32)) | (0xfc & (lap<<2));
	data[5] = 0xff & (lap >> 6);
	data[6] = 0xff & (lap >> 14);
	data[7] = (0x03 & (lap >> 22))
		| ((has_eir&1) << 2) 	// EIR
    4244:	00a4      	lsls	r4, r4, #2
    4246:	f004 0504 	and.w	r5, r4, #4
	data[7] = (0x03 & (lap >> 22))
    424a:	f3c1 5481 	ubfx	r4, r1, #22, #2
		| ((has_eir&1) << 2) 	// EIR
    424e:	432c      	orrs	r4, r5
	data[1] = 0xff & (parity>>8);
    4250:	0a15      	lsrs	r5, r2, #8
	data[4] = (0x3 & (parity>>32)) | (0xfc & (lap<<2));
    4252:	f003 0303 	and.w	r3, r3, #3
	data[0] = 0xff & parity;
    4256:	7002      	strb	r2, [r0, #0]
	data[1] = 0xff & (parity>>8);
    4258:	7045      	strb	r5, [r0, #1]
	data[2] = 0xff & (parity>>16);
    425a:	0c15      	lsrs	r5, r2, #16
	data[3] = 0xff & (parity>>24);
    425c:	0e12      	lsrs	r2, r2, #24
	data[4] = (0x3 & (parity>>32)) | (0xfc & (lap<<2));
    425e:	ea43 0381 	orr.w	r3, r3, r1, lsl #2
	data[3] = 0xff & (parity>>24);
    4262:	70c2      	strb	r2, [r0, #3]
	data[5] = 0xff & (lap >> 6);
    4264:	098a      	lsrs	r2, r1, #6
{
    4266:	f8bd 6014 	ldrh.w	r6, [sp, #20]
	data[2] = 0xff & (parity>>16);
    426a:	7085      	strb	r5, [r0, #2]
	data[4] = (0x3 & (parity>>32)) | (0xfc & (lap<<2));
    426c:	7103      	strb	r3, [r0, #4]
{
    426e:	9d06      	ldr	r5, [sp, #24]
	data[6] = 0xff & (lap >> 14);
    4270:	0b8b      	lsrs	r3, r1, #14
	data[5] = 0xff & (lap >> 6);
    4272:	7142      	strb	r2, [r0, #5]
{
    4274:	f89d 2010 	ldrb.w	r2, [sp, #16]
//		| (0 << 3) 	// RES = 0
		| (1 << 4) 	// SR = 1
		| (2 << 6);	// SP = 2
    4278:	f064 046f 	orn	r4, r4, #111	; 0x6f
	data[6] = 0xff & (lap >> 14);
    427c:	7183      	strb	r3, [r0, #6]
{
    427e:	f89d 301c 	ldrb.w	r3, [sp, #28]
	data[8] = uap;
	data[9] = 0xff & nap;
	data[10] = 0xff & (nap>>8);
	data[11] = 0xff & (cls);
	data[12] = 0xff & (cls>>8);
    4282:	0a29      	lsrs	r1, r5, #8
	data[7] = (0x03 & (lap >> 22))
    4284:	71c4      	strb	r4, [r0, #7]
	data[8] = uap;
    4286:	7202      	strb	r2, [r0, #8]
	data[10] = 0xff & (nap>>8);
    4288:	0a34      	lsrs	r4, r6, #8
	data[13] = 0xff & (cls>>16);
    428a:	0c2a      	lsrs	r2, r5, #16
	data[9] = 0xff & nap;
    428c:	7246      	strb	r6, [r0, #9]
	data[10] = 0xff & (nap>>8);
    428e:	7284      	strb	r4, [r0, #10]
	data[11] = 0xff & (cls);
    4290:	72c5      	strb	r5, [r0, #11]
	data[12] = 0xff & (cls>>8);
    4292:	7301      	strb	r1, [r0, #12]
	data[13] = 0xff & (cls>>16);
    4294:	7342      	strb	r2, [r0, #13]
	// 3 low bits are ltaddr
	data[14] = ltaddr;
    4296:	7383      	strb	r3, [r0, #14]
}
    4298:	bc70      	pop	{r4, r5, r6}
    429a:	4770      	bx	lr

0000429c <bbpkt_fhs_finalize_payload>:
 * compute crc
 * whiten 
 * write the fec23 encoded payload in air_data
 */
void bbpkt_fhs_finalize_payload(uint8_t *fhs_data, uint32_t clk27_2)
{
    429c:	b410      	push	{r4}
	uint8_t tmp[20];
	uint16_t crc;
	fhs_data[14] = (fhs_data[14]&7) | (0xf8 & (clk27_2<<3));
    429e:	7b83      	ldrb	r3, [r0, #14]
	fhs_data[15] = 0xff & (clk27_2>>5);
    42a0:	094c      	lsrs	r4, r1, #5
	fhs_data[14] = (fhs_data[14]&7) | (0xf8 & (clk27_2<<3));
    42a2:	f003 0307 	and.w	r3, r3, #7
    42a6:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
	fhs_data[16] = 0xff & (clk27_2>>13);
    42aa:	0b4a      	lsrs	r2, r1, #13
	// 3 high bits are psmode = 0
	fhs_data[17] = 0x1f & (clk27_2>>21);
    42ac:	f3c1 5144 	ubfx	r1, r1, #21, #5
	fhs_data[15] = 0xff & (clk27_2>>5);
    42b0:	73c4      	strb	r4, [r0, #15]
	fhs_data[14] = (fhs_data[14]&7) | (0xf8 & (clk27_2<<3));
    42b2:	7383      	strb	r3, [r0, #14]
}
    42b4:	bc10      	pop	{r4}
	fhs_data[16] = 0xff & (clk27_2>>13);
    42b6:	7402      	strb	r2, [r0, #16]
	fhs_data[17] = 0x1f & (clk27_2>>21);
    42b8:	7441      	strb	r1, [r0, #17]
}
    42ba:	4770      	bx	lr

000042bc <bbpkt_decode_fhs>:
 * 0     4                    8             14                      18   20
 * |  34   | 24 | 1 | 1 |2 |2 | 8 |16 | 24  |  3   |26  |      3     |16 |
 * |Parity | Lap|EIR|Res|SR|SP|UAP|NAP|Class|ltaddr|clk2|PageScanMode|CRC|
 */
void bbpkt_decode_fhs(uint8_t *data, fhs_info_t *info)
{
    42bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	/* 34 low bits of syncword */
	//parity = 0x3ffffffff & (data[0]|(data[1]<<8)|(data[2]<<16)|(data[3]<<24)|((uint64_t)(data[4]&3)<<32));

	/* 24 low bits of address */
	lap = (data[4]>>2)|(data[5]<<6)|(data[6]<<14)|((data[7]&3)<<22);
    42c0:	7943      	ldrb	r3, [r0, #5]
    42c2:	7905      	ldrb	r5, [r0, #4]
    42c4:	7984      	ldrb	r4, [r0, #6]
    42c6:	79c2      	ldrb	r2, [r0, #7]
    42c8:	019b      	lsls	r3, r3, #6
    42ca:	ea43 0395 	orr.w	r3, r3, r5, lsr #2
    42ce:	ea43 3384 	orr.w	r3, r3, r4, lsl #14
    42d2:	0592      	lsls	r2, r2, #22
	// sp =  3&(data[7]>>6);	// Must be 2
	uap = data[8];
	nap = data[9]|((uint16_t)data[10]<<8);
	//cls = data[11]|((uint32_t)data[12]<<8)|((uint32_t)data[13]<<16);
	ltaddr = data[14]&7;
	clk27_2 = (data[14]>>3)|(data[15]<<5)|(data[16]<<13)|((data[17]&0x1f)<<21);
    42d4:	7c44      	ldrb	r4, [r0, #17]
	ltaddr = data[14]&7;
    42d6:	7b86      	ldrb	r6, [r0, #14]
	lap = (data[4]>>2)|(data[5]<<6)|(data[6]<<14)|((data[7]&3)<<22);
    42d8:	f402 0240 	and.w	r2, r2, #12582912	; 0xc00000
	clk27_2 = (data[14]>>3)|(data[15]<<5)|(data[16]<<13)|((data[17]&0x1f)<<21);
    42dc:	f890 c00f 	ldrb.w	ip, [r0, #15]
	lap = (data[4]>>2)|(data[5]<<6)|(data[6]<<14)|((data[7]&3)<<22);
    42e0:	4313      	orrs	r3, r2
	clk27_2 = (data[14]>>3)|(data[15]<<5)|(data[16]<<13)|((data[17]&0x1f)<<21);
    42e2:	0562      	lsls	r2, r4, #21
	//psmode = data[17]>>5;

	info->bdaddr = (lap|((uint64_t)uap<<24)|((uint64_t)nap<<32));
    42e4:	f890 8008 	ldrb.w	r8, [r0, #8]
	clk27_2 = (data[14]>>3)|(data[15]<<5)|(data[16]<<13)|((data[17]&0x1f)<<21);
    42e8:	7c07      	ldrb	r7, [r0, #16]
	nap = data[9]|((uint16_t)data[10]<<8);
    42ea:	f890 e00a 	ldrb.w	lr, [r0, #10]
	clk27_2 = (data[14]>>3)|(data[15]<<5)|(data[16]<<13)|((data[17]&0x1f)<<21);
    42ee:	f002 7478 	and.w	r4, r2, #65011712	; 0x3e00000
	nap = data[9]|((uint16_t)data[10]<<8);
    42f2:	7a40      	ldrb	r0, [r0, #9]
	clk27_2 = (data[14]>>3)|(data[15]<<5)|(data[16]<<13)|((data[17]&0x1f)<<21);
    42f4:	08f2      	lsrs	r2, r6, #3
    42f6:	ea42 124c 	orr.w	r2, r2, ip, lsl #5
	info->bdaddr = (lap|((uint64_t)uap<<24)|((uint64_t)nap<<32));
    42fa:	ea4f 7be3 	mov.w	fp, r3, asr #31
	nap = data[9]|((uint16_t)data[10]<<8);
    42fe:	ea40 200e 	orr.w	r0, r0, lr, lsl #8
	clk27_2 = (data[14]>>3)|(data[15]<<5)|(data[16]<<13)|((data[17]&0x1f)<<21);
    4302:	ea42 3247 	orr.w	r2, r2, r7, lsl #13
    4306:	4322      	orrs	r2, r4
	info->bdaddr = (lap|((uint64_t)uap<<24)|((uint64_t)nap<<32));
    4308:	ea43 6308 	orr.w	r3, r3, r8, lsl #24
	ltaddr = data[14]&7;
    430c:	f006 0407 	and.w	r4, r6, #7
	info->bdaddr = (lap|((uint64_t)uap<<24)|((uint64_t)nap<<32));
    4310:	ea40 000b 	orr.w	r0, r0, fp
    4314:	600b      	str	r3, [r1, #0]
	info->clk27_2= clk27_2;;
    4316:	608a      	str	r2, [r1, #8]
	info->lt_addr = ltaddr;
    4318:	730c      	strb	r4, [r1, #12]
	info->bdaddr = (lap|((uint64_t)uap<<24)|((uint64_t)nap<<32));
    431a:	6048      	str	r0, [r1, #4]

	//BB_DEBUG("Valid fhs: parity = %llx, bdaddr=%04x:%02x:%06x\n", (unsigned long long)parity, nap, uap, lap);
	//BB_DEBUG("\teir=%d, res=%d, sr=%d, sp=%d, ltaddr=%d, clk27=%d, cls=0x%x, psmode=%d\n", eir, res, sr, sp, ltaddr, clk27_2, cls, psmode);
}
    431c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00004320 <btbb_gen_syncword>:
        0x00000203ef526bd1ULL, 0x000001033511ab3cULL, 0x000000819a88d59eULL, 0x00000040cd446acfULL,
        0x00000022a41aabb3ULL, 0x0000001390b5cb0dULL, 0x0000000b0ae27b52ULL, 0x0000000585713da9ULL};

/* Generate Sync Word from an LAP */
uint64_t btbb_gen_syncword(const uint32_t LAP)
{
    4320:	b4f0      	push	{r4, r5, r6, r7}
        int i;
        uint64_t codeword = DEFAULT_CODEWORD;

        /* the sync word generated is in host order, not air order */
        for (i = 0; i < 24; i++)
    4322:	2300      	movs	r3, #0
                if (LAP & (0x800000 >> i))
    4324:	f44f 0600 	mov.w	r6, #8388608	; 0x800000
{
    4328:	4605      	mov	r5, r0
    432a:	4c09      	ldr	r4, [pc, #36]	; (4350 <btbb_gen_syncword+0x30>)
        uint64_t codeword = DEFAULT_CODEWORD;
    432c:	4809      	ldr	r0, [pc, #36]	; (4354 <btbb_gen_syncword+0x34>)
    432e:	490a      	ldr	r1, [pc, #40]	; (4358 <btbb_gen_syncword+0x38>)
                if (LAP & (0x800000 >> i))
    4330:	fa46 f203 	asr.w	r2, r6, r3
    4334:	422a      	tst	r2, r5
    4336:	f103 0301 	add.w	r3, r3, #1
    433a:	d003      	beq.n	4344 <btbb_gen_syncword+0x24>
                        codeword ^= sw_matrix[i];
    433c:	e9d4 7200 	ldrd	r7, r2, [r4]
    4340:	4078      	eors	r0, r7
    4342:	4051      	eors	r1, r2
        for (i = 0; i < 24; i++)
    4344:	2b18      	cmp	r3, #24
    4346:	f104 0408 	add.w	r4, r4, #8
    434a:	d1f1      	bne.n	4330 <btbb_gen_syncword+0x10>

        return codeword;
}
    434c:	bcf0      	pop	{r4, r5, r6, r7}
    434e:	4770      	bx	lr
    4350:	0000c810 	.word	0x0000c810
    4354:	c7820e7e 	.word	0xc7820e7e
    4358:	b0000002 	.word	0xb0000002

0000435c <bbcodec_decode_header>:
		codec->t = &bbcodec_acl_types[0];
	}
}

int bbcodec_decode_header(bbcodec_t *codec, bbhdr_t *out_hdr, uint8_t *in_data)
{
    435c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4360:	b085      	sub	sp, #20
	uint32_t v0, v1, v2, v3, v4, v5, v6,v7,v8;
	/* Skip 4 bits of trailer */
	uint8_t *in = pkt_data;

	/* 9 lut accesses */
	v0 = unfec13_tbl[EXTRACT6_4(in+0)]; 	// b0
    4362:	f892 e001 	ldrb.w	lr, [r2, #1]
    4366:	4e5f      	ldr	r6, [pc, #380]	; (44e4 <bbcodec_decode_header+0x188>)
	v1 = unfec13_tbl[EXTRACT6_2(in+1)];	// b1
	v2 = unfec13_tbl[EXTRACT6_0(in+2)]; 	// b2
	v3 = unfec13_tbl[EXTRACT6_6(in+2)];	
	v4 = unfec13_tbl[EXTRACT6_4(in+3)];	// b3
    4368:	7917      	ldrb	r7, [r2, #4]
	v1 = unfec13_tbl[EXTRACT6_2(in+1)];	// b1
    436a:	ea4f 059e 	mov.w	r5, lr, lsr #2
    436e:	f836 a015 	ldrh.w	sl, [r6, r5, lsl #1]
	v5 = unfec13_tbl[EXTRACT6_2(in+4)];	// b4
    4372:	08bd      	lsrs	r5, r7, #2
	v4 = unfec13_tbl[EXTRACT6_4(in+3)];	// b3
    4374:	013f      	lsls	r7, r7, #4
    4376:	f007 0730 	and.w	r7, r7, #48	; 0x30
    437a:	9101      	str	r1, [sp, #4]
    437c:	4639      	mov	r1, r7
	v2 = unfec13_tbl[EXTRACT6_0(in+2)]; 	// b2
    437e:	f892 b002 	ldrb.w	fp, [r2, #2]
	v3 = unfec13_tbl[EXTRACT6_6(in+2)];	
    4382:	f892 c003 	ldrb.w	ip, [r2, #3]
	v6 = unfec13_tbl[EXTRACT6_0(in+5)];	// b5
    4386:	f892 9005 	ldrb.w	r9, [r2, #5]
	v2 = unfec13_tbl[EXTRACT6_0(in+2)]; 	// b2
    438a:	f00b 043f 	and.w	r4, fp, #63	; 0x3f
	v3 = unfec13_tbl[EXTRACT6_6(in+2)];	
    438e:	ea4f 078c 	mov.w	r7, ip, lsl #2
	v0 = unfec13_tbl[EXTRACT6_4(in+0)]; 	// b0
    4392:	7813      	ldrb	r3, [r2, #0]
	v2 = unfec13_tbl[EXTRACT6_0(in+2)]; 	// b2
    4394:	f836 4014 	ldrh.w	r4, [r6, r4, lsl #1]
	v0 = unfec13_tbl[EXTRACT6_4(in+0)]; 	// b0
    4398:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
	v3 = unfec13_tbl[EXTRACT6_6(in+2)];	
    439c:	f007 073c 	and.w	r7, r7, #60	; 0x3c
	v5 = unfec13_tbl[EXTRACT6_2(in+4)];	// b4
    43a0:	f836 8015 	ldrh.w	r8, [r6, r5, lsl #1]
	v3 = unfec13_tbl[EXTRACT6_6(in+2)];	
    43a4:	ea47 179b 	orr.w	r7, r7, fp, lsr #6
	v6 = unfec13_tbl[EXTRACT6_0(in+5)];	// b5
    43a8:	f009 053f 	and.w	r5, r9, #63	; 0x3f
	v7 = unfec13_tbl[EXTRACT6_6(in+5)];	// 
    43ac:	f892 b006 	ldrb.w	fp, [r2, #6]
	v0 = unfec13_tbl[EXTRACT6_4(in+0)]; 	// b0
    43b0:	f00e 0e30 	and.w	lr, lr, #48	; 0x30
	v6 = unfec13_tbl[EXTRACT6_0(in+5)];	// b5
    43b4:	f836 5015 	ldrh.w	r5, [r6, r5, lsl #1]
	v0 = unfec13_tbl[EXTRACT6_4(in+0)]; 	// b0
    43b8:	ea4e 1e13 	orr.w	lr, lr, r3, lsr #4
	v8 = unfec13_tbl[EXTRACT6_4(in+6)]; 	// b6
    43bc:	79d2      	ldrb	r2, [r2, #7]
	out[0] = v0|(v1<<2)|(v2<<4)|(v3<<6);
	out[1] = v4|(v5<<2)|(v6<<4)|(v7<<6);
	out[2] = v8;
	
	// bit error
	return (v0+v1+v2+v3+v4+v5+v6+v7+v8)>>14;
    43be:	eb0a 0304 	add.w	r3, sl, r4
	out[0] = v0|(v1<<2)|(v2<<4)|(v3<<6);
    43c2:	0124      	lsls	r4, r4, #4
    43c4:	ea44 048a 	orr.w	r4, r4, sl, lsl #2
	v0 = unfec13_tbl[EXTRACT6_4(in+0)]; 	// b0
    43c8:	f836 e01e 	ldrh.w	lr, [r6, lr, lsl #1]
	return (v0+v1+v2+v3+v4+v5+v6+v7+v8)>>14;
    43cc:	4443      	add	r3, r8
	v7 = unfec13_tbl[EXTRACT6_6(in+5)];	// 
    43ce:	ea4f 0a8b 	mov.w	sl, fp, lsl #2
	v3 = unfec13_tbl[EXTRACT6_6(in+2)];	
    43d2:	f836 7017 	ldrh.w	r7, [r6, r7, lsl #1]
	return (v0+v1+v2+v3+v4+v5+v6+v7+v8)>>14;
    43d6:	442b      	add	r3, r5
	v4 = unfec13_tbl[EXTRACT6_4(in+3)];	// b3
    43d8:	ea41 1c1c 	orr.w	ip, r1, ip, lsr #4
	v8 = unfec13_tbl[EXTRACT6_4(in+6)]; 	// b6
    43dc:	0112      	lsls	r2, r2, #4
	v7 = unfec13_tbl[EXTRACT6_6(in+5)];	// 
    43de:	f00a 0a3c 	and.w	sl, sl, #60	; 0x3c
	v4 = unfec13_tbl[EXTRACT6_4(in+3)];	// b3
    43e2:	f836 c01c 	ldrh.w	ip, [r6, ip, lsl #1]
	return (v0+v1+v2+v3+v4+v5+v6+v7+v8)>>14;
    43e6:	4473      	add	r3, lr
	v8 = unfec13_tbl[EXTRACT6_4(in+6)]; 	// b6
    43e8:	f002 0230 	and.w	r2, r2, #48	; 0x30
	out[1] = v4|(v5<<2)|(v6<<4)|(v7<<6);
    43ec:	012d      	lsls	r5, r5, #4
	v7 = unfec13_tbl[EXTRACT6_6(in+5)];	// 
    43ee:	ea4a 1999 	orr.w	r9, sl, r9, lsr #6
	out[1] = v4|(v5<<2)|(v6<<4)|(v7<<6);
    43f2:	ea45 0588 	orr.w	r5, r5, r8, lsl #2
	return (v0+v1+v2+v3+v4+v5+v6+v7+v8)>>14;
    43f6:	443b      	add	r3, r7
	v7 = unfec13_tbl[EXTRACT6_6(in+5)];	// 
    43f8:	f836 8019 	ldrh.w	r8, [r6, r9, lsl #1]
	v8 = unfec13_tbl[EXTRACT6_4(in+6)]; 	// b6
    43fc:	ea42 1b1b 	orr.w	fp, r2, fp, lsr #4
	return (v0+v1+v2+v3+v4+v5+v6+v7+v8)>>14;
    4400:	eb03 020c 	add.w	r2, r3, ip
	v8 = unfec13_tbl[EXTRACT6_4(in+6)]; 	// b6
    4404:	f836 301b 	ldrh.w	r3, [r6, fp, lsl #1]
	out[0] = v0|(v1<<2)|(v2<<4)|(v3<<6);
    4408:	ea44 0e0e 	orr.w	lr, r4, lr
	out[1] = v4|(v5<<2)|(v6<<4)|(v7<<6);
    440c:	ea45 0c0c 	orr.w	ip, r5, ip
	return (v0+v1+v2+v3+v4+v5+v6+v7+v8)>>14;
    4410:	4442      	add	r2, r8
	out[0] = v0|(v1<<2)|(v2<<4)|(v3<<6);
    4412:	ea4e 1787 	orr.w	r7, lr, r7, lsl #6
	return (v0+v1+v2+v3+v4+v5+v6+v7+v8)>>14;
    4416:	441a      	add	r2, r3
	out[1] = v4|(v5<<2)|(v6<<4)|(v7<<6);
    4418:	ea4c 1e88 	orr.w	lr, ip, r8, lsl #6
	out[0] = v0|(v1<<2)|(v2<<4)|(v3<<6);
    441c:	b2ff      	uxtb	r7, r7
	out[1] = v4|(v5<<2)|(v6<<4)|(v7<<6);
    441e:	fa5f fc8e 	uxtb.w	ip, lr
	out[2] = v8;
    4422:	b2db      	uxtb	r3, r3
	uint32_t h32, hdr_data;
	uint8_t hec;

	/* Unfec13 header */
	be = unfec13_hdr(hdr_bytes, in_data);
	if (be>3)
    4424:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
{
    4428:	4604      	mov	r4, r0
    442a:	9d01      	ldr	r5, [sp, #4]
	out[0] = v0|(v1<<2)|(v2<<4)|(v3<<6);
    442c:	f88d 700c 	strb.w	r7, [sp, #12]
	out[1] = v4|(v5<<2)|(v6<<4)|(v7<<6);
    4430:	f88d c00d 	strb.w	ip, [sp, #13]
	out[2] = v8;
    4434:	f88d 300e 	strb.w	r3, [sp, #14]
	if (be>3)
    4438:	d251      	bcs.n	44de <bbcodec_decode_header+0x182>
		BB_DEBUG("(hdr be: %d)", be);
		return -1;
	}

	/* Unwhiten header */
	if (codec->use_whiten)
    443a:	6842      	ldr	r2, [r0, #4]
    443c:	2a00      	cmp	r2, #0
    443e:	d138      	bne.n	44b2 <bbcodec_decode_header+0x156>
		bbcodec_unwhiten(&codec->whiten_state, hdr_bytes, hdr_bytes, 18);

	/* Decode header */
	h32 = hdr_bytes[0]|((uint32_t)hdr_bytes[1]<<8)|((uint32_t)hdr_bytes[2]<<16);
    4440:	ea4f 4e03 	mov.w	lr, r3, lsl #16
    4444:	ea4e 2e0c 	orr.w	lr, lr, ip, lsl #8
    4448:	ea4e 0e07 	orr.w	lr, lr, r7
	hdr_data = h32&0x3ff;
	out_hdr->hec =(h32>>10);
    444c:	f3ce 2687 	ubfx	r6, lr, #10, #8
	out_hdr->lt_addr = hdr_data & 7;
    4450:	f00e 0207 	and.w	r2, lr, #7
	out_hdr->type   = (hdr_data>>3) & 0xf;
	out_hdr->flags  = (hdr_data>>7) & 7;
    4454:	f3ce 13c2 	ubfx	r3, lr, #7, #3
	out_hdr->type   = (hdr_data>>3) & 0xf;
    4458:	f3ce 01c3 	ubfx	r1, lr, #3, #4
	out_hdr->lt_addr = hdr_data & 7;
    445c:	702a      	strb	r2, [r5, #0]
	out_hdr->hec =(h32>>10);
    445e:	70ee      	strb	r6, [r5, #3]
	out_hdr->type   = (hdr_data>>3) & 0xf;
    4460:	7069      	strb	r1, [r5, #1]
	out_hdr->flags  = (hdr_data>>7) & 7;
    4462:	70ab      	strb	r3, [r5, #2]
        return rev8_map[data];
    4464:	7823      	ldrb	r3, [r4, #0]
    4466:	4a20      	ldr	r2, [pc, #128]	; (44e8 <bbcodec_decode_header+0x18c>)
	hdr_data = h32&0x3ff;
    4468:	f3ce 0e09 	ubfx	lr, lr, #0, #10
    446c:	5cd0      	ldrb	r0, [r2, r3]
	hec = (hec>>5) ^ hec_tbl[(data^hec)&0x1f];
    446e:	4d1f      	ldr	r5, [pc, #124]	; (44ec <bbcodec_decode_header+0x190>)
    4470:	ea8e 0200 	eor.w	r2, lr, r0
    4474:	f002 021f 	and.w	r2, r2, #31
    4478:	5cab      	ldrb	r3, [r5, r2]
    447a:	ea83 1350 	eor.w	r3, r3, r0, lsr #5
	hec = (hec>>5) ^ hec_tbl[((data>>5)^hec)&0x1f];
    447e:	ea83 1e5e 	eor.w	lr, r3, lr, lsr #5
    4482:	f00e 0e1f 	and.w	lr, lr, #31

	/* Check HEC */
	hec = hec_compute(hdr_data, codec->uap);
	/* FIXME: Why on earth is the high bit wrong half of the time ? */
	if ((hec&0x7f) != (0x7f&out_hdr->hec))
    4486:	f815 000e 	ldrb.w	r0, [r5, lr]
    448a:	ea86 1353 	eor.w	r3, r6, r3, lsr #5
    448e:	4058      	eors	r0, r3
    4490:	f010 007f 	ands.w	r0, r0, #127	; 0x7f
    4494:	d123      	bne.n	44de <bbcodec_decode_header+0x182>
	{
		BB_DEBUG("(heccal %x, pkt %x)", hec, out_hdr->hec);
		return -1;
	}
	codec->air_off_b = 58;
    4496:	223a      	movs	r2, #58	; 0x3a
	codec->t = &bbcodec_acl_types[type&0xf];
    4498:	4d15      	ldr	r5, [pc, #84]	; (44f0 <bbcodec_decode_header+0x194>)
    449a:	eb01 0341 	add.w	r3, r1, r1, lsl #1
	if (codec->t->nslots == 0)
    449e:	f815 6013 	ldrb.w	r6, [r5, r3, lsl #1]
	codec->t = &bbcodec_acl_types[type&0xf];
    44a2:	eb05 0743 	add.w	r7, r5, r3, lsl #1
    44a6:	6167      	str	r7, [r4, #20]
	codec->air_off_b = 58;
    44a8:	6262      	str	r2, [r4, #36]	; 0x24
	if (codec->t->nslots == 0)
    44aa:	b186      	cbz	r6, 44ce <bbcodec_decode_header+0x172>

	bbcodec_set_payload_type(codec, out_hdr->type);

	return 0;
}
    44ac:	b005      	add	sp, #20
    44ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	whiten(out, in, bit_count, whiten_state);
    44b2:	a903      	add	r1, sp, #12
    44b4:	f104 030c 	add.w	r3, r4, #12
    44b8:	4608      	mov	r0, r1
    44ba:	2212      	movs	r2, #18
    44bc:	f000 fa76 	bl	49ac <whiten>
    44c0:	f89d 700c 	ldrb.w	r7, [sp, #12]
    44c4:	f89d c00d 	ldrb.w	ip, [sp, #13]
    44c8:	f89d 300e 	ldrb.w	r3, [sp, #14]
}
    44cc:	e7b8      	b.n	4440 <bbcodec_decode_header+0xe4>
		cprintf("(Nyi plt %d)", type);
    44ce:	4809      	ldr	r0, [pc, #36]	; (44f4 <bbcodec_decode_header+0x198>)
    44d0:	f004 fea0 	bl	9214 <cprintf>
	return 0;
    44d4:	4630      	mov	r0, r6
		codec->t = &bbcodec_acl_types[0];
    44d6:	6165      	str	r5, [r4, #20]
}
    44d8:	b005      	add	sp, #20
    44da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return -1;
    44de:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    44e2:	e7e3      	b.n	44ac <bbcodec_decode_header+0x150>
    44e4:	0000d6b4 	.word	0x0000d6b4
    44e8:	0000d954 	.word	0x0000d954
    44ec:	0000d734 	.word	0x0000d734
    44f0:	0000c95c 	.word	0x0000c95c
    44f4:	0000c8d0 	.word	0x0000c8d0

000044f8 <bbcodec_encode_header>:

/* encode pkt's header in given buffer
 * data: packet buffer, must be zeroed by caller
 */
void bbcodec_encode_header(bbcodec_t *codec, uint8_t *air_data, bbhdr_t *in_hdr, uint8_t trailer, uint8_t *in_data)
{
    44f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    44fc:	b082      	sub	sp, #8
    44fe:	4605      	mov	r5, r0
    4500:	4616      	mov	r6, r2
	uint8_t hdr_bytes[3];
	// Write 4bits sw_trailer + 18*3 bits header in air_data
	
	/* encode the header */
	h32 = 7 & in_hdr->lt_addr;
	h32 |= (uint32_t)(0xf & in_hdr->type) << 3;
    4502:	7854      	ldrb	r4, [r2, #1]
	h32 |= (uint32_t)(0x7 & in_hdr->flags) << 7;
    4504:	7892      	ldrb	r2, [r2, #2]
        return rev8_map[data];
    4506:	782f      	ldrb	r7, [r5, #0]
    4508:	f8df c11c 	ldr.w	ip, [pc, #284]	; 4628 <bbcodec_encode_header+0x130>
	h32 = 7 & in_hdr->lt_addr;
    450c:	7830      	ldrb	r0, [r6, #0]
	h32 |= (uint32_t)(0xf & in_hdr->type) << 3;
    450e:	00e4      	lsls	r4, r4, #3
	h32 |= (uint32_t)(0x7 & in_hdr->flags) << 7;
    4510:	01d2      	lsls	r2, r2, #7
    4512:	f402 7260 	and.w	r2, r2, #896	; 0x380
	h32 |= (uint32_t)(0xf & in_hdr->type) << 3;
    4516:	f004 0478 	and.w	r4, r4, #120	; 0x78
    451a:	f81c e007 	ldrb.w	lr, [ip, r7]
	h32 |= (uint32_t)(0x7 & in_hdr->flags) << 7;
    451e:	4314      	orrs	r4, r2
	h32 = 7 & in_hdr->lt_addr;
    4520:	f000 0007 	and.w	r0, r0, #7
	h32 |= (uint32_t)(0x7 & in_hdr->flags) << 7;
    4524:	4304      	orrs	r4, r0
	hec = (hec>>5) ^ hec_tbl[(data^hec)&0x1f];
    4526:	f8df c104 	ldr.w	ip, [pc, #260]	; 462c <bbcodec_encode_header+0x134>
    452a:	ea84 000e 	eor.w	r0, r4, lr
    452e:	f000 001f 	and.w	r0, r0, #31
    4532:	f81c 2000 	ldrb.w	r2, [ip, r0]
{
    4536:	460f      	mov	r7, r1
    4538:	ea82 125e 	eor.w	r2, r2, lr, lsr #5
	hec = (hec>>5) ^ hec_tbl[((data>>5)^hec)&0x1f];
    453c:	ea82 1154 	eor.w	r1, r2, r4, lsr #5
    4540:	f001 011f 	and.w	r1, r1, #31
    4544:	f81c 0001 	ldrb.w	r0, [ip, r1]
	hdr_bytes[0] = 0xff & h32;
	hdr_bytes[1] = 0xff & (h32>>8);
	hdr_bytes[2] = 0xff & (h32>>16);

	/* whiten the header */
	if (codec->use_whiten)
    4548:	6869      	ldr	r1, [r5, #4]
	h32 |= (uint32_t)hec_compute(h32, codec->uap) << 10;
    454a:	ea80 1252 	eor.w	r2, r0, r2, lsr #5
    454e:	ea44 2482 	orr.w	r4, r4, r2, lsl #10
	hdr_bytes[2] = 0xff & (h32>>16);
    4552:	0c22      	lsrs	r2, r4, #16
	hdr_bytes[0] = 0xff & h32;
    4554:	f8ad 4004 	strh.w	r4, [sp, #4]
{
    4558:	4698      	mov	r8, r3
	hdr_bytes[2] = 0xff & (h32>>16);
    455a:	f88d 2006 	strb.w	r2, [sp, #6]
	whiten(out, in, bit_count, whiten_state);
    455e:	ac01      	add	r4, sp, #4
	if (codec->use_whiten)
    4560:	2900      	cmp	r1, #0
    4562:	d14a      	bne.n	45fa <bbcodec_encode_header+0x102>

	/* Write trailer of syncword in the buffer */
	air_data[0] = trailer;

	/* fec13 & write the header at position 4 */
	fec13(air_data, hdr_bytes, 4, 18);
    4564:	4621      	mov	r1, r4
    4566:	2312      	movs	r3, #18
    4568:	2204      	movs	r2, #4
    456a:	4638      	mov	r0, r7
	air_data[0] = trailer;
    456c:	f887 8000 	strb.w	r8, [r7]
	fec13(air_data, hdr_bytes, 4, 18);
    4570:	f000 fd98 	bl	50a4 <fec13>

	/* encoder output position */
	codec->air_off_b = 58;
    4574:	233a      	movs	r3, #58	; 0x3a
    4576:	626b      	str	r3, [r5, #36]	; 0x24

	/* Configure codec type */
	bbcodec_set_payload_type(codec, in_hdr->type);
    4578:	7871      	ldrb	r1, [r6, #1]
	codec->t = &bbcodec_acl_types[type&0xf];
    457a:	4e28      	ldr	r6, [pc, #160]	; (461c <bbcodec_encode_header+0x124>)
    457c:	f001 020f 	and.w	r2, r1, #15
    4580:	eb02 0242 	add.w	r2, r2, r2, lsl #1
	if (codec->t->nslots == 0)
    4584:	f816 4012 	ldrb.w	r4, [r6, r2, lsl #1]
	codec->t = &bbcodec_acl_types[type&0xf];
    4588:	eb06 0242 	add.w	r2, r6, r2, lsl #1
    458c:	616a      	str	r2, [r5, #20]
	if (codec->t->nslots == 0)
    458e:	b354      	cbz	r4, 45e6 <bbcodec_encode_header+0xee>
    4590:	8851      	ldrh	r1, [r2, #2]
	if (t->payload_bytes != 0 && payload == NULL)
    4592:	b111      	cbz	r1, 459a <bbcodec_encode_header+0xa2>
    4594:	9b08      	ldr	r3, [sp, #32]
    4596:	2b00      	cmp	r3, #0
    4598:	d03c      	beq.n	4614 <bbcodec_encode_header+0x11c>
	if (codec->rx_raw)
    459a:	68a8      	ldr	r0, [r5, #8]
	hdr_len = t->payload_header_bytes;
    459c:	7853      	ldrb	r3, [r2, #1]
	if (codec->rx_raw)
    459e:	b198      	cbz	r0, 45c8 <bbcodec_encode_header+0xd0>
			codec->payload_length = t->payload_bytes;
    45a0:	61a9      	str	r1, [r5, #24]
		if (codec->payload_length > t->payload_bytes)
    45a2:	440b      	add	r3, r1
	codec->coded_total = (hdr_len + codec->payload_length);
    45a4:	622b      	str	r3, [r5, #32]
	if (t->has_crc)
    45a6:	7951      	ldrb	r1, [r2, #5]
    45a8:	b109      	cbz	r1, 45ae <bbcodec_encode_header+0xb6>
		codec->coded_total += 2;
    45aa:	3302      	adds	r3, #2
    45ac:	622b      	str	r3, [r5, #32]
	if (t->has_fec23)
    45ae:	7912      	ldrb	r2, [r2, #4]
    45b0:	b932      	cbnz	r2, 45c0 <bbcodec_encode_header+0xc8>
		payload_bits = codec->coded_total*8;
    45b2:	00db      	lsls	r3, r3, #3
	codec->air_bytes = BYTE_ALIGN(58+payload_bits);
    45b4:	3341      	adds	r3, #65	; 0x41
    45b6:	08db      	lsrs	r3, r3, #3
    45b8:	61eb      	str	r3, [r5, #28]

	/* Set codec type / payload length */
	bbcodec_calc_payload_length(codec, in_data);
}
    45ba:	b002      	add	sp, #8
    45bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		payload_bits = codec->coded_total*12;
    45c0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    45c4:	009b      	lsls	r3, r3, #2
    45c6:	e7f5      	b.n	45b4 <bbcodec_encode_header+0xbc>
		switch(hdr_len)
    45c8:	2b01      	cmp	r3, #1
    45ca:	d01e      	beq.n	460a <bbcodec_encode_header+0x112>
    45cc:	2b02      	cmp	r3, #2
    45ce:	d1e7      	bne.n	45a0 <bbcodec_encode_header+0xa8>
			codec->payload_length = 0x3ff & ((payload[0]|(payload[1]<<8))>>3);
    45d0:	9808      	ldr	r0, [sp, #32]
    45d2:	8800      	ldrh	r0, [r0, #0]
    45d4:	f3c0 00c9 	ubfx	r0, r0, #3, #10
    45d8:	61a8      	str	r0, [r5, #24]
		if (codec->payload_length > t->payload_bytes)
    45da:	4281      	cmp	r1, r0
			codec->payload_length = 0;
    45dc:	bf36      	itet	cc
    45de:	2100      	movcc	r1, #0
    45e0:	181b      	addcs	r3, r3, r0
    45e2:	61a9      	strcc	r1, [r5, #24]
    45e4:	e7de      	b.n	45a4 <bbcodec_encode_header+0xac>
		cprintf("(Nyi plt %d)", type);
    45e6:	480e      	ldr	r0, [pc, #56]	; (4620 <bbcodec_encode_header+0x128>)
    45e8:	f004 fe14 	bl	9214 <cprintf>
	if (codec->rx_raw)
    45ec:	68a9      	ldr	r1, [r5, #8]
		codec->t = &bbcodec_acl_types[0];
    45ee:	616e      	str	r6, [r5, #20]
	if (codec->rx_raw)
    45f0:	b101      	cbz	r1, 45f4 <bbcodec_encode_header+0xfc>
    45f2:	4621      	mov	r1, r4
    45f4:	4632      	mov	r2, r6
	hdr_len = t->payload_header_bytes;
    45f6:	460b      	mov	r3, r1
		codec->payload_length = t->payload_bytes;
    45f8:	e7d2      	b.n	45a0 <bbcodec_encode_header+0xa8>
	whiten(out, in, bit_count, whiten_state);
    45fa:	4621      	mov	r1, r4
    45fc:	4620      	mov	r0, r4
    45fe:	2212      	movs	r2, #18
    4600:	f105 030c 	add.w	r3, r5, #12
    4604:	f000 f9d2 	bl	49ac <whiten>
}
    4608:	e7ac      	b.n	4564 <bbcodec_encode_header+0x6c>
			codec->payload_length = payload[0]>>3;
    460a:	9808      	ldr	r0, [sp, #32]
    460c:	7800      	ldrb	r0, [r0, #0]
    460e:	08c0      	lsrs	r0, r0, #3
    4610:	61a8      	str	r0, [r5, #24]
			break;
    4612:	e7e2      	b.n	45da <bbcodec_encode_header+0xe2>
		DIE("No payload for type %p\n", codec->t);
    4614:	4611      	mov	r1, r2
    4616:	4803      	ldr	r0, [pc, #12]	; (4624 <bbcodec_encode_header+0x12c>)
    4618:	f003 fcfc 	bl	8014 <die>
    461c:	0000c95c 	.word	0x0000c95c
    4620:	0000c8d0 	.word	0x0000c8d0
    4624:	0000c8e0 	.word	0x0000c8e0
    4628:	0000d954 	.word	0x0000d954
    462c:	0000d734 	.word	0x0000d734

00004630 <bbcodec_encode_chunk>:

void bbcodec_encode_chunk(bbcodec_t *codec, uint8_t *air_data, bbhdr_t *in_hdr, uint8_t *in_data)
{
    4630:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    4634:	b095      	sub	sp, #84	; 0x54
	const bbcodec_types_t *t = codec->t;
	uint8_t tmp[CODEC_TX_CHUNK_SIZE], *inp;
	unsigned byte_left, crc_num, byte_num, out_bitlen;

	/* Current input pointer */
	inp = in_data + codec->coded_pos;
    4636:	6a86      	ldr	r6, [r0, #40]	; 0x28

	/* total encode bytes left including crc */
	byte_left = codec->coded_total - codec->coded_pos;
    4638:	f8d0 c020 	ldr.w	ip, [r0, #32]
{
    463c:	4604      	mov	r4, r0

	/* nothing to do */
	if (byte_left == 0)
    463e:	ebbc 0006 	subs.w	r0, ip, r6
{
    4642:	460d      	mov	r5, r1
	if (byte_left == 0)
    4644:	d045      	beq.n	46d2 <bbcodec_encode_chunk+0xa2>
		return;

	/* If the crc calculation is not done yet */
	if (!codec->rx_raw && t->has_crc && byte_left > 2)
    4646:	68a2      	ldr	r2, [r4, #8]
	inp = in_data + codec->coded_pos;
    4648:	1999      	adds	r1, r3, r6
	const bbcodec_types_t *t = codec->t;
    464a:	6966      	ldr	r6, [r4, #20]
	if (!codec->rx_raw && t->has_crc && byte_left > 2)
    464c:	bb3a      	cbnz	r2, 469e <bbcodec_encode_chunk+0x6e>
    464e:	7977      	ldrb	r7, [r6, #5]
    4650:	b32f      	cbz	r7, 469e <bbcodec_encode_chunk+0x6e>
    4652:	2802      	cmp	r0, #2
    4654:	d923      	bls.n	469e <bbcodec_encode_chunk+0x6e>
	{
		/* Num bytes we're going to crc */
		crc_num = MIN(byte_left-2, CODEC_TX_CHUNK_SIZE);
    4656:	f1a0 0802 	sub.w	r8, r0, #2
    465a:	f1b8 0f50 	cmp.w	r8, #80	; 0x50
	for(i = 0; i < nbytes; i++)
    465e:	4617      	mov	r7, r2
    4660:	bf28      	it	cs
    4662:	f04f 0850 	movcs.w	r8, #80	; 0x50

		codec->crc_state = crc_compute(inp, crc_num, codec->crc_state);
    4666:	f8b4 e00e 	ldrh.w	lr, [r4, #14]
    466a:	f8df 909c 	ldr.w	r9, [pc, #156]	; 4708 <bbcodec_encode_chunk+0xd8>
		crc = (crc>>8) ^ crc_tbl[0xff & (in[i]^crc)];
    466e:	5dcf      	ldrb	r7, [r1, r7]
	for(i = 0; i < nbytes; i++)
    4670:	3201      	adds	r2, #1
		crc = (crc>>8) ^ crc_tbl[0xff & (in[i]^crc)];
    4672:	ea87 070e 	eor.w	r7, r7, lr
    4676:	b2ff      	uxtb	r7, r7
    4678:	f839 7017 	ldrh.w	r7, [r9, r7, lsl #1]
	for(i = 0; i < nbytes; i++)
    467c:	b292      	uxth	r2, r2
    467e:	4590      	cmp	r8, r2
		crc = (crc>>8) ^ crc_tbl[0xff & (in[i]^crc)];
    4680:	ea87 2e1e 	eor.w	lr, r7, lr, lsr #8
	for(i = 0; i < nbytes; i++)
    4684:	4617      	mov	r7, r2
    4686:	d8f2      	bhi.n	466e <bbcodec_encode_chunk+0x3e>

		/* If the crc calculation is done, write crc in in_data */
		if (codec->coded_pos+byte_left == codec->coded_total)
		{
			in_data[codec->coded_total-2] = 0xff & codec->crc_state;
    4688:	449c      	add	ip, r3
		codec->crc_state = crc_compute(inp, crc_num, codec->crc_state);
    468a:	f8a4 e00e 	strh.w	lr, [r4, #14]
			in_data[codec->coded_total-2] = 0xff & codec->crc_state;
    468e:	f80c ec02 	strb.w	lr, [ip, #-2]
			in_data[codec->coded_total-1] = 0xff & (codec->crc_state>>8);
    4692:	6a27      	ldr	r7, [r4, #32]
    4694:	89e2      	ldrh	r2, [r4, #14]
    4696:	443b      	add	r3, r7
    4698:	0a12      	lsrs	r2, r2, #8
    469a:	f803 2c01 	strb.w	r2, [r3, #-1]
		}
	}

	/* Num bytes we're going to encode */
	byte_num = MIN(byte_left, CODEC_TX_CHUNK_SIZE);
    469e:	2850      	cmp	r0, #80	; 0x50
    46a0:	bf28      	it	cs
    46a2:	2050      	movcs	r0, #80	; 0x50

	/* whiten the encode bytes */
	if (codec->use_whiten)
    46a4:	6863      	ldr	r3, [r4, #4]
	byte_num = MIN(byte_left, CODEC_TX_CHUNK_SIZE);
    46a6:	4607      	mov	r7, r0
	whiten(out, in, bit_count, whiten_state);
    46a8:	46e9      	mov	r9, sp
		bbcodec_unwhiten(&codec->whiten_state, tmp, inp, byte_num*8);
    46aa:	ea4f 08c0 	mov.w	r8, r0, lsl #3
	if (codec->use_whiten)
    46ae:	bb03      	cbnz	r3, 46f2 <bbcodec_encode_chunk+0xc2>

	/* Encode data in the air buffer */
	if (t->has_fec23)
    46b0:	7933      	ldrb	r3, [r6, #4]
	{
		fec23(air_data+(codec->air_off_b>>3), tmp, codec->air_off_b&7, byte_num*8);
    46b2:	6a62      	ldr	r2, [r4, #36]	; 0x24
	if (t->has_fec23)
    46b4:	b983      	cbnz	r3, 46d8 <bbcodec_encode_chunk+0xa8>
		out_bitlen = byte_num*12;
	}
	else
	{
		null_encode(air_data+(codec->air_off_b>>3), tmp, codec->air_off_b&7, byte_num);
    46b6:	eb05 00d2 	add.w	r0, r5, r2, lsr #3
    46ba:	4649      	mov	r1, r9
    46bc:	463b      	mov	r3, r7
    46be:	f002 0207 	and.w	r2, r2, #7
    46c2:	f000 f93b 	bl	493c <null_encode>

	/* Update input position */
	codec->coded_pos += byte_num;

	/* Update output position */
	codec->air_off_b += out_bitlen;
    46c6:	e9d4 3009 	ldrd	r3, r0, [r4, #36]	; 0x24
	codec->coded_pos += byte_num;
    46ca:	4438      	add	r0, r7
	codec->air_off_b += out_bitlen;
    46cc:	4443      	add	r3, r8
    46ce:	e9c4 3009 	strd	r3, r0, [r4, #36]	; 0x24
}
    46d2:	b015      	add	sp, #84	; 0x54
    46d4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		fec23(air_data+(codec->air_off_b>>3), tmp, codec->air_off_b&7, byte_num*8);
    46d8:	4643      	mov	r3, r8
    46da:	eb05 00d2 	add.w	r0, r5, r2, lsr #3
    46de:	4649      	mov	r1, r9
    46e0:	f002 0207 	and.w	r2, r2, #7
		out_bitlen = byte_num*12;
    46e4:	eb07 0847 	add.w	r8, r7, r7, lsl #1
		fec23(air_data+(codec->air_off_b>>3), tmp, codec->air_off_b&7, byte_num*8);
    46e8:	f000 f998 	bl	4a1c <fec23>
		out_bitlen = byte_num*12;
    46ec:	ea4f 0888 	mov.w	r8, r8, lsl #2
    46f0:	e7e9      	b.n	46c6 <bbcodec_encode_chunk+0x96>
	whiten(out, in, bit_count, whiten_state);
    46f2:	4642      	mov	r2, r8
    46f4:	f104 030c 	add.w	r3, r4, #12
    46f8:	4648      	mov	r0, r9
    46fa:	f000 f957 	bl	49ac <whiten>
	if (t->has_fec23)
    46fe:	7933      	ldrb	r3, [r6, #4]
		fec23(air_data+(codec->air_off_b>>3), tmp, codec->air_off_b&7, byte_num*8);
    4700:	6a62      	ldr	r2, [r4, #36]	; 0x24
	if (t->has_fec23)
    4702:	2b00      	cmp	r3, #0
    4704:	d0d7      	beq.n	46b6 <bbcodec_encode_chunk+0x86>
    4706:	e7e7      	b.n	46d8 <bbcodec_encode_chunk+0xa8>
    4708:	0000d754 	.word	0x0000d754

0000470c <bbcodec_decode_chunk>:
	}
}

/* Decode 10 host bytes */
int bbcodec_decode_chunk(bbcodec_t *codec, uint8_t *out, bbhdr_t *in_hdr, uint8_t *in_data, unsigned in_length)
{
    470c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	const bbcodec_types_t *t = codec->t;
    4710:	6947      	ldr	r7, [r0, #20]
{
    4712:	4604      	mov	r4, r0
	int bit_av, in_bitlen, first_chunk = codec->coded_pos == 0;
	uint8_t *outp;
	unsigned byte_num;

	/* Check if there is a payload to decode */
	if (t->payload_bytes == 0)
    4714:	887a      	ldrh	r2, [r7, #2]
{
    4716:	460e      	mov	r6, r1
	if (t->payload_bytes == 0)
    4718:	2a00      	cmp	r2, #0
    471a:	d063      	beq.n	47e4 <bbcodec_decode_chunk+0xd8>
	int bit_av, in_bitlen, first_chunk = codec->coded_pos == 0;
    471c:	f8d0 8028 	ldr.w	r8, [r0, #40]	; 0x28
		return BBCODEC_DONE;

	/* First chunk: we do not know coded position,
	 * Just do one full chunk */
	if (first_chunk)
    4720:	f1b8 0f00 	cmp.w	r8, #0
    4724:	d05b      	beq.n	47de <bbcodec_decode_chunk+0xd2>
		byte_num = CODEC_RX_CHUNK_SIZE;
		outp = out;
	}
	else{
		/* FIXME: hacky assert that payload length was decoded */
		if(codec->coded_total == 0)
    4726:	6a05      	ldr	r5, [r0, #32]
    4728:	2d00      	cmp	r5, #0
    472a:	f000 80b3 	beq.w	4894 <bbcodec_decode_chunk+0x188>
			DIE("dec_nc: unk pl len\n");
		byte_num = MIN(CODEC_RX_CHUNK_SIZE,codec->coded_total - codec->coded_pos);
		outp = out+codec->coded_pos;
	}

	if (byte_num == 0)
    472e:	45a8      	cmp	r8, r5
    4730:	d058      	beq.n	47e4 <bbcodec_decode_chunk+0xd8>
		byte_num = MIN(CODEC_RX_CHUNK_SIZE,codec->coded_total - codec->coded_pos);
    4732:	eba5 0508 	sub.w	r5, r5, r8
    4736:	2d0a      	cmp	r5, #10
    4738:	bf28      	it	cs
    473a:	250a      	movcs	r5, #10
		outp = out+codec->coded_pos;
    473c:	eb01 0a08 	add.w	sl, r1, r8
		return BBCODEC_DONE;

	bit_av = in_length*8 - codec->air_off_b;
    4740:	6a62      	ldr	r2, [r4, #36]	; 0x24
	if (bit_av < 0)
    4742:	990a      	ldr	r1, [sp, #40]	; 0x28
    4744:	ebd2 00c1 	rsbs	r0, r2, r1, lsl #3
    4748:	f100 80a1 	bmi.w	488e <bbcodec_decode_chunk+0x182>
		DIE("dec_nc: error av %d of %d\n", in_length, codec->air_off_b);

	if (t->has_fec23)
    474c:	7939      	ldrb	r1, [r7, #4]
    474e:	2900      	cmp	r1, #0
    4750:	d04b      	beq.n	47ea <bbcodec_decode_chunk+0xde>
	{
		in_bitlen = 12*byte_num;
    4752:	eb05 0145 	add.w	r1, r5, r5, lsl #1
		if (bit_av < in_bitlen)
    4756:	ebb0 0f81 	cmp.w	r0, r1, lsl #2
		in_bitlen = 12*byte_num;
    475a:	ea4f 0981 	mov.w	r9, r1, lsl #2
		if (bit_av < in_bitlen)
    475e:	db5e      	blt.n	481e <bbcodec_decode_chunk+0x112>
			return BBCODEC_SHORT;
		/* TODO: return unfec23 error for pkt->flags ?
		 * For now, we're just relying on CRC to check validity of message. */
		unfec23(outp, in_data, codec->air_off_b, 8*byte_num);
    4760:	ea4f 0bc5 	mov.w	fp, r5, lsl #3
    4764:	4619      	mov	r1, r3
    4766:	4650      	mov	r0, sl
    4768:	465b      	mov	r3, fp
    476a:	f000 fb71 	bl	4e50 <unfec23>
		in_bitlen = 8*byte_num;
		if (bit_av < in_bitlen)
			return BBCODEC_SHORT;
		null_decode(outp, in_data, codec->air_off_b, byte_num);
	}
	if (codec->use_whiten)
    476e:	6863      	ldr	r3, [r4, #4]
    4770:	2b00      	cmp	r3, #0
    4772:	d048      	beq.n	4806 <bbcodec_decode_chunk+0xfa>
	whiten(out, in, bit_count, whiten_state);
    4774:	4650      	mov	r0, sl
    4776:	f104 030c 	add.w	r3, r4, #12
    477a:	465a      	mov	r2, fp
    477c:	4651      	mov	r1, sl
    477e:	f000 f915 	bl	49ac <whiten>
		bbcodec_unwhiten(&codec->whiten_state, outp, outp, byte_num*8);

	codec->air_off_b += in_bitlen;
	codec->coded_pos += byte_num;
    4782:	e9d4 3009 	ldrd	r3, r0, [r4, #36]	; 0x24
	codec->air_off_b += in_bitlen;
    4786:	444b      	add	r3, r9
	codec->coded_pos += byte_num;
    4788:	4405      	add	r5, r0
    478a:	e9c4 3509 	strd	r3, r5, [r4, #36]	; 0x24

	if (first_chunk)
    478e:	f1b8 0f00 	cmp.w	r8, #0
    4792:	d141      	bne.n	4818 <bbcodec_decode_chunk+0x10c>
	const bbcodec_types_t *t = codec->t;
    4794:	6961      	ldr	r1, [r4, #20]
	if (t->payload_bytes != 0 && payload == NULL)
    4796:	884a      	ldrh	r2, [r1, #2]
    4798:	b10a      	cbz	r2, 479e <bbcodec_decode_chunk+0x92>
    479a:	2e00      	cmp	r6, #0
    479c:	d07d      	beq.n	489a <bbcodec_decode_chunk+0x18e>
	if (codec->rx_raw)
    479e:	68a3      	ldr	r3, [r4, #8]
	hdr_len = t->payload_header_bytes;
    47a0:	7848      	ldrb	r0, [r1, #1]
	if (codec->rx_raw)
    47a2:	b91b      	cbnz	r3, 47ac <bbcodec_decode_chunk+0xa0>
		switch(hdr_len)
    47a4:	2801      	cmp	r0, #1
    47a6:	d06b      	beq.n	4880 <bbcodec_decode_chunk+0x174>
    47a8:	2802      	cmp	r0, #2
    47aa:	d05d      	beq.n	4868 <bbcodec_decode_chunk+0x15c>
			codec->payload_length = t->payload_bytes;
    47ac:	61a2      	str	r2, [r4, #24]
		if (codec->payload_length > t->payload_bytes)
    47ae:	4410      	add	r0, r2
	codec->coded_total = (hdr_len + codec->payload_length);
    47b0:	6220      	str	r0, [r4, #32]
	if (t->has_crc)
    47b2:	794a      	ldrb	r2, [r1, #5]
    47b4:	b10a      	cbz	r2, 47ba <bbcodec_decode_chunk+0xae>
		codec->coded_total += 2;
    47b6:	3002      	adds	r0, #2
    47b8:	6220      	str	r0, [r4, #32]
	if (t->has_fec23)
    47ba:	790a      	ldrb	r2, [r1, #4]
    47bc:	2a00      	cmp	r2, #0
    47be:	d051      	beq.n	4864 <bbcodec_decode_chunk+0x158>
		payload_bits = codec->coded_total*12;
    47c0:	eb00 0240 	add.w	r2, r0, r0, lsl #1
    47c4:	0092      	lsls	r2, r2, #2
	codec->air_bytes = BYTE_ALIGN(58+payload_bits);
    47c6:	3241      	adds	r2, #65	; 0x41
    47c8:	08d2      	lsrs	r2, r2, #3
    47ca:	61e2      	str	r2, [r4, #28]
	{
		/* Read payload length */
		bbcodec_calc_payload_length(codec, out);
	}
	/* update crc */
	if (!codec->rx_raw && t->has_crc)
    47cc:	b90b      	cbnz	r3, 47d2 <bbcodec_decode_chunk+0xc6>
    47ce:	797a      	ldrb	r2, [r7, #5]
    47d0:	bb42      	cbnz	r2, 4824 <bbcodec_decode_chunk+0x118>
	{
		bbcodec_decode_update_crc(codec, out);
	}
	if (codec->coded_pos >= codec->coded_total)
    47d2:	4285      	cmp	r5, r0
    47d4:	bf34      	ite	cc
    47d6:	2000      	movcc	r0, #0
    47d8:	2001      	movcs	r0, #1
	{
		return BBCODEC_DONE;
	}
	return 0;
}
    47da:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    47de:	468a      	mov	sl, r1
		byte_num = CODEC_RX_CHUNK_SIZE;
    47e0:	250a      	movs	r5, #10
    47e2:	e7ad      	b.n	4740 <bbcodec_decode_chunk+0x34>
		return BBCODEC_DONE;
    47e4:	2001      	movs	r0, #1
}
    47e6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (bit_av < in_bitlen)
    47ea:	ebb0 0fc5 	cmp.w	r0, r5, lsl #3
		in_bitlen = 8*byte_num;
    47ee:	ea4f 09c5 	mov.w	r9, r5, lsl #3
		if (bit_av < in_bitlen)
    47f2:	db14      	blt.n	481e <bbcodec_decode_chunk+0x112>
		null_decode(outp, in_data, codec->air_off_b, byte_num);
    47f4:	4619      	mov	r1, r3
    47f6:	4650      	mov	r0, sl
    47f8:	462b      	mov	r3, r5
    47fa:	f000 f87d 	bl	48f8 <null_decode>
	if (codec->use_whiten)
    47fe:	6863      	ldr	r3, [r4, #4]
		null_decode(outp, in_data, codec->air_off_b, byte_num);
    4800:	46cb      	mov	fp, r9
	if (codec->use_whiten)
    4802:	2b00      	cmp	r3, #0
    4804:	d1b6      	bne.n	4774 <bbcodec_decode_chunk+0x68>
	codec->coded_pos += byte_num;
    4806:	e9d4 3009 	ldrd	r3, r0, [r4, #36]	; 0x24
	codec->air_off_b += in_bitlen;
    480a:	444b      	add	r3, r9
	codec->coded_pos += byte_num;
    480c:	4405      	add	r5, r0
    480e:	e9c4 3509 	strd	r3, r5, [r4, #36]	; 0x24
	if (first_chunk)
    4812:	f1b8 0f00 	cmp.w	r8, #0
    4816:	d0bd      	beq.n	4794 <bbcodec_decode_chunk+0x88>
    4818:	68a3      	ldr	r3, [r4, #8]
    481a:	6a20      	ldr	r0, [r4, #32]
    481c:	e7d6      	b.n	47cc <bbcodec_decode_chunk+0xc0>
			return BBCODEC_SHORT;
    481e:	2002      	movs	r0, #2
}
    4820:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	const uint8_t *crc_data = data+codec->crc_pos;
    4824:	f8b4 c010 	ldrh.w	ip, [r4, #16]
	unsigned crc_num = MIN(codec->coded_total-2,codec->coded_pos)-codec->crc_pos;
    4828:	1e81      	subs	r1, r0, #2
    482a:	42a9      	cmp	r1, r5
    482c:	bf94      	ite	ls
    482e:	ebcc 0101 	rsbls	r1, ip, r1
    4832:	ebcc 0105 	rsbhi	r1, ip, r5
	if (crc_num)
    4836:	2900      	cmp	r1, #0
    4838:	d0cb      	beq.n	47d2 <bbcodec_decode_chunk+0xc6>
    483a:	461a      	mov	r2, r3
		codec->crc_state = crc_compute(crc_data, crc_num, codec->crc_state);
    483c:	89e7      	ldrh	r7, [r4, #14]
    483e:	f8df e06c 	ldr.w	lr, [pc, #108]	; 48ac <bbcodec_decode_chunk+0x1a0>
    4842:	4466      	add	r6, ip
		crc = (crc>>8) ^ crc_tbl[0xff & (in[i]^crc)];
    4844:	5cb2      	ldrb	r2, [r6, r2]
	for(i = 0; i < nbytes; i++)
    4846:	3301      	adds	r3, #1
		crc = (crc>>8) ^ crc_tbl[0xff & (in[i]^crc)];
    4848:	407a      	eors	r2, r7
    484a:	b2d2      	uxtb	r2, r2
    484c:	f83e 2012 	ldrh.w	r2, [lr, r2, lsl #1]
	for(i = 0; i < nbytes; i++)
    4850:	b29b      	uxth	r3, r3
    4852:	4299      	cmp	r1, r3
		crc = (crc>>8) ^ crc_tbl[0xff & (in[i]^crc)];
    4854:	ea82 2717 	eor.w	r7, r2, r7, lsr #8
	for(i = 0; i < nbytes; i++)
    4858:	461a      	mov	r2, r3
    485a:	d8f3      	bhi.n	4844 <bbcodec_decode_chunk+0x138>
		codec->crc_pos += crc_num;
    485c:	4461      	add	r1, ip
    485e:	8221      	strh	r1, [r4, #16]
		codec->crc_state = crc_compute(crc_data, crc_num, codec->crc_state);
    4860:	81e7      	strh	r7, [r4, #14]
		codec->crc_pos += crc_num;
    4862:	e7b6      	b.n	47d2 <bbcodec_decode_chunk+0xc6>
		payload_bits = codec->coded_total*8;
    4864:	00c2      	lsls	r2, r0, #3
    4866:	e7ae      	b.n	47c6 <bbcodec_decode_chunk+0xba>
			codec->payload_length = 0x3ff & ((payload[0]|(payload[1]<<8))>>3);
    4868:	f8b6 c000 	ldrh.w	ip, [r6]
    486c:	f3cc 0cc9 	ubfx	ip, ip, #3, #10
    4870:	f8c4 c018 	str.w	ip, [r4, #24]
		if (codec->payload_length > t->payload_bytes)
    4874:	4562      	cmp	r2, ip
			codec->payload_length = 0;
    4876:	bf36      	itet	cc
    4878:	2200      	movcc	r2, #0
    487a:	4460      	addcs	r0, ip
    487c:	61a2      	strcc	r2, [r4, #24]
    487e:	e797      	b.n	47b0 <bbcodec_decode_chunk+0xa4>
			codec->payload_length = payload[0]>>3;
    4880:	f896 c000 	ldrb.w	ip, [r6]
    4884:	ea4f 0cdc 	mov.w	ip, ip, lsr #3
    4888:	f8c4 c018 	str.w	ip, [r4, #24]
			break;
    488c:	e7f2      	b.n	4874 <bbcodec_decode_chunk+0x168>
		DIE("dec_nc: error av %d of %d\n", in_length, codec->air_off_b);
    488e:	4804      	ldr	r0, [pc, #16]	; (48a0 <bbcodec_decode_chunk+0x194>)
    4890:	f003 fbc0 	bl	8014 <die>
			DIE("dec_nc: unk pl len\n");
    4894:	4803      	ldr	r0, [pc, #12]	; (48a4 <bbcodec_decode_chunk+0x198>)
    4896:	f003 fbbd 	bl	8014 <die>
		DIE("No payload for type %p\n", codec->t);
    489a:	4803      	ldr	r0, [pc, #12]	; (48a8 <bbcodec_decode_chunk+0x19c>)
    489c:	f003 fbba 	bl	8014 <die>
    48a0:	0000c91c 	.word	0x0000c91c
    48a4:	0000c900 	.word	0x0000c900
    48a8:	0000c8e0 	.word	0x0000c8e0
    48ac:	0000d754 	.word	0x0000d754

000048b0 <bbcodec_decode_finalize>:

/* Finalize decoding of the packet type,
 * must be called after all chunks are received
 */
uint8_t bbcodec_decode_finalize(bbcodec_t *codec, uint8_t *out, uint16_t *out_size)
{
    48b0:	b538      	push	{r3, r4, r5, lr}
	uint8_t *outp;
	uint8_t rc = 0;
	const bbcodec_types_t *t = codec->t;

	/* Check if there is a payload to decode */
	if (codec->coded_pos < codec->coded_total)
    48b2:	6a83      	ldr	r3, [r0, #40]	; 0x28
    48b4:	6a04      	ldr	r4, [r0, #32]
    48b6:	42a3      	cmp	r3, r4
    48b8:	d316      	bcc.n	48e8 <bbcodec_decode_finalize+0x38>
	{
		DIE("Pkt not decoded? %d:%d\n",
			codec->coded_pos, codec->coded_total);
	}
	if (!codec->rx_raw && t->has_crc)
    48ba:	6883      	ldr	r3, [r0, #8]
    48bc:	b98b      	cbnz	r3, 48e2 <bbcodec_decode_finalize+0x32>
    48be:	6943      	ldr	r3, [r0, #20]
    48c0:	795b      	ldrb	r3, [r3, #5]
    48c2:	b173      	cbz	r3, 48e2 <bbcodec_decode_finalize+0x32>
	{
		/* Verify crc */
		crc = out[codec->coded_total-2]|(out[codec->coded_total-1]<<8);
    48c4:	4421      	add	r1, r4
    48c6:	f811 5c01 	ldrb.w	r5, [r1, #-1]
    48ca:	f811 3c02 	ldrb.w	r3, [r1, #-2]
		if (crc!=codec->crc_state)
    48ce:	89c0      	ldrh	r0, [r0, #14]
			BB_DEBUG("(bad crc: cal=%x, crc=%x)", codec->crc_state, crc);
		}
		else{
			rc |= 1<<BBPKT_F_GOOD_CRC;
		}
		*out_size = codec->coded_total-2;
    48d0:	3c02      	subs	r4, #2
		if (crc!=codec->crc_state)
    48d2:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
			rc |= 1<<BBPKT_F_GOOD_CRC;
    48d6:	4298      	cmp	r0, r3
    48d8:	bf0c      	ite	eq
    48da:	2008      	moveq	r0, #8
    48dc:	2000      	movne	r0, #0
		*out_size = codec->coded_total-2;
    48de:	8014      	strh	r4, [r2, #0]
	{
		*out_size = codec->coded_total;
	}

	return rc;
}
    48e0:	bd38      	pop	{r3, r4, r5, pc}
	uint8_t rc = 0;
    48e2:	2000      	movs	r0, #0
		*out_size = codec->coded_total;
    48e4:	8014      	strh	r4, [r2, #0]
}
    48e6:	bd38      	pop	{r3, r4, r5, pc}
		DIE("Pkt not decoded? %d:%d\n",
    48e8:	4622      	mov	r2, r4
    48ea:	4619      	mov	r1, r3
    48ec:	4801      	ldr	r0, [pc, #4]	; (48f4 <bbcodec_decode_finalize+0x44>)
    48ee:	f003 fb91 	bl	8014 <die>
    48f2:	bf00      	nop
    48f4:	0000c93c 	.word	0x0000c93c

000048f8 <null_decode>:
	0xe5, 0x2b, 0xb2, 0x7c, 0x4b, 0x85, 0x1c, 0xd2, 
	0x72, 0xbc, 0x25, 0xeb, 0xdc, 0x12, 0x8b, 0x45, 
};

void null_decode(uint8_t *out, uint8_t *in, unsigned in_of, unsigned byte_count)
{
    48f8:	b538      	push	{r3, r4, r5, lr}
	unsigned i;
	uint8_t b, byte_of;

	if (byte_count == 0)
    48fa:	b19b      	cbz	r3, 4924 <null_decode+0x2c>
		return;

	byte_of = in_of/8;
	in_of &= 7;
	in += byte_of;
    48fc:	f3c2 05c7 	ubfx	r5, r2, #3, #8
	if (in_of == 0)
    4900:	f012 0207 	ands.w	r2, r2, #7
	in += byte_of;
    4904:	4429      	add	r1, r5
	if (in_of == 0)
    4906:	d00e      	beq.n	4926 <null_decode+0x2e>
	{
		memcpy(out, in, byte_count);
		return;
	}
	if (in_of != 2)
    4908:	2a02      	cmp	r2, #2
    490a:	d111      	bne.n	4930 <null_decode+0x38>
    490c:	3801      	subs	r0, #1
    490e:	18ca      	adds	r2, r1, r3
		DIE("nyi unaligned in %d\n", in_of);

	for (i=0;i<byte_count;i++)
	{
		out[i] = 0xff & ((in[i]>>2)|(in[i+1]<<6));
    4910:	780b      	ldrb	r3, [r1, #0]
    4912:	f811 4f01 	ldrb.w	r4, [r1, #1]!
    4916:	089b      	lsrs	r3, r3, #2
    4918:	ea43 1384 	orr.w	r3, r3, r4, lsl #6
	for (i=0;i<byte_count;i++)
    491c:	4291      	cmp	r1, r2
		out[i] = 0xff & ((in[i]>>2)|(in[i+1]<<6));
    491e:	f800 3f01 	strb.w	r3, [r0, #1]!
	for (i=0;i<byte_count;i++)
    4922:	d1f5      	bne.n	4910 <null_decode+0x18>
	}
}
    4924:	bd38      	pop	{r3, r4, r5, pc}
		memcpy(out, in, byte_count);
    4926:	461a      	mov	r2, r3
}
    4928:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		memcpy(out, in, byte_count);
    492c:	f005 beca 	b.w	a6c4 <memcpy>
		DIE("nyi unaligned in %d\n", in_of);
    4930:	4611      	mov	r1, r2
    4932:	4801      	ldr	r0, [pc, #4]	; (4938 <null_decode+0x40>)
    4934:	f003 fb6e 	bl	8014 <die>
    4938:	0000c9bc 	.word	0x0000c9bc

0000493c <null_encode>:

void null_encode(uint8_t *out, uint8_t *in, unsigned out_of, unsigned byte_count)
{
    493c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    493e:	468c      	mov	ip, r1
	unsigned i;
	uint8_t b, byte_of;

	if (byte_count == 0)
    4940:	b323      	cbz	r3, 498c <null_encode+0x50>
		return;
	
	byte_of = out_of/8;
	out_of &= 7;
	out += byte_of;
    4942:	f3c2 04c7 	ubfx	r4, r2, #3, #8
	if (out_of == 0)
    4946:	f012 0207 	ands.w	r2, r2, #7
	out += byte_of;
    494a:	eb00 0e04 	add.w	lr, r0, r4
	if (out_of == 0)
    494e:	d020      	beq.n	4992 <null_encode+0x56>
	{
		memcpy(out, in, byte_count);
		return;
	}
	if (out_of != 2)
    4950:	2a02      	cmp	r2, #2
    4952:	d124      	bne.n	499e <null_encode+0x62>
		DIE("nyi unaligned out %d\n", out_of);

	out[0] |= 0xff & (in[0]<<2);
    4954:	7809      	ldrb	r1, [r1, #0]
    4956:	5d02      	ldrb	r2, [r0, r4]
    4958:	ea42 0281 	orr.w	r2, r2, r1, lsl #2
	for (i=0;i<byte_count-1;i++)
    495c:	1e59      	subs	r1, r3, #1
	out[0] |= 0xff & (in[0]<<2);
    495e:	5502      	strb	r2, [r0, r4]
	for (i=0;i<byte_count-1;i++)
    4960:	d015      	beq.n	498e <null_encode+0x52>
    4962:	4665      	mov	r5, ip
    4964:	4676      	mov	r6, lr
    4966:	f10c 32ff 	add.w	r2, ip, #4294967295	; 0xffffffff
    496a:	441a      	add	r2, r3
	{
		out[i+1] = 0xff & ((in[i]>>6)|(in[i+1]<<2));
    496c:	782c      	ldrb	r4, [r5, #0]
    496e:	f815 7f01 	ldrb.w	r7, [r5, #1]!
    4972:	09a4      	lsrs	r4, r4, #6
    4974:	ea44 0487 	orr.w	r4, r4, r7, lsl #2
	for (i=0;i<byte_count-1;i++)
    4978:	4295      	cmp	r5, r2
		out[i+1] = 0xff & ((in[i]>>6)|(in[i+1]<<2));
    497a:	f806 4f01 	strb.w	r4, [r6, #1]!
	for (i=0;i<byte_count-1;i++)
    497e:	d1f5      	bne.n	496c <null_encode+0x30>
    4980:	448c      	add	ip, r1
	}
	// last bits
	out[i+1] = (in[i]>>6);
    4982:	f89c 2000 	ldrb.w	r2, [ip]
    4986:	0992      	lsrs	r2, r2, #6
    4988:	f80e 2003 	strb.w	r2, [lr, r3]
}
    498c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	for (i=0;i<byte_count-1;i++)
    498e:	2301      	movs	r3, #1
    4990:	e7f7      	b.n	4982 <null_encode+0x46>
		memcpy(out, in, byte_count);
    4992:	461a      	mov	r2, r3
    4994:	4670      	mov	r0, lr
}
    4996:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		memcpy(out, in, byte_count);
    499a:	f005 be93 	b.w	a6c4 <memcpy>
		DIE("nyi unaligned out %d\n", out_of);
    499e:	4611      	mov	r1, r2
    49a0:	4801      	ldr	r0, [pc, #4]	; (49a8 <null_encode+0x6c>)
    49a2:	f003 fb37 	bl	8014 <die>
    49a6:	bf00      	nop
    49a8:	0000c9d8 	.word	0x0000c9d8

000049ac <whiten>:

/* (Un)whiten n bits from input to output, possibly in place*/
void whiten(uint8_t* output, uint8_t* input, int length, uint8_t *statep)
{
    49ac:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	unsigned i;
	uint8_t state = *statep;
    49b0:	781c      	ldrb	r4, [r3, #0]
	unsigned nbytes = length>>3;
	unsigned nbits = length&7;

	state &= 0x7f;

	for(i=0;i<nbytes;i++)
    49b2:	ea5f 09e2 	movs.w	r9, r2, asr #3
	state &= 0x7f;
    49b6:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	unsigned nbits = length&7;
    49ba:	f002 0807 	and.w	r8, r2, #7
	for(i=0;i<nbytes;i++)
    49be:	d011      	beq.n	49e4 <whiten+0x38>
    49c0:	1e4d      	subs	r5, r1, #1
    49c2:	4f15      	ldr	r7, [pc, #84]	; (4a18 <whiten+0x6c>)
    49c4:	eb05 0e09 	add.w	lr, r5, r9
    49c8:	1e46      	subs	r6, r0, #1
	{
		output[i] = input[i]^whiten_word_tbl[state];
    49ca:	f815 2f01 	ldrb.w	r2, [r5, #1]!
    49ce:	f817 c004 	ldrb.w	ip, [r7, r4]
	for(i=0;i<nbytes;i++)
    49d2:	4575      	cmp	r5, lr
		state = whiten_state_tbl[7][state];
    49d4:	443c      	add	r4, r7
		output[i] = input[i]^whiten_word_tbl[state];
    49d6:	ea82 020c 	eor.w	r2, r2, ip
		state = whiten_state_tbl[7][state];
    49da:	f894 4400 	ldrb.w	r4, [r4, #1024]	; 0x400
		output[i] = input[i]^whiten_word_tbl[state];
    49de:	f806 2f01 	strb.w	r2, [r6, #1]!
	for(i=0;i<nbytes;i++)
    49e2:	d1f2      	bne.n	49ca <whiten+0x1e>
	}
	if (nbits)
    49e4:	f1b8 0f00 	cmp.w	r8, #0
    49e8:	d013      	beq.n	4a12 <whiten+0x66>
	{
		output[i] = (input[i]^whiten_word_tbl[state]) & ((1<<nbits)-1);
    49ea:	2501      	movs	r5, #1
    49ec:	4a0a      	ldr	r2, [pc, #40]	; (4a18 <whiten+0x6c>)
    49ee:	f811 1009 	ldrb.w	r1, [r1, r9]
    49f2:	5d16      	ldrb	r6, [r2, r4]
    49f4:	fa05 f508 	lsl.w	r5, r5, r8

		/* Advance state */
		state = whiten_state_tbl[nbits-1][state];
    49f8:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    49fc:	eb02 18c8 	add.w	r8, r2, r8, lsl #7
    4a00:	4444      	add	r4, r8
		output[i] = (input[i]^whiten_word_tbl[state]) & ((1<<nbits)-1);
    4a02:	ea81 0206 	eor.w	r2, r1, r6
    4a06:	1e69      	subs	r1, r5, #1
    4a08:	400a      	ands	r2, r1
		state = whiten_state_tbl[nbits-1][state];
    4a0a:	f894 4080 	ldrb.w	r4, [r4, #128]	; 0x80
		output[i] = (input[i]^whiten_word_tbl[state]) & ((1<<nbits)-1);
    4a0e:	f800 2009 	strb.w	r2, [r0, r9]
	}
	*statep = state;
    4a12:	701c      	strb	r4, [r3, #0]
}
    4a14:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    4a18:	0000c9f4 	.word	0x0000c9f4

00004a1c <fec23>:
 * in : input buffer of nbits
 * out_of: output offset in bits
 * nbits: size of input in bits
*/
int fec23(uint8_t *out, uint8_t *in, unsigned out_of, unsigned nbits)
{
    4a1c:	b5f0      	push	{r4, r5, r6, r7, lr}
	unsigned in_bit_pos, byte_pos, out_bit_pos, data;
	unsigned nout = ((nbits+9)/10)*15;
    4a1e:	4c74      	ldr	r4, [pc, #464]	; (4bf0 <fec23+0x1d4>)
    4a20:	f103 0509 	add.w	r5, r3, #9
    4a24:	fba4 3505 	umull	r3, r5, r4, r5
    4a28:	08ed      	lsrs	r5, r5, #3

	// 10 bits in -> 15 output bits
	for(in_bit_pos=0, out_bit_pos=out_of
    4a2a:	ebd5 1505 	rsbs	r5, r5, r5, lsl #4
    4a2e:	d03a      	beq.n	4aa6 <fec23+0x8a>
    4a30:	2400      	movs	r4, #0
    4a32:	4e70      	ldr	r6, [pc, #448]	; (4bf4 <fec23+0x1d8>)
		; in_bit_pos<nout
		; in_bit_pos+=10, out_bit_pos+=15)
	{
		byte_pos =in_bit_pos>>3;
		switch(in_bit_pos&7) {
    4a34:	f004 0307 	and.w	r3, r4, #7
		byte_pos =in_bit_pos>>3;
    4a38:	08e7      	lsrs	r7, r4, #3
		switch(in_bit_pos&7) {
    4a3a:	2b06      	cmp	r3, #6
    4a3c:	f200 80b9 	bhi.w	4bb2 <fec23+0x196>
    4a40:	e8df f003 	tbb	[pc, r3]
    4a44:	949da6af 	.word	0x949da6af
    4a48:	828b      	.short	0x828b
    4a4a:	04          	.byte	0x04
    4a4b:	00          	.byte	0x00
		case 1: data = EXTRACT10_1(in+byte_pos); break;
		case 2: data = EXTRACT10_2(in+byte_pos); break;
		case 3: data = EXTRACT10_3(in+byte_pos); break;
		case 4: data = EXTRACT10_4(in+byte_pos); break;
		case 5: data = EXTRACT10_5(in+byte_pos); break;
		case 6: data = EXTRACT10_6(in+byte_pos); break;
    4a4c:	5dcb      	ldrb	r3, [r1, r7]
    4a4e:	eb01 0c07 	add.w	ip, r1, r7
    4a52:	f89c 7001 	ldrb.w	r7, [ip, #1]
    4a56:	099b      	lsrs	r3, r3, #6
    4a58:	ea43 0387 	orr.w	r3, r3, r7, lsl #2
		default:data = EXTRACT10_7(in+byte_pos); break;
		}
		/* Add the fec23 word  */
		data |= fec23_tbl[data]<<10;
    4a5c:	18f7      	adds	r7, r6, r3
    4a5e:	f897 c480 	ldrb.w	ip, [r7, #1152]	; 0x480

		/* write to */
		byte_pos = out_bit_pos>>3;
		switch(out_bit_pos&7) {
    4a62:	f002 0707 	and.w	r7, r2, #7
		data |= fec23_tbl[data]<<10;
    4a66:	ea43 238c 	orr.w	r3, r3, ip, lsl #10
		byte_pos = out_bit_pos>>3;
    4a6a:	ea4f 0cd2 	mov.w	ip, r2, lsr #3
		switch(out_bit_pos&7) {
    4a6e:	2f06      	cmp	r7, #6
    4a70:	f200 80ae 	bhi.w	4bd0 <fec23+0x1b4>
    4a74:	e8df f007 	tbb	[pc, r7]
    4a78:	37465561 	.word	0x37465561
    4a7c:	1928      	.short	0x1928
    4a7e:	04          	.byte	0x04
    4a7f:	00          	.byte	0x00
		case 1: ENCODE15_1(out+byte_pos,data); break;
		case 2: ENCODE15_2(out+byte_pos,data); break;
		case 3: ENCODE15_3(out+byte_pos,data); break;
		case 4: ENCODE15_4(out+byte_pos,data); break;
		case 5: ENCODE15_5(out+byte_pos,data); break;
		case 6: ENCODE15_6(out+byte_pos,data); break;
    4a80:	f810 700c 	ldrb.w	r7, [r0, ip]
    4a84:	eb00 0e0c 	add.w	lr, r0, ip
    4a88:	ea47 1783 	orr.w	r7, r7, r3, lsl #6
    4a8c:	f800 700c 	strb.w	r7, [r0, ip]
    4a90:	089f      	lsrs	r7, r3, #2
    4a92:	0a9b      	lsrs	r3, r3, #10
    4a94:	f88e 7001 	strb.w	r7, [lr, #1]
    4a98:	f88e 3002 	strb.w	r3, [lr, #2]
		; in_bit_pos+=10, out_bit_pos+=15)
    4a9c:	340a      	adds	r4, #10
	for(in_bit_pos=0, out_bit_pos=out_of
    4a9e:	42a5      	cmp	r5, r4
		; in_bit_pos+=10, out_bit_pos+=15)
    4aa0:	f102 020f 	add.w	r2, r2, #15
	for(in_bit_pos=0, out_bit_pos=out_of
    4aa4:	d8c6      	bhi.n	4a34 <fec23+0x18>
		default:ENCODE15_7(out+byte_pos,data); break;
		}
		/* TODO: last word padding ? */
	}
	return 0;
}
    4aa6:	2000      	movs	r0, #0
    4aa8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		case 5: ENCODE15_5(out+byte_pos,data); break;
    4aaa:	f810 700c 	ldrb.w	r7, [r0, ip]
    4aae:	eb00 0e0c 	add.w	lr, r0, ip
    4ab2:	ea47 1743 	orr.w	r7, r7, r3, lsl #5
    4ab6:	f800 700c 	strb.w	r7, [r0, ip]
    4aba:	08df      	lsrs	r7, r3, #3
    4abc:	0adb      	lsrs	r3, r3, #11
    4abe:	f88e 7001 	strb.w	r7, [lr, #1]
    4ac2:	f88e 3002 	strb.w	r3, [lr, #2]
    4ac6:	e7e9      	b.n	4a9c <fec23+0x80>
		case 4: ENCODE15_4(out+byte_pos,data); break;
    4ac8:	f810 700c 	ldrb.w	r7, [r0, ip]
    4acc:	eb00 0e0c 	add.w	lr, r0, ip
    4ad0:	ea47 1703 	orr.w	r7, r7, r3, lsl #4
    4ad4:	f800 700c 	strb.w	r7, [r0, ip]
    4ad8:	091f      	lsrs	r7, r3, #4
    4ada:	0b1b      	lsrs	r3, r3, #12
    4adc:	f88e 7001 	strb.w	r7, [lr, #1]
    4ae0:	f88e 3002 	strb.w	r3, [lr, #2]
    4ae4:	e7da      	b.n	4a9c <fec23+0x80>
		case 3: ENCODE15_3(out+byte_pos,data); break;
    4ae6:	f810 700c 	ldrb.w	r7, [r0, ip]
    4aea:	eb00 0e0c 	add.w	lr, r0, ip
    4aee:	ea47 07c3 	orr.w	r7, r7, r3, lsl #3
    4af2:	f800 700c 	strb.w	r7, [r0, ip]
    4af6:	095f      	lsrs	r7, r3, #5
    4af8:	0b5b      	lsrs	r3, r3, #13
    4afa:	f88e 7001 	strb.w	r7, [lr, #1]
    4afe:	f88e 3002 	strb.w	r3, [lr, #2]
    4b02:	e7cb      	b.n	4a9c <fec23+0x80>
		case 2: ENCODE15_2(out+byte_pos,data); break;
    4b04:	f810 700c 	ldrb.w	r7, [r0, ip]
    4b08:	eb00 0e0c 	add.w	lr, r0, ip
    4b0c:	ea47 0783 	orr.w	r7, r7, r3, lsl #2
    4b10:	f800 700c 	strb.w	r7, [r0, ip]
    4b14:	099f      	lsrs	r7, r3, #6
    4b16:	0b9b      	lsrs	r3, r3, #14
    4b18:	f88e 7001 	strb.w	r7, [lr, #1]
    4b1c:	f88e 3002 	strb.w	r3, [lr, #2]
    4b20:	e7bc      	b.n	4a9c <fec23+0x80>
		case 1: ENCODE15_1(out+byte_pos,data); break;
    4b22:	f810 700c 	ldrb.w	r7, [r0, ip]
    4b26:	eb00 0e0c 	add.w	lr, r0, ip
    4b2a:	ea47 0743 	orr.w	r7, r7, r3, lsl #1
    4b2e:	09db      	lsrs	r3, r3, #7
    4b30:	f800 700c 	strb.w	r7, [r0, ip]
    4b34:	f88e 3001 	strb.w	r3, [lr, #1]
    4b38:	e7b0      	b.n	4a9c <fec23+0x80>
		case 0: ENCODE15_0(out+byte_pos,data); break;
    4b3a:	f800 300c 	strb.w	r3, [r0, ip]
    4b3e:	eb00 070c 	add.w	r7, r0, ip
    4b42:	0a1b      	lsrs	r3, r3, #8
    4b44:	707b      	strb	r3, [r7, #1]
    4b46:	e7a9      	b.n	4a9c <fec23+0x80>
		case 5: data = EXTRACT10_5(in+byte_pos); break;
    4b48:	19cb      	adds	r3, r1, r7
    4b4a:	785b      	ldrb	r3, [r3, #1]
    4b4c:	5dcf      	ldrb	r7, [r1, r7]
    4b4e:	00db      	lsls	r3, r3, #3
    4b50:	f403 737e 	and.w	r3, r3, #1016	; 0x3f8
    4b54:	ea43 1357 	orr.w	r3, r3, r7, lsr #5
    4b58:	e780      	b.n	4a5c <fec23+0x40>
		case 4: data = EXTRACT10_4(in+byte_pos); break;
    4b5a:	19cb      	adds	r3, r1, r7
    4b5c:	785b      	ldrb	r3, [r3, #1]
    4b5e:	5dcf      	ldrb	r7, [r1, r7]
    4b60:	011b      	lsls	r3, r3, #4
    4b62:	f403 737c 	and.w	r3, r3, #1008	; 0x3f0
    4b66:	ea43 1317 	orr.w	r3, r3, r7, lsr #4
    4b6a:	e777      	b.n	4a5c <fec23+0x40>
		case 3: data = EXTRACT10_3(in+byte_pos); break;
    4b6c:	19cb      	adds	r3, r1, r7
    4b6e:	785b      	ldrb	r3, [r3, #1]
    4b70:	5dcf      	ldrb	r7, [r1, r7]
    4b72:	015b      	lsls	r3, r3, #5
    4b74:	f403 7378 	and.w	r3, r3, #992	; 0x3e0
    4b78:	ea43 03d7 	orr.w	r3, r3, r7, lsr #3
    4b7c:	e76e      	b.n	4a5c <fec23+0x40>
		case 2: data = EXTRACT10_2(in+byte_pos); break;
    4b7e:	19cb      	adds	r3, r1, r7
    4b80:	785b      	ldrb	r3, [r3, #1]
    4b82:	5dcf      	ldrb	r7, [r1, r7]
    4b84:	019b      	lsls	r3, r3, #6
    4b86:	f403 7370 	and.w	r3, r3, #960	; 0x3c0
    4b8a:	ea43 0397 	orr.w	r3, r3, r7, lsr #2
    4b8e:	e765      	b.n	4a5c <fec23+0x40>
		case 1: data = EXTRACT10_1(in+byte_pos); break;
    4b90:	19cb      	adds	r3, r1, r7
    4b92:	785b      	ldrb	r3, [r3, #1]
    4b94:	5dcf      	ldrb	r7, [r1, r7]
    4b96:	01db      	lsls	r3, r3, #7
    4b98:	f403 7360 	and.w	r3, r3, #896	; 0x380
    4b9c:	ea43 0357 	orr.w	r3, r3, r7, lsr #1
    4ba0:	e75c      	b.n	4a5c <fec23+0x40>
		case 0: data = EXTRACT10_0(in+byte_pos); break;
    4ba2:	19cb      	adds	r3, r1, r7
    4ba4:	785b      	ldrb	r3, [r3, #1]
    4ba6:	5dcf      	ldrb	r7, [r1, r7]
    4ba8:	021b      	lsls	r3, r3, #8
    4baa:	f403 7340 	and.w	r3, r3, #768	; 0x300
    4bae:	433b      	orrs	r3, r7
    4bb0:	e754      	b.n	4a5c <fec23+0x40>
		default:data = EXTRACT10_7(in+byte_pos); break;
    4bb2:	eb01 0c07 	add.w	ip, r1, r7
    4bb6:	5dcb      	ldrb	r3, [r1, r7]
    4bb8:	f89c 7002 	ldrb.w	r7, [ip, #2]
    4bbc:	f89c c001 	ldrb.w	ip, [ip, #1]
    4bc0:	09db      	lsrs	r3, r3, #7
    4bc2:	027f      	lsls	r7, r7, #9
    4bc4:	ea43 034c 	orr.w	r3, r3, ip, lsl #1
    4bc8:	f407 7700 	and.w	r7, r7, #512	; 0x200
    4bcc:	433b      	orrs	r3, r7
    4bce:	e745      	b.n	4a5c <fec23+0x40>
		default:ENCODE15_7(out+byte_pos,data); break;
    4bd0:	f810 700c 	ldrb.w	r7, [r0, ip]
    4bd4:	eb00 0e0c 	add.w	lr, r0, ip
    4bd8:	ea47 17c3 	orr.w	r7, r7, r3, lsl #7
    4bdc:	f800 700c 	strb.w	r7, [r0, ip]
    4be0:	085f      	lsrs	r7, r3, #1
    4be2:	0a5b      	lsrs	r3, r3, #9
    4be4:	f88e 7001 	strb.w	r7, [lr, #1]
    4be8:	f88e 3002 	strb.w	r3, [lr, #2]
    4bec:	e756      	b.n	4a9c <fec23+0x80>
    4bee:	bf00      	nop
    4bf0:	cccccccd 	.word	0xcccccccd
    4bf4:	0000c9f4 	.word	0x0000c9f4

00004bf8 <unfec23_10bytes>:
}


/* Unfec23 15 bytes in -> 10 bytes out, start at bit 2 for obvious reasons */
int unfec23_10bytes(uint8_t *out, uint8_t *in)
{
    4bf8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4bfc:	b08b      	sub	sp, #44	; 0x2c
    4bfe:	4684      	mov	ip, r0

	in1 = unfec23_10bits(EXTRACT15_2(in));
	in2 = unfec23_10bits(EXTRACT15_1(in+2));
	in3 = unfec23_10bits(EXTRACT15_0(in+4));
	in4 = unfec23_10bits(EXTRACT15_7(in+5));
	in5 = unfec23_10bits(EXTRACT15_6(in+7));
    4c00:	7a4d      	ldrb	r5, [r1, #9]
	in3 = unfec23_10bits(EXTRACT15_0(in+4));
    4c02:	7948      	ldrb	r0, [r1, #5]
	in4 = unfec23_10bits(EXTRACT15_7(in+5));
    4c04:	798e      	ldrb	r6, [r1, #6]
	in5 = unfec23_10bits(EXTRACT15_6(in+7));
    4c06:	9502      	str	r5, [sp, #8]
	in3 = unfec23_10bits(EXTRACT15_0(in+4));
    4c08:	f891 e004 	ldrb.w	lr, [r1, #4]
    4c0c:	0205      	lsls	r5, r0, #8
	in4 = unfec23_10bits(EXTRACT15_7(in+5));
    4c0e:	9604      	str	r6, [sp, #16]
	in3 = unfec23_10bits(EXTRACT15_0(in+4));
    4c10:	f405 45fe 	and.w	r5, r5, #32512	; 0x7f00
    4c14:	ea4e 0e05 	orr.w	lr, lr, r5
	in4 = unfec23_10bits(EXTRACT15_7(in+5));
    4c18:	9d04      	ldr	r5, [sp, #16]
	in1 = unfec23_10bits(EXTRACT15_2(in));
    4c1a:	788b      	ldrb	r3, [r1, #2]
    4c1c:	784a      	ldrb	r2, [r1, #1]
	in4 = unfec23_10bits(EXTRACT15_7(in+5));
    4c1e:	09c0      	lsrs	r0, r0, #7
	in2 = unfec23_10bits(EXTRACT15_1(in+2));
    4c20:	f891 a003 	ldrb.w	sl, [r1, #3]
	in6 = unfec23_10bits(EXTRACT15_5(in+9));
	in7 = unfec23_10bits(EXTRACT15_4(in+11));
    4c24:	7b4e      	ldrb	r6, [r1, #13]
	in4 = unfec23_10bits(EXTRACT15_7(in+5));
    4c26:	ea40 0045 	orr.w	r0, r0, r5, lsl #1
	in6 = unfec23_10bits(EXTRACT15_5(in+9));
    4c2a:	9d02      	ldr	r5, [sp, #8]
    4c2c:	f891 b00b 	ldrb.w	fp, [r1, #11]
    4c30:	7a8f      	ldrb	r7, [r1, #10]
	in2 = unfec23_10bits(EXTRACT15_1(in+2));
    4c32:	ea4f 0953 	mov.w	r9, r3, lsr #1
	in1 = unfec23_10bits(EXTRACT15_2(in));
    4c36:	0192      	lsls	r2, r2, #6
    4c38:	9201      	str	r2, [sp, #4]
	in4 = unfec23_10bits(EXTRACT15_7(in+5));
    4c3a:	79cc      	ldrb	r4, [r1, #7]
	in7 = unfec23_10bits(EXTRACT15_4(in+11));
    4c3c:	9603      	str	r6, [sp, #12]
	in2 = unfec23_10bits(EXTRACT15_1(in+2));
    4c3e:	ea49 12ca 	orr.w	r2, r9, sl, lsl #7
	in7 = unfec23_10bits(EXTRACT15_4(in+11));
    4c42:	7b0e      	ldrb	r6, [r1, #12]
	in6 = unfec23_10bits(EXTRACT15_5(in+9));
    4c44:	096d      	lsrs	r5, r5, #5
	in2 = unfec23_10bits(EXTRACT15_1(in+2));
    4c46:	9200      	str	r2, [sp, #0]
	in6 = unfec23_10bits(EXTRACT15_5(in+9));
    4c48:	ea45 07c7 	orr.w	r7, r5, r7, lsl #3
	in7 = unfec23_10bits(EXTRACT15_4(in+11));
    4c4c:	ea4f 151b 	mov.w	r5, fp, lsr #4
	in1 = unfec23_10bits(EXTRACT15_2(in));
    4c50:	f891 8000 	ldrb.w	r8, [r1]
    4c54:	9a01      	ldr	r2, [sp, #4]
	in7 = unfec23_10bits(EXTRACT15_4(in+11));
    4c56:	ea45 1606 	orr.w	r6, r5, r6, lsl #4
	in4 = unfec23_10bits(EXTRACT15_7(in+5));
    4c5a:	ea4f 2944 	mov.w	r9, r4, lsl #9
	data = in & 0x3ff;
    4c5e:	9d00      	ldr	r5, [sp, #0]
	in4 = unfec23_10bits(EXTRACT15_7(in+5));
    4c60:	f409 49fc 	and.w	r9, r9, #32256	; 0x7e00
	in3 = unfec23_10bits(EXTRACT15_0(in+4));
    4c64:	f8cd e004 	str.w	lr, [sp, #4]
	in1 = unfec23_10bits(EXTRACT15_2(in));
    4c68:	ea42 0298 	orr.w	r2, r2, r8, lsr #2
	in4 = unfec23_10bits(EXTRACT15_7(in+5));
    4c6c:	ea40 0009 	orr.w	r0, r0, r9
	in5 = unfec23_10bits(EXTRACT15_6(in+7));
    4c70:	f891 8008 	ldrb.w	r8, [r1, #8]
	data = in & 0x3ff;
    4c74:	f3c5 0509 	ubfx	r5, r5, #0, #10
    4c78:	9507      	str	r5, [sp, #28]
	in4 = unfec23_10bits(EXTRACT15_7(in+5));
    4c7a:	9009      	str	r0, [sp, #36]	; 0x24
	in8 = unfec23_10bits(EXTRACT15_3(in+13));
    4c7c:	9d03      	ldr	r5, [sp, #12]
	data = in & 0x3ff;
    4c7e:	9801      	ldr	r0, [sp, #4]
	in5 = unfec23_10bits(EXTRACT15_6(in+7));
    4c80:	09a4      	lsrs	r4, r4, #6
	in8 = unfec23_10bits(EXTRACT15_3(in+13));
    4c82:	f891 e00e 	ldrb.w	lr, [r1, #14]
	data = in & 0x3ff;
    4c86:	ea44 0488 	orr.w	r4, r4, r8, lsl #2
    4c8a:	f3c2 0809 	ubfx	r8, r2, #0, #10
    4c8e:	9405      	str	r4, [sp, #20]
    4c90:	f8cd 8020 	str.w	r8, [sp, #32]
	in8 = unfec23_10bits(EXTRACT15_3(in+13));
    4c94:	08ec      	lsrs	r4, r5, #3
	data = in & 0x3ff;
    4c96:	f3c0 0809 	ubfx	r8, r0, #0, #10
	cor = fec23_cor[err];
    4c9a:	f8df a1b0 	ldr.w	sl, [pc, #432]	; 4e4c <unfec23_10bytes+0x254>
	in8 = unfec23_10bits(EXTRACT15_3(in+13));
    4c9e:	ea44 1e4e 	orr.w	lr, r4, lr, lsl #5
    4ca2:	7bc9      	ldrb	r1, [r1, #15]
	data = in & 0x3ff;
    4ca4:	f8cd 8018 	str.w	r8, [sp, #24]
	err = 0x1f & ((in>>10)^fec23_tbl[data]);
    4ca8:	9c07      	ldr	r4, [sp, #28]
	in1 = unfec23_10bits(EXTRACT15_2(in));
    4caa:	ea4f 3883 	mov.w	r8, r3, lsl #14
	err = 0x1f & ((in>>10)^fec23_tbl[data]);
    4cae:	eb0a 0004 	add.w	r0, sl, r4
	in7 = unfec23_10bits(EXTRACT15_4(in+11));
    4cb2:	032c      	lsls	r4, r5, #12
	in1 = unfec23_10bits(EXTRACT15_2(in));
    4cb4:	f408 4880 	and.w	r8, r8, #16384	; 0x4000
	in7 = unfec23_10bits(EXTRACT15_4(in+11));
    4cb8:	f404 44e0 	and.w	r4, r4, #28672	; 0x7000
	in1 = unfec23_10bits(EXTRACT15_2(in));
    4cbc:	ea42 0208 	orr.w	r2, r2, r8
	in7 = unfec23_10bits(EXTRACT15_4(in+11));
    4cc0:	4334      	orrs	r4, r6
	data = in & 0x3ff;
    4cc2:	f3c6 0809 	ubfx	r8, r6, #0, #10
	err = 0x1f & ((in>>10)^fec23_tbl[data]);
    4cc6:	9e08      	ldr	r6, [sp, #32]
	data = in & 0x3ff;
    4cc8:	f3c7 0909 	ubfx	r9, r7, #0, #10
	in8 = unfec23_10bits(EXTRACT15_3(in+13));
    4ccc:	0349      	lsls	r1, r1, #13
	data = in & 0x3ff;
    4cce:	f8cd 9010 	str.w	r9, [sp, #16]
	err = 0x1f & ((in>>10)^fec23_tbl[data]);
    4cd2:	eb0a 0306 	add.w	r3, sl, r6
    4cd6:	f890 9480 	ldrb.w	r9, [r0, #1152]	; 0x480
    4cda:	9e06      	ldr	r6, [sp, #24]
	in8 = unfec23_10bits(EXTRACT15_3(in+13));
    4cdc:	f401 40c0 	and.w	r0, r1, #24576	; 0x6000
	err = 0x1f & ((in>>10)^fec23_tbl[data]);
    4ce0:	9900      	ldr	r1, [sp, #0]
	data = in & 0x3ff;
    4ce2:	f8cd 800c 	str.w	r8, [sp, #12]
	err = 0x1f & ((in>>10)^fec23_tbl[data]);
    4ce6:	f893 8480 	ldrb.w	r8, [r3, #1152]	; 0x480
    4cea:	eb0a 0306 	add.w	r3, sl, r6
    4cee:	ea89 2691 	eor.w	r6, r9, r1, lsr #10
    4cf2:	9905      	ldr	r1, [sp, #20]
    4cf4:	ea88 2892 	eor.w	r8, r8, r2, lsr #10
    4cf8:	9a04      	ldr	r2, [sp, #16]
    4cfa:	f893 5480 	ldrb.w	r5, [r3, #1152]	; 0x480
    4cfe:	eb0a 0301 	add.w	r3, sl, r1
    4d02:	f893 1480 	ldrb.w	r1, [r3, #1152]	; 0x480
    4d06:	eb0a 0302 	add.w	r3, sl, r2
    4d0a:	9a01      	ldr	r2, [sp, #4]
	in6 = unfec23_10bits(EXTRACT15_5(in+9));
    4d0c:	ea4f 2bcb 	mov.w	fp, fp, lsl #11
	err = 0x1f & ((in>>10)^fec23_tbl[data]);
    4d10:	ea85 2592 	eor.w	r5, r5, r2, lsr #10
    4d14:	9a03      	ldr	r2, [sp, #12]
	in6 = unfec23_10bits(EXTRACT15_5(in+9));
    4d16:	f40b 4bf0 	and.w	fp, fp, #30720	; 0x7800
    4d1a:	ea47 070b 	orr.w	r7, r7, fp
	err = 0x1f & ((in>>10)^fec23_tbl[data]);
    4d1e:	f893 b480 	ldrb.w	fp, [r3, #1152]	; 0x480
    4d22:	eb0a 0302 	add.w	r3, sl, r2
    4d26:	f893 9480 	ldrb.w	r9, [r3, #1152]	; 0x480
    4d2a:	9b02      	ldr	r3, [sp, #8]
    4d2c:	ea8b 2b97 	eor.w	fp, fp, r7, lsr #10
    4d30:	4059      	eors	r1, r3
	data = in & 0x3ff;
    4d32:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4d34:	f3ce 0709 	ubfx	r7, lr, #0, #10
    4d38:	f3c3 0209 	ubfx	r2, r3, #0, #10
	in8 = unfec23_10bits(EXTRACT15_3(in+13));
    4d3c:	ea4e 0e00 	orr.w	lr, lr, r0
	err = 0x1f & ((in>>10)^fec23_tbl[data]);
    4d40:	eb0a 0002 	add.w	r0, sl, r2
    4d44:	ea89 2494 	eor.w	r4, r9, r4, lsr #10
	cor = fec23_cor[err];
    4d48:	f006 061f 	and.w	r6, r6, #31
	err = 0x1f & ((in>>10)^fec23_tbl[data]);
    4d4c:	f890 9480 	ldrb.w	r9, [r0, #1152]	; 0x480
	cor = fec23_cor[err];
    4d50:	eb0a 0646 	add.w	r6, sl, r6, lsl #1
	err = 0x1f & ((in>>10)^fec23_tbl[data]);
    4d54:	eb0a 0007 	add.w	r0, sl, r7
    4d58:	f890 0480 	ldrb.w	r0, [r0, #1152]	; 0x480
    4d5c:	9701      	str	r7, [sp, #4]
    4d5e:	ea89 2993 	eor.w	r9, r9, r3, lsr #10
	cor = fec23_cor[err];
    4d62:	f8b6 7880 	ldrh.w	r7, [r6, #2176]	; 0x880

	ENCODE10_0(out,  in1&0x3ff);
	ENCODE10_2(out+1,in2&0x3ff);
    4d66:	9b07      	ldr	r3, [sp, #28]
	cor = fec23_cor[err];
    4d68:	f008 081f 	and.w	r8, r8, #31
    4d6c:	eb0a 0848 	add.w	r8, sl, r8, lsl #1
	ENCODE10_2(out+1,in2&0x3ff);
    4d70:	405f      	eors	r7, r3
	err = 0x1f & ((in>>10)^fec23_tbl[data]);
    4d72:	ea80 2e9e 	eor.w	lr, r0, lr, lsr #10
	data ^= cor;
    4d76:	9b08      	ldr	r3, [sp, #32]
	cor = fec23_cor[err];
    4d78:	f8b8 0880 	ldrh.w	r0, [r8, #2176]	; 0x880
    4d7c:	f005 051f 	and.w	r5, r5, #31
    4d80:	eb0a 0545 	add.w	r5, sl, r5, lsl #1
	data ^= cor;
    4d84:	4058      	eors	r0, r3
	cor = fec23_cor[err];
    4d86:	f8b5 6880 	ldrh.w	r6, [r5, #2176]	; 0x880
	ENCODE10_4(out+2,in3&0x3ff);
    4d8a:	9b06      	ldr	r3, [sp, #24]
	cor = fec23_cor[err];
    4d8c:	f00e 0e1f 	and.w	lr, lr, #31
    4d90:	f001 011f 	and.w	r1, r1, #31
    4d94:	f00b 0b1f 	and.w	fp, fp, #31
    4d98:	f004 041f 	and.w	r4, r4, #31
    4d9c:	f009 091f 	and.w	r9, r9, #31
    4da0:	eb0a 0b4b 	add.w	fp, sl, fp, lsl #1
    4da4:	eb0a 0949 	add.w	r9, sl, r9, lsl #1
    4da8:	eb0a 0141 	add.w	r1, sl, r1, lsl #1
    4dac:	eb0a 0444 	add.w	r4, sl, r4, lsl #1
    4db0:	eb0a 0a4e 	add.w	sl, sl, lr, lsl #1
    4db4:	f8ba 8880 	ldrh.w	r8, [sl, #2176]	; 0x880
    4db8:	f8b9 e880 	ldrh.w	lr, [r9, #2176]	; 0x880
    4dbc:	f8b1 1880 	ldrh.w	r1, [r1, #2176]	; 0x880
    4dc0:	f8bb 5880 	ldrh.w	r5, [fp, #2176]	; 0x880
	ENCODE10_4(out+2,in3&0x3ff);
    4dc4:	405e      	eors	r6, r3
	cor = fec23_cor[err];
    4dc6:	f8b4 4880 	ldrh.w	r4, [r4, #2176]	; 0x880
	data ^= cor;
    4dca:	9b05      	ldr	r3, [sp, #20]
	ENCODE10_0(out,  in1&0x3ff);
    4dcc:	f3c0 2b01 	ubfx	fp, r0, #8, #2
	data ^= cor;
    4dd0:	404b      	eors	r3, r1
    4dd2:	9300      	str	r3, [sp, #0]
	ENCODE10_6(out+3,in4&0x3ff);
	ENCODE10_0(out+5,in5&0x3ff);
	ENCODE10_2(out+6,in6&0x3ff);
    4dd4:	9b04      	ldr	r3, [sp, #16]
	ENCODE10_0(out,  in1&0x3ff);
    4dd6:	f88c 0000 	strb.w	r0, [ip]
	ENCODE10_2(out+6,in6&0x3ff);
    4dda:	405d      	eors	r5, r3
	ENCODE10_4(out+7,in7&0x3ff);
    4ddc:	9b03      	ldr	r3, [sp, #12]

	/* FIXME: return bit error count */
	//return ((in1 | in2 | in3 | in4 | in5 | in6 | in7 | in8) >> 10);
	return 0;

}
    4dde:	2000      	movs	r0, #0
	ENCODE10_4(out+7,in7&0x3ff);
    4de0:	405c      	eors	r4, r3
	ENCODE10_6(out+8,in8&0x3ff);
    4de2:	9b01      	ldr	r3, [sp, #4]
	ENCODE10_6(out+3,in4&0x3ff);
    4de4:	ea82 020e 	eor.w	r2, r2, lr
	ENCODE10_6(out+8,in8&0x3ff);
    4de8:	ea83 0308 	eor.w	r3, r3, r8
    4dec:	4619      	mov	r1, r3
	ENCODE10_4(out+2,in3&0x3ff);
    4dee:	f3c6 1a05 	ubfx	sl, r6, #4, #6
	ENCODE10_0(out+5,in5&0x3ff);
    4df2:	9b00      	ldr	r3, [sp, #0]
	ENCODE10_6(out+3,in4&0x3ff);
    4df4:	ea4a 1a82 	orr.w	sl, sl, r2, lsl #6
    4df8:	1092      	asrs	r2, r2, #2
	ENCODE10_2(out+1,in2&0x3ff);
    4dfa:	f3c7 1983 	ubfx	r9, r7, #6, #4
	ENCODE10_2(out+6,in6&0x3ff);
    4dfe:	f3c5 1883 	ubfx	r8, r5, #6, #4
	ENCODE10_0(out+5,in5&0x3ff);
    4e02:	f3c3 2301 	ubfx	r3, r3, #8, #2
	ENCODE10_4(out+7,in7&0x3ff);
    4e06:	f3c4 1e05 	ubfx	lr, r4, #4, #6
	ENCODE10_6(out+3,in4&0x3ff);
    4e0a:	f88c 2004 	strb.w	r2, [ip, #4]
	ENCODE10_0(out+5,in5&0x3ff);
    4e0e:	9a00      	ldr	r2, [sp, #0]
	ENCODE10_2(out+6,in6&0x3ff);
    4e10:	ea43 0585 	orr.w	r5, r3, r5, lsl #2
	ENCODE10_2(out+1,in2&0x3ff);
    4e14:	ea4b 0787 	orr.w	r7, fp, r7, lsl #2
	ENCODE10_4(out+2,in3&0x3ff);
    4e18:	ea49 1606 	orr.w	r6, r9, r6, lsl #4
	ENCODE10_4(out+7,in7&0x3ff);
    4e1c:	ea48 1404 	orr.w	r4, r8, r4, lsl #4
	ENCODE10_6(out+8,in8&0x3ff);
    4e20:	ea4e 1e81 	orr.w	lr, lr, r1, lsl #6
    4e24:	108b      	asrs	r3, r1, #2
	ENCODE10_2(out+1,in2&0x3ff);
    4e26:	f88c 7001 	strb.w	r7, [ip, #1]
	ENCODE10_6(out+3,in4&0x3ff);
    4e2a:	f88c a003 	strb.w	sl, [ip, #3]
	ENCODE10_4(out+2,in3&0x3ff);
    4e2e:	f88c 6002 	strb.w	r6, [ip, #2]
	ENCODE10_0(out+5,in5&0x3ff);
    4e32:	f88c 2005 	strb.w	r2, [ip, #5]
	ENCODE10_4(out+7,in7&0x3ff);
    4e36:	f88c 4007 	strb.w	r4, [ip, #7]
	ENCODE10_6(out+8,in8&0x3ff);
    4e3a:	f88c e008 	strb.w	lr, [ip, #8]
	ENCODE10_2(out+6,in6&0x3ff);
    4e3e:	f88c 5006 	strb.w	r5, [ip, #6]
	ENCODE10_6(out+8,in8&0x3ff);
    4e42:	f88c 3009 	strb.w	r3, [ip, #9]
}
    4e46:	b00b      	add	sp, #44	; 0x2c
    4e48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4e4c:	0000c9f4 	.word	0x0000c9f4

00004e50 <unfec23>:
int unfec23(uint8_t *out, uint8_t *in, unsigned in_of, unsigned nbits)
{
    4e50:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    4e54:	4615      	mov	r5, r2
	unsigned in_bit_pos=in_of, byte_pos, data;
	int out_bit_pos=0;
	int rc = 0;

	/* align output to 10 bits */
	nbits = (10*nbits+9)/10;
    4e56:	eb03 0783 	add.w	r7, r3, r3, lsl #2
    4e5a:	007f      	lsls	r7, r7, #1
    4e5c:	4b8f      	ldr	r3, [pc, #572]	; (509c <unfec23+0x24c>)
    4e5e:	3709      	adds	r7, #9
    4e60:	fba3 3707 	umull	r3, r7, r3, r7
    4e64:	08ff      	lsrs	r7, r7, #3

	/* clear output buffer */
	memset(out, 0, BYTE_ALIGN(nbits));
    4e66:	1dfa      	adds	r2, r7, #7
{
    4e68:	4688      	mov	r8, r1
	memset(out, 0, BYTE_ALIGN(nbits));
    4e6a:	08d2      	lsrs	r2, r2, #3
    4e6c:	2100      	movs	r1, #0
{
    4e6e:	4606      	mov	r6, r0
	memset(out, 0, BYTE_ALIGN(nbits));
    4e70:	f7ff f994 	bl	419c <memset>

	if ((in_of & 7) == 2)
    4e74:	f005 0307 	and.w	r3, r5, #7
    4e78:	2b02      	cmp	r3, #2
    4e7a:	f000 80de 	beq.w	503a <unfec23+0x1ea>
	int out_bit_pos=0;
    4e7e:	f04f 0900 	mov.w	r9, #0
		}
	}


	// 15 bits in -> 10 output bits
	for(//out_bit_pos=0, in_bit_pos=in_of
    4e82:	45b9      	cmp	r9, r7
    4e84:	f04f 0000 	mov.w	r0, #0
    4e88:	da4b      	bge.n	4f22 <unfec23+0xd2>
    4e8a:	4a85      	ldr	r2, [pc, #532]	; (50a0 <unfec23+0x250>)
		; out_bit_pos<(int)nbits
		; in_bit_pos+=15, out_bit_pos+=10)
	{
		byte_pos = in_bit_pos>>3;
		switch(in_bit_pos&7) {
    4e8c:	f005 0307 	and.w	r3, r5, #7
		byte_pos = in_bit_pos>>3;
    4e90:	08e9      	lsrs	r1, r5, #3
		switch(in_bit_pos&7) {
    4e92:	2b06      	cmp	r3, #6
    4e94:	f200 80f2 	bhi.w	507c <unfec23+0x22c>
    4e98:	e8df f003 	tbb	[pc, r3]
    4e9c:	9cacbcc5 	.word	0x9cacbcc5
    4ea0:	7c8c      	.short	0x7c8c
    4ea2:	04          	.byte	0x04
    4ea3:	00          	.byte	0x00
		case 1: data = EXTRACT15_1(in+byte_pos); break;
		case 2: data = EXTRACT15_2(in+byte_pos); break;
		case 3: data = EXTRACT15_3(in+byte_pos); break;
		case 4: data = EXTRACT15_4(in+byte_pos); break;
		case 5: data = EXTRACT15_5(in+byte_pos); break;
		case 6: data = EXTRACT15_6(in+byte_pos); break;
    4ea4:	eb08 0c01 	add.w	ip, r8, r1
    4ea8:	f818 3001 	ldrb.w	r3, [r8, r1]
    4eac:	f89c 4002 	ldrb.w	r4, [ip, #2]
    4eb0:	f89c 1001 	ldrb.w	r1, [ip, #1]
    4eb4:	099b      	lsrs	r3, r3, #6
    4eb6:	02a4      	lsls	r4, r4, #10
    4eb8:	ea43 0381 	orr.w	r3, r3, r1, lsl #2
    4ebc:	f404 44f8 	and.w	r4, r4, #31744	; 0x7c00
    4ec0:	431c      	orrs	r4, r3
	data = in & 0x3ff;
    4ec2:	f3c4 0c09 	ubfx	ip, r4, #0, #10
	err = 0x1f & ((in>>10)^fec23_tbl[data]);
    4ec6:	eb02 030c 	add.w	r3, r2, ip
    4eca:	f893 3480 	ldrb.w	r3, [r3, #1152]	; 0x480
		data = unfec23_10bits(data);
		rc |= (data>>10);
		data &= 0x3ff;
		/* write output */
		byte_pos = out_bit_pos>>3;
		switch(out_bit_pos&7) {
    4ece:	f009 0107 	and.w	r1, r9, #7
	err = 0x1f & ((in>>10)^fec23_tbl[data]);
    4ed2:	ea83 2394 	eor.w	r3, r3, r4, lsr #10
	cor = fec23_cor[err];
    4ed6:	f003 031f 	and.w	r3, r3, #31
    4eda:	eb02 0343 	add.w	r3, r2, r3, lsl #1
    4ede:	f8b3 3880 	ldrh.w	r3, [r3, #2176]	; 0x880
		byte_pos = out_bit_pos>>3;
    4ee2:	ea4f 04e9 	mov.w	r4, r9, asr #3
	data ^= cor;
    4ee6:	ea8c 0303 	eor.w	r3, ip, r3
		rc |= (data>>10);
    4eea:	ea40 2093 	orr.w	r0, r0, r3, lsr #10
		data &= 0x3ff;
    4eee:	f3c3 0309 	ubfx	r3, r3, #0, #10
		switch(out_bit_pos&7) {
    4ef2:	2906      	cmp	r1, #6
    4ef4:	f200 80b5 	bhi.w	5062 <unfec23+0x212>
    4ef8:	e8df f001 	tbb	[pc, r1]
    4efc:	29333d47 	.word	0x29333d47
    4f00:	151f      	.short	0x151f
    4f02:	04          	.byte	0x04
    4f03:	00          	.byte	0x00
		case 1: ENCODE10_1(out+byte_pos,data); break;
		case 2: ENCODE10_2(out+byte_pos,data); break;
		case 3: ENCODE10_3(out+byte_pos,data); break;
		case 4: ENCODE10_4(out+byte_pos,data); break;
		case 5: ENCODE10_5(out+byte_pos,data); break;
		case 6: ENCODE10_6(out+byte_pos,data); break;
    4f04:	5d31      	ldrb	r1, [r6, r4]
    4f06:	eb06 0c04 	add.w	ip, r6, r4
    4f0a:	ea41 1183 	orr.w	r1, r1, r3, lsl #6
    4f0e:	089b      	lsrs	r3, r3, #2
    4f10:	5531      	strb	r1, [r6, r4]
    4f12:	f88c 3001 	strb.w	r3, [ip, #1]
		; in_bit_pos+=15, out_bit_pos+=10)
    4f16:	f109 090a 	add.w	r9, r9, #10
	for(//out_bit_pos=0, in_bit_pos=in_of
    4f1a:	45b9      	cmp	r9, r7
		; in_bit_pos+=15, out_bit_pos+=10)
    4f1c:	f105 050f 	add.w	r5, r5, #15
	for(//out_bit_pos=0, in_bit_pos=in_of
    4f20:	dbb4      	blt.n	4e8c <unfec23+0x3c>
		default:ENCODE10_7(out+byte_pos,data); break;
		}
		
	}
	return rc;
}
    4f22:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		case 5: ENCODE10_5(out+byte_pos,data); break;
    4f26:	5d31      	ldrb	r1, [r6, r4]
    4f28:	eb06 0c04 	add.w	ip, r6, r4
    4f2c:	ea41 1143 	orr.w	r1, r1, r3, lsl #5
    4f30:	08db      	lsrs	r3, r3, #3
    4f32:	5531      	strb	r1, [r6, r4]
    4f34:	f88c 3001 	strb.w	r3, [ip, #1]
    4f38:	e7ed      	b.n	4f16 <unfec23+0xc6>
		case 4: ENCODE10_4(out+byte_pos,data); break;
    4f3a:	5d31      	ldrb	r1, [r6, r4]
    4f3c:	eb06 0c04 	add.w	ip, r6, r4
    4f40:	ea41 1103 	orr.w	r1, r1, r3, lsl #4
    4f44:	091b      	lsrs	r3, r3, #4
    4f46:	5531      	strb	r1, [r6, r4]
    4f48:	f88c 3001 	strb.w	r3, [ip, #1]
    4f4c:	e7e3      	b.n	4f16 <unfec23+0xc6>
		case 3: ENCODE10_3(out+byte_pos,data); break;
    4f4e:	5d31      	ldrb	r1, [r6, r4]
    4f50:	eb06 0c04 	add.w	ip, r6, r4
    4f54:	ea41 01c3 	orr.w	r1, r1, r3, lsl #3
    4f58:	095b      	lsrs	r3, r3, #5
    4f5a:	5531      	strb	r1, [r6, r4]
    4f5c:	f88c 3001 	strb.w	r3, [ip, #1]
    4f60:	e7d9      	b.n	4f16 <unfec23+0xc6>
		case 2: ENCODE10_2(out+byte_pos,data); break;
    4f62:	5d31      	ldrb	r1, [r6, r4]
    4f64:	eb06 0c04 	add.w	ip, r6, r4
    4f68:	ea41 0183 	orr.w	r1, r1, r3, lsl #2
    4f6c:	099b      	lsrs	r3, r3, #6
    4f6e:	5531      	strb	r1, [r6, r4]
    4f70:	f88c 3001 	strb.w	r3, [ip, #1]
    4f74:	e7cf      	b.n	4f16 <unfec23+0xc6>
		case 1: ENCODE10_1(out+byte_pos,data); break;
    4f76:	5d31      	ldrb	r1, [r6, r4]
    4f78:	eb06 0c04 	add.w	ip, r6, r4
    4f7c:	ea41 0143 	orr.w	r1, r1, r3, lsl #1
    4f80:	09db      	lsrs	r3, r3, #7
    4f82:	5531      	strb	r1, [r6, r4]
    4f84:	f88c 3001 	strb.w	r3, [ip, #1]
    4f88:	e7c5      	b.n	4f16 <unfec23+0xc6>
		case 0: ENCODE10_0(out+byte_pos,data); break;
    4f8a:	5533      	strb	r3, [r6, r4]
    4f8c:	1931      	adds	r1, r6, r4
    4f8e:	0a1b      	lsrs	r3, r3, #8
    4f90:	704b      	strb	r3, [r1, #1]
    4f92:	e7c0      	b.n	4f16 <unfec23+0xc6>
		case 5: data = EXTRACT15_5(in+byte_pos); break;
    4f94:	eb08 0c01 	add.w	ip, r8, r1
    4f98:	f818 3001 	ldrb.w	r3, [r8, r1]
    4f9c:	f89c 4002 	ldrb.w	r4, [ip, #2]
    4fa0:	f89c 1001 	ldrb.w	r1, [ip, #1]
    4fa4:	095b      	lsrs	r3, r3, #5
    4fa6:	02e4      	lsls	r4, r4, #11
    4fa8:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
    4fac:	f404 44f0 	and.w	r4, r4, #30720	; 0x7800
    4fb0:	431c      	orrs	r4, r3
    4fb2:	e786      	b.n	4ec2 <unfec23+0x72>
		case 4: data = EXTRACT15_4(in+byte_pos); break;
    4fb4:	eb08 0c01 	add.w	ip, r8, r1
    4fb8:	f818 3001 	ldrb.w	r3, [r8, r1]
    4fbc:	f89c 4002 	ldrb.w	r4, [ip, #2]
    4fc0:	f89c 1001 	ldrb.w	r1, [ip, #1]
    4fc4:	091b      	lsrs	r3, r3, #4
    4fc6:	0324      	lsls	r4, r4, #12
    4fc8:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
    4fcc:	f404 44e0 	and.w	r4, r4, #28672	; 0x7000
    4fd0:	431c      	orrs	r4, r3
    4fd2:	e776      	b.n	4ec2 <unfec23+0x72>
		case 3: data = EXTRACT15_3(in+byte_pos); break;
    4fd4:	eb08 0c01 	add.w	ip, r8, r1
    4fd8:	f818 3001 	ldrb.w	r3, [r8, r1]
    4fdc:	f89c 4002 	ldrb.w	r4, [ip, #2]
    4fe0:	f89c 1001 	ldrb.w	r1, [ip, #1]
    4fe4:	08db      	lsrs	r3, r3, #3
    4fe6:	0364      	lsls	r4, r4, #13
    4fe8:	ea43 1341 	orr.w	r3, r3, r1, lsl #5
    4fec:	f404 44c0 	and.w	r4, r4, #24576	; 0x6000
    4ff0:	431c      	orrs	r4, r3
    4ff2:	e766      	b.n	4ec2 <unfec23+0x72>
		case 2: data = EXTRACT15_2(in+byte_pos); break;
    4ff4:	eb08 0c01 	add.w	ip, r8, r1
    4ff8:	f818 3001 	ldrb.w	r3, [r8, r1]
    4ffc:	f89c 4002 	ldrb.w	r4, [ip, #2]
    5000:	f89c 1001 	ldrb.w	r1, [ip, #1]
    5004:	089b      	lsrs	r3, r3, #2
    5006:	03a4      	lsls	r4, r4, #14
    5008:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
    500c:	f404 4480 	and.w	r4, r4, #16384	; 0x4000
    5010:	431c      	orrs	r4, r3
    5012:	e756      	b.n	4ec2 <unfec23+0x72>
		case 1: data = EXTRACT15_1(in+byte_pos); break;
    5014:	f818 3001 	ldrb.w	r3, [r8, r1]
    5018:	eb08 0401 	add.w	r4, r8, r1
    501c:	7864      	ldrb	r4, [r4, #1]
    501e:	085b      	lsrs	r3, r3, #1
    5020:	ea43 14c4 	orr.w	r4, r3, r4, lsl #7
    5024:	e74d      	b.n	4ec2 <unfec23+0x72>
		case 0: data = EXTRACT15_0(in+byte_pos); break;
    5026:	eb08 0301 	add.w	r3, r8, r1
    502a:	785b      	ldrb	r3, [r3, #1]
    502c:	f818 4001 	ldrb.w	r4, [r8, r1]
    5030:	021b      	lsls	r3, r3, #8
    5032:	f403 43fe 	and.w	r3, r3, #32512	; 0x7f00
    5036:	431c      	orrs	r4, r3
    5038:	e743      	b.n	4ec2 <unfec23+0x72>
			; out_bit_pos<=(int)nbits-80
    503a:	f1a7 044f 	sub.w	r4, r7, #79	; 0x4f
		for(//out_bit_pos=0, in_bit_pos=in_of
    503e:	2c00      	cmp	r4, #0
	int out_bit_pos=0;
    5040:	f04f 0900 	mov.w	r9, #0
		for(//out_bit_pos=0, in_bit_pos=in_of
    5044:	f77f af1d 	ble.w	4e82 <unfec23+0x32>
			unfec23_10bytes(&out[out_bit_pos/8], &in[in_bit_pos/8]);
    5048:	eb08 01d5 	add.w	r1, r8, r5, lsr #3
    504c:	eb06 00e9 	add.w	r0, r6, r9, asr #3
			; in_bit_pos+=15*8, out_bit_pos+=10*8)
    5050:	f109 0950 	add.w	r9, r9, #80	; 0x50
			unfec23_10bytes(&out[out_bit_pos/8], &in[in_bit_pos/8]);
    5054:	f7ff fdd0 	bl	4bf8 <unfec23_10bytes>
		for(//out_bit_pos=0, in_bit_pos=in_of
    5058:	45a1      	cmp	r9, r4
			; in_bit_pos+=15*8, out_bit_pos+=10*8)
    505a:	f105 0578 	add.w	r5, r5, #120	; 0x78
		for(//out_bit_pos=0, in_bit_pos=in_of
    505e:	dbf3      	blt.n	5048 <unfec23+0x1f8>
    5060:	e70f      	b.n	4e82 <unfec23+0x32>
		default:ENCODE10_7(out+byte_pos,data); break;
    5062:	5d31      	ldrb	r1, [r6, r4]
    5064:	eb06 0c04 	add.w	ip, r6, r4
    5068:	ea41 11c3 	orr.w	r1, r1, r3, lsl #7
    506c:	5531      	strb	r1, [r6, r4]
    506e:	0859      	lsrs	r1, r3, #1
    5070:	0a5b      	lsrs	r3, r3, #9
    5072:	f88c 1001 	strb.w	r1, [ip, #1]
    5076:	f88c 3002 	strb.w	r3, [ip, #2]
    507a:	e74c      	b.n	4f16 <unfec23+0xc6>
		default:data = EXTRACT15_7(in+byte_pos); break;
    507c:	eb08 0c01 	add.w	ip, r8, r1
    5080:	f818 3001 	ldrb.w	r3, [r8, r1]
    5084:	f89c 4002 	ldrb.w	r4, [ip, #2]
    5088:	f89c 1001 	ldrb.w	r1, [ip, #1]
    508c:	09db      	lsrs	r3, r3, #7
    508e:	0264      	lsls	r4, r4, #9
    5090:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
    5094:	f404 44fc 	and.w	r4, r4, #32256	; 0x7e00
    5098:	431c      	orrs	r4, r3
    509a:	e712      	b.n	4ec2 <unfec23+0x72>
    509c:	cccccccd 	.word	0xcccccccd
    50a0:	0000c9f4 	.word	0x0000c9f4

000050a4 <fec13>:
 * in : input buffer of nbits 
 * out_of: output offset in bits, must be multiple of 2
 * nbits: size of input in bits, must be multiple of two
*/
int fec13(uint8_t *out, uint8_t *in, unsigned out_of, unsigned nbits)
{
    50a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	unsigned in_bit_pos, out_bit_pos, byte_pos, left;
	uint32_t data;

	if ((out_of|nbits) & 1)
    50a8:	ea42 0503 	orr.w	r5, r2, r3
    50ac:	f015 0501 	ands.w	r5, r5, #1
    50b0:	f040 80ac 	bne.w	520c <fec13+0x168>
		BB_DEBUG("fec13: invalid arguments\n");
		return -1;
	}

	/* 8 bits in -> 24 bits out */
	for(in_bit_pos = 0, out_bit_pos = out_of
    50b4:	f033 0c07 	bics.w	ip, r3, #7
    50b8:	d03b      	beq.n	5132 <fec13+0x8e>
    50ba:	f8df e158 	ldr.w	lr, [pc, #344]	; 5214 <fec13+0x170>
    50be:	e014      	b.n	50ea <fec13+0x46>
	; in_bit_pos < (nbits&~7)
	; in_bit_pos+=8, out_bit_pos += 24)
	{
		data = fec13_tbl[in[in_bit_pos>>3]];
		byte_pos = out_bit_pos>>3; 
		switch(out_bit_pos&7)
    50c0:	2f00      	cmp	r7, #0
    50c2:	d070      	beq.n	51a6 <fec13+0x102>
		{
		case 0: ENCODE24_0(out+byte_pos, data); break;
		case 2: ENCODE24_2(out+byte_pos, data); break;
		case 4: ENCODE24_4(out+byte_pos, data); break;
		default: ENCODE24_6(out+byte_pos, data); break;
    50c4:	5d87      	ldrb	r7, [r0, r6]
    50c6:	ea4f 0894 	mov.w	r8, r4, lsr #2
    50ca:	ea47 1784 	orr.w	r7, r7, r4, lsl #6
    50ce:	5587      	strb	r7, [r0, r6]
    50d0:	4406      	add	r6, r0
    50d2:	0aa7      	lsrs	r7, r4, #10
    50d4:	f3c4 4485 	ubfx	r4, r4, #18, #6
    50d8:	f886 8001 	strb.w	r8, [r6, #1]
    50dc:	70b7      	strb	r7, [r6, #2]
    50de:	70f4      	strb	r4, [r6, #3]
	; in_bit_pos+=8, out_bit_pos += 24)
    50e0:	3508      	adds	r5, #8
	for(in_bit_pos = 0, out_bit_pos = out_of
    50e2:	4565      	cmp	r5, ip
	; in_bit_pos+=8, out_bit_pos += 24)
    50e4:	f102 0218 	add.w	r2, r2, #24
	for(in_bit_pos = 0, out_bit_pos = out_of
    50e8:	d222      	bcs.n	5130 <fec13+0x8c>
		data = fec13_tbl[in[in_bit_pos>>3]];
    50ea:	08ec      	lsrs	r4, r5, #3
    50ec:	5d0c      	ldrb	r4, [r1, r4]
		switch(out_bit_pos&7)
    50ee:	f002 0707 	and.w	r7, r2, #7
		data = fec13_tbl[in[in_bit_pos>>3]];
    50f2:	eb0e 0484 	add.w	r4, lr, r4, lsl #2
		switch(out_bit_pos&7)
    50f6:	2f02      	cmp	r7, #2
		data = fec13_tbl[in[in_bit_pos>>3]];
    50f8:	f8d4 48c0 	ldr.w	r4, [r4, #2240]	; 0x8c0
		byte_pos = out_bit_pos>>3; 
    50fc:	ea4f 06d2 	mov.w	r6, r2, lsr #3
		switch(out_bit_pos&7)
    5100:	d040      	beq.n	5184 <fec13+0xe0>
    5102:	2f04      	cmp	r7, #4
    5104:	d1dc      	bne.n	50c0 <fec13+0x1c>
		case 4: ENCODE24_4(out+byte_pos, data); break;
    5106:	f810 8006 	ldrb.w	r8, [r0, r6]
	; in_bit_pos+=8, out_bit_pos += 24)
    510a:	3508      	adds	r5, #8
		case 4: ENCODE24_4(out+byte_pos, data); break;
    510c:	ea48 1804 	orr.w	r8, r8, r4, lsl #4
    5110:	f800 8006 	strb.w	r8, [r0, r6]
    5114:	1987      	adds	r7, r0, r6
    5116:	ea4f 1814 	mov.w	r8, r4, lsr #4
    511a:	0b26      	lsrs	r6, r4, #12
	for(in_bit_pos = 0, out_bit_pos = out_of
    511c:	4565      	cmp	r5, ip
		case 4: ENCODE24_4(out+byte_pos, data); break;
    511e:	f3c4 5403 	ubfx	r4, r4, #20, #4
    5122:	f887 8001 	strb.w	r8, [r7, #1]
    5126:	70be      	strb	r6, [r7, #2]
    5128:	70fc      	strb	r4, [r7, #3]
	; in_bit_pos+=8, out_bit_pos += 24)
    512a:	f102 0218 	add.w	r2, r2, #24
	for(in_bit_pos = 0, out_bit_pos = out_of
    512e:	d3dc      	bcc.n	50ea <fec13+0x46>
    5130:	1b5b      	subs	r3, r3, r5
		}
	}
	left = nbits-in_bit_pos;
	/* write left bits */
	if (left)
    5132:	2b00      	cmp	r3, #0
    5134:	d040      	beq.n	51b8 <fec13+0x114>
	{
		data = fec13_tbl[in[in_bit_pos>>3]];
		data &= (1<<(left*3))-1;
    5136:	2401      	movs	r4, #1
		data = fec13_tbl[in[in_bit_pos>>3]];
    5138:	08ed      	lsrs	r5, r5, #3
    513a:	5d49      	ldrb	r1, [r1, r5]
    513c:	4d35      	ldr	r5, [pc, #212]	; (5214 <fec13+0x170>)
		data &= (1<<(left*3))-1;
    513e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
		data = fec13_tbl[in[in_bit_pos>>3]];
    5142:	eb05 0581 	add.w	r5, r5, r1, lsl #2
    5146:	f8d5 58c0 	ldr.w	r5, [r5, #2240]	; 0x8c0
		data &= (1<<(left*3))-1;
    514a:	fa04 f103 	lsl.w	r1, r4, r3
		byte_pos = out_bit_pos>>3;
		switch(out_bit_pos&7)
    514e:	f002 0307 	and.w	r3, r2, #7
		data &= (1<<(left*3))-1;
    5152:	3901      	subs	r1, #1
		switch(out_bit_pos&7)
    5154:	2b02      	cmp	r3, #2
		data &= (1<<(left*3))-1;
    5156:	ea01 0105 	and.w	r1, r1, r5
		byte_pos = out_bit_pos>>3;
    515a:	ea4f 02d2 	mov.w	r2, r2, lsr #3
		switch(out_bit_pos&7)
    515e:	d02e      	beq.n	51be <fec13+0x11a>
    5160:	2b04      	cmp	r3, #4
    5162:	d044      	beq.n	51ee <fec13+0x14a>
    5164:	b3d3      	cbz	r3, 51dc <fec13+0x138>
		{
		case 0: ENCODE24_0(out+byte_pos, data); break;
		case 2: ENCODE24_2(out+byte_pos, data); break;
		case 4: ENCODE24_4(out+byte_pos, data); break;
		default: ENCODE24_6(out+byte_pos, data); break;
    5166:	5c84      	ldrb	r4, [r0, r2]
    5168:	1883      	adds	r3, r0, r2
    516a:	ea44 1481 	orr.w	r4, r4, r1, lsl #6
    516e:	5484      	strb	r4, [r0, r2]
    5170:	088d      	lsrs	r5, r1, #2
    5172:	0a8a      	lsrs	r2, r1, #10
    5174:	f3c1 4185 	ubfx	r1, r1, #18, #6
    5178:	705d      	strb	r5, [r3, #1]
    517a:	709a      	strb	r2, [r3, #2]
    517c:	70d9      	strb	r1, [r3, #3]
		}
	}
	return 0;
    517e:	2000      	movs	r0, #0
}
    5180:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		case 2: ENCODE24_2(out+byte_pos, data); break;
    5184:	f810 8006 	ldrb.w	r8, [r0, r6]
    5188:	1987      	adds	r7, r0, r6
    518a:	ea48 0884 	orr.w	r8, r8, r4, lsl #2
    518e:	f800 8006 	strb.w	r8, [r0, r6]
    5192:	ea4f 1894 	mov.w	r8, r4, lsr #6
    5196:	0ba6      	lsrs	r6, r4, #14
    5198:	f3c4 5481 	ubfx	r4, r4, #22, #2
    519c:	f887 8001 	strb.w	r8, [r7, #1]
    51a0:	70be      	strb	r6, [r7, #2]
    51a2:	70fc      	strb	r4, [r7, #3]
    51a4:	e79c      	b.n	50e0 <fec13+0x3c>
		case 0: ENCODE24_0(out+byte_pos, data); break;
    51a6:	5584      	strb	r4, [r0, r6]
    51a8:	1987      	adds	r7, r0, r6
    51aa:	ea4f 2814 	mov.w	r8, r4, lsr #8
    51ae:	0c24      	lsrs	r4, r4, #16
    51b0:	f887 8001 	strb.w	r8, [r7, #1]
    51b4:	70bc      	strb	r4, [r7, #2]
    51b6:	e793      	b.n	50e0 <fec13+0x3c>
	return 0;
    51b8:	4618      	mov	r0, r3
}
    51ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		case 2: ENCODE24_2(out+byte_pos, data); break;
    51be:	5c84      	ldrb	r4, [r0, r2]
    51c0:	1883      	adds	r3, r0, r2
    51c2:	ea44 0481 	orr.w	r4, r4, r1, lsl #2
    51c6:	5484      	strb	r4, [r0, r2]
    51c8:	098d      	lsrs	r5, r1, #6
    51ca:	0b8a      	lsrs	r2, r1, #14
    51cc:	f3c1 5181 	ubfx	r1, r1, #22, #2
    51d0:	705d      	strb	r5, [r3, #1]
    51d2:	709a      	strb	r2, [r3, #2]
    51d4:	70d9      	strb	r1, [r3, #3]
	return 0;
    51d6:	2000      	movs	r0, #0
}
    51d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		case 0: ENCODE24_0(out+byte_pos, data); break;
    51dc:	5481      	strb	r1, [r0, r2]
    51de:	1884      	adds	r4, r0, r2
    51e0:	0a0d      	lsrs	r5, r1, #8
    51e2:	0c09      	lsrs	r1, r1, #16
    51e4:	7065      	strb	r5, [r4, #1]
    51e6:	70a1      	strb	r1, [r4, #2]
	return 0;
    51e8:	4618      	mov	r0, r3
}
    51ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		case 4: ENCODE24_4(out+byte_pos, data); break;
    51ee:	5c84      	ldrb	r4, [r0, r2]
    51f0:	1883      	adds	r3, r0, r2
    51f2:	ea44 1401 	orr.w	r4, r4, r1, lsl #4
    51f6:	5484      	strb	r4, [r0, r2]
    51f8:	090d      	lsrs	r5, r1, #4
    51fa:	0b0a      	lsrs	r2, r1, #12
    51fc:	f3c1 5103 	ubfx	r1, r1, #20, #4
    5200:	705d      	strb	r5, [r3, #1]
    5202:	709a      	strb	r2, [r3, #2]
    5204:	70d9      	strb	r1, [r3, #3]
	return 0;
    5206:	2000      	movs	r0, #0
}
    5208:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -1;
    520c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    5210:	e7d3      	b.n	51ba <fec13+0x116>
    5212:	bf00      	nop
    5214:	0000c9f4 	.word	0x0000c9f4

00005218 <main>:
#include <ubtbr/btctl_intf.h>
#include <ubtbr/vendor_request_handler.h>
#include <ubtbr/btphy.h>

int main()
{
    5218:	b570      	push	{r4, r5, r6, lr}
	unsigned clk, clk_prev = 0;

	// enable all fault handlers (see fault.c)
	SCB_SHCSR = (1 << 18) | (1 << 17) | (1 << 16);
    521a:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
    521e:	4b0e      	ldr	r3, [pc, #56]	; (5258 <main+0x40>)
    5220:	f44f 6548 	mov.w	r5, #3200	; 0xc80
    5224:	601a      	str	r2, [r3, #0]

	ubertooth_init();
    5226:	f004 fca5 	bl	9b74 <ubertooth_init>
	ubertooth_usb_init(vendor_request_handler);
    522a:	480c      	ldr	r0, [pc, #48]	; (525c <main+0x44>)
    522c:	f004 f8f2 	bl	9414 <ubertooth_usb_init>

	/* Initialize memory */
	mem_pool_init();
    5230:	f002 fdb0 	bl	7d94 <mem_pool_init>

	/* Initialize control interface */
	btctl_init();
    5234:	f000 fac2 	bl	57bc <btctl_init>

	/* Initialize sync & phy */
	btphy_init();
    5238:	f000 fd6a 	bl	5d10 <btphy_init>

	while (1) {
		/* Flush console once per second */
		if ((clk = MASTER_CLKN) >= clk_prev+3200)
    523c:	4e08      	ldr	r6, [pc, #32]	; (5260 <main+0x48>)
    523e:	6834      	ldr	r4, [r6, #0]
    5240:	42a5      	cmp	r5, r4
    5242:	d803      	bhi.n	524c <main+0x34>
		{
			console_flush();
    5244:	f002 fe22 	bl	7e8c <console_flush>
			clk_prev = clk;
    5248:	f504 6548 	add.w	r5, r4, #3200	; 0xc80
		}
		/* Handle usb async work */
		usb_work();
    524c:	f004 f934 	bl	94b8 <usb_work>
		/* Handle host messages */
		btctl_work();
    5250:	f000 f906 	bl	5460 <btctl_work>
		if ((clk = MASTER_CLKN) >= clk_prev+3200)
    5254:	e7f3      	b.n	523e <main+0x26>
    5256:	bf00      	nop
    5258:	e000ed24 	.word	0xe000ed24
    525c:	00005265 	.word	0x00005265
    5260:	40008008 	.word	0x40008008

00005264 <vendor_request_handler>:
{
	btctl_rx_enqueue(btctl_msg_alloc(BTCTL_RESET_REQ));
}

int vendor_request_handler(uint8_t request, uint16_t* request_params, uint8_t* data, int* data_len)
{
    5264:	b530      	push	{r4, r5, lr}
    5266:	b083      	sub	sp, #12
    5268:	461c      	mov	r4, r3
    526a:	2823      	cmp	r0, #35	; 0x23
    526c:	d825      	bhi.n	52ba <vendor_request_handler+0x56>
    526e:	e8df f010 	tbh	[pc, r0, lsl #1]
    5272:	0029      	.short	0x0029
    5274:	00240024 	.word	0x00240024
    5278:	00930036 	.word	0x00930036
    527c:	00b3008a 	.word	0x00b3008a
    5280:	00a400aa 	.word	0x00a400aa
    5284:	002d009b 	.word	0x002d009b
    5288:	00240024 	.word	0x00240024
    528c:	00da00e0 	.word	0x00da00e0
    5290:	00cb00d4 	.word	0x00cb00d4
    5294:	00c000c3 	.word	0x00c000c3
    5298:	002400b8 	.word	0x002400b8
    529c:	00240024 	.word	0x00240024
    52a0:	00270024 	.word	0x00270024
    52a4:	0024004b 	.word	0x0024004b
    52a8:	003f0024 	.word	0x003f0024
    52ac:	00240068 	.word	0x00240068
    52b0:	00240024 	.word	0x00240024
    52b4:	00240077 	.word	0x00240077
    52b8:	0072      	.short	0x0072

	case UBERTOOTH_SET_PALEVEL:
		if( request_params[0] < 8 ) {
			cc2400_set(FREND, 8 | request_params[0]);
		} else {
			return 0;
    52ba:	2000      	movs	r0, #0

	default:
		return 0;
	}
	return 1;
}
    52bc:	b003      	add	sp, #12
    52be:	bd30      	pop	{r4, r5, pc}
		set_isp();
    52c0:	f004 fcca 	bl	9c58 <set_isp>
		*data_len = 0; /* should never return */
    52c4:	2300      	movs	r3, #0
	return 1;
    52c6:	2001      	movs	r0, #1
		*data_len = 0; /* should never return */
    52c8:	6023      	str	r3, [r4, #0]
		break;
    52ca:	e7f7      	b.n	52bc <vendor_request_handler+0x58>
		if (request_params[0])
    52cc:	880b      	ldrh	r3, [r1, #0]
			CC1V8_SET;
    52ce:	f44f 7200 	mov.w	r2, #512	; 0x200
		if (request_params[0])
    52d2:	2b00      	cmp	r3, #0
    52d4:	d064      	beq.n	53a0 <vendor_request_handler+0x13c>
			CC1V8_SET;
    52d6:	4b58      	ldr	r3, [pc, #352]	; (5438 <vendor_request_handler+0x1d4>)
	return 1;
    52d8:	2001      	movs	r0, #1
			CC1V8_SET;
    52da:	601a      	str	r2, [r3, #0]
    52dc:	e7ee      	b.n	52bc <vendor_request_handler+0x58>
		*data_len = 1;
    52de:	2101      	movs	r1, #1
		data[0] = (USRLED) ? 1 : 0;
    52e0:	4b56      	ldr	r3, [pc, #344]	; (543c <vendor_request_handler+0x1d8>)
	return 1;
    52e2:	4608      	mov	r0, r1
		data[0] = (USRLED) ? 1 : 0;
    52e4:	681b      	ldr	r3, [r3, #0]
    52e6:	f3c3 0340 	ubfx	r3, r3, #1, #1
    52ea:	7013      	strb	r3, [r2, #0]
		*data_len = 1;
    52ec:	6021      	str	r1, [r4, #0]
		break;
    52ee:	e7e5      	b.n	52bc <vendor_request_handler+0x58>
		data[0] = cc2400_get(FREND) & 0x7;
    52f0:	2005      	movs	r0, #5
    52f2:	9201      	str	r2, [sp, #4]
    52f4:	f004 fb6a 	bl	99cc <cc2400_get>
		*data_len = 1;
    52f8:	2301      	movs	r3, #1
		data[0] = cc2400_get(FREND) & 0x7;
    52fa:	9a01      	ldr	r2, [sp, #4]
    52fc:	f000 0007 	and.w	r0, r0, #7
    5300:	7010      	strb	r0, [r2, #0]
	return 1;
    5302:	4618      	mov	r0, r3
		*data_len = 1;
    5304:	6023      	str	r3, [r4, #0]
		break;
    5306:	e7d9      	b.n	52bc <vendor_request_handler+0x58>
} msg_t;

/* Allocate a msg_t wigh given room*/
static inline msg_t *msg_alloc(unsigned size)
{
	msg_t *msg = (msg_t*)btctl_mem_alloc(sizeof(msg_t)+size);
    5308:	f44f 70ba 	mov.w	r0, #372	; 0x174
		bootloader_ctrl = DFU_MODE;
    530c:	4b4c      	ldr	r3, [pc, #304]	; (5440 <vendor_request_handler+0x1dc>)
    530e:	4a4d      	ldr	r2, [pc, #308]	; (5444 <vendor_request_handler+0x1e0>)
    5310:	601a      	str	r2, [r3, #0]
    5312:	f002 fd87 	bl	7e24 <mem_pool_alloc>
    5316:	4601      	mov	r1, r0
	btctl_hdr_t *hdr;

	/* maximum size ?*/
	msg = msg_alloc(sizeof(btctl_hdr_t)+sizeof(btctl_rx_pkt_t)+MAX_ACL_PACKET_SIZE);
	hdr = (btctl_hdr_t*) msg_put(msg, sizeof(*hdr));
	hdr->type = type;
    5318:	2314      	movs	r3, #20

	msg->write = msg->data;
	msg->read = msg->data;
	msg->data_len = size;
    531a:	f44f 70b4 	mov.w	r0, #360	; 0x168
	msg->write = msg->data;
    531e:	f101 040c 	add.w	r4, r1, #12
{
        uint8_t *tmp = msg->write;

        if (msg_write_avail(msg) < (int) len)
		DIE("msg_put: short buf\n");
        msg->write += len;
    5322:	f101 0210 	add.w	r2, r1, #16
	msg->read = msg->data;
    5326:	604c      	str	r4, [r1, #4]
	msg->data_len = size;
    5328:	8048      	strh	r0, [r1, #2]
        msg->write += len;
    532a:	608a      	str	r2, [r1, #8]
    532c:	730b      	strb	r3, [r1, #12]

static inline uint32_t irq_save_disable(void)
{
	uint32_t primask;

	__asm__ __volatile__ (
    532e:	f3ef 8410 	mrs	r4, PRIMASK
    5332:	b672      	cpsid	i
static inline int safe_enqueue(msg_queue_t *q, msg_t *msg)
{
	uint32_t flags = irq_save_disable();
	int rc;

	rc = msg_enqueue(q, msg);
    5334:	4844      	ldr	r0, [pc, #272]	; (5448 <vendor_request_handler+0x1e4>)
    5336:	f002 fef7 	bl	8128 <msg_enqueue>
	return primask;
}

static inline void irq_restore(uint32_t primask)
{
	__asm__ __volatile__ (
    533a:	f384 8810 	msr	PRIMASK, r4
	return 1;
    533e:	2001      	movs	r0, #1
}
    5340:	e7bc      	b.n	52bc <vendor_request_handler+0x58>
		if( request_params[0] < 8 ) {
    5342:	8809      	ldrh	r1, [r1, #0]
    5344:	2907      	cmp	r1, #7
    5346:	d8b8      	bhi.n	52ba <vendor_request_handler+0x56>
			cc2400_set(FREND, 8 | request_params[0]);
    5348:	2005      	movs	r0, #5
    534a:	f041 0108 	orr.w	r1, r1, #8
    534e:	f004 fb46 	bl	99de <cc2400_set>
	return 1;
    5352:	2001      	movs	r0, #1
		break;
    5354:	e7b2      	b.n	52bc <vendor_request_handler+0x58>
		data[0] = BOARD_ID;
    5356:	2301      	movs	r3, #1
    5358:	7013      	strb	r3, [r2, #0]
	return 1;
    535a:	4618      	mov	r0, r3
		*data_len = 1;
    535c:	6023      	str	r3, [r4, #0]
		break;
    535e:	e7ad      	b.n	52bc <vendor_request_handler+0x58>
		data[0] = 0x00;
    5360:	2300      	movs	r3, #0
		length = (u8)strlen(GIT_REVISION);
    5362:	483a      	ldr	r0, [pc, #232]	; (544c <vendor_request_handler+0x1e8>)
		data[0] = 0x00;
    5364:	7013      	strb	r3, [r2, #0]
		data[1] = 0x00;
    5366:	7053      	strb	r3, [r2, #1]
    5368:	9201      	str	r2, [sp, #4]
		length = (u8)strlen(GIT_REVISION);
    536a:	f005 fa21 	bl	a7b0 <strlen>
    536e:	9a01      	ldr	r2, [sp, #4]
    5370:	b2c5      	uxtb	r5, r0
    5372:	7090      	strb	r0, [r2, #2]
		memcpy(&data[3], GIT_REVISION, length);
    5374:	4935      	ldr	r1, [pc, #212]	; (544c <vendor_request_handler+0x1e8>)
    5376:	1cd0      	adds	r0, r2, #3
    5378:	462a      	mov	r2, r5
		*data_len = 2 + 1 + length;
    537a:	3503      	adds	r5, #3
		memcpy(&data[3], GIT_REVISION, length);
    537c:	f005 f9a2 	bl	a6c4 <memcpy>
	return 1;
    5380:	2001      	movs	r0, #1
		*data_len = 2 + 1 + length;
    5382:	6025      	str	r5, [r4, #0]
		break;
    5384:	e79a      	b.n	52bc <vendor_request_handler+0x58>
		*data_len = 1;
    5386:	2101      	movs	r1, #1
		data[0] = (RXLED) ? 1 : 0;
    5388:	4b2c      	ldr	r3, [pc, #176]	; (543c <vendor_request_handler+0x1d8>)
	return 1;
    538a:	4608      	mov	r0, r1
		data[0] = (RXLED) ? 1 : 0;
    538c:	681b      	ldr	r3, [r3, #0]
    538e:	f3c3 1300 	ubfx	r3, r3, #4, #1
    5392:	7013      	strb	r3, [r2, #0]
		*data_len = 1;
    5394:	6021      	str	r1, [r4, #0]
		break;
    5396:	e791      	b.n	52bc <vendor_request_handler+0x58>
		if (request_params[0])
    5398:	880b      	ldrh	r3, [r1, #0]
			USRLED_SET;
    539a:	2202      	movs	r2, #2
		if (request_params[0])
    539c:	2b00      	cmp	r3, #0
    539e:	d19a      	bne.n	52d6 <vendor_request_handler+0x72>
			CC1V8_CLR;
    53a0:	4b2b      	ldr	r3, [pc, #172]	; (5450 <vendor_request_handler+0x1ec>)
	return 1;
    53a2:	2001      	movs	r0, #1
			CC1V8_CLR;
    53a4:	601a      	str	r2, [r3, #0]
    53a6:	e789      	b.n	52bc <vendor_request_handler+0x58>
		*data_len = 1;
    53a8:	2101      	movs	r1, #1
		data[0] = (CC1V8) ? 1 : 0;
    53aa:	4b24      	ldr	r3, [pc, #144]	; (543c <vendor_request_handler+0x1d8>)
	return 1;
    53ac:	4608      	mov	r0, r1
		data[0] = (CC1V8) ? 1 : 0;
    53ae:	681b      	ldr	r3, [r3, #0]
    53b0:	f3c3 2340 	ubfx	r3, r3, #9, #1
    53b4:	7013      	strb	r3, [r2, #0]
		*data_len = 1;
    53b6:	6021      	str	r1, [r4, #0]
		break;
    53b8:	e780      	b.n	52bc <vendor_request_handler+0x58>
		if (request_params[0])
    53ba:	880b      	ldrh	r3, [r1, #0]
			TXLED_SET;
    53bc:	f44f 7280 	mov.w	r2, #256	; 0x100
		if (request_params[0])
    53c0:	2b00      	cmp	r3, #0
    53c2:	d0ed      	beq.n	53a0 <vendor_request_handler+0x13c>
    53c4:	e787      	b.n	52d6 <vendor_request_handler+0x72>
		*data_len = 1;
    53c6:	2101      	movs	r1, #1
		data[0] = (TXLED) ? 1 : 0;
    53c8:	4b1c      	ldr	r3, [pc, #112]	; (543c <vendor_request_handler+0x1d8>)
		data[0] = (HGM) ? 1 : 0;
    53ca:	681b      	ldr	r3, [r3, #0]
	return 1;
    53cc:	4608      	mov	r0, r1
		data[0] = (HGM) ? 1 : 0;
    53ce:	f3c3 2300 	ubfx	r3, r3, #8, #1
    53d2:	7013      	strb	r3, [r2, #0]
		*data_len = 1;
    53d4:	6021      	str	r1, [r4, #0]
		break;
    53d6:	e771      	b.n	52bc <vendor_request_handler+0x58>
		if (request_params[0])
    53d8:	880b      	ldrh	r3, [r1, #0]
			RXLED_SET;
    53da:	2210      	movs	r2, #16
		if (request_params[0])
    53dc:	2b00      	cmp	r3, #0
    53de:	d0df      	beq.n	53a0 <vendor_request_handler+0x13c>
    53e0:	e779      	b.n	52d6 <vendor_request_handler+0x72>
		if (request_params[0])
    53e2:	880b      	ldrh	r3, [r1, #0]
			HGM_SET;
    53e4:	f44f 7280 	mov.w	r2, #256	; 0x100
		if (request_params[0])
    53e8:	b153      	cbz	r3, 5400 <vendor_request_handler+0x19c>
			HGM_SET;
    53ea:	4b1a      	ldr	r3, [pc, #104]	; (5454 <vendor_request_handler+0x1f0>)
	return 1;
    53ec:	2001      	movs	r0, #1
			HGM_SET;
    53ee:	601a      	str	r2, [r3, #0]
    53f0:	e764      	b.n	52bc <vendor_request_handler+0x58>
		*data_len = 1;
    53f2:	2101      	movs	r1, #1
		data[0] = (HGM) ? 1 : 0;
    53f4:	4b18      	ldr	r3, [pc, #96]	; (5458 <vendor_request_handler+0x1f4>)
    53f6:	e7e8      	b.n	53ca <vendor_request_handler+0x166>
		if (request_params[0])
    53f8:	880b      	ldrh	r3, [r1, #0]
			PAEN_SET;
    53fa:	2280      	movs	r2, #128	; 0x80
		if (request_params[0])
    53fc:	2b00      	cmp	r3, #0
    53fe:	d1f4      	bne.n	53ea <vendor_request_handler+0x186>
			HGM_CLR;
    5400:	4b16      	ldr	r3, [pc, #88]	; (545c <vendor_request_handler+0x1f8>)
	return 1;
    5402:	2001      	movs	r0, #1
			HGM_CLR;
    5404:	601a      	str	r2, [r3, #0]
    5406:	e759      	b.n	52bc <vendor_request_handler+0x58>
		*data_len = 1;
    5408:	2101      	movs	r1, #1
		data[0] = (PAEN) ? 1 : 0;
    540a:	4b13      	ldr	r3, [pc, #76]	; (5458 <vendor_request_handler+0x1f4>)
	return 1;
    540c:	4608      	mov	r0, r1
		data[0] = (PAEN) ? 1 : 0;
    540e:	681b      	ldr	r3, [r3, #0]
    5410:	f3c3 13c0 	ubfx	r3, r3, #7, #1
    5414:	7013      	strb	r3, [r2, #0]
		*data_len = 1;
    5416:	6021      	str	r1, [r4, #0]
		break;
    5418:	e750      	b.n	52bc <vendor_request_handler+0x58>
		get_part_num(data, data_len);
    541a:	4610      	mov	r0, r2
    541c:	4621      	mov	r1, r4
    541e:	f004 fbcf 	bl	9bc0 <get_part_num>
	return 1;
    5422:	2001      	movs	r0, #1
		break;
    5424:	e74a      	b.n	52bc <vendor_request_handler+0x58>
		get_device_serial(data, data_len);
    5426:	4610      	mov	r0, r2
    5428:	4621      	mov	r1, r4
    542a:	f004 fbe3 	bl	9bf4 <get_device_serial>
	return 1;
    542e:	2001      	movs	r0, #1
		break;
    5430:	e744      	b.n	52bc <vendor_request_handler+0x58>
	msg_t *msg = (msg_t*)btctl_mem_alloc(sizeof(msg_t)+size);
    5432:	f44f 70ba 	mov.w	r0, #372	; 0x174
    5436:	e76c      	b.n	5312 <vendor_request_handler+0xae>
    5438:	2009c038 	.word	0x2009c038
    543c:	2009c034 	.word	0x2009c034
    5440:	1000001c 	.word	0x1000001c
    5444:	4305bb21 	.word	0x4305bb21
    5448:	100023e0 	.word	0x100023e0
    544c:	0000da54 	.word	0x0000da54
    5450:	2009c03c 	.word	0x2009c03c
    5454:	2009c058 	.word	0x2009c058
    5458:	2009c054 	.word	0x2009c054
    545c:	2009c05c 	.word	0x2009c05c

00005460 <btctl_work>:
end_nofree:
	return;
}

int btctl_work(void)
{
    5460:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	__asm__ __volatile__ (
    5464:	f3ef 8510 	mrs	r5, PRIMASK
    5468:	b672      	cpsid	i
	msg = msg_dequeue(q);
    546a:	487e      	ldr	r0, [pc, #504]	; (5664 <btctl_work+0x204>)
    546c:	f002 fe46 	bl	80fc <msg_dequeue>
    5470:	4604      	mov	r4, r0
	__asm__ __volatile__ (
    5472:	f385 8810 	msr	PRIMASK, r5
	msg_t *msg = btctl_rx_dequeue();

	if (msg == NULL)
    5476:	b330      	cbz	r0, 54c6 <btctl_work+0x66>
	switch(hdr->type)
    5478:	7b01      	ldrb	r1, [r0, #12]
    547a:	2920      	cmp	r1, #32
    547c:	d825      	bhi.n	54ca <btctl_work+0x6a>
    547e:	e8df f001 	tbb	[pc, r1]
    5482:	24ab      	.short	0x24ab
    5484:	24242424 	.word	0x24242424
    5488:	24242424 	.word	0x24242424
    548c:	24242424 	.word	0x24242424
    5490:	24242424 	.word	0x24242424
    5494:	85a82424 	.word	0x85a82424
    5498:	5e75787f 	.word	0x5e75787f
    549c:	b14a4d58 	.word	0xb14a4d58
    54a0:	3411      	.short	0x3411
    54a2:	2d          	.byte	0x2d
    54a3:	00          	.byte	0x00
	if (btctl.state != BTCTL_STATE_STANDBY)
    54a4:	4d70      	ldr	r5, [pc, #448]	; (5668 <btctl_work+0x208>)
    54a6:	782b      	ldrb	r3, [r5, #0]
    54a8:	2b00      	cmp	r3, #0
    54aa:	f040 80cf 	bne.w	564c <btctl_work+0x1ec>
	if (btctl.eir_msg)
    54ae:	6fe8      	ldr	r0, [r5, #124]	; 0x7c
    54b0:	b108      	cbz	r0, 54b6 <btctl_work+0x56>
	btctl_mem_free(msg);
    54b2:	f002 fcdb 	bl	7e6c <mem_pool_free>
	cprintf("EIR updated\n");
    54b6:	486d      	ldr	r0, [pc, #436]	; (566c <btctl_work+0x20c>)
    54b8:	f003 feac 	bl	9214 <cprintf>
		return 0;

	btctl_handle_msg(msg);

	return 1;
    54bc:	2001      	movs	r0, #1
	btctl.eir_pkt = (btctl_tx_pkt_t *)h->data;
    54be:	f104 0310 	add.w	r3, r4, #16
    54c2:	e9c5 431f 	strd	r4, r3, [r5, #124]	; 0x7c
}
    54c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		cprintf("Invalid message type %d\n", hdr->type);
    54ca:	4869      	ldr	r0, [pc, #420]	; (5670 <btctl_work+0x210>)
    54cc:	f003 fea2 	bl	9214 <cprintf>
	btctl_mem_free(msg);
    54d0:	4620      	mov	r0, r4
    54d2:	f002 fccb 	bl	7e6c <mem_pool_free>
	return 1;
    54d6:	2001      	movs	r0, #1
}
    54d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	monitor1_state_setup(req->bdaddr);
    54dc:	f100 0110 	add.w	r1, r0, #16
    54e0:	e9d1 0100 	ldrd	r0, r1, [r1]
    54e4:	f001 ffc0 	bl	7468 <monitor1_state_setup>
}
    54e8:	e7f2      	b.n	54d0 <btctl_work+0x70>
	__asm__ __volatile__ (
    54ea:	f3ef 8610 	mrs	r6, PRIMASK
    54ee:	b672      	cpsid	i
	afh_buf[0] = req->mode;
    54f0:	4d60      	ldr	r5, [pc, #384]	; (5674 <btctl_work+0x214>)
    54f2:	7d03      	ldrb	r3, [r0, #20]
    54f4:	4628      	mov	r0, r5
	memcpy(afh_buf+1, req->map, 10);
    54f6:	f104 0115 	add.w	r1, r4, #21
    54fa:	220a      	movs	r2, #10
	afh_buf[0] = req->mode;
    54fc:	f800 3b01 	strb.w	r3, [r0], #1
	memcpy(afh_buf+1, req->map, 10);
    5500:	f005 f8e0 	bl	a6c4 <memcpy>
	btphy_timer_add(req->instant, (btphy_timer_fn_t)hop_cfg_afh, afh_buf, 0);
    5504:	462a      	mov	r2, r5
    5506:	2300      	movs	r3, #0
    5508:	6920      	ldr	r0, [r4, #16]
    550a:	495b      	ldr	r1, [pc, #364]	; (5678 <btctl_work+0x218>)
    550c:	f000 fa7c 	bl	5a08 <btphy_timer_add>
	__asm__ __volatile__ (
    5510:	f386 8810 	msr	PRIMASK, r6
}
    5514:	e7dc      	b.n	54d0 <btctl_work+0x70>
	inquiry_scan_state_setup();
    5516:	f001 fe75 	bl	7204 <inquiry_scan_state_setup>
}
    551a:	e7d9      	b.n	54d0 <btctl_work+0x70>
	__asm__ __volatile__ (
    551c:	f3ef 8510 	mrs	r5, PRIMASK
    5520:	b672      	cpsid	i
	rc = msg_enqueue(q, msg);
    5522:	4856      	ldr	r0, [pc, #344]	; (567c <btctl_work+0x21c>)
    5524:	4621      	mov	r1, r4
    5526:	f002 fdff 	bl	8128 <msg_enqueue>
	__asm__ __volatile__ (
    552a:	f385 8810 	msr	PRIMASK, r5
	return 1;
    552e:	2001      	movs	r0, #1
		goto end_nofree;
    5530:	e7c9      	b.n	54c6 <btctl_work+0x66>
	btphy_rf_set_max_ac_errors(req->reg&3);
    5532:	7c00      	ldrb	r0, [r0, #16]
    5534:	f000 0003 	and.w	r0, r0, #3
    5538:	f002 fb22 	bl	7b80 <btphy_rf_set_max_ac_errors>
}
    553c:	e7c8      	b.n	54d0 <btctl_work+0x70>
	uint32_t lap = req->bdaddr & 0xffffff;
    553e:	6907      	ldr	r7, [r0, #16]
	msg = msg_dequeue(q);
    5540:	4e4e      	ldr	r6, [pc, #312]	; (567c <btctl_work+0x21c>)
    5542:	f027 487f 	bic.w	r8, r7, #4278190080	; 0xff000000
	uint8_t uap = (req->bdaddr >> 24) & 0xff;
    5546:	0e3f      	lsrs	r7, r7, #24
	while ((msg = safe_dequeue(&btctl.acl_tx_q)) != NULL)
    5548:	e001      	b.n	554e <btctl_work+0xee>
    554a:	f002 fc8f 	bl	7e6c <mem_pool_free>
	__asm__ __volatile__ (
    554e:	f3ef 8510 	mrs	r5, PRIMASK
    5552:	b672      	cpsid	i
    5554:	4630      	mov	r0, r6
    5556:	f002 fdd1 	bl	80fc <msg_dequeue>
	__asm__ __volatile__ (
    555a:	f385 8810 	msr	PRIMASK, r5
    555e:	2800      	cmp	r0, #0
    5560:	d1f3      	bne.n	554a <btctl_work+0xea>
	paging_state_setup(lap, uap);
    5562:	4639      	mov	r1, r7
    5564:	4640      	mov	r0, r8
    5566:	f001 fa11 	bl	698c <paging_state_setup>
}
    556a:	e7b1      	b.n	54d0 <btctl_work+0x70>
	inquiry_state_setup();
    556c:	f001 f906 	bl	677c <inquiry_state_setup>
}
    5570:	e7ae      	b.n	54d0 <btctl_work+0x70>
	btphy_set_bdaddr(req->bdaddr);
    5572:	f100 0110 	add.w	r1, r0, #16
    5576:	e9d1 0100 	ldrd	r0, r1, [r1]
    557a:	f000 fba9 	bl	5cd0 <btphy_set_bdaddr>
}
    557e:	e7a7      	b.n	54d0 <btctl_work+0x70>
	btphy_rf_set_freq_off(req->reg&0x3f);
    5580:	7c00      	ldrb	r0, [r0, #16]
    5582:	f000 003f 	and.w	r0, r0, #63	; 0x3f
    5586:	f002 fadd 	bl	7b44 <btphy_rf_set_freq_off>
}
    558a:	e7a1      	b.n	54d0 <btctl_work+0x70>
	__asm__ __volatile__ (
    558c:	f3ef 8810 	mrs	r8, PRIMASK
    5590:	b672      	cpsid	i
}

void btctl_set_state(btctl_state_t state, btctl_reason_t reason)
{
	uint32_t flags = irq_save_disable();
	btctl_state_t old_state = btctl.state;
    5592:	4d35      	ldr	r5, [pc, #212]	; (5668 <btctl_work+0x208>)
    5594:	782e      	ldrb	r6, [r5, #0]
	if (state >= BTCTL_STATE_COUNT)
    5596:	2e05      	cmp	r6, #5
    5598:	d835      	bhi.n	5606 <btctl_work+0x1a6>
	name = btctl_state_name_tbl[state];
    559a:	4a39      	ldr	r2, [pc, #228]	; (5680 <btctl_work+0x220>)
		name = "TODO";
    559c:	4b39      	ldr	r3, [pc, #228]	; (5684 <btctl_work+0x224>)
	name = btctl_state_name_tbl[state];
    559e:	f852 1026 	ldr.w	r1, [r2, r6, lsl #2]
		name = "TODO";
    55a2:	2900      	cmp	r1, #0
    55a4:	bf08      	it	eq
    55a6:	4619      	moveq	r1, r3
		irq_restore(flags);
		DIE("Invalid state transition %s -> %s\n",
			btctl_state_name(old_state),
			btctl_state_name(state));
	}
	btctl.state = state;
    55a8:	2700      	movs	r7, #0
	cprintf("State %s -> %s\n",
    55aa:	4a37      	ldr	r2, [pc, #220]	; (5688 <btctl_work+0x228>)
    55ac:	4837      	ldr	r0, [pc, #220]	; (568c <btctl_work+0x22c>)
    55ae:	f003 fe31 	bl	9214 <cprintf>
	btctl.state = state;
    55b2:	702f      	strb	r7, [r5, #0]
	__asm__ __volatile__ (
    55b4:	f388 8810 	msr	PRIMASK, r8
	irq_restore(flags);
	if (!(old_state == BTCTL_STATE_STANDBY && state == BTCTL_STATE_STANDBY))
    55b8:	bb3e      	cbnz	r6, 560a <btctl_work+0x1aa>
	wait_clkn = MASTER_CLKN+30;
    55ba:	4d35      	ldr	r5, [pc, #212]	; (5690 <btctl_work+0x230>)
    55bc:	682e      	ldr	r6, [r5, #0]
	while (MASTER_CLKN < wait_clkn)
    55be:	682b      	ldr	r3, [r5, #0]
	wait_clkn = MASTER_CLKN+30;
    55c0:	361e      	adds	r6, #30
	while (MASTER_CLKN < wait_clkn)
    55c2:	429e      	cmp	r6, r3
    55c4:	d984      	bls.n	54d0 <btctl_work+0x70>
		usb_work();
    55c6:	f003 ff77 	bl	94b8 <usb_work>
	while (MASTER_CLKN < wait_clkn)
    55ca:	682b      	ldr	r3, [r5, #0]
    55cc:	429e      	cmp	r6, r3
    55ce:	d8fa      	bhi.n	55c6 <btctl_work+0x166>
    55d0:	e77e      	b.n	54d0 <btctl_work+0x70>
	reset();
    55d2:	f004 fad9 	bl	9b88 <reset>
}
    55d6:	e77b      	b.n	54d0 <btctl_work+0x70>
	cprintf("debug req: %s\n", (char*)hdr->data);
    55d8:	f100 0110 	add.w	r1, r0, #16
    55dc:	482d      	ldr	r0, [pc, #180]	; (5694 <btctl_work+0x234>)
    55de:	f003 fe19 	bl	9214 <cprintf>
}
    55e2:	e775      	b.n	54d0 <btctl_work+0x70>
    55e4:	4e25      	ldr	r6, [pc, #148]	; (567c <btctl_work+0x21c>)
    55e6:	e001      	b.n	55ec <btctl_work+0x18c>
    55e8:	f002 fc40 	bl	7e6c <mem_pool_free>
	__asm__ __volatile__ (
    55ec:	f3ef 8510 	mrs	r5, PRIMASK
    55f0:	b672      	cpsid	i
    55f2:	4630      	mov	r0, r6
    55f4:	f002 fd82 	bl	80fc <msg_dequeue>
	__asm__ __volatile__ (
    55f8:	f385 8810 	msr	PRIMASK, r5
	while ((msg = safe_dequeue(&btctl.acl_tx_q)) != NULL)
    55fc:	2800      	cmp	r0, #0
    55fe:	d1f3      	bne.n	55e8 <btctl_work+0x188>
	page_scan_state_setup();
    5600:	f002 fa0a 	bl	7a18 <page_scan_state_setup>
}
    5604:	e764      	b.n	54d0 <btctl_work+0x70>
		return "Invalid";
    5606:	4924      	ldr	r1, [pc, #144]	; (5698 <btctl_work+0x238>)
    5608:	e7ce      	b.n	55a8 <btctl_work+0x148>
	msg_t *msg = (msg_t*)btctl_mem_alloc(sizeof(msg_t)+size);
    560a:	f44f 70ba 	mov.w	r0, #372	; 0x174
    560e:	f002 fc09 	bl	7e24 <mem_pool_alloc>
    5612:	4601      	mov	r1, r0
	hdr->type = type;
    5614:	2329      	movs	r3, #41	; 0x29
	msg->data_len = size;
    5616:	f44f 75b4 	mov.w	r5, #360	; 0x168
	msg->write = msg->data;
    561a:	300c      	adds	r0, #12
        msg->write += len;
    561c:	f101 0210 	add.w	r2, r1, #16
    5620:	730b      	strb	r3, [r1, #12]
	return (int)(msg->write - msg->data);
    5622:	1a13      	subs	r3, r2, r0
        return msg->data_len - msg_write_len(msg);
    5624:	1aeb      	subs	r3, r5, r3
        if (msg_write_avail(msg) < (int) len)
    5626:	2b01      	cmp	r3, #1
        msg->write += len;
    5628:	e9c1 0201 	strd	r0, r2, [r1, #4]
	msg->data_len = size;
    562c:	804d      	strh	r5, [r1, #2]
        if (msg_write_avail(msg) < (int) len)
    562e:	dd15      	ble.n	565c <btctl_work+0x1fc>
        msg->write += len;
    5630:	f101 0312 	add.w	r3, r1, #18
	resp->state = state;
    5634:	740f      	strb	r7, [r1, #16]
	resp->reason = reason;
    5636:	744f      	strb	r7, [r1, #17]
    5638:	608b      	str	r3, [r1, #8]
	__asm__ __volatile__ (
    563a:	f3ef 8510 	mrs	r5, PRIMASK
    563e:	b672      	cpsid	i
	rc = msg_enqueue(q, msg);
    5640:	4816      	ldr	r0, [pc, #88]	; (569c <btctl_work+0x23c>)
    5642:	f002 fd71 	bl	8128 <msg_enqueue>
	__asm__ __volatile__ (
    5646:	f385 8810 	msr	PRIMASK, r5
}
    564a:	e7b6      	b.n	55ba <btctl_work+0x15a>
		cprintf("Cannot change eir_msg now\n");
    564c:	4814      	ldr	r0, [pc, #80]	; (56a0 <btctl_work+0x240>)
    564e:	f003 fde1 	bl	9214 <cprintf>
	btctl_mem_free(msg);
    5652:	4620      	mov	r0, r4
    5654:	f002 fc0a 	bl	7e6c <mem_pool_free>
	return 1;
    5658:	2001      	movs	r0, #1
		return;
    565a:	e734      	b.n	54c6 <btctl_work+0x66>
		DIE("msg_put: short buf\n");
    565c:	4811      	ldr	r0, [pc, #68]	; (56a4 <btctl_work+0x244>)
    565e:	f002 fcd9 	bl	8014 <die>
    5662:	bf00      	nop
    5664:	100023e0 	.word	0x100023e0
    5668:	100023dc 	.word	0x100023dc
    566c:	0000dad0 	.word	0x0000dad0
    5670:	0000dae0 	.word	0x0000dae0
    5674:	100001a4 	.word	0x100001a4
    5678:	00007595 	.word	0x00007595
    567c:	10002430 	.word	0x10002430
    5680:	0000db5c 	.word	0x0000db5c
    5684:	0000da68 	.word	0x0000da68
    5688:	0000da80 	.word	0x0000da80
    568c:	0000da88 	.word	0x0000da88
    5690:	40008008 	.word	0x40008008
    5694:	0000da70 	.word	0x0000da70
    5698:	0000da60 	.word	0x0000da60
    569c:	10002408 	.word	0x10002408
    56a0:	0000dab4 	.word	0x0000dab4
    56a4:	0000da98 	.word	0x0000da98

000056a8 <btctl_set_state>:
{
    56a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    56ac:	4604      	mov	r4, r0
    56ae:	460e      	mov	r6, r1
	__asm__ __volatile__ (
    56b0:	f3ef 8810 	mrs	r8, PRIMASK
    56b4:	b672      	cpsid	i
	btctl_state_t old_state = btctl.state;
    56b6:	4f39      	ldr	r7, [pc, #228]	; (579c <btctl_set_state+0xf4>)
    56b8:	783d      	ldrb	r5, [r7, #0]
	if (state >= BTCTL_STATE_COUNT)
    56ba:	2d05      	cmp	r5, #5
    56bc:	d849      	bhi.n	5752 <btctl_set_state+0xaa>
	name = btctl_state_name_tbl[state];
    56be:	4a38      	ldr	r2, [pc, #224]	; (57a0 <btctl_set_state+0xf8>)
		name = "TODO";
    56c0:	4b38      	ldr	r3, [pc, #224]	; (57a4 <btctl_set_state+0xfc>)
	name = btctl_state_name_tbl[state];
    56c2:	f852 1025 	ldr.w	r1, [r2, r5, lsl #2]
		name = "TODO";
    56c6:	2900      	cmp	r1, #0
    56c8:	bf08      	it	eq
    56ca:	4619      	moveq	r1, r3
	if (state >= BTCTL_STATE_COUNT)
    56cc:	2c05      	cmp	r4, #5
    56ce:	d839      	bhi.n	5744 <btctl_set_state+0x9c>
	name = btctl_state_name_tbl[state];
    56d0:	4a33      	ldr	r2, [pc, #204]	; (57a0 <btctl_set_state+0xf8>)
		name = "TODO";
    56d2:	4b34      	ldr	r3, [pc, #208]	; (57a4 <btctl_set_state+0xfc>)
	name = btctl_state_name_tbl[state];
    56d4:	f852 2024 	ldr.w	r2, [r2, r4, lsl #2]
	cprintf("State %s -> %s\n",
    56d8:	4833      	ldr	r0, [pc, #204]	; (57a8 <btctl_set_state+0x100>)
    56da:	2a00      	cmp	r2, #0
    56dc:	bf08      	it	eq
    56de:	461a      	moveq	r2, r3
    56e0:	f003 fd98 	bl	9214 <cprintf>
	if (next == BTCTL_STATE_STANDBY)
    56e4:	bb4c      	cbnz	r4, 573a <btctl_set_state+0x92>
	btctl.state = state;
    56e6:	703c      	strb	r4, [r7, #0]
	__asm__ __volatile__ (
    56e8:	f388 8810 	msr	PRIMASK, r8
	if (!(old_state == BTCTL_STATE_STANDBY && state == BTCTL_STATE_STANDBY))
    56ec:	ea55 0304 	orrs.w	r3, r5, r4
    56f0:	d101      	bne.n	56f6 <btctl_set_state+0x4e>
		btctl_send_state_resp(state, reason);
}
    56f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	msg_t *msg = (msg_t*)btctl_mem_alloc(sizeof(msg_t)+size);
    56f6:	f44f 70ba 	mov.w	r0, #372	; 0x174
    56fa:	f002 fb93 	bl	7e24 <mem_pool_alloc>
    56fe:	4601      	mov	r1, r0
	hdr->type = type;
    5700:	2329      	movs	r3, #41	; 0x29
	msg->data_len = size;
    5702:	f44f 75b4 	mov.w	r5, #360	; 0x168
	msg->write = msg->data;
    5706:	300c      	adds	r0, #12
        msg->write += len;
    5708:	f101 0210 	add.w	r2, r1, #16
    570c:	730b      	strb	r3, [r1, #12]
	return (int)(msg->write - msg->data);
    570e:	1a13      	subs	r3, r2, r0
        return msg->data_len - msg_write_len(msg);
    5710:	1aeb      	subs	r3, r5, r3
        if (msg_write_avail(msg) < (int) len)
    5712:	2b01      	cmp	r3, #1
        msg->write += len;
    5714:	e9c1 0201 	strd	r0, r2, [r1, #4]
	msg->data_len = size;
    5718:	804d      	strh	r5, [r1, #2]
        if (msg_write_avail(msg) < (int) len)
    571a:	dd3c      	ble.n	5796 <btctl_set_state+0xee>
        msg->write += len;
    571c:	f101 0312 	add.w	r3, r1, #18
	resp->state = state;
    5720:	740c      	strb	r4, [r1, #16]
	resp->reason = reason;
    5722:	744e      	strb	r6, [r1, #17]
    5724:	608b      	str	r3, [r1, #8]
	__asm__ __volatile__ (
    5726:	f3ef 8410 	mrs	r4, PRIMASK
    572a:	b672      	cpsid	i
	rc = msg_enqueue(q, msg);
    572c:	481f      	ldr	r0, [pc, #124]	; (57ac <btctl_set_state+0x104>)
    572e:	f002 fcfb 	bl	8128 <msg_enqueue>
	__asm__ __volatile__ (
    5732:	f384 8810 	msr	PRIMASK, r4
}
    5736:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (next == BTCTL_STATE_CONNECTED)
    573a:	2c03      	cmp	r4, #3
    573c:	d00b      	beq.n	5756 <btctl_set_state+0xae>
	if (!btctl_state_transition_valid(old_state, state))
    573e:	2d00      	cmp	r5, #0
    5740:	d0d1      	beq.n	56e6 <btctl_set_state+0x3e>
    5742:	e00d      	b.n	5760 <btctl_set_state+0xb8>
	cprintf("State %s -> %s\n",
    5744:	4a1a      	ldr	r2, [pc, #104]	; (57b0 <btctl_set_state+0x108>)
    5746:	4818      	ldr	r0, [pc, #96]	; (57a8 <btctl_set_state+0x100>)
    5748:	f003 fd64 	bl	9214 <cprintf>
	if (!btctl_state_transition_valid(old_state, state))
    574c:	2d00      	cmp	r5, #0
    574e:	d0ca      	beq.n	56e6 <btctl_set_state+0x3e>
    5750:	e006      	b.n	5760 <btctl_set_state+0xb8>
		return "Invalid";
    5752:	4917      	ldr	r1, [pc, #92]	; (57b0 <btctl_set_state+0x108>)
    5754:	e7ba      	b.n	56cc <btctl_set_state+0x24>
			|| cur == BTCTL_STATE_CONNECTED;
    5756:	1eab      	subs	r3, r5, #2
    5758:	2b01      	cmp	r3, #1
    575a:	d9c4      	bls.n	56e6 <btctl_set_state+0x3e>
			|| cur == BTCTL_STATE_PAGE_SCAN
    575c:	2d05      	cmp	r5, #5
    575e:	d0c2      	beq.n	56e6 <btctl_set_state+0x3e>
    5760:	f388 8810 	msr	PRIMASK, r8
	if (state >= BTCTL_STATE_COUNT)
    5764:	2d05      	cmp	r5, #5
    5766:	d812      	bhi.n	578e <btctl_set_state+0xe6>
	name = btctl_state_name_tbl[state];
    5768:	4a0d      	ldr	r2, [pc, #52]	; (57a0 <btctl_set_state+0xf8>)
		name = "TODO";
    576a:	4b0e      	ldr	r3, [pc, #56]	; (57a4 <btctl_set_state+0xfc>)
	name = btctl_state_name_tbl[state];
    576c:	f852 1025 	ldr.w	r1, [r2, r5, lsl #2]
		name = "TODO";
    5770:	2900      	cmp	r1, #0
    5772:	bf08      	it	eq
    5774:	4619      	moveq	r1, r3
	if (state >= BTCTL_STATE_COUNT)
    5776:	2c05      	cmp	r4, #5
    5778:	d80b      	bhi.n	5792 <btctl_set_state+0xea>
	name = btctl_state_name_tbl[state];
    577a:	4a09      	ldr	r2, [pc, #36]	; (57a0 <btctl_set_state+0xf8>)
		name = "TODO";
    577c:	4b09      	ldr	r3, [pc, #36]	; (57a4 <btctl_set_state+0xfc>)
	name = btctl_state_name_tbl[state];
    577e:	f852 2024 	ldr.w	r2, [r2, r4, lsl #2]
		name = "TODO";
    5782:	2a00      	cmp	r2, #0
    5784:	bf08      	it	eq
    5786:	461a      	moveq	r2, r3
		DIE("Invalid state transition %s -> %s\n",
    5788:	480a      	ldr	r0, [pc, #40]	; (57b4 <btctl_set_state+0x10c>)
    578a:	f002 fc43 	bl	8014 <die>
		return "Invalid";
    578e:	4908      	ldr	r1, [pc, #32]	; (57b0 <btctl_set_state+0x108>)
    5790:	e7f1      	b.n	5776 <btctl_set_state+0xce>
    5792:	4a07      	ldr	r2, [pc, #28]	; (57b0 <btctl_set_state+0x108>)
    5794:	e7f8      	b.n	5788 <btctl_set_state+0xe0>
		DIE("msg_put: short buf\n");
    5796:	4808      	ldr	r0, [pc, #32]	; (57b8 <btctl_set_state+0x110>)
    5798:	f002 fc3c 	bl	8014 <die>
    579c:	100023dc 	.word	0x100023dc
    57a0:	0000db5c 	.word	0x0000db5c
    57a4:	0000da68 	.word	0x0000da68
    57a8:	0000da88 	.word	0x0000da88
    57ac:	10002408 	.word	0x10002408
    57b0:	0000da60 	.word	0x0000da60
    57b4:	0000dafc 	.word	0x0000dafc
    57b8:	0000da98 	.word	0x0000da98

000057bc <btctl_init>:

void btctl_init(void)
{
    57bc:	b510      	push	{r4, lr}
	btctl.state = BTCTL_STATE_STANDBY;
    57be:	2300      	movs	r3, #0
    57c0:	4c08      	ldr	r4, [pc, #32]	; (57e4 <btctl_init+0x28>)
	btctl.eir_msg = NULL;
	btctl.eir_pkt = NULL;
	msg_queue_init(&btctl.rx_q);
    57c2:	1d20      	adds	r0, r4, #4
	btctl.eir_pkt = NULL;
    57c4:	e9c4 331f 	strd	r3, r3, [r4, #124]	; 0x7c
	btctl.state = BTCTL_STATE_STANDBY;
    57c8:	7023      	strb	r3, [r4, #0]
	msg_queue_init(&btctl.rx_q);
    57ca:	f002 fcc5 	bl	8158 <msg_queue_init>
	msg_queue_init(&btctl.tx_q);
    57ce:	f104 002c 	add.w	r0, r4, #44	; 0x2c
    57d2:	f002 fcc1 	bl	8158 <msg_queue_init>
	msg_queue_init(&btctl.acl_tx_q);
    57d6:	f104 0054 	add.w	r0, r4, #84	; 0x54
}
    57da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	msg_queue_init(&btctl.acl_tx_q);
    57de:	f002 bcbb 	b.w	8158 <msg_queue_init>
    57e2:	bf00      	nop
    57e4:	100023dc 	.word	0x100023dc

000057e8 <ll_process_rx>:
 * return: 0 if nothing to do
 *	   1 if tx required
 * 	  <0 on error
 */
int ll_process_rx(link_layer_t *ll, msg_t *msg)
{
    57e8:	b570      	push	{r4, r5, r6, lr}
	uint32_t clk_diff;
	int rc = ll->is_master != 0;	// master always tx
    57ea:	7842      	ldrb	r2, [r0, #1]
	int do_free_msg = 1;
	btctl_rx_pkt_t *pkt;
	btctl_hdr_t *h = (btctl_hdr_t*)msg->data;

	/* RX packet */
	if (h->type != BTCTL_RX_PKT)
    57ec:	7b0b      	ldrb	r3, [r1, #12]
	int rc = ll->is_master != 0;	// master always tx
    57ee:	1e16      	subs	r6, r2, #0
    57f0:	bf18      	it	ne
    57f2:	2601      	movne	r6, #1
	if (h->type != BTCTL_RX_PKT)
    57f4:	2b28      	cmp	r3, #40	; 0x28
{
    57f6:	4604      	mov	r4, r0
    57f8:	460d      	mov	r5, r1
	if (h->type != BTCTL_RX_PKT)
    57fa:	f040 8092 	bne.w	5922 <ll_process_rx+0x13a>
		DIE("rx : expect rx pkt");
	pkt = (btctl_rx_pkt_t *)h->data;

	/* No packet received, update timeout */
	if (!BBPKT_HAS_HDR(pkt))
    57fe:	7d4b      	ldrb	r3, [r1, #21]
    5800:	079b      	lsls	r3, r3, #30
    5802:	d54b      	bpl.n	589c <ll_process_rx+0xb4>
		}
		goto end;
	}

	/* Check for connection establishment */
	if (!ll->is_connected)
    5804:	7803      	ldrb	r3, [r0, #0]
    5806:	b1c3      	cbz	r3, 583a <ll_process_rx+0x52>
#define CUR_MASTER_SLOT_IDX()	(btphy.master_clkn&3)
#define CUR_SLAVE_SLOT_IDX()	(btphy.slave_clkn&3)

static inline uint32_t btphy_cur_clkn(void)
{
	switch(btphy.mode)
    5808:	4b49      	ldr	r3, [pc, #292]	; (5930 <ll_process_rx+0x148>)
    580a:	7819      	ldrb	r1, [r3, #0]
    580c:	2903      	cmp	r1, #3
    580e:	d810      	bhi.n	5832 <ll_process_rx+0x4a>
    5810:	2901      	cmp	r1, #1
    5812:	d810      	bhi.n	5836 <ll_process_rx+0x4e>
	case BT_MODE_INQUIRY_SCAN:
	case BT_MODE_PAGE_SCAN:
	case BT_MODE_SLAVE:
		return btphy.slave_clkn;
	default:
		return btphy.master_clkn;
    5814:	6859      	ldr	r1, [r3, #4]
		/* Inform host of connection establishment */
		btctl_set_state(BTCTL_STATE_CONNECTED, BTCTL_REASON_SUCCESS|(ll->lt_addr<<5));
	}
	/* Update supervision timeout / stats */
	ll->clkn_last_rx = btphy_cur_clkn();
	ll->rx_count ++;
    5816:	68e3      	ldr	r3, [r4, #12]
	ll->clkn_last_rx = btphy_cur_clkn();
    5818:	60a1      	str	r1, [r4, #8]
	ll->rx_count ++;
    581a:	3301      	adds	r3, #1
    581c:	60e3      	str	r3, [r4, #12]

	/* Check if we must discard the packet */
	if (!ll->is_master && pkt->bb_hdr.lt_addr != ll->lt_addr)
    581e:	b9da      	cbnz	r2, 5858 <ll_process_rx+0x70>
    5820:	7e2a      	ldrb	r2, [r5, #24]
    5822:	7c23      	ldrb	r3, [r4, #16]
    5824:	429a      	cmp	r2, r3
    5826:	d017      	beq.n	5858 <ll_process_rx+0x70>
	btctl_mem_free(msg);
    5828:	4628      	mov	r0, r5
    582a:	f002 fb1f 	bl	7e6c <mem_pool_free>
end:
	if (do_free_msg)
		msg_free(msg);

	return rc;
}
    582e:	4630      	mov	r0, r6
    5830:	bd70      	pop	{r4, r5, r6, pc}
	switch(btphy.mode)
    5832:	2905      	cmp	r1, #5
    5834:	d1ee      	bne.n	5814 <ll_process_rx+0x2c>
		return btphy.slave_clkn;
    5836:	6899      	ldr	r1, [r3, #8]
    5838:	e7ed      	b.n	5816 <ll_process_rx+0x2e>
		ll->is_connected = 1;
    583a:	2301      	movs	r3, #1
		btctl_set_state(BTCTL_STATE_CONNECTED, BTCTL_REASON_SUCCESS|(ll->lt_addr<<5));
    583c:	7c01      	ldrb	r1, [r0, #16]
		ll->is_connected = 1;
    583e:	7003      	strb	r3, [r0, #0]
		btctl_set_state(BTCTL_STATE_CONNECTED, BTCTL_REASON_SUCCESS|(ll->lt_addr<<5));
    5840:	0149      	lsls	r1, r1, #5
    5842:	f001 01e0 	and.w	r1, r1, #224	; 0xe0
    5846:	2003      	movs	r0, #3
    5848:	f7ff ff2e 	bl	56a8 <btctl_set_state>
	switch(btphy.mode)
    584c:	4b38      	ldr	r3, [pc, #224]	; (5930 <ll_process_rx+0x148>)
    584e:	7862      	ldrb	r2, [r4, #1]
    5850:	7819      	ldrb	r1, [r3, #0]
    5852:	2903      	cmp	r1, #3
    5854:	d8ed      	bhi.n	5832 <ll_process_rx+0x4a>
    5856:	e7db      	b.n	5810 <ll_process_rx+0x28>
	if (pkt->bb_hdr.flags & (1<<BTHDR_ARQN))
    5858:	7eab      	ldrb	r3, [r5, #26]
    585a:	0798      	lsls	r0, r3, #30
    585c:	d50a      	bpl.n	5874 <ll_process_rx+0x8c>
		if (ll->cur_tx_msg != NULL)
    585e:	69a0      	ldr	r0, [r4, #24]
    5860:	b140      	cbz	r0, 5874 <ll_process_rx+0x8c>
    5862:	f002 fb03 	bl	7e6c <mem_pool_free>
			ll->cur_tx_msg = NULL;
    5866:	2200      	movs	r2, #0
			ll->loc_seqn ^= 1;
    5868:	7ca3      	ldrb	r3, [r4, #18]
			ll->cur_tx_msg = NULL;
    586a:	61a2      	str	r2, [r4, #24]
			ll->loc_seqn ^= 1;
    586c:	f083 0301 	eor.w	r3, r3, #1
    5870:	74a3      	strb	r3, [r4, #18]
    5872:	7eab      	ldrb	r3, [r5, #26]
	if (BBPKT_HAS_CRC(pkt))
    5874:	7d6a      	ldrb	r2, [r5, #21]
    5876:	0751      	lsls	r1, r2, #29
    5878:	d506      	bpl.n	5888 <ll_process_rx+0xa0>
		if ((1&(pkt->bb_hdr.flags>>BTHDR_SEQN)) != ll->rmt_seqn)
    587a:	7c61      	ldrb	r1, [r4, #17]
    587c:	f3c3 0380 	ubfx	r3, r3, #2, #1
    5880:	4299      	cmp	r1, r3
    5882:	d036      	beq.n	58f2 <ll_process_rx+0x10a>
			ll->loc_arqn = 1;
    5884:	2301      	movs	r3, #1
    5886:	74e3      	strb	r3, [r4, #19]
	if (ll->is_master || pkt->bb_hdr.type == BB_TYPE_POLL || ll->loc_arqn)
    5888:	7863      	ldrb	r3, [r4, #1]
    588a:	bb83      	cbnz	r3, 58ee <ll_process_rx+0x106>
    588c:	7e6b      	ldrb	r3, [r5, #25]
    588e:	2b01      	cmp	r3, #1
    5890:	d045      	beq.n	591e <ll_process_rx+0x136>
    5892:	7ce3      	ldrb	r3, [r4, #19]
		rc = 1;
    5894:	2b00      	cmp	r3, #0
    5896:	bf18      	it	ne
    5898:	2601      	movne	r6, #1
    589a:	e7c5      	b.n	5828 <ll_process_rx+0x40>
    589c:	4b24      	ldr	r3, [pc, #144]	; (5930 <ll_process_rx+0x148>)
    589e:	781a      	ldrb	r2, [r3, #0]
    58a0:	2a03      	cmp	r2, #3
    58a2:	d81b      	bhi.n	58dc <ll_process_rx+0xf4>
    58a4:	2a01      	cmp	r2, #1
    58a6:	d81b      	bhi.n	58e0 <ll_process_rx+0xf8>
		return btphy.master_clkn;
    58a8:	6859      	ldr	r1, [r3, #4]
		clk_diff = btphy_cur_clkn() - ll->clkn_last_rx;
    58aa:	68a0      	ldr	r0, [r4, #8]
    58ac:	1a09      	subs	r1, r1, r0
		if (clk_diff > SUPERVISION_TO)
    58ae:	f5b1 6f48 	cmp.w	r1, #3200	; 0xc80
    58b2:	d9b9      	bls.n	5828 <ll_process_rx+0x40>
	switch(btphy.mode)
    58b4:	2a03      	cmp	r2, #3
    58b6:	d82e      	bhi.n	5916 <ll_process_rx+0x12e>
    58b8:	2a01      	cmp	r2, #1
    58ba:	d82e      	bhi.n	591a <ll_process_rx+0x132>
		return btphy.master_clkn;
    58bc:	685b      	ldr	r3, [r3, #4]
				(btphy_cur_clkn()-ll->clkn_start-SUPERVISION_TO)/CLKN_RATE,
    58be:	6861      	ldr	r1, [r4, #4]
			cprintf("LS To (con for %d sec, %d pkt rx)\n",
    58c0:	4a1c      	ldr	r2, [pc, #112]	; (5934 <ll_process_rx+0x14c>)
				(btphy_cur_clkn()-ll->clkn_start-SUPERVISION_TO)/CLKN_RATE,
    58c2:	1a59      	subs	r1, r3, r1
    58c4:	f5a1 6148 	sub.w	r1, r1, #3200	; 0xc80
			cprintf("LS To (con for %d sec, %d pkt rx)\n",
    58c8:	fba2 3101 	umull	r3, r1, r2, r1
    58cc:	481a      	ldr	r0, [pc, #104]	; (5938 <ll_process_rx+0x150>)
    58ce:	68e2      	ldr	r2, [r4, #12]
    58d0:	0a89      	lsrs	r1, r1, #10
    58d2:	f003 fc9f 	bl	9214 <cprintf>
			rc = -BTCTL_REASON_TIMEOUT;
    58d6:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
    58da:	e7a5      	b.n	5828 <ll_process_rx+0x40>
	switch(btphy.mode)
    58dc:	2a05      	cmp	r2, #5
    58de:	d1e3      	bne.n	58a8 <ll_process_rx+0xc0>
		return btphy.slave_clkn;
    58e0:	6899      	ldr	r1, [r3, #8]
		clk_diff = btphy_cur_clkn() - ll->clkn_last_rx;
    58e2:	68a0      	ldr	r0, [r4, #8]
    58e4:	1a09      	subs	r1, r1, r0
		if (clk_diff > SUPERVISION_TO)
    58e6:	f5b1 6f48 	cmp.w	r1, #3200	; 0xc80
    58ea:	d99d      	bls.n	5828 <ll_process_rx+0x40>
    58ec:	e7e2      	b.n	58b4 <ll_process_rx+0xcc>
		rc = 1;
    58ee:	2601      	movs	r6, #1
    58f0:	e79a      	b.n	5828 <ll_process_rx+0x40>
			if (BBPKT_GOOD_CRC(pkt))
    58f2:	0713      	lsls	r3, r2, #28
    58f4:	d5c8      	bpl.n	5888 <ll_process_rx+0xa0>
	__asm__ __volatile__ (
    58f6:	f3ef 8610 	mrs	r6, PRIMASK
    58fa:	b672      	cpsid	i
    58fc:	480f      	ldr	r0, [pc, #60]	; (593c <ll_process_rx+0x154>)
    58fe:	4629      	mov	r1, r5
    5900:	f002 fc12 	bl	8128 <msg_enqueue>
	__asm__ __volatile__ (
    5904:	f386 8810 	msr	PRIMASK, r6
				if (btctl_tx_enqueue(msg) != 0)
    5908:	b970      	cbnz	r0, 5928 <ll_process_rx+0x140>
				ll->loc_arqn = 1;
    590a:	2601      	movs	r6, #1
				ll->rmt_seqn ^= 1;
    590c:	7c63      	ldrb	r3, [r4, #17]
				ll->loc_arqn = 1;
    590e:	74e6      	strb	r6, [r4, #19]
				ll->rmt_seqn ^= 1;
    5910:	4073      	eors	r3, r6
    5912:	7463      	strb	r3, [r4, #17]
	if (ll->is_master || pkt->bb_hdr.type == BB_TYPE_POLL || ll->loc_arqn)
    5914:	e78b      	b.n	582e <ll_process_rx+0x46>
	switch(btphy.mode)
    5916:	2a05      	cmp	r2, #5
    5918:	d1d0      	bne.n	58bc <ll_process_rx+0xd4>
		return btphy.slave_clkn;
    591a:	689b      	ldr	r3, [r3, #8]
    591c:	e7cf      	b.n	58be <ll_process_rx+0xd6>
		rc = 1;
    591e:	461e      	mov	r6, r3
    5920:	e782      	b.n	5828 <ll_process_rx+0x40>
		DIE("rx : expect rx pkt");
    5922:	4807      	ldr	r0, [pc, #28]	; (5940 <ll_process_rx+0x158>)
    5924:	f002 fb76 	bl	8014 <die>
					DIE("txq full in master\n");
    5928:	4806      	ldr	r0, [pc, #24]	; (5944 <ll_process_rx+0x15c>)
    592a:	f002 fb73 	bl	8014 <die>
    592e:	bf00      	nop
    5930:	100001b0 	.word	0x100001b0
    5934:	51eb851f 	.word	0x51eb851f
    5938:	0000db8c 	.word	0x0000db8c
    593c:	10002408 	.word	0x10002408
    5940:	0000db74 	.word	0x0000db74
    5944:	0000dbb0 	.word	0x0000dbb0

00005948 <ll_prepare_tx>:

void ll_prepare_tx(link_layer_t *ll, bbhdr_t **tx_hdr, uint8_t **tx_data)
{
    5948:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    594a:	4604      	mov	r4, r0
	btctl_hdr_t *btctl_hdr;
	btctl_tx_pkt_t *tx_pkt;

	if (ll->cur_tx_msg == NULL)
    594c:	6980      	ldr	r0, [r0, #24]
{
    594e:	460f      	mov	r7, r1
    5950:	4616      	mov	r6, r2
	if (ll->cur_tx_msg == NULL)
    5952:	b190      	cbz	r0, 597a <ll_prepare_tx+0x32>
		*tx_data = NULL;
	}
	else{
		LL_DEBUG('T');
		btctl_hdr = (btctl_hdr_t*)ll->cur_tx_msg->data;
		if (btctl_hdr->type != BTCTL_TX_ACL_REQ)
    5954:	7b03      	ldrb	r3, [r0, #12]
    5956:	2b1b      	cmp	r3, #27
    5958:	d126      	bne.n	59a8 <ll_prepare_tx+0x60>
			DIE("BTCTL_TX_ACL_REQ expected\n");
		tx_pkt = (btctl_tx_pkt_t*)btctl_hdr->data;
		*tx_hdr =  &tx_pkt->bb_hdr;
    595a:	f100 0510 	add.w	r5, r0, #16
		*tx_data = tx_pkt->bt_data;
    595e:	3014      	adds	r0, #20
		*tx_hdr =  &tx_pkt->bb_hdr;
    5960:	603d      	str	r5, [r7, #0]
		*tx_data = tx_pkt->bt_data;
    5962:	6030      	str	r0, [r6, #0]
	/* Write ll flags in tx header */
	(*tx_hdr)->flags =
		(ll->loc_arqn<<BTHDR_ARQN)
		 | (ll->loc_seqn<<BTHDR_SEQN)
		 | (1<<BTHDR_FLOW);
	ll->loc_arqn = 0;
    5964:	2200      	movs	r2, #0
		 | (ll->loc_seqn<<BTHDR_SEQN)
    5966:	7ca3      	ldrb	r3, [r4, #18]
		(ll->loc_arqn<<BTHDR_ARQN)
    5968:	7ce1      	ldrb	r1, [r4, #19]
		 | (ll->loc_seqn<<BTHDR_SEQN)
    596a:	009b      	lsls	r3, r3, #2
    596c:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
		 | (1<<BTHDR_FLOW);
    5970:	f043 0301 	orr.w	r3, r3, #1
	(*tx_hdr)->flags =
    5974:	70ab      	strb	r3, [r5, #2]
	ll->loc_arqn = 0;
    5976:	74e2      	strb	r2, [r4, #19]
}
    5978:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	__asm__ __volatile__ (
    597a:	f3ef 8510 	mrs	r5, PRIMASK
    597e:	b672      	cpsid	i
	msg = msg_dequeue(q);
    5980:	480b      	ldr	r0, [pc, #44]	; (59b0 <ll_prepare_tx+0x68>)
    5982:	f002 fbbb 	bl	80fc <msg_dequeue>
	__asm__ __volatile__ (
    5986:	f385 8810 	msr	PRIMASK, r5
		ll->cur_tx_msg=btctl_acl_tx_dequeue();
    598a:	61a0      	str	r0, [r4, #24]
	if (ll->cur_tx_msg == NULL)
    598c:	2800      	cmp	r0, #0
    598e:	d1e1      	bne.n	5954 <ll_prepare_tx+0xc>
		if (ll->is_master)
    5990:	7863      	ldrb	r3, [r4, #1]
		ll->tx_hdr.lt_addr = ll->lt_addr;
    5992:	7c22      	ldrb	r2, [r4, #16]
		if (ll->is_master)
    5994:	3b00      	subs	r3, #0
    5996:	bf18      	it	ne
    5998:	2301      	movne	r3, #1
		*tx_hdr = &ll->tx_hdr;
    599a:	f104 0514 	add.w	r5, r4, #20
		ll->tx_hdr.lt_addr = ll->lt_addr;
    599e:	7522      	strb	r2, [r4, #20]
		if (ll->is_master)
    59a0:	7563      	strb	r3, [r4, #21]
		*tx_hdr = &ll->tx_hdr;
    59a2:	603d      	str	r5, [r7, #0]
		*tx_data = NULL;
    59a4:	6030      	str	r0, [r6, #0]
    59a6:	e7dd      	b.n	5964 <ll_prepare_tx+0x1c>
			DIE("BTCTL_TX_ACL_REQ expected\n");
    59a8:	4802      	ldr	r0, [pc, #8]	; (59b4 <ll_prepare_tx+0x6c>)
    59aa:	f002 fb33 	bl	8014 <die>
    59ae:	bf00      	nop
    59b0:	10002430 	.word	0x10002430
    59b4:	0000dbcc 	.word	0x0000dbcc

000059b8 <ll_reset>:

void ll_reset(link_layer_t *ll)
{
    59b8:	b510      	push	{r4, lr}
    59ba:	4604      	mov	r4, r0
	// Todo : free msg_t*
	if (ll->cur_tx_msg)
    59bc:	6980      	ldr	r0, [r0, #24]
    59be:	b118      	cbz	r0, 59c8 <ll_reset+0x10>
    59c0:	f002 fa54 	bl	7e6c <mem_pool_free>
	{
		msg_free(ll->cur_tx_msg);
		ll->cur_tx_msg = NULL;
    59c4:	2300      	movs	r3, #0
    59c6:	61a3      	str	r3, [r4, #24]
	}
}
    59c8:	bd10      	pop	{r4, pc}
    59ca:	bf00      	nop

000059cc <ll_init>:

void ll_init(link_layer_t *ll, uint8_t is_master, uint8_t lt_addr)
{
    59cc:	b470      	push	{r4, r5, r6}
	ll->is_master = is_master;
	ll->is_connected = 0;
    59ce:	2400      	movs	r4, #0

	/* Link flags */
	ll->lt_addr = lt_addr;
	ll->rmt_seqn = 1;
    59d0:	2601      	movs	r6, #1
	switch(btphy.mode)
    59d2:	4d0c      	ldr	r5, [pc, #48]	; (5a04 <ll_init+0x38>)
	ll->is_connected = 0;
    59d4:	7004      	strb	r4, [r0, #0]
    59d6:	782b      	ldrb	r3, [r5, #0]
	ll->is_master = is_master;
    59d8:	7041      	strb	r1, [r0, #1]
    59da:	2b03      	cmp	r3, #3
	ll->lt_addr = lt_addr;
    59dc:	7402      	strb	r2, [r0, #16]
	ll->loc_seqn = 1;
	ll->loc_arqn = 0;

	/* TX message */
	ll->cur_tx_msg = NULL;
    59de:	6184      	str	r4, [r0, #24]

	/* Stats / timeout */
	ll->rx_count = 0;
    59e0:	60c4      	str	r4, [r0, #12]
	ll->rmt_seqn = 1;
    59e2:	7446      	strb	r6, [r0, #17]
	ll->loc_seqn = 1;
    59e4:	8246      	strh	r6, [r0, #18]
    59e6:	d806      	bhi.n	59f6 <ll_init+0x2a>
    59e8:	42b3      	cmp	r3, r6
    59ea:	d806      	bhi.n	59fa <ll_init+0x2e>
		return btphy.master_clkn;
    59ec:	686b      	ldr	r3, [r5, #4]
	ll->clkn_last_rx = ll->clkn_start = btphy_cur_clkn();
}
    59ee:	bc70      	pop	{r4, r5, r6}
	ll->clkn_last_rx = ll->clkn_start = btphy_cur_clkn();
    59f0:	e9c0 3301 	strd	r3, r3, [r0, #4]
}
    59f4:	4770      	bx	lr
	switch(btphy.mode)
    59f6:	2b05      	cmp	r3, #5
    59f8:	d1f8      	bne.n	59ec <ll_init+0x20>
		return btphy.slave_clkn;
    59fa:	68ab      	ldr	r3, [r5, #8]
    59fc:	bc70      	pop	{r4, r5, r6}
	ll->clkn_last_rx = ll->clkn_start = btphy_cur_clkn();
    59fe:	e9c0 3301 	strd	r3, r3, [r0, #4]
}
    5a02:	4770      	bx	lr
    5a04:	100001b0 	.word	0x100001b0

00005a08 <btphy_timer_add>:
		}
	}
}

void btphy_timer_add(uint32_t instant, btphy_timer_fn_t cb, void *cb_arg, uint8_t anyway)
{
    5a08:	b570      	push	{r4, r5, r6, lr}
	unsigned i;
	btphy_timer_t *t;

	if (btphy_timers.count == BTPHY_TIMER_COUNT)
    5a0a:	4c20      	ldr	r4, [pc, #128]	; (5a8c <btphy_timer_add+0x84>)
    5a0c:	6825      	ldr	r5, [r4, #0]
    5a0e:	2d0a      	cmp	r5, #10
    5a10:	d039      	beq.n	5a86 <btphy_timer_add+0x7e>
	{
		DIE("too many timers");
	}
	for(i=0, t=btphy_timers.timers; i<BTPHY_TIMER_COUNT; i++,t++)
	{
		if (t->cb == NULL)
    5a12:	68a6      	ldr	r6, [r4, #8]
    5a14:	b1b6      	cbz	r6, 5a44 <btphy_timer_add+0x3c>
    5a16:	69a6      	ldr	r6, [r4, #24]
    5a18:	b1e6      	cbz	r6, 5a54 <btphy_timer_add+0x4c>
    5a1a:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    5a1c:	b1ee      	cbz	r6, 5a5a <btphy_timer_add+0x52>
    5a1e:	6ba6      	ldr	r6, [r4, #56]	; 0x38
    5a20:	b1f6      	cbz	r6, 5a60 <btphy_timer_add+0x58>
    5a22:	6ca6      	ldr	r6, [r4, #72]	; 0x48
    5a24:	b1fe      	cbz	r6, 5a66 <btphy_timer_add+0x5e>
    5a26:	6da6      	ldr	r6, [r4, #88]	; 0x58
    5a28:	b306      	cbz	r6, 5a6c <btphy_timer_add+0x64>
    5a2a:	6ea6      	ldr	r6, [r4, #104]	; 0x68
    5a2c:	b30e      	cbz	r6, 5a72 <btphy_timer_add+0x6a>
    5a2e:	6fa6      	ldr	r6, [r4, #120]	; 0x78
    5a30:	b316      	cbz	r6, 5a78 <btphy_timer_add+0x70>
    5a32:	f8d4 6088 	ldr.w	r6, [r4, #136]	; 0x88
    5a36:	b316      	cbz	r6, 5a7e <btphy_timer_add+0x76>
    5a38:	f8d4 6098 	ldr.w	r6, [r4, #152]	; 0x98
    5a3c:	b30e      	cbz	r6, 5a82 <btphy_timer_add+0x7a>
			t->anyway = anyway;
			btphy_timers.count++;
			return;
		}
	}
	DIE("timers overflow");
    5a3e:	4814      	ldr	r0, [pc, #80]	; (5a90 <btphy_timer_add+0x88>)
    5a40:	f002 fae8 	bl	8014 <die>
	for(i=0, t=btphy_timers.timers; i<BTPHY_TIMER_COUNT; i++,t++)
    5a44:	1d26      	adds	r6, r4, #4
			btphy_timers.count++;
    5a46:	3501      	adds	r5, #1
			t->anyway = anyway;
    5a48:	7333      	strb	r3, [r6, #12]
			t->cb = cb;
    5a4a:	e9c6 0100 	strd	r0, r1, [r6]
			t->cb_arg = cb_arg;
    5a4e:	60b2      	str	r2, [r6, #8]
			btphy_timers.count++;
    5a50:	6025      	str	r5, [r4, #0]
}
    5a52:	bd70      	pop	{r4, r5, r6, pc}
	for(i=0, t=btphy_timers.timers; i<BTPHY_TIMER_COUNT; i++,t++)
    5a54:	f104 0614 	add.w	r6, r4, #20
    5a58:	e7f5      	b.n	5a46 <btphy_timer_add+0x3e>
    5a5a:	f104 0624 	add.w	r6, r4, #36	; 0x24
    5a5e:	e7f2      	b.n	5a46 <btphy_timer_add+0x3e>
    5a60:	f104 0634 	add.w	r6, r4, #52	; 0x34
    5a64:	e7ef      	b.n	5a46 <btphy_timer_add+0x3e>
    5a66:	f104 0644 	add.w	r6, r4, #68	; 0x44
    5a6a:	e7ec      	b.n	5a46 <btphy_timer_add+0x3e>
    5a6c:	f104 0654 	add.w	r6, r4, #84	; 0x54
    5a70:	e7e9      	b.n	5a46 <btphy_timer_add+0x3e>
    5a72:	f104 0664 	add.w	r6, r4, #100	; 0x64
    5a76:	e7e6      	b.n	5a46 <btphy_timer_add+0x3e>
    5a78:	f104 0674 	add.w	r6, r4, #116	; 0x74
    5a7c:	e7e3      	b.n	5a46 <btphy_timer_add+0x3e>
    5a7e:	4e05      	ldr	r6, [pc, #20]	; (5a94 <btphy_timer_add+0x8c>)
    5a80:	e7e1      	b.n	5a46 <btphy_timer_add+0x3e>
    5a82:	4e05      	ldr	r6, [pc, #20]	; (5a98 <btphy_timer_add+0x90>)
    5a84:	e7df      	b.n	5a46 <btphy_timer_add+0x3e>
		DIE("too many timers");
    5a86:	4805      	ldr	r0, [pc, #20]	; (5a9c <btphy_timer_add+0x94>)
    5a88:	f002 fac4 	bl	8014 <die>
    5a8c:	10002460 	.word	0x10002460
    5a90:	0000dc04 	.word	0x0000dc04
    5a94:	100024e4 	.word	0x100024e4
    5a98:	100024f4 	.word	0x100024f4
    5a9c:	0000dbec 	.word	0x0000dbec

00005aa0 <TIMER0_IRQHandler>:
	/* Advance scheduler */
	tdma_sched_advance();
}

void TIMER0_IRQHandler()
{
    5aa0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	/* Timer0: tdma frame */
	if (T0IR & TIR_MR0_Interrupt)
    5aa4:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    5aa8:	6813      	ldr	r3, [r2, #0]
    5aaa:	07db      	lsls	r3, r3, #31
    5aac:	d401      	bmi.n	5ab2 <TIMER0_IRQHandler+0x12>
		{
			console_putc('O');
			T0IR = TIR_MR0_Interrupt;
		}
	}
}
    5aae:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		T0IR = TIR_MR0_Interrupt;
    5ab2:	2101      	movs	r1, #1
	btphy.master_clkn++;
    5ab4:	4b31      	ldr	r3, [pc, #196]	; (5b7c <TIMER0_IRQHandler+0xdc>)
		T0IR = TIR_MR0_Interrupt;
    5ab6:	6011      	str	r1, [r2, #0]
	if (btphy.clkn_delayed)
    5ab8:	6918      	ldr	r0, [r3, #16]
	btphy.slave_clkn ++;
    5aba:	e9d3 1201 	ldrd	r1, r2, [r3, #4]
	btphy.master_clkn++;
    5abe:	3101      	adds	r1, #1
	btphy.slave_clkn ++;
    5ac0:	3201      	adds	r2, #1
    5ac2:	e9c3 1201 	strd	r1, r2, [r3, #4]
	if (btphy.clkn_delayed)
    5ac6:	b128      	cbz	r0, 5ad4 <TIMER0_IRQHandler+0x34>
		T0MR0 = (CLKN_OFFSET_RESET_VAL)-1;
    5ac8:	f640 4134 	movw	r1, #3124	; 0xc34
		btphy.clkn_delayed = 0;
    5acc:	2000      	movs	r0, #0
		T0MR0 = (CLKN_OFFSET_RESET_VAL)-1;
    5ace:	4a2c      	ldr	r2, [pc, #176]	; (5b80 <TIMER0_IRQHandler+0xe0>)
		btphy.clkn_delayed = 0;
    5ad0:	6118      	str	r0, [r3, #16]
		T0MR0 = (CLKN_OFFSET_RESET_VAL)-1;
    5ad2:	6011      	str	r1, [r2, #0]
	switch(btphy.mode)
    5ad4:	781a      	ldrb	r2, [r3, #0]
    5ad6:	2a03      	cmp	r2, #3
    5ad8:	d838      	bhi.n	5b4c <TIMER0_IRQHandler+0xac>
    5ada:	2a01      	cmp	r2, #1
    5adc:	d838      	bhi.n	5b50 <TIMER0_IRQHandler+0xb0>
		return btphy.master_clkn;
    5ade:	685e      	ldr	r6, [r3, #4]
		; j<btphy_timers.count && i<BTPHY_TIMER_COUNT
    5ae0:	f8df b0a0 	ldr.w	fp, [pc, #160]	; 5b84 <TIMER0_IRQHandler+0xe4>
    5ae4:	f8db 3000 	ldr.w	r3, [fp]
	for (i=0,j=0,t=btphy_timers.timers
    5ae8:	b3a3      	cbz	r3, 5b54 <TIMER0_IRQHandler+0xb4>
    5aea:	2500      	movs	r5, #0
    5aec:	465c      	mov	r4, fp
				t->cb = NULL;
    5aee:	46a8      	mov	r8, r5
					cprintf("(missed timer)");
    5af0:	f8df a094 	ldr.w	sl, [pc, #148]	; 5b88 <TIMER0_IRQHandler+0xe8>
					cprintf("(X)");
    5af4:	f8df 9094 	ldr.w	r9, [pc, #148]	; 5b8c <TIMER0_IRQHandler+0xec>
    5af8:	f10b 07a0 	add.w	r7, fp, #160	; 0xa0
    5afc:	e016      	b.n	5b2c <TIMER0_IRQHandler+0x8c>
			else if (t->instant < clkn)
    5afe:	d20f      	bcs.n	5b20 <TIMER0_IRQHandler+0x80>
				if (t->anyway)
    5b00:	7c23      	ldrb	r3, [r4, #16]
    5b02:	2b00      	cmp	r3, #0
    5b04:	d036      	beq.n	5b74 <TIMER0_IRQHandler+0xd4>
					cprintf("(X)");
    5b06:	4648      	mov	r0, r9
    5b08:	f003 fb84 	bl	9214 <cprintf>
					t->cb(t->cb_arg);
    5b0c:	e9d4 3002 	ldrd	r3, r0, [r4, #8]
    5b10:	4798      	blx	r3
				btphy_timers.count--;
    5b12:	f8db 3000 	ldr.w	r3, [fp]
				t->cb = NULL;
    5b16:	f8c4 8008 	str.w	r8, [r4, #8]
				btphy_timers.count--;
    5b1a:	3b01      	subs	r3, #1
    5b1c:	f8cb 3000 	str.w	r3, [fp]
			j++;
    5b20:	3501      	adds	r5, #1
	for (i=0,j=0,t=btphy_timers.timers
    5b22:	429d      	cmp	r5, r3
    5b24:	d216      	bcs.n	5b54 <TIMER0_IRQHandler+0xb4>
    5b26:	3410      	adds	r4, #16
		; j<btphy_timers.count && i<BTPHY_TIMER_COUNT
    5b28:	42bc      	cmp	r4, r7
    5b2a:	d013      	beq.n	5b54 <TIMER0_IRQHandler+0xb4>
		if (t->cb)
    5b2c:	68a1      	ldr	r1, [r4, #8]
    5b2e:	2900      	cmp	r1, #0
    5b30:	d0f7      	beq.n	5b22 <TIMER0_IRQHandler+0x82>
			if (t->instant == clkn)
    5b32:	6862      	ldr	r2, [r4, #4]
    5b34:	42b2      	cmp	r2, r6
    5b36:	d1e2      	bne.n	5afe <TIMER0_IRQHandler+0x5e>
				t->cb(t->cb_arg);
    5b38:	68e0      	ldr	r0, [r4, #12]
    5b3a:	4788      	blx	r1
				btphy_timers.count--;
    5b3c:	f8db 3000 	ldr.w	r3, [fp]
				t->cb = NULL;
    5b40:	f8c4 8008 	str.w	r8, [r4, #8]
				btphy_timers.count--;
    5b44:	3b01      	subs	r3, #1
    5b46:	f8cb 3000 	str.w	r3, [fp]
    5b4a:	e7e9      	b.n	5b20 <TIMER0_IRQHandler+0x80>
	switch(btphy.mode)
    5b4c:	2a05      	cmp	r2, #5
    5b4e:	d1c6      	bne.n	5ade <TIMER0_IRQHandler+0x3e>
		return btphy.slave_clkn;
    5b50:	689e      	ldr	r6, [r3, #8]
    5b52:	e7c5      	b.n	5ae0 <TIMER0_IRQHandler+0x40>
		if (T0IR)
    5b54:	f04f 2440 	mov.w	r4, #1073758208	; 0x40004000
	tdma_sched_execute();
    5b58:	f000 f9ee 	bl	5f38 <tdma_sched_execute>
	tdma_sched_advance();
    5b5c:	f000 f9e0 	bl	5f20 <tdma_sched_advance>
		if (T0IR)
    5b60:	6823      	ldr	r3, [r4, #0]
    5b62:	2b00      	cmp	r3, #0
    5b64:	d0a3      	beq.n	5aae <TIMER0_IRQHandler+0xe>
			console_putc('O');
    5b66:	204f      	movs	r0, #79	; 0x4f
    5b68:	f002 f9be 	bl	7ee8 <console_putc>
			T0IR = TIR_MR0_Interrupt;
    5b6c:	2301      	movs	r3, #1
    5b6e:	6023      	str	r3, [r4, #0]
}
    5b70:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					cprintf("(missed timer)");
    5b74:	4650      	mov	r0, sl
    5b76:	f003 fb4d 	bl	9214 <cprintf>
    5b7a:	e7ca      	b.n	5b12 <TIMER0_IRQHandler+0x72>
    5b7c:	100001b0 	.word	0x100001b0
    5b80:	40004018 	.word	0x40004018
    5b84:	10002460 	.word	0x10002460
    5b88:	0000dc20 	.word	0x0000dc20
    5b8c:	0000dc1c 	.word	0x0000dc1c

00005b90 <btphy_adj_clkn_delay>:

void btphy_adj_clkn_delay(int delay)
{
    5b90:	b430      	push	{r4, r5}
	T0MR0 = (CLKN_OFFSET_RESET_VAL+delay)-1;
	btphy.slave_clkn_delay += delay;
	btphy.clkn_delayed = 1;
    5b92:	2101      	movs	r1, #1
	btphy.slave_clkn_delay += delay;
    5b94:	4b05      	ldr	r3, [pc, #20]	; (5bac <btphy_adj_clkn_delay+0x1c>)
	T0MR0 = (CLKN_OFFSET_RESET_VAL+delay)-1;
    5b96:	4c06      	ldr	r4, [pc, #24]	; (5bb0 <btphy_adj_clkn_delay+0x20>)
	btphy.slave_clkn_delay += delay;
    5b98:	68da      	ldr	r2, [r3, #12]
	T0MR0 = (CLKN_OFFSET_RESET_VAL+delay)-1;
    5b9a:	f600 4534 	addw	r5, r0, #3124	; 0xc34
	btphy.slave_clkn_delay += delay;
    5b9e:	4410      	add	r0, r2
	T0MR0 = (CLKN_OFFSET_RESET_VAL+delay)-1;
    5ba0:	6025      	str	r5, [r4, #0]
	btphy.clkn_delayed = 1;
    5ba2:	e9c3 0103 	strd	r0, r1, [r3, #12]
}
    5ba6:	bc30      	pop	{r4, r5}
    5ba8:	4770      	bx	lr
    5baa:	bf00      	nop
    5bac:	100001b0 	.word	0x100001b0
    5bb0:	40004018 	.word	0x40004018

00005bb4 <btphy_cancel_clkn_delay>:

void btphy_cancel_clkn_delay(void)
{
    5bb4:	b430      	push	{r4, r5}
	btphy.clkn_delayed = 1;
    5bb6:	2301      	movs	r3, #1
	unsigned delay = btphy.slave_clkn_delay % CLKN_OFFSET_RESET_VAL;
    5bb8:	f640 4535 	movw	r5, #3125	; 0xc35
    5bbc:	490b      	ldr	r1, [pc, #44]	; (5bec <btphy_cancel_clkn_delay+0x38>)
    5bbe:	4c0c      	ldr	r4, [pc, #48]	; (5bf0 <btphy_cancel_clkn_delay+0x3c>)
    5bc0:	68ca      	ldr	r2, [r1, #12]
	btphy.clkn_delayed = 1;
    5bc2:	610b      	str	r3, [r1, #16]
	unsigned delay = btphy.slave_clkn_delay % CLKN_OFFSET_RESET_VAL;
    5bc4:	fb84 3402 	smull	r3, r4, r4, r2
    5bc8:	17d0      	asrs	r0, r2, #31
    5bca:	ebc0 2324 	rsb	r3, r0, r4, asr #8
    5bce:	fb05 2313 	mls	r3, r5, r3, r2
	unsigned clk_delay = btphy.slave_clkn_delay / CLKN_OFFSET_RESET_VAL;

	btphy.master_clkn += clk_delay;
    5bd2:	684d      	ldr	r5, [r1, #4]
	unsigned clk_delay = btphy.slave_clkn_delay / CLKN_OFFSET_RESET_VAL;
    5bd4:	ebc0 2024 	rsb	r0, r0, r4, asr #8
	T0MR0 = (CLKN_OFFSET_RESET_VAL+delay)-1;
    5bd8:	4c06      	ldr	r4, [pc, #24]	; (5bf4 <btphy_cancel_clkn_delay+0x40>)
	btphy.master_clkn += clk_delay;
    5bda:	4428      	add	r0, r5
	btphy.slave_clkn_delay += delay;
    5bdc:	441a      	add	r2, r3
	T0MR0 = (CLKN_OFFSET_RESET_VAL+delay)-1;
    5bde:	f603 4334 	addw	r3, r3, #3124	; 0xc34
	btphy.master_clkn += clk_delay;
    5be2:	6048      	str	r0, [r1, #4]
	btphy.slave_clkn_delay += delay;
    5be4:	60ca      	str	r2, [r1, #12]
	T0MR0 = (CLKN_OFFSET_RESET_VAL+delay)-1;
    5be6:	6023      	str	r3, [r4, #0]
	btphy_adj_clkn_delay(delay);
}
    5be8:	bc30      	pop	{r4, r5}
    5bea:	4770      	bx	lr
    5bec:	100001b0 	.word	0x100001b0
    5bf0:	14f8b589 	.word	0x14f8b589
    5bf4:	40004018 	.word	0x40004018

00005bf8 <btphy_whiten_seed>:
	T0TCR = 1;
}

/* TODO: move this ?*/
uint8_t btphy_whiten_seed(uint32_t clk)
{
    5bf8:	b508      	push	{r3, lr}
	/* Initialize whiten seed */
	switch(btphy.mode)
    5bfa:	4b0a      	ldr	r3, [pc, #40]	; (5c24 <btphy_whiten_seed+0x2c>)
    5bfc:	7819      	ldrb	r1, [r3, #0]
    5bfe:	2903      	cmp	r1, #3
    5c00:	d804      	bhi.n	5c0c <btphy_whiten_seed+0x14>
	case BT_MODE_INQUIRY_SCAN:
	case BT_MODE_PAGE_SCAN:
	/* BT 5.1|Vol 2, Part B, 7.2 :
	 * Instead of the master clock, the X-input used in the inquiry or page response (depending on current state)
	 * routine shall be used The 5-bit value shall be extended with two MSBs of value 1 */
		return hop_state.x|0x60;
    5c02:	4b09      	ldr	r3, [pc, #36]	; (5c28 <btphy_whiten_seed+0x30>)
    5c04:	7998      	ldrb	r0, [r3, #6]
    5c06:	f040 0060 	orr.w	r0, r0, #96	; 0x60
	case BT_MODE_SLAVE:
		return (clk>>1)|0x40;
	default:
		DIE("Invalid rx mode %d\n", btphy.mode);
	}
}
    5c0a:	bd08      	pop	{r3, pc}
	switch(btphy.mode)
    5c0c:	1f0b      	subs	r3, r1, #4
    5c0e:	2b01      	cmp	r3, #1
    5c10:	d804      	bhi.n	5c1c <btphy_whiten_seed+0x24>
		return (clk>>1)|0x40;
    5c12:	f3c0 0047 	ubfx	r0, r0, #1, #8
    5c16:	f040 0040 	orr.w	r0, r0, #64	; 0x40
}
    5c1a:	bd08      	pop	{r3, pc}
		DIE("Invalid rx mode %d\n", btphy.mode);
    5c1c:	4803      	ldr	r0, [pc, #12]	; (5c2c <btphy_whiten_seed+0x34>)
    5c1e:	f002 f9f9 	bl	8014 <die>
    5c22:	bf00      	nop
    5c24:	100001b0 	.word	0x100001b0
    5c28:	10002520 	.word	0x10002520
    5c2c:	0000dc30 	.word	0x0000dc30

00005c30 <btphy_set_mode>:


void btphy_set_mode(btphy_mode_t mode, uint32_t lap, uint8_t uap)
{
    5c30:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    5c34:	4681      	mov	r9, r0
	uint64_t sw = btbb_gen_syncword(lap);
    5c36:	4608      	mov	r0, r1
{
    5c38:	4690      	mov	r8, r2
    5c3a:	460f      	mov	r7, r1
	uint64_t sw = btbb_gen_syncword(lap);
    5c3c:	f7fe fb70 	bl	4320 <btbb_gen_syncword>
    5c40:	4604      	mov	r4, r0
	btphy.chan_sw_hi[0] = 0xff&(sw>>32);
	btphy.chan_sw_hi[1] = 0xff&(sw>>40);
	btphy.chan_sw_hi[2] = 0xff&(sw>>48);
	btphy.chan_sw_hi[3] = 0xff&(sw>>56);

	btphy.chan_trailer = (btphy.chan_sw >> 63) ? 0x0a : 0x05;
    5c42:	2800      	cmp	r0, #0
	uint64_t sw = btbb_gen_syncword(lap);
    5c44:	460d      	mov	r5, r1
	btphy.chan_trailer = (btphy.chan_sw >> 63) ? 0x0a : 0x05;
    5c46:	f171 0300 	sbcs.w	r3, r1, #0
    5c4a:	bfb4      	ite	lt
    5c4c:	f04f 0c0a 	movlt.w	ip, #10
    5c50:	f04f 0c05 	movge.w	ip, #5
        return rev8_map[data];
    5c54:	4b1c      	ldr	r3, [pc, #112]	; (5cc8 <btphy_set_mode+0x98>)
	btphy.chan_sw_lo[2] = 0xff&(sw>>16);
    5c56:	0c02      	lsrs	r2, r0, #16
    5c58:	b2d6      	uxtb	r6, r2
    5c5a:	b2e1      	uxtb	r1, r4
        return (uint16_t)reverse8(data>>8) | (uint16_t)(reverse8(data&0xff)<<8);
    5c5c:	f813 e006 	ldrb.w	lr, [r3, r6]
        return rev8_map[data];
    5c60:	0a10      	lsrs	r0, r2, #8
        return (uint16_t)reverse8(data>>8) | (uint16_t)(reverse8(data&0xff)<<8);
    5c62:	5c5e      	ldrb	r6, [r3, r1]
        return rev8_map[data];
    5c64:	f3c4 2107 	ubfx	r1, r4, #8, #8
        return (uint16_t)reverse8(data>>8) | (uint16_t)(reverse8(data&0xff)<<8);
    5c68:	5c18      	ldrb	r0, [r3, r0]
    5c6a:	5c59      	ldrb	r1, [r3, r1]
        return (uint32_t)reverse16(data>>16)|((uint32_t)reverse16(data&0xffff)<<16);
    5c6c:	ea40 2e0e 	orr.w	lr, r0, lr, lsl #8
    5c70:	ea41 2006 	orr.w	r0, r1, r6, lsl #8
	btphy.chan_lap = lap;
    5c74:	4e15      	ldr	r6, [pc, #84]	; (5ccc <btphy_set_mode+0x9c>)
	btphy.chan_sw_lo[1] = 0xff&(sw>>8);
    5c76:	0a23      	lsrs	r3, r4, #8
	btphy_rf_cfg_sync(reverse32(btphy.chan_sw & 0xffffffff));
    5c78:	ea4e 4000 	orr.w	r0, lr, r0, lsl #16
	btphy.chan_sw_hi[1] = 0xff&(sw>>40);
    5c7c:	0a29      	lsrs	r1, r5, #8
	btphy.chan_sw_lo[3] = 0xff&(sw>>24);
    5c7e:	ea4f 6e14 	mov.w	lr, r4, lsr #24
	btphy.chan_sw_lo[2] = 0xff&(sw>>16);
    5c82:	f886 202b 	strb.w	r2, [r6, #43]	; 0x2b
	btphy.chan_sw_lo[1] = 0xff&(sw>>8);
    5c86:	f886 302a 	strb.w	r3, [r6, #42]	; 0x2a
	btphy.chan_sw_hi[2] = 0xff&(sw>>48);
    5c8a:	0c2a      	lsrs	r2, r5, #16
	btphy.chan_sw_hi[3] = 0xff&(sw>>56);
    5c8c:	0e2b      	lsrs	r3, r5, #24
	btphy.chan_sw_lo[3] = 0xff&(sw>>24);
    5c8e:	f886 e02c 	strb.w	lr, [r6, #44]	; 0x2c
	btphy.chan_sw_hi[1] = 0xff&(sw>>40);
    5c92:	f886 102e 	strb.w	r1, [r6, #46]	; 0x2e
	btphy.chan_sw_hi[2] = 0xff&(sw>>48);
    5c96:	f886 202f 	strb.w	r2, [r6, #47]	; 0x2f
	btphy.chan_sw_hi[3] = 0xff&(sw>>56);
    5c9a:	f886 3030 	strb.w	r3, [r6, #48]	; 0x30
	btphy.chan_trailer = (btphy.chan_sw >> 63) ? 0x0a : 0x05;
    5c9e:	f886 c028 	strb.w	ip, [r6, #40]	; 0x28
	btphy.chan_sw = sw;
    5ca2:	e9c6 4508 	strd	r4, r5, [r6, #32]
	btphy.chan_lap = lap;
    5ca6:	6177      	str	r7, [r6, #20]
	btphy.chan_uap = uap;
    5ca8:	f886 8018 	strb.w	r8, [r6, #24]
	btphy.chan_sw_lo[0] = 0xff&(sw>>0);
    5cac:	f886 4029 	strb.w	r4, [r6, #41]	; 0x29
	btphy.chan_sw_hi[0] = 0xff&(sw>>32);
    5cb0:	f886 502d 	strb.w	r5, [r6, #45]	; 0x2d
	btphy_rf_cfg_sync(reverse32(btphy.chan_sw & 0xffffffff));
    5cb4:	f001 ff70 	bl	7b98 <btphy_rf_cfg_sync>
	/* BT Core Spec v5.2|Vol 2, Part B, table 2.3:
	 * A23_0=lap, and A27_24=uap3_0 */
	hop_init(lap|(uap<<24));
    5cb8:	ea47 6008 	orr.w	r0, r7, r8, lsl #24
    5cbc:	f001 fc08 	bl	74d0 <hop_init>
	btphy.mode = mode;
    5cc0:	f886 9000 	strb.w	r9, [r6]
}
    5cc4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    5cc8:	0000d954 	.word	0x0000d954
    5ccc:	100001b0 	.word	0x100001b0

00005cd0 <btphy_set_bdaddr>:

void btphy_set_bdaddr(uint64_t bdaddr)
{
    5cd0:	b5f0      	push	{r4, r5, r6, r7, lr}
    5cd2:	b083      	sub	sp, #12
    5cd4:	4605      	mov	r5, r0
	btphy.my_lap = 0xffffff & bdaddr;
    5cd6:	4c0b      	ldr	r4, [pc, #44]	; (5d04 <btphy_set_bdaddr+0x34>)
	btphy.my_uap = 0xff & (bdaddr>>24);
    5cd8:	0e2b      	lsrs	r3, r5, #24
	btphy.my_lap = 0xffffff & bdaddr;
    5cda:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
{
    5cde:	460f      	mov	r7, r1
	btphy.my_uap = 0xff & (bdaddr>>24);
    5ce0:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
	btphy.my_lap = 0xffffff & bdaddr;
    5ce4:	6360      	str	r0, [r4, #52]	; 0x34
	btphy.my_nap = 0xffff & (bdaddr>>32);
    5ce6:	8761      	strh	r1, [r4, #58]	; 0x3a
	btphy.my_sw = btbb_gen_syncword(btphy.my_lap);
    5ce8:	f7fe fb1a 	bl	4320 <btbb_gen_syncword>
    5cec:	4606      	mov	r6, r0
	cprintf("Set bdaddr %llx -> sw %llx\n", bdaddr, btphy.my_sw);
    5cee:	e9cd 0100 	strd	r0, r1, [sp]
    5cf2:	462a      	mov	r2, r5
    5cf4:	463b      	mov	r3, r7
    5cf6:	4804      	ldr	r0, [pc, #16]	; (5d08 <btphy_set_bdaddr+0x38>)
	btphy.my_sw = btbb_gen_syncword(btphy.my_lap);
    5cf8:	e9c4 6110 	strd	r6, r1, [r4, #64]	; 0x40
	cprintf("Set bdaddr %llx -> sw %llx\n", bdaddr, btphy.my_sw);
    5cfc:	f003 fa8a 	bl	9214 <cprintf>
}
    5d00:	b003      	add	sp, #12
    5d02:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5d04:	100001b0 	.word	0x100001b0
    5d08:	0000dc4c 	.word	0x0000dc4c
    5d0c:	00000000 	.word	0x00000000

00005d10 <btphy_init>:

void btphy_init(void)
{
    5d10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5d14:	b082      	sub	sp, #8
	tdma_sched_reset();
    5d16:	f000 f97f 	bl	6018 <tdma_sched_reset>
	ICER0 = ICER0_ICE_TIMER1;
    5d1a:	2504      	movs	r5, #4
	ICER0 = ICER0_ICE_TIMER0;
    5d1c:	2302      	movs	r3, #2
	T0TCR = 0;
    5d1e:	2400      	movs	r4, #0
	T0MCR = TMCR_MR0R | TMCR_MR0I;
    5d20:	f04f 0e03 	mov.w	lr, #3
	T0MR0 = CLKN_OFFSET_RESET_VAL-1;
    5d24:	f640 4834 	movw	r8, #3124	; 0xc34
	T1PR = (PERIPH_CLK_RATE/CLKN_RATE)-1;
    5d28:	f643 5c08 	movw	ip, #15624	; 0x3d08
	T1MR0 = 0xffffffff-1;
    5d2c:	f06f 0701 	mvn.w	r7, #1
	T1TCR = 1;
    5d30:	2101      	movs	r1, #1
	ICER0 = ICER0_ICE_TIMER0;
    5d32:	4e29      	ldr	r6, [pc, #164]	; (5dd8 <btphy_init+0xc8>)
	T0TCR = 0;
    5d34:	4a29      	ldr	r2, [pc, #164]	; (5ddc <btphy_init+0xcc>)
	ICER0 = ICER0_ICE_TIMER0;
    5d36:	6033      	str	r3, [r6, #0]
	T1TCR = 0;
    5d38:	4829      	ldr	r0, [pc, #164]	; (5de0 <btphy_init+0xd0>)
	ICER0 = ICER0_ICE_TIMER1;
    5d3a:	6035      	str	r5, [r6, #0]
	T0PR = CLKN_OFFSET_PRESCALE_VAL-1;
    5d3c:	4e29      	ldr	r6, [pc, #164]	; (5de4 <btphy_init+0xd4>)
	T0TCR = 0;
    5d3e:	6014      	str	r4, [r2, #0]
	T1TCR = 0;
    5d40:	6004      	str	r4, [r0, #0]
	T0PR = CLKN_OFFSET_PRESCALE_VAL-1;
    5d42:	6035      	str	r5, [r6, #0]
	T0MR0 = CLKN_OFFSET_RESET_VAL-1;
    5d44:	4d28      	ldr	r5, [pc, #160]	; (5de8 <btphy_init+0xd8>)
	T1MR0 = 0xffffffff-1;
    5d46:	f506 4680 	add.w	r6, r6, #16384	; 0x4000
	T0MR0 = CLKN_OFFSET_RESET_VAL-1;
    5d4a:	f8c5 8000 	str.w	r8, [r5]
	T0MCR = TMCR_MR0R | TMCR_MR0I;
    5d4e:	f845 ec04 	str.w	lr, [r5, #-4]
	T1PR = (PERIPH_CLK_RATE/CLKN_RATE)-1;
    5d52:	f505 557f 	add.w	r5, r5, #16320	; 0x3fc0
	T1MR0 = 0xffffffff-1;
    5d56:	360c      	adds	r6, #12
	T1PR = (PERIPH_CLK_RATE/CLKN_RATE)-1;
    5d58:	f8c5 c034 	str.w	ip, [r5, #52]	; 0x34
	T1MR0 = 0xffffffff-1;
    5d5c:	6037      	str	r7, [r6, #0]
	ISER0 = ISER0_ISE_TIMER0;
    5d5e:	4e23      	ldr	r6, [pc, #140]	; (5dec <btphy_init+0xdc>)
	T1MCR = TMCR_MR0R;
    5d60:	63eb      	str	r3, [r5, #60]	; 0x3c
	T1PR = (PERIPH_CLK_RATE/CLKN_RATE)-1;
    5d62:	3534      	adds	r5, #52	; 0x34
	btphy.master_clkn = 0;
    5d64:	4d22      	ldr	r5, [pc, #136]	; (5df0 <btphy_init+0xe0>)
	ISER0 = ISER0_ISE_TIMER0;
    5d66:	6033      	str	r3, [r6, #0]
	T1TCR = 1;
    5d68:	6001      	str	r1, [r0, #0]
	T0TCR = 1;
    5d6a:	6011      	str	r1, [r2, #0]
	btphy_rf_init();

	tx_task_reset();
	rx_task_reset();

	btphy.chan_sw = 0;
    5d6c:	2600      	movs	r6, #0
	btphy.master_clkn = 0;
    5d6e:	606c      	str	r4, [r5, #4]
	btphy.chan_sw = 0;
    5d70:	2700      	movs	r7, #0
	btphy_rf_init();
    5d72:	f001 ff1d 	bl	7bb0 <btphy_rf_init>
	tx_task_reset();
    5d76:	f001 f8b5 	bl	6ee4 <tx_task_reset>
	rx_task_reset();
    5d7a:	f000 fc15 	bl	65a8 <rx_task_reset>
	btphy.my_nap = 0xffff & (bdaddr>>32);
    5d7e:	f241 1222 	movw	r2, #4386	; 0x1122
	btphy.my_uap = 0xff & (bdaddr>>24);
    5d82:	2133      	movs	r1, #51	; 0x33
	btphy_timers.count = 0;
    5d84:	4b1b      	ldr	r3, [pc, #108]	; (5df4 <btphy_init+0xe4>)
	btphy.my_lap = 0xffffff & bdaddr;
    5d86:	481c      	ldr	r0, [pc, #112]	; (5df8 <btphy_init+0xe8>)
		btphy_timers.timers[i].cb = NULL;
    5d88:	609c      	str	r4, [r3, #8]
    5d8a:	619c      	str	r4, [r3, #24]
    5d8c:	629c      	str	r4, [r3, #40]	; 0x28
    5d8e:	639c      	str	r4, [r3, #56]	; 0x38
    5d90:	649c      	str	r4, [r3, #72]	; 0x48
    5d92:	659c      	str	r4, [r3, #88]	; 0x58
    5d94:	669c      	str	r4, [r3, #104]	; 0x68
    5d96:	679c      	str	r4, [r3, #120]	; 0x78
    5d98:	f8c3 4088 	str.w	r4, [r3, #136]	; 0x88
    5d9c:	f8c3 4098 	str.w	r4, [r3, #152]	; 0x98
	btphy.my_nap = 0xffff & (bdaddr>>32);
    5da0:	876a      	strh	r2, [r5, #58]	; 0x3a
	btphy_timers.count = 0;
    5da2:	601c      	str	r4, [r3, #0]
	btphy.chan_sw = 0;
    5da4:	e9c5 6708 	strd	r6, r7, [r5, #32]
	btphy.my_uap = 0xff & (bdaddr>>24);
    5da8:	f885 1038 	strb.w	r1, [r5, #56]	; 0x38
	btphy.my_lap = 0xffffff & bdaddr;
    5dac:	6368      	str	r0, [r5, #52]	; 0x34
	btphy.my_sw = btbb_gen_syncword(btphy.my_lap);
    5dae:	f7fe fab7 	bl	4320 <btbb_gen_syncword>
	cprintf("Set bdaddr %llx -> sw %llx\n", bdaddr, btphy.my_sw);
    5db2:	a307      	add	r3, pc, #28	; (adr r3, 5dd0 <btphy_init+0xc0>)
    5db4:	e9d3 2300 	ldrd	r2, r3, [r3]
	btphy.my_sw = btbb_gen_syncword(btphy.my_lap);
    5db8:	4604      	mov	r4, r0
	cprintf("Set bdaddr %llx -> sw %llx\n", bdaddr, btphy.my_sw);
    5dba:	e9cd 0100 	strd	r0, r1, [sp]
	btphy.my_sw = btbb_gen_syncword(btphy.my_lap);
    5dbe:	e9c5 4110 	strd	r4, r1, [r5, #64]	; 0x40
	cprintf("Set bdaddr %llx -> sw %llx\n", bdaddr, btphy.my_sw);
    5dc2:	480e      	ldr	r0, [pc, #56]	; (5dfc <btphy_init+0xec>)
    5dc4:	f003 fa26 	bl	9214 <cprintf>
	btphy_timers_reset();

	btphy_set_bdaddr(DEFAULT_BDADDR);
}
    5dc8:	b002      	add	sp, #8
    5dca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5dce:	bf00      	nop
    5dd0:	33445566 	.word	0x33445566
    5dd4:	00001122 	.word	0x00001122
    5dd8:	e000e180 	.word	0xe000e180
    5ddc:	40004004 	.word	0x40004004
    5de0:	40008004 	.word	0x40008004
    5de4:	4000400c 	.word	0x4000400c
    5de8:	40004018 	.word	0x40004018
    5dec:	e000e100 	.word	0xe000e100
    5df0:	100001b0 	.word	0x100001b0
    5df4:	10002460 	.word	0x10002460
    5df8:	00445566 	.word	0x00445566
    5dfc:	0000dc4c 	.word	0x0000dc4c

00005e00 <tdma_end_set>:
/* dummy function to mark end of set */
int tdma_end_set(__unused uint8_t p1, __unused uint8_t p2,
		 __unused uint16_t p3)
{
	return 0;
}
    5e00:	2000      	movs	r0, #0
    5e02:	4770      	bx	lr

00005e04 <tdma_schedule>:
}

/* Schedule an item at 'frame_offset' TDMA frames in the future */
int tdma_schedule(uint8_t frame_offset, tdma_sched_cb *cb,
                  uint8_t p1, uint8_t p2, uint16_t p3, int16_t prio)
{
    5e04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct tdma_scheduler *sched = &tdma_sched;
	uint8_t bucket_nr = wrap_bucket(frame_offset);
	struct tdma_sched_bucket *bucket = &sched->bucket[bucket_nr];
	struct tdma_sched_item *sched_item;

	if (bucket->num_items >= ARRAY_SIZE(bucket->item)) {
    5e08:	2434      	movs	r4, #52	; 0x34
	bucket = (tdma_sched.cur_bucket + offset)
    5e0a:	4e15      	ldr	r6, [pc, #84]	; (5e60 <tdma_schedule+0x5c>)
{
    5e0c:	f8bd 8018 	ldrh.w	r8, [sp, #24]
					% ARRAY_SIZE(tdma_sched.bucket);
    5e10:	f896 5340 	ldrb.w	r5, [r6, #832]	; 0x340
{
    5e14:	f9bd e01c 	ldrsh.w	lr, [sp, #28]
					% ARRAY_SIZE(tdma_sched.bucket);
    5e18:	4428      	add	r0, r5
	struct tdma_sched_bucket *bucket = &sched->bucket[bucket_nr];
    5e1a:	f000 000f 	and.w	r0, r0, #15
	if (bucket->num_items >= ARRAY_SIZE(bucket->item)) {
    5e1e:	fb04 f400 	mul.w	r4, r4, r0
    5e22:	eb06 0c04 	add.w	ip, r6, r4
    5e26:	f89c 5030 	ldrb.w	r5, [ip, #48]	; 0x30
    5e2a:	2d03      	cmp	r5, #3
    5e2c:	d811      	bhi.n	5e52 <tdma_schedule+0x4e>
	sched_item->p1 = p1;
	sched_item->p2 = p2;
	sched_item->p3 = p3;
	sched_item->prio = prio;

	return 0;
    5e2e:	2000      	movs	r0, #0
	sched_item->cb = cb;
    5e30:	eb05 0745 	add.w	r7, r5, r5, lsl #1
    5e34:	eb04 0487 	add.w	r4, r4, r7, lsl #2
    5e38:	1937      	adds	r7, r6, r4
	sched_item = &bucket->item[bucket->num_items++];
    5e3a:	3501      	adds	r5, #1
	sched_item->cb = cb;
    5e3c:	5131      	str	r1, [r6, r4]
	sched_item->p1 = p1;
    5e3e:	713a      	strb	r2, [r7, #4]
	sched_item->p2 = p2;
    5e40:	717b      	strb	r3, [r7, #5]
	sched_item->p3 = p3;
    5e42:	f8a7 8006 	strh.w	r8, [r7, #6]
	sched_item->prio = prio;
    5e46:	f8a7 e008 	strh.w	lr, [r7, #8]
	sched_item = &bucket->item[bucket->num_items++];
    5e4a:	f88c 5030 	strb.w	r5, [ip, #48]	; 0x30
}
    5e4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		cprintf("tdma_schedule bucket overflow\n");
    5e52:	4804      	ldr	r0, [pc, #16]	; (5e64 <tdma_schedule+0x60>)
    5e54:	f003 f9de 	bl	9214 <cprintf>
		return -1;
    5e58:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    5e5c:	e7f7      	b.n	5e4e <tdma_schedule+0x4a>
    5e5e:	bf00      	nop
    5e60:	100001f8 	.word	0x100001f8
    5e64:	0000dc68 	.word	0x0000dc68

00005e68 <tdma_schedule_set>:

/* Schedule a set of items starting from 'frame_offset' TDMA frames in the future */
int tdma_schedule_set(uint8_t frame_offset, const struct tdma_sched_item *item_set, uint16_t p3)
{
    5e68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5e6c:	b083      	sub	sp, #12
    5e6e:	4607      	mov	r7, r0
	bucket = (tdma_sched.cur_bucket + offset)
    5e70:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 5f18 <tdma_schedule_set+0xb0>

	for (i = 0, j = 0; 1; i++) {
		const struct tdma_sched_item *sched_item = &item_set[i];
		struct tdma_sched_bucket *bucket = &sched->bucket[bucket_nr];

		if (sched_item->cb == &tdma_end_set) {
    5e74:	6808      	ldr	r0, [r1, #0]
					% ARRAY_SIZE(tdma_sched.bucket);
    5e76:	f899 6340 	ldrb.w	r6, [r9, #832]	; 0x340
		if (sched_item->cb == &tdma_end_set) {
    5e7a:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 5f1c <tdma_schedule_set+0xb4>
					% ARRAY_SIZE(tdma_sched.bucket);
    5e7e:	443e      	add	r6, r7
		if (sched_item->cb == &tdma_end_set) {
    5e80:	4540      	cmp	r0, r8
    5e82:	f006 060f 	and.w	r6, r6, #15
    5e86:	d042      	beq.n	5f0e <tdma_schedule_set+0xa6>
	for (i = 0, j = 0; 1; i++) {
    5e88:	2300      	movs	r3, #0
    5e8a:	468b      	mov	fp, r1
			bucket_nr = wrap_bucket(++frame_offset);
			j++;
			continue;
		}
		/* check for bucket overflow */
		if (bucket->num_items >= ARRAY_SIZE(bucket->item)) {
    5e8c:	f04f 0a34 	mov.w	sl, #52	; 0x34
    5e90:	4615      	mov	r5, r2
	for (i = 0, j = 0; 1; i++) {
    5e92:	9300      	str	r3, [sp, #0]
		if (bucket->num_items >= ARRAY_SIZE(bucket->item)) {
    5e94:	9701      	str	r7, [sp, #4]
		if (sched_item->cb == NULL) {
    5e96:	b318      	cbz	r0, 5ee0 <tdma_schedule_set+0x78>
		if (bucket->num_items >= ARRAY_SIZE(bucket->item)) {
    5e98:	fb0a f406 	mul.w	r4, sl, r6
    5e9c:	eb09 0704 	add.w	r7, r9, r4
    5ea0:	f897 0030 	ldrb.w	r0, [r7, #48]	; 0x30
    5ea4:	2803      	cmp	r0, #3
    5ea6:	d828      	bhi.n	5efa <tdma_schedule_set+0x92>
			cprintf("tdma_schedule bucket overflow\n");
			return -1;
		}
		/* copy the item from the set into the current bucket item position */
		memcpy(&bucket->item[bucket->num_items], sched_item, sizeof(*sched_item));
    5ea8:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    5eac:	eb04 0080 	add.w	r0, r4, r0, lsl #2
    5eb0:	220c      	movs	r2, #12
    5eb2:	4659      	mov	r1, fp
    5eb4:	4448      	add	r0, r9
    5eb6:	f004 fc05 	bl	a6c4 <memcpy>
		bucket->item[bucket->num_items].p3 = p3;
    5eba:	f897 2030 	ldrb.w	r2, [r7, #48]	; 0x30
    5ebe:	eb02 0042 	add.w	r0, r2, r2, lsl #1
    5ec2:	eb04 0480 	add.w	r4, r4, r0, lsl #2
    5ec6:	444c      	add	r4, r9
		bucket->num_items++;
    5ec8:	3201      	adds	r2, #1
		bucket->item[bucket->num_items].p3 = p3;
    5eca:	80e5      	strh	r5, [r4, #6]
		bucket->num_items++;
    5ecc:	f887 2030 	strb.w	r2, [r7, #48]	; 0x30
		if (sched_item->cb == &tdma_end_set) {
    5ed0:	f85b 0f0c 	ldr.w	r0, [fp, #12]!
    5ed4:	4540      	cmp	r0, r8
    5ed6:	d1de      	bne.n	5e96 <tdma_schedule_set+0x2e>
	}

	return j;
}
    5ed8:	9800      	ldr	r0, [sp, #0]
    5eda:	b003      	add	sp, #12
    5edc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			bucket_nr = wrap_bucket(++frame_offset);
    5ee0:	9f01      	ldr	r7, [sp, #4]
					% ARRAY_SIZE(tdma_sched.bucket);
    5ee2:	f899 6340 	ldrb.w	r6, [r9, #832]	; 0x340
			bucket_nr = wrap_bucket(++frame_offset);
    5ee6:	3701      	adds	r7, #1
    5ee8:	b2fb      	uxtb	r3, r7
					% ARRAY_SIZE(tdma_sched.bucket);
    5eea:	441e      	add	r6, r3
			bucket_nr = wrap_bucket(++frame_offset);
    5eec:	9301      	str	r3, [sp, #4]
			j++;
    5eee:	9b00      	ldr	r3, [sp, #0]
    5ef0:	f006 060f 	and.w	r6, r6, #15
    5ef4:	3301      	adds	r3, #1
    5ef6:	9300      	str	r3, [sp, #0]
			continue;
    5ef8:	e7ea      	b.n	5ed0 <tdma_schedule_set+0x68>
			cprintf("tdma_schedule bucket overflow\n");
    5efa:	4806      	ldr	r0, [pc, #24]	; (5f14 <tdma_schedule_set+0xac>)
    5efc:	f003 f98a 	bl	9214 <cprintf>
			return -1;
    5f00:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    5f04:	9300      	str	r3, [sp, #0]
}
    5f06:	9800      	ldr	r0, [sp, #0]
    5f08:	b003      	add	sp, #12
    5f0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (i = 0, j = 0; 1; i++) {
    5f0e:	2300      	movs	r3, #0
    5f10:	9300      	str	r3, [sp, #0]
    5f12:	e7e1      	b.n	5ed8 <tdma_schedule_set+0x70>
    5f14:	0000dc68 	.word	0x0000dc68
    5f18:	100001f8 	.word	0x100001f8
    5f1c:	00005e01 	.word	0x00005e01

00005f20 <tdma_sched_advance>:
	struct tdma_scheduler *sched = &tdma_sched;
	uint8_t next_bucket;

	/* advance to the next bucket */
	next_bucket = wrap_bucket(1);
	sched->cur_bucket = next_bucket;
    5f20:	4a04      	ldr	r2, [pc, #16]	; (5f34 <tdma_sched_advance+0x14>)
					% ARRAY_SIZE(tdma_sched.bucket);
    5f22:	f892 3340 	ldrb.w	r3, [r2, #832]	; 0x340
    5f26:	3301      	adds	r3, #1
	sched->cur_bucket = next_bucket;
    5f28:	f003 030f 	and.w	r3, r3, #15
    5f2c:	f882 3340 	strb.w	r3, [r2, #832]	; 0x340
}
    5f30:	4770      	bx	lr
    5f32:	bf00      	nop
    5f34:	100001f8 	.word	0x100001f8

00005f38 <tdma_sched_execute>:
	}
}

/* Execute pre-scheduled events for current frame */
int tdma_sched_execute(void)
{
    5f38:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5f3c:	b087      	sub	sp, #28
		seq[i] = i;
    5f3e:	2000      	movs	r0, #0
    5f40:	2101      	movs	r1, #1
	for (i=0; i<bucket->num_items; i++)
    5f42:	2734      	movs	r7, #52	; 0x34
		seq[i] = i;
    5f44:	2303      	movs	r3, #3
    5f46:	2202      	movs	r2, #2
	struct tdma_sched_bucket *bucket;
	int i, num_events = 0;
	int seq[TDMASCHED_NUM_CB];

	/* determine current bucket */
	bucket = &sched->bucket[sched->cur_bucket];
    5f48:	4d32      	ldr	r5, [pc, #200]	; (6014 <tdma_sched_execute+0xdc>)
		seq[i] = i;
    5f4a:	e9cd 0102 	strd	r0, r1, [sp, #8]
	bucket = &sched->bucket[sched->cur_bucket];
    5f4e:	f895 1340 	ldrb.w	r1, [r5, #832]	; 0x340
		seq[i] = i;
    5f52:	e9cd 2304 	strd	r2, r3, [sp, #16]
	for (i=0; i<bucket->num_items; i++)
    5f56:	fb07 f701 	mul.w	r7, r7, r1
    5f5a:	19eb      	adds	r3, r5, r7
    5f5c:	f893 0030 	ldrb.w	r0, [r3, #48]	; 0x30
	bucket = &sched->bucket[sched->cur_bucket];
    5f60:	9101      	str	r1, [sp, #4]
	for (i=0; i<bucket->num_items; i++)
    5f62:	4606      	mov	r6, r0
    5f64:	2800      	cmp	r0, #0
    5f66:	d049      	beq.n	5ffc <tdma_sched_execute+0xc4>
    5f68:	2600      	movs	r6, #0
			if (item_i->prio > item_j->prio)
    5f6a:	46be      	mov	lr, r7
    5f6c:	a902      	add	r1, sp, #8
    5f6e:	eb01 0c80 	add.w	ip, r1, r0, lsl #2
		item_i = &bucket->item[seq[i]];
    5f72:	f851 3b04 	ldr.w	r3, [r1], #4
		for (j=i+1; j<bucket->num_items; j++)
    5f76:	3601      	adds	r6, #1
		item_i = &bucket->item[seq[i]];
    5f78:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    5f7c:	eb07 0383 	add.w	r3, r7, r3, lsl #2
		for (j=i+1; j<bucket->num_items; j++)
    5f80:	4286      	cmp	r6, r0
    5f82:	bfb8      	it	lt
    5f84:	4688      	movlt	r8, r1
		item_i = &bucket->item[seq[i]];
    5f86:	442b      	add	r3, r5
		for (j=i+1; j<bucket->num_items; j++)
    5f88:	da18      	bge.n	5fbc <tdma_sched_execute+0x84>
			item_j = &bucket->item[seq[j]];
    5f8a:	f858 9b04 	ldr.w	r9, [r8], #4
			if (item_i->prio > item_j->prio)
    5f8e:	f9b3 b008 	ldrsh.w	fp, [r3, #8]
    5f92:	eb09 0249 	add.w	r2, r9, r9, lsl #1
    5f96:	eb0e 0a82 	add.w	sl, lr, r2, lsl #2
    5f9a:	44aa      	add	sl, r5
    5f9c:	f9ba a008 	ldrsh.w	sl, [sl, #8]
    5fa0:	0092      	lsls	r2, r2, #2
    5fa2:	45d3      	cmp	fp, sl
    5fa4:	dd07      	ble.n	5fb6 <tdma_sched_execute+0x7e>
				k      = seq[i];
    5fa6:	f851 4c04 	ldr.w	r4, [r1, #-4]
			item_j = &bucket->item[seq[j]];
    5faa:	19d3      	adds	r3, r2, r7
				seq[i] = seq[j];
    5fac:	f841 9c04 	str.w	r9, [r1, #-4]
			item_j = &bucket->item[seq[j]];
    5fb0:	442b      	add	r3, r5
				seq[j] = k;
    5fb2:	f848 4c04 	str.w	r4, [r8, #-4]
		for (j=i+1; j<bucket->num_items; j++)
    5fb6:	45e0      	cmp	r8, ip
    5fb8:	d1e7      	bne.n	5f8a <tdma_sched_execute+0x52>
    5fba:	e7da      	b.n	5f72 <tdma_sched_execute+0x3a>
	for (i=0; i<bucket->num_items; i++)
    5fbc:	d1d9      	bne.n	5f72 <tdma_sched_execute+0x3a>
		struct tdma_sched_item *item = &bucket->item[seq[i]];
		int rc;

		num_events++;

		rc = item->cb(item->p1, item->p2, item->p3);
    5fbe:	2734      	movs	r7, #52	; 0x34
    5fc0:	9b01      	ldr	r3, [sp, #4]
	for (i = 0; i < bucket->num_items; i++) {
    5fc2:	2600      	movs	r6, #0
		rc = item->cb(item->p1, item->p2, item->p3);
    5fc4:	fb07 f703 	mul.w	r7, r7, r3
    5fc8:	eb05 0807 	add.w	r8, r5, r7
    5fcc:	e001      	b.n	5fd2 <tdma_sched_execute+0x9a>
    5fce:	f898 0030 	ldrb.w	r0, [r8, #48]	; 0x30
	for (i = 0; i < bucket->num_items; i++) {
    5fd2:	42b0      	cmp	r0, r6
    5fd4:	dd12      	ble.n	5ffc <tdma_sched_execute+0xc4>
		struct tdma_sched_item *item = &bucket->item[seq[i]];
    5fd6:	ab02      	add	r3, sp, #8
    5fd8:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
		num_events++;
    5fdc:	3601      	adds	r6, #1
		rc = item->cb(item->p1, item->p2, item->p3);
    5fde:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    5fe2:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    5fe6:	18e8      	adds	r0, r5, r3
    5fe8:	88c2      	ldrh	r2, [r0, #6]
    5fea:	7941      	ldrb	r1, [r0, #5]
    5fec:	58eb      	ldr	r3, [r5, r3]
    5fee:	7900      	ldrb	r0, [r0, #4]
    5ff0:	4798      	blx	r3
		if (rc < 0) {
    5ff2:	2800      	cmp	r0, #0
    5ff4:	daeb      	bge.n	5fce <tdma_sched_execute+0x96>
	/* clear/reset the bucket */
	bucket->num_items = 0;

	/* return number of items that we called */
	return num_events;
}
    5ff6:	b007      	add	sp, #28
    5ff8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	bucket->num_items = 0;
    5ffc:	2234      	movs	r2, #52	; 0x34
    5ffe:	2300      	movs	r3, #0
	return num_events;
    6000:	4630      	mov	r0, r6
	bucket->num_items = 0;
    6002:	9901      	ldr	r1, [sp, #4]
    6004:	fb02 5401 	mla	r4, r2, r1, r5
    6008:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
}
    600c:	b007      	add	sp, #28
    600e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6012:	bf00      	nop
    6014:	100001f8 	.word	0x100001f8

00006018 <tdma_sched_reset>:
	unsigned int bucket_nr;

	for (bucket_nr = 0; bucket_nr < ARRAY_SIZE(sched->bucket); bucket_nr++) {
		struct tdma_sched_bucket *bucket = &sched->bucket[bucket_nr];
		/* current bucket will be reset by iteration code above! */
		if (bucket_nr != sched->cur_bucket)
    6018:	4b40      	ldr	r3, [pc, #256]	; (611c <tdma_sched_reset+0x104>)
    601a:	f893 2340 	ldrb.w	r2, [r3, #832]	; 0x340
    601e:	2a00      	cmp	r2, #0
    6020:	d074      	beq.n	610c <tdma_sched_reset+0xf4>
			bucket->num_items = 0;
    6022:	2100      	movs	r1, #0
		if (bucket_nr != sched->cur_bucket)
    6024:	2a01      	cmp	r2, #1
			bucket->num_items = 0;
    6026:	f883 1030 	strb.w	r1, [r3, #48]	; 0x30
		if (bucket_nr != sched->cur_bucket)
    602a:	d147      	bne.n	60bc <tdma_sched_reset+0xa4>
			bucket->num_items = 0;
    602c:	2100      	movs	r1, #0
		if (bucket_nr != sched->cur_bucket)
    602e:	2a03      	cmp	r2, #3
			bucket->num_items = 0;
    6030:	f883 1098 	strb.w	r1, [r3, #152]	; 0x98
		if (bucket_nr != sched->cur_bucket)
    6034:	d11f      	bne.n	6076 <tdma_sched_reset+0x5e>
			bucket->num_items = 0;
    6036:	f883 1100 	strb.w	r1, [r3, #256]	; 0x100
    603a:	2100      	movs	r1, #0
		if (bucket_nr != sched->cur_bucket)
    603c:	2a06      	cmp	r2, #6
			bucket->num_items = 0;
    603e:	f883 1134 	strb.w	r1, [r3, #308]	; 0x134
    6042:	bf08      	it	eq
    6044:	f883 119c 	strbeq.w	r1, [r3, #412]	; 0x19c
		if (bucket_nr != sched->cur_bucket)
    6048:	d11c      	bne.n	6084 <tdma_sched_reset+0x6c>
			bucket->num_items = 0;
    604a:	2100      	movs	r1, #0
		if (bucket_nr != sched->cur_bucket)
    604c:	2a09      	cmp	r2, #9
			bucket->num_items = 0;
    604e:	f883 11d0 	strb.w	r1, [r3, #464]	; 0x1d0
    6052:	bf08      	it	eq
    6054:	f883 1238 	strbeq.w	r1, [r3, #568]	; 0x238
		if (bucket_nr != sched->cur_bucket)
    6058:	d11c      	bne.n	6094 <tdma_sched_reset+0x7c>
			bucket->num_items = 0;
    605a:	2100      	movs	r1, #0
		if (bucket_nr != sched->cur_bucket)
    605c:	2a0c      	cmp	r2, #12
			bucket->num_items = 0;
    605e:	f883 126c 	strb.w	r1, [r3, #620]	; 0x26c
    6062:	bf08      	it	eq
    6064:	f883 12d4 	strbeq.w	r1, [r3, #724]	; 0x2d4
		if (bucket_nr != sched->cur_bucket)
    6068:	d11c      	bne.n	60a4 <tdma_sched_reset+0x8c>
			bucket->num_items = 0;
    606a:	2100      	movs	r1, #0
		if (bucket_nr != sched->cur_bucket)
    606c:	2a0f      	cmp	r2, #15
			bucket->num_items = 0;
    606e:	f883 1308 	strb.w	r1, [r3, #776]	; 0x308
		if (bucket_nr != sched->cur_bucket)
    6072:	d11f      	bne.n	60b4 <tdma_sched_reset+0x9c>
	}

	/* Don't reset cur_bucket, as it would upset the bucket iteration code
	 * in tdma_sched_execute() */
}
    6074:	4770      	bx	lr
		if (bucket_nr != sched->cur_bucket)
    6076:	2a04      	cmp	r2, #4
			bucket->num_items = 0;
    6078:	f883 10cc 	strb.w	r1, [r3, #204]	; 0xcc
    607c:	bf08      	it	eq
    607e:	f883 1134 	strbeq.w	r1, [r3, #308]	; 0x134
		if (bucket_nr != sched->cur_bucket)
    6082:	d122      	bne.n	60ca <tdma_sched_reset+0xb2>
			bucket->num_items = 0;
    6084:	2100      	movs	r1, #0
		if (bucket_nr != sched->cur_bucket)
    6086:	2a07      	cmp	r2, #7
			bucket->num_items = 0;
    6088:	f883 1168 	strb.w	r1, [r3, #360]	; 0x168
    608c:	bf08      	it	eq
    608e:	f883 11d0 	strbeq.w	r1, [r3, #464]	; 0x1d0
		if (bucket_nr != sched->cur_bucket)
    6092:	d122      	bne.n	60da <tdma_sched_reset+0xc2>
			bucket->num_items = 0;
    6094:	2100      	movs	r1, #0
		if (bucket_nr != sched->cur_bucket)
    6096:	2a0a      	cmp	r2, #10
			bucket->num_items = 0;
    6098:	f883 1204 	strb.w	r1, [r3, #516]	; 0x204
    609c:	bf08      	it	eq
    609e:	f883 126c 	strbeq.w	r1, [r3, #620]	; 0x26c
		if (bucket_nr != sched->cur_bucket)
    60a2:	d122      	bne.n	60ea <tdma_sched_reset+0xd2>
			bucket->num_items = 0;
    60a4:	2100      	movs	r1, #0
		if (bucket_nr != sched->cur_bucket)
    60a6:	2a0d      	cmp	r2, #13
			bucket->num_items = 0;
    60a8:	f883 12a0 	strb.w	r1, [r3, #672]	; 0x2a0
    60ac:	bf08      	it	eq
    60ae:	f883 1308 	strbeq.w	r1, [r3, #776]	; 0x308
		if (bucket_nr != sched->cur_bucket)
    60b2:	d122      	bne.n	60fa <tdma_sched_reset+0xe2>
			bucket->num_items = 0;
    60b4:	2200      	movs	r2, #0
    60b6:	f883 233c 	strb.w	r2, [r3, #828]	; 0x33c
}
    60ba:	4770      	bx	lr
		if (bucket_nr != sched->cur_bucket)
    60bc:	2a02      	cmp	r2, #2
			bucket->num_items = 0;
    60be:	f883 1064 	strb.w	r1, [r3, #100]	; 0x64
    60c2:	bf08      	it	eq
    60c4:	f883 10cc 	strbeq.w	r1, [r3, #204]	; 0xcc
		if (bucket_nr != sched->cur_bucket)
    60c8:	d1b0      	bne.n	602c <tdma_sched_reset+0x14>
			bucket->num_items = 0;
    60ca:	2100      	movs	r1, #0
		if (bucket_nr != sched->cur_bucket)
    60cc:	2a05      	cmp	r2, #5
			bucket->num_items = 0;
    60ce:	f883 1100 	strb.w	r1, [r3, #256]	; 0x100
    60d2:	bf08      	it	eq
    60d4:	f883 1168 	strbeq.w	r1, [r3, #360]	; 0x168
		if (bucket_nr != sched->cur_bucket)
    60d8:	d1af      	bne.n	603a <tdma_sched_reset+0x22>
			bucket->num_items = 0;
    60da:	2100      	movs	r1, #0
		if (bucket_nr != sched->cur_bucket)
    60dc:	2a08      	cmp	r2, #8
			bucket->num_items = 0;
    60de:	f883 119c 	strb.w	r1, [r3, #412]	; 0x19c
    60e2:	bf08      	it	eq
    60e4:	f883 1204 	strbeq.w	r1, [r3, #516]	; 0x204
		if (bucket_nr != sched->cur_bucket)
    60e8:	d1af      	bne.n	604a <tdma_sched_reset+0x32>
			bucket->num_items = 0;
    60ea:	2100      	movs	r1, #0
		if (bucket_nr != sched->cur_bucket)
    60ec:	2a0b      	cmp	r2, #11
			bucket->num_items = 0;
    60ee:	f883 1238 	strb.w	r1, [r3, #568]	; 0x238
    60f2:	bf08      	it	eq
    60f4:	f883 12a0 	strbeq.w	r1, [r3, #672]	; 0x2a0
		if (bucket_nr != sched->cur_bucket)
    60f8:	d1af      	bne.n	605a <tdma_sched_reset+0x42>
			bucket->num_items = 0;
    60fa:	2100      	movs	r1, #0
		if (bucket_nr != sched->cur_bucket)
    60fc:	2a0e      	cmp	r2, #14
			bucket->num_items = 0;
    60fe:	f883 12d4 	strb.w	r1, [r3, #724]	; 0x2d4
		if (bucket_nr != sched->cur_bucket)
    6102:	d1b2      	bne.n	606a <tdma_sched_reset+0x52>
			bucket->num_items = 0;
    6104:	2200      	movs	r2, #0
    6106:	f883 233c 	strb.w	r2, [r3, #828]	; 0x33c
}
    610a:	4770      	bx	lr
			bucket->num_items = 0;
    610c:	2100      	movs	r1, #0
		if (bucket_nr != sched->cur_bucket)
    610e:	2a03      	cmp	r2, #3
			bucket->num_items = 0;
    6110:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
    6114:	f883 1098 	strb.w	r1, [r3, #152]	; 0x98
		if (bucket_nr != sched->cur_bucket)
    6118:	d08d      	beq.n	6036 <tdma_sched_reset+0x1e>
    611a:	e7ac      	b.n	6076 <tdma_sched_reset+0x5e>
    611c:	100001f8 	.word	0x100001f8

00006120 <rx_prepare>:
	rx_task.pkt_cb(msg, rx_task.cb_arg, rx_task.pkt_time-RF_EXPECTED_RX_CLKN_OFFSET);
}

// -1
static int rx_prepare(uint8_t p1, uint8_t p2, uint16_t p3)
{
    6120:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	switch(btphy.mode)
    6124:	f8df 812c 	ldr.w	r8, [pc, #300]	; 6254 <rx_prepare+0x134>
    6128:	f898 3000 	ldrb.w	r3, [r8]
    612c:	2b03      	cmp	r3, #3
    612e:	d870      	bhi.n	6212 <rx_prepare+0xf2>
    6130:	2b01      	cmp	r3, #1
    6132:	d874      	bhi.n	621e <rx_prepare+0xfe>
	uint8_t chan;
	uint32_t rx_clkn = btphy_cur_clkn()+1;
    6134:	f8d8 6004 	ldr.w	r6, [r8, #4]
    6138:	3601      	adds	r6, #1
	 * of the master / RX of the slave
	 * (Actually, rx_task in not used in mode INQUIRY_SCAN)
	 */
	if (btphy.mode == BT_MODE_PAGE_SCAN)
		hop_increment();
	chan = hop_channel(rx_clkn);
    613a:	4630      	mov	r0, r6
    613c:	f001 fac8 	bl	76d0 <hop_channel>
    6140:	4607      	mov	r7, r0

	/* Tune to chan & start RX */
	//cprintf("tune rx %d\n", pkt->chan);
	btphy_rf_tune_chan(2402+chan, 0);
    6142:	f600 1062 	addw	r0, r0, #2402	; 0x962
    6146:	2100      	movs	r1, #0
    6148:	b280      	uxth	r0, r0
    614a:	f001 fe0f 	bl	7d6c <btphy_rf_tune_chan>
	/* Here i must strobe SRX before & after GRMDM cfg. why ? */
	cc2400_strobe(SFSON);
    614e:	2061      	movs	r0, #97	; 0x61
    6150:	f003 fc51 	bl	99f6 <cc2400_strobe>

/* cc2400 configure for un-buffered rx */
static inline void btphy_rf_cfg_rx(void)
{
	/* un-buffered mode, packet w/ sync word detection */
	cc2400_set(GRMDM,   0x4E1|(rf_state.max_ac_errors<<13));
    6154:	f240 41e1 	movw	r1, #1249	; 0x4e1
    6158:	4b38      	ldr	r3, [pc, #224]	; (623c <rx_prepare+0x11c>)
    615a:	2020      	movs	r0, #32
    615c:	885b      	ldrh	r3, [r3, #2]
	msg->data_len = size;
    615e:	f44f 75b4 	mov.w	r5, #360	; 0x168
    6162:	b29b      	uxth	r3, r3
    6164:	ea41 3143 	orr.w	r1, r1, r3, lsl #13
    6168:	b289      	uxth	r1, r1
    616a:	f003 fc38 	bl	99de <cc2400_set>
	//   |  |  | |   +-----------> sync word: 32 MSB bits of SYNC_WORD
	//   |  |  | +---------------> 1 preamble bytes of (0)1010101
	//   |  |  +-----------------> packet mode
	//   |  +--------------------> un-buffered mode // use sync word to trigger 
	//   +-----------------------> sync error bits allowed: N
	cc2400_set(IOCFG, 0x170|(GIO_PKT<<9));
    616e:	f44f 6157 	mov.w	r1, #3440	; 0xd70
    6172:	2008      	movs	r0, #8
    6174:	f003 fc33 	bl	99de <cc2400_set>
	cc2400_strobe(SRX);
    6178:	2062      	movs	r0, #98	; 0x62
    617a:	f003 fc3c 	bl	99f6 <cc2400_strobe>
	RXLED_SET;
    617e:	2210      	movs	r2, #16
    6180:	4b2f      	ldr	r3, [pc, #188]	; (6240 <rx_prepare+0x120>)
	msg_t *msg = (msg_t*)btctl_mem_alloc(sizeof(msg_t)+size);
    6182:	f44f 70ba 	mov.w	r0, #372	; 0x174
    6186:	601a      	str	r2, [r3, #0]
    6188:	f001 fe4c 	bl	7e24 <mem_pool_alloc>
    618c:	4603      	mov	r3, r0
	hdr->type = type;
    618e:	2228      	movs	r2, #40	; 0x28
	msg->write = msg->data;
    6190:	300c      	adds	r0, #12
        msg->write += len;
    6192:	f103 0110 	add.w	r1, r3, #16
    6196:	731a      	strb	r2, [r3, #12]
	return (int)(msg->write - msg->data);
    6198:	1a0a      	subs	r2, r1, r0
	btphy_rf_cfg_rx();
	btphy_rf_rx();

	/* Alloc & reset RX packet */
	if (!(rx_task.rx_msg = btctl_msg_alloc(BTCTL_RX_PKT)))
    619a:	4c2a      	ldr	r4, [pc, #168]	; (6244 <rx_prepare+0x124>)
        return msg->data_len - msg_write_len(msg);
    619c:	1aaa      	subs	r2, r5, r2
        if (msg_write_avail(msg) < (int) len)
    619e:	2a0b      	cmp	r2, #11
        msg->write += len;
    61a0:	e9c3 0101 	strd	r0, r1, [r3, #4]
	msg->data_len = size;
    61a4:	805d      	strh	r5, [r3, #2]
    61a6:	60a3      	str	r3, [r4, #8]
        if (msg_write_avail(msg) < (int) len)
    61a8:	dd44      	ble.n	6234 <rx_prepare+0x114>
		DIE("rx_prepare: no more buf");
	pkt = rx_task.rx_pkt = (btctl_rx_pkt_t*)msg_put(rx_task.rx_msg, sizeof(*rx_task.rx_pkt));

	/* Setup rx packet */
	pkt->chan = chan;
	pkt->data_size = 0;
    61aa:	2500      	movs	r5, #0
        msg->write += len;
    61ac:	f103 021c 	add.w	r2, r3, #28
    61b0:	609a      	str	r2, [r3, #8]
	pkt->chan = chan;
    61b2:	751f      	strb	r7, [r3, #20]
	pkt->clkn = rx_clkn; // clkn at time of execute
    61b4:	611e      	str	r6, [r3, #16]
	pkt->data_size = 0;
    61b6:	759d      	strb	r5, [r3, #22]
    61b8:	75dd      	strb	r5, [r3, #23]
	pkt->flags = 0;
    61ba:	755d      	strb	r5, [r3, #21]

	bbcodec_init(&rx_task.codec, btphy_whiten_seed(rx_clkn), btphy.chan_uap, 1, rx_task.rx_raw);
    61bc:	4630      	mov	r0, r6
	pkt = rx_task.rx_pkt = (btctl_rx_pkt_t*)msg_put(rx_task.rx_msg, sizeof(*rx_task.rx_pkt));
    61be:	60e1      	str	r1, [r4, #12]
	bbcodec_init(&rx_task.codec, btphy_whiten_seed(rx_clkn), btphy.chan_uap, 1, rx_task.rx_raw);
    61c0:	f7ff fd1a 	bl	5bf8 <btphy_whiten_seed>
		uint8_t uap,
		int use_whiten,
		int rx_raw)
{
	codec->uap = uap;
	codec->use_whiten = use_whiten;
    61c4:	2101      	movs	r1, #1
	codec->rx_raw = rx_raw;
	codec->crc_state = reverse8(uap)<<8;
	codec->crc_pos = 0;
	codec->whiten_state = whiten_init;
	codec->t = NULL;
	codec->payload_length = 0;
    61c6:	2600      	movs	r6, #0
    61c8:	2700      	movs	r7, #0
    61ca:	f898 3018 	ldrb.w	r3, [r8, #24]
        return rev8_map[data];
    61ce:	4a1e      	ldr	r2, [pc, #120]	; (6248 <rx_prepare+0x128>)
	codec->uap = uap;
    61d0:	7423      	strb	r3, [r4, #16]
	codec->crc_state = reverse8(uap)<<8;
    61d2:	5cd3      	ldrb	r3, [r2, r3]
    61d4:	f894 2256 	ldrb.w	r2, [r4, #598]	; 0x256
    61d8:	021b      	lsls	r3, r3, #8
	codec->whiten_state = whiten_init;
    61da:	7720      	strb	r0, [r4, #28]
	codec->use_whiten = use_whiten;
    61dc:	6161      	str	r1, [r4, #20]
	rx_task.pkt_time = 0;
	rx_task.rx_done = 0;
	rx_task.rx_offset = 0;
	/* Configure DMA RX */
	dma_init_rx_single(rx_task.rx_dma_buf, sizeof(rx_task.rx_dma_buf));
    61de:	f104 003d 	add.w	r0, r4, #61	; 0x3d
    61e2:	f44f 7104 	mov.w	r1, #528	; 0x210
	codec->crc_state = reverse8(uap)<<8;
    61e6:	83e3      	strh	r3, [r4, #30]
	codec->rx_raw = rx_raw;
    61e8:	61a2      	str	r2, [r4, #24]
	codec->payload_length = 0;
    61ea:	e9c4 670a 	strd	r6, r7, [r4, #40]	; 0x28
    61ee:	e9c4 670c 	strd	r6, r7, [r4, #48]	; 0x30
	codec->crc_pos = 0;
    61f2:	8425      	strh	r5, [r4, #32]
	codec->t = NULL;
    61f4:	6265      	str	r5, [r4, #36]	; 0x24
	codec->air_off_b = 0;
	codec->air_bytes = 0;
	codec->coded_total = 0;
	codec->coded_pos = 0;
    61f6:	63a5      	str	r5, [r4, #56]	; 0x38
	rx_task.pkt_time = 0;
    61f8:	f8a4 524e 	strh.w	r5, [r4, #590]	; 0x24e
	rx_task.rx_done = 0;
    61fc:	f884 5254 	strb.w	r5, [r4, #596]	; 0x254
	rx_task.rx_offset = 0;
    6200:	f8c4 5250 	str.w	r5, [r4, #592]	; 0x250
	dma_init_rx_single(rx_task.rx_dma_buf, sizeof(rx_task.rx_dma_buf));
    6204:	f003 faa8 	bl	9758 <dma_init_rx_single>

	/* Start SPI DMA */
	dio_ssp_start_rx();
    6208:	f003 fa84 	bl	9714 <dio_ssp_start_rx>


	return 0; 
}
    620c:	4628      	mov	r0, r5
    620e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    6212:	2b05      	cmp	r3, #5
    6214:	d18e      	bne.n	6134 <rx_prepare+0x14>
	uint32_t rx_clkn = btphy_cur_clkn()+1;
    6216:	f8d8 6008 	ldr.w	r6, [r8, #8]
    621a:	3601      	adds	r6, #1
	if (btphy.mode == BT_MODE_PAGE_SCAN)
    621c:	e78d      	b.n	613a <rx_prepare+0x1a>
	uint32_t rx_clkn = btphy_cur_clkn()+1;
    621e:	f8d8 6008 	ldr.w	r6, [r8, #8]
	if (btphy.mode == BT_MODE_PAGE_SCAN)
    6222:	2b03      	cmp	r3, #3
	uint32_t rx_clkn = btphy_cur_clkn()+1;
    6224:	f106 0601 	add.w	r6, r6, #1
	if (btphy.mode == BT_MODE_PAGE_SCAN)
    6228:	d187      	bne.n	613a <rx_prepare+0x1a>

/* This function increment the x variable of for paging/inquiry hopping.
 * It must be called before each master's transmission. */
static inline void hop_increment(void)
{
	hop_state.x++;
    622a:	4a08      	ldr	r2, [pc, #32]	; (624c <rx_prepare+0x12c>)
    622c:	7993      	ldrb	r3, [r2, #6]
    622e:	3301      	adds	r3, #1
    6230:	7193      	strb	r3, [r2, #6]
}
    6232:	e782      	b.n	613a <rx_prepare+0x1a>
		DIE("msg_put: short buf\n");
    6234:	4806      	ldr	r0, [pc, #24]	; (6250 <rx_prepare+0x130>)
    6236:	f001 feed 	bl	8014 <die>
    623a:	bf00      	nop
    623c:	10000a8c 	.word	0x10000a8c
    6240:	2009c038 	.word	0x2009c038
    6244:	10000540 	.word	0x10000540
    6248:	0000d954 	.word	0x0000d954
    624c:	10002520 	.word	0x10002520
    6250:	0000da98 	.word	0x0000da98
    6254:	100001b0 	.word	0x100001b0

00006258 <rx_finalize>:
{
    6258:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	msg_t *msg = rx_task.rx_msg;
    625c:	4d2e      	ldr	r5, [pc, #184]	; (6318 <rx_finalize+0xc0>)
	cc2400_strobe(SRFOFF);
    625e:	2064      	movs	r0, #100	; 0x64
	btctl_rx_pkt_t *pkt = rx_task.rx_pkt;
    6260:	e9d5 6402 	ldrd	r6, r4, [r5, #8]
    6264:	f003 fbc7 	bl	99f6 <cc2400_strobe>
	TXLED_CLR;
    6268:	f44f 7180 	mov.w	r1, #256	; 0x100
	RXLED_CLR;
    626c:	2210      	movs	r2, #16
	TXLED_CLR;
    626e:	4b2b      	ldr	r3, [pc, #172]	; (631c <rx_finalize+0xc4>)
    6270:	6019      	str	r1, [r3, #0]
	RXLED_CLR;
    6272:	601a      	str	r2, [r3, #0]
	dio_ssp_stop();
    6274:	f003 fa12 	bl	969c <dio_ssp_stop>
	if (!pkt)
    6278:	2c00      	cmp	r4, #0
    627a:	d049      	beq.n	6310 <rx_finalize+0xb8>
	if (!rx_task.pkt_cb)
    627c:	682f      	ldr	r7, [r5, #0]
    627e:	2f00      	cmp	r7, #0
    6280:	d043      	beq.n	630a <rx_finalize+0xb2>
	if (BBPKT_HAS_HDR(pkt))
    6282:	7963      	ldrb	r3, [r4, #5]
    6284:	f013 0302 	ands.w	r3, r3, #2
    6288:	d11d      	bne.n	62c6 <rx_finalize+0x6e>
		pkt->data_size = 0;
    628a:	210c      	movs	r1, #12
    628c:	71a3      	strb	r3, [r4, #6]
    628e:	71e3      	strb	r3, [r4, #7]
	msg_set_write(rx_task.rx_msg, &pkt->bt_data[pkt->data_size]);
    6290:	68aa      	ldr	r2, [r5, #8]
    6292:	440c      	add	r4, r1
	if (write < msg->data || write > (msg->data + msg->data_len))
    6294:	f102 030c 	add.w	r3, r2, #12
    6298:	429c      	cmp	r4, r3
    629a:	d304      	bcc.n	62a6 <rx_finalize+0x4e>
    629c:	8851      	ldrh	r1, [r2, #2]
    629e:	440b      	add	r3, r1
    62a0:	429c      	cmp	r4, r3
        msg->write = write;
    62a2:	bf98      	it	ls
    62a4:	6094      	strls	r4, [r2, #8]
	rx_task.rx_msg = NULL;
    62a6:	f04f 0800 	mov.w	r8, #0
    62aa:	f04f 0900 	mov.w	r9, #0
	rx_task.pkt_cb(msg, rx_task.cb_arg, rx_task.pkt_time-RF_EXPECTED_RX_CLKN_OFFSET);
    62ae:	f8b5 224e 	ldrh.w	r2, [r5, #590]	; 0x24e
    62b2:	4630      	mov	r0, r6
    62b4:	463b      	mov	r3, r7
	rx_task.rx_msg = NULL;
    62b6:	e9c5 8902 	strd	r8, r9, [r5, #8]
	rx_task.pkt_cb(msg, rx_task.cb_arg, rx_task.pkt_time-RF_EXPECTED_RX_CLKN_OFFSET);
    62ba:	6869      	ldr	r1, [r5, #4]
    62bc:	f2a2 2262 	subw	r2, r2, #610	; 0x262
}
    62c0:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	rx_task.pkt_cb(msg, rx_task.cb_arg, rx_task.pkt_time-RF_EXPECTED_RX_CLKN_OFFSET);
    62c4:	4718      	bx	r3
	unsigned i, size = dma_get_rx_offset();
    62c6:	f003 fa67 	bl	9798 <dma_get_rx_offset>
	for(i=rx_task.rx_offset;i<size;i++)
    62ca:	f8d5 3250 	ldr.w	r3, [r5, #592]	; 0x250
	unsigned i, size = dma_get_rx_offset();
    62ce:	4607      	mov	r7, r0
	for(i=rx_task.rx_offset;i<size;i++)
    62d0:	4298      	cmp	r0, r3
    62d2:	d90b      	bls.n	62ec <rx_finalize+0x94>
    62d4:	333d      	adds	r3, #61	; 0x3d
    62d6:	f105 013d 	add.w	r1, r5, #61	; 0x3d
    62da:	4811      	ldr	r0, [pc, #68]	; (6320 <rx_finalize+0xc8>)
    62dc:	442b      	add	r3, r5
    62de:	4439      	add	r1, r7
		rx_task.rx_dma_buf[i] = reverse8(rx_task.rx_dma_buf[i]);
    62e0:	781a      	ldrb	r2, [r3, #0]
    62e2:	5c82      	ldrb	r2, [r0, r2]
    62e4:	f803 2b01 	strb.w	r2, [r3], #1
	for(i=rx_task.rx_offset;i<size;i++)
    62e8:	428b      	cmp	r3, r1
    62ea:	d1f9      	bne.n	62e0 <rx_finalize+0x88>
		pkt->flags |= bbcodec_decode_finalize(&rx_task.codec, pkt->bt_data, &pkt->data_size);
    62ec:	f104 010c 	add.w	r1, r4, #12
    62f0:	480c      	ldr	r0, [pc, #48]	; (6324 <rx_finalize+0xcc>)
    62f2:	1da2      	adds	r2, r4, #6
	rx_task.rx_offset = size;
    62f4:	f8c5 7250 	str.w	r7, [r5, #592]	; 0x250
		pkt->flags |= bbcodec_decode_finalize(&rx_task.codec, pkt->bt_data, &pkt->data_size);
    62f8:	f7fe fada 	bl	48b0 <bbcodec_decode_finalize>
    62fc:	7963      	ldrb	r3, [r4, #5]
    62fe:	88e1      	ldrh	r1, [r4, #6]
    6300:	4318      	orrs	r0, r3
    6302:	682f      	ldr	r7, [r5, #0]
    6304:	7160      	strb	r0, [r4, #5]
    6306:	310c      	adds	r1, #12
    6308:	e7c2      	b.n	6290 <rx_finalize+0x38>
		DIE("rxnd: no pkt_cb");
    630a:	4807      	ldr	r0, [pc, #28]	; (6328 <rx_finalize+0xd0>)
    630c:	f001 fe82 	bl	8014 <die>
		DIE("rxnd: no rx_pkt");
    6310:	4806      	ldr	r0, [pc, #24]	; (632c <rx_finalize+0xd4>)
    6312:	f001 fe7f 	bl	8014 <die>
    6316:	bf00      	nop
    6318:	10000540 	.word	0x10000540
    631c:	2009c03c 	.word	0x2009c03c
    6320:	0000d954 	.word	0x0000d954
    6324:	10000550 	.word	0x10000550
    6328:	0000dcac 	.word	0x0000dcac
    632c:	0000dc94 	.word	0x0000dc94

00006330 <rx_execute>:
	}
}

// 0
static int rx_execute(uint8_t p1, uint8_t p2, uint16_t p3)
{
    6330:	b5f0      	push	{r4, r5, r6, r7, lr}
    6332:	b083      	sub	sp, #12
	unsigned i, delay;
	btctl_rx_pkt_t *pkt = rx_task.rx_pkt;
    6334:	4c4e      	ldr	r4, [pc, #312]	; (6470 <rx_execute+0x140>)

	if ((cc2400_get(FSMSTATE) & 0x1f) != STATE_STROBE_RX)
    6336:	200e      	movs	r0, #14
	btctl_rx_pkt_t *pkt = rx_task.rx_pkt;
    6338:	68e5      	ldr	r5, [r4, #12]
	if ((cc2400_get(FSMSTATE) & 0x1f) != STATE_STROBE_RX)
    633a:	f003 fb47 	bl	99cc <cc2400_get>
    633e:	f000 001f 	and.w	r0, r0, #31
    6342:	2810      	cmp	r0, #16
    6344:	d170      	bne.n	6428 <rx_execute+0xf8>
		cprintf("rxne: RF not rdy\n");
		rx_finalize();
		return 0;
	}

	while (CLKN_OFFSET < WAIT_SYNCWORD)
    6346:	f240 21c5 	movw	r1, #709	; 0x2c5
    634a:	4a4a      	ldr	r2, [pc, #296]	; (6474 <rx_execute+0x144>)
	{
		/* PKT strobe goes low if a syncword is detected */
		if (GIO6 == 0)
    634c:	484a      	ldr	r0, [pc, #296]	; (6478 <rx_execute+0x148>)
    634e:	e002      	b.n	6356 <rx_execute+0x26>
    6350:	6803      	ldr	r3, [r0, #0]
    6352:	075e      	lsls	r6, r3, #29
    6354:	d50a      	bpl.n	636c <rx_execute+0x3c>
	while (CLKN_OFFSET < WAIT_SYNCWORD)
    6356:	6813      	ldr	r3, [r2, #0]
    6358:	428b      	cmp	r3, r1
    635a:	d9f9      	bls.n	6350 <rx_execute+0x20>
			pkt->flags |= 1<<BBPKT_F_HAS_PKT;
			break;
		}
	}
	/* If a packet is being received and it has a payload,*/
	if (BBPKT_HAS_PKT(pkt) && rx_task.do_rx_payload)
    635c:	796b      	ldrb	r3, [r5, #5]
    635e:	07db      	lsls	r3, r3, #31
    6360:	d40b      	bmi.n	637a <rx_execute+0x4a>
				}
			}
		}
	}
	/* No packet/ID was received, stop now */
	rx_finalize();
    6362:	f7ff ff79 	bl	6258 <rx_finalize>

	return 0; 
}
    6366:	2000      	movs	r0, #0
    6368:	b003      	add	sp, #12
    636a:	bdf0      	pop	{r4, r5, r6, r7, pc}
			rx_task.pkt_time = CLKN_OFFSET;
    636c:	6813      	ldr	r3, [r2, #0]
    636e:	f8a4 324e 	strh.w	r3, [r4, #590]	; 0x24e
			pkt->flags |= 1<<BBPKT_F_HAS_PKT;
    6372:	796b      	ldrb	r3, [r5, #5]
    6374:	f043 0301 	orr.w	r3, r3, #1
    6378:	716b      	strb	r3, [r5, #5]
	if (BBPKT_HAS_PKT(pkt) && rx_task.do_rx_payload)
    637a:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
    637e:	2b00      	cmp	r3, #0
    6380:	d0ef      	beq.n	6362 <rx_execute+0x32>
	btctl_rx_pkt_t *pkt = rx_task.rx_pkt;
    6382:	68e6      	ldr	r6, [r4, #12]
	while((size=rx_buf_update()) < NUM_PKT_HDR_BYTES);
    6384:	4d3d      	ldr	r5, [pc, #244]	; (647c <rx_execute+0x14c>)
    6386:	4f3e      	ldr	r7, [pc, #248]	; (6480 <rx_execute+0x150>)
	unsigned i, size = dma_get_rx_offset();
    6388:	f003 fa06 	bl	9798 <dma_get_rx_offset>
	for(i=rx_task.rx_offset;i<size;i++)
    638c:	f8d4 3250 	ldr.w	r3, [r4, #592]	; 0x250
    6390:	4298      	cmp	r0, r3
    6392:	d908      	bls.n	63a6 <rx_execute+0x76>
    6394:	333d      	adds	r3, #61	; 0x3d
    6396:	4423      	add	r3, r4
    6398:	1829      	adds	r1, r5, r0
		rx_task.rx_dma_buf[i] = reverse8(rx_task.rx_dma_buf[i]);
    639a:	781a      	ldrb	r2, [r3, #0]
    639c:	5cba      	ldrb	r2, [r7, r2]
    639e:	f803 2b01 	strb.w	r2, [r3], #1
	for(i=rx_task.rx_offset;i<size;i++)
    63a2:	428b      	cmp	r3, r1
    63a4:	d1f9      	bne.n	639a <rx_execute+0x6a>
	if (size > 4)
    63a6:	280b      	cmp	r0, #11
	rx_task.rx_offset = size;
    63a8:	f8c4 0250 	str.w	r0, [r4, #592]	; 0x250
	if (size > 4)
    63ac:	d9ec      	bls.n	6388 <rx_execute+0x58>
	if(bbcodec_decode_header(&rx_task.codec, &pkt->bb_hdr, rx_task.rx_dma_buf+4))
    63ae:	4a35      	ldr	r2, [pc, #212]	; (6484 <rx_execute+0x154>)
    63b0:	f106 0108 	add.w	r1, r6, #8
    63b4:	f1a2 0031 	sub.w	r0, r2, #49	; 0x31
    63b8:	f7fd ffd0 	bl	435c <bbcodec_decode_header>
    63bc:	2800      	cmp	r0, #0
    63be:	d1d0      	bne.n	6362 <rx_execute+0x32>
	if (rx_task.codec.t->has_crc)
    63c0:	6a62      	ldr	r2, [r4, #36]	; 0x24
    63c2:	7953      	ldrb	r3, [r2, #5]
    63c4:	2b00      	cmp	r3, #0
    63c6:	d137      	bne.n	6438 <rx_execute+0x108>
    63c8:	7973      	ldrb	r3, [r6, #5]
	pkt->flags |= 1<<BBPKT_F_HAS_HDR;
    63ca:	f043 0302 	orr.w	r3, r3, #2
    63ce:	7173      	strb	r3, [r6, #5]
			if (rx_task.codec.t->payload_bytes)
    63d0:	8853      	ldrh	r3, [r2, #2]
    63d2:	2b00      	cmp	r3, #0
    63d4:	d0c5      	beq.n	6362 <rx_execute+0x32>
	btctl_rx_pkt_t *pkt = rx_task.rx_pkt;
    63d6:	68e6      	ldr	r6, [r4, #12]
	while((size=rx_buf_update()) < NUM_DATA_HDR_BYTES);
    63d8:	4d28      	ldr	r5, [pc, #160]	; (647c <rx_execute+0x14c>)
    63da:	4f29      	ldr	r7, [pc, #164]	; (6480 <rx_execute+0x150>)
	unsigned i, size = dma_get_rx_offset();
    63dc:	f003 f9dc 	bl	9798 <dma_get_rx_offset>
	for(i=rx_task.rx_offset;i<size;i++)
    63e0:	f8d4 3250 	ldr.w	r3, [r4, #592]	; 0x250
    63e4:	4298      	cmp	r0, r3
    63e6:	d908      	bls.n	63fa <rx_execute+0xca>
    63e8:	333d      	adds	r3, #61	; 0x3d
    63ea:	4423      	add	r3, r4
    63ec:	1829      	adds	r1, r5, r0
		rx_task.rx_dma_buf[i] = reverse8(rx_task.rx_dma_buf[i]);
    63ee:	781a      	ldrb	r2, [r3, #0]
    63f0:	5cba      	ldrb	r2, [r7, r2]
    63f2:	f803 2b01 	strb.w	r2, [r3], #1
	for(i=rx_task.rx_offset;i<size;i++)
    63f6:	428b      	cmp	r3, r1
    63f8:	d1f9      	bne.n	63ee <rx_execute+0xbe>
	if (size > 4)
    63fa:	2804      	cmp	r0, #4
	rx_task.rx_offset = size;
    63fc:	f8c4 0250 	str.w	r0, [r4, #592]	; 0x250
	if (size > 4)
    6400:	d9ec      	bls.n	63dc <rx_execute+0xac>
		return size-4;
    6402:	3804      	subs	r0, #4
	while((size=rx_buf_update()) < NUM_DATA_HDR_BYTES);
    6404:	2816      	cmp	r0, #22
    6406:	d9e9      	bls.n	63dc <rx_execute+0xac>
	if((rc=bbcodec_decode_chunk(&rx_task.codec, pkt->bt_data, &pkt->bb_hdr, rx_task.rx_dma_buf+4, size)))
    6408:	4b1e      	ldr	r3, [pc, #120]	; (6484 <rx_execute+0x154>)
    640a:	9000      	str	r0, [sp, #0]
    640c:	f106 0208 	add.w	r2, r6, #8
    6410:	f1a3 0031 	sub.w	r0, r3, #49	; 0x31
    6414:	f106 010c 	add.w	r1, r6, #12
    6418:	f7fe f978 	bl	470c <bbcodec_decode_chunk>
    641c:	b180      	cbz	r0, 6440 <rx_execute+0x110>
		if (rc == 1)
    641e:	2801      	cmp	r0, #1
    6420:	d120      	bne.n	6464 <rx_execute+0x134>
			rx_task.rx_done = 1;
    6422:	f884 0254 	strb.w	r0, [r4, #596]	; 0x254
				if (!rx_task.rx_done)
    6426:	e79c      	b.n	6362 <rx_execute+0x32>
		cprintf("rxne: RF not rdy\n");
    6428:	4817      	ldr	r0, [pc, #92]	; (6488 <rx_execute+0x158>)
    642a:	f002 fef3 	bl	9214 <cprintf>
		rx_finalize();
    642e:	f7ff ff13 	bl	6258 <rx_finalize>
}
    6432:	2000      	movs	r0, #0
    6434:	b003      	add	sp, #12
    6436:	bdf0      	pop	{r4, r5, r6, r7, pc}
		pkt->flags |= 1<<BBPKT_F_HAS_CRC;
    6438:	7973      	ldrb	r3, [r6, #5]
    643a:	f043 0304 	orr.w	r3, r3, #4
    643e:	e7c4      	b.n	63ca <rx_execute+0x9a>
				if (!rx_task.rx_done)
    6440:	f894 3254 	ldrb.w	r3, [r4, #596]	; 0x254
    6444:	2b00      	cmp	r3, #0
    6446:	d18c      	bne.n	6362 <rx_execute+0x32>
					rx_task.slot_num = rx_task.codec.t->nslots*2-1;
    6448:	6a62      	ldr	r2, [r4, #36]	; 0x24
					tdma_schedule(1, rx_decode, 0, 0, 0, 0);
    644a:	4910      	ldr	r1, [pc, #64]	; (648c <rx_execute+0x15c>)
					rx_task.slot_num = rx_task.codec.t->nslots*2-1;
    644c:	7815      	ldrb	r5, [r2, #0]
					tdma_schedule(1, rx_decode, 0, 0, 0, 0);
    644e:	2001      	movs	r0, #1
					rx_task.slot_num = rx_task.codec.t->nslots*2-1;
    6450:	006d      	lsls	r5, r5, #1
    6452:	3d01      	subs	r5, #1
					tdma_schedule(1, rx_decode, 0, 0, 0, 0);
    6454:	461a      	mov	r2, r3
    6456:	e9cd 3300 	strd	r3, r3, [sp]
					rx_task.slot_num = rx_task.codec.t->nslots*2-1;
    645a:	f884 5255 	strb.w	r5, [r4, #597]	; 0x255
					tdma_schedule(1, rx_decode, 0, 0, 0, 0);
    645e:	f7ff fcd1 	bl	5e04 <tdma_schedule>
					return 0;
    6462:	e780      	b.n	6366 <rx_execute+0x36>
			DIE("dec hdr %d: rc=%d\n", pkt->bb_hdr.type, rc);
    6464:	4602      	mov	r2, r0
    6466:	7a71      	ldrb	r1, [r6, #9]
    6468:	4809      	ldr	r0, [pc, #36]	; (6490 <rx_execute+0x160>)
    646a:	f001 fdd3 	bl	8014 <die>
    646e:	bf00      	nop
    6470:	10000540 	.word	0x10000540
    6474:	40004008 	.word	0x40004008
    6478:	2009c054 	.word	0x2009c054
    647c:	1000057d 	.word	0x1000057d
    6480:	0000d954 	.word	0x0000d954
    6484:	10000581 	.word	0x10000581
    6488:	0000dcc4 	.word	0x0000dcc4
    648c:	00006495 	.word	0x00006495
    6490:	0000dcd8 	.word	0x0000dcd8

00006494 <rx_decode>:

/* 1+n : Rx multislot: decode available data */
static int rx_decode(uint8_t p1, uint8_t p2, uint16_t p3)
{
    6494:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    6498:	b083      	sub	sp, #12
	unsigned i, size, bytes_left;
	int rc, last;
	btctl_rx_pkt_t *pkt = rx_task.rx_pkt;
    649a:	4d3c      	ldr	r5, [pc, #240]	; (658c <rx_decode+0xf8>)

	/* Check if we're in the last slot according to BT spec table 6.2 */
	last = --rx_task.slot_num == 0;
    649c:	f895 6255 	ldrb.w	r6, [r5, #597]	; 0x255
	btctl_rx_pkt_t *pkt = rx_task.rx_pkt;
    64a0:	68ec      	ldr	r4, [r5, #12]
	last = --rx_task.slot_num == 0;
    64a2:	3e01      	subs	r6, #1
    64a4:	b2f6      	uxtb	r6, r6
    64a6:	f885 6255 	strb.w	r6, [r5, #597]	; 0x255
	unsigned i, size = dma_get_rx_offset();
    64aa:	f003 f975 	bl	9798 <dma_get_rx_offset>
	last = --rx_task.slot_num == 0;
    64ae:	fab6 f686 	clz	r6, r6
	for(i=rx_task.rx_offset;i<size;i++)
    64b2:	f8d5 3250 	ldr.w	r3, [r5, #592]	; 0x250
	last = --rx_task.slot_num == 0;
    64b6:	0976      	lsrs	r6, r6, #5
	for(i=rx_task.rx_offset;i<size;i++)
    64b8:	4298      	cmp	r0, r3
    64ba:	d90b      	bls.n	64d4 <rx_decode+0x40>
    64bc:	333d      	adds	r3, #61	; 0x3d
    64be:	f105 013d 	add.w	r1, r5, #61	; 0x3d
    64c2:	4f33      	ldr	r7, [pc, #204]	; (6590 <rx_decode+0xfc>)
    64c4:	442b      	add	r3, r5
    64c6:	4401      	add	r1, r0
		rx_task.rx_dma_buf[i] = reverse8(rx_task.rx_dma_buf[i]);
    64c8:	781a      	ldrb	r2, [r3, #0]
    64ca:	5cba      	ldrb	r2, [r7, r2]
    64cc:	f803 2b01 	strb.w	r2, [r3], #1
	for(i=rx_task.rx_offset;i<size;i++)
    64d0:	428b      	cmp	r3, r1
    64d2:	d1f9      	bne.n	64c8 <rx_decode+0x34>
	if (size > 4)
    64d4:	2804      	cmp	r0, #4
	rx_task.rx_offset = size;
    64d6:	f8c5 0250 	str.w	r0, [r5, #592]	; 0x250
	if (size > 4)
    64da:	d854      	bhi.n	6586 <rx_decode+0xf2>
	return 0;
    64dc:	f04f 0800 	mov.w	r8, #0

	/* Reverse the dma buf */
	size=rx_buf_update();

	/* Check if we can rx end of packet in this slot*/
	bytes_left = rx_task.codec.air_bytes - size;
    64e0:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    64e2:	eba3 0208 	sub.w	r2, r3, r8
	last |= bytes_left < MAX_WAIT_BYTES;

	/* last slot: wait for rx end */
	if (last)
    64e6:	2a0f      	cmp	r2, #15
    64e8:	d91c      	bls.n	6524 <rx_decode+0x90>
    64ea:	b9de      	cbnz	r6, 6524 <rx_decode+0x90>
			size=rx_buf_update();
		}
	}

	/* Decode what we can */
	while((rc=bbcodec_decode_chunk(&rx_task.codec, pkt->bt_data, &pkt->bb_hdr, rx_task.rx_dma_buf+4, size))==0)
    64ec:	4e29      	ldr	r6, [pc, #164]	; (6594 <rx_decode+0x100>)
    64ee:	f104 050c 	add.w	r5, r4, #12
    64f2:	3408      	adds	r4, #8
    64f4:	4633      	mov	r3, r6
    64f6:	4622      	mov	r2, r4
    64f8:	4629      	mov	r1, r5
    64fa:	4827      	ldr	r0, [pc, #156]	; (6598 <rx_decode+0x104>)
    64fc:	f8cd 8000 	str.w	r8, [sp]
    6500:	f7fe f904 	bl	470c <bbcodec_decode_chunk>
    6504:	2800      	cmp	r0, #0
    6506:	d0f5      	beq.n	64f4 <rx_decode+0x60>
	{
		//cputc('D');
	}
	if (rc == BBCODEC_DONE)
    6508:	2801      	cmp	r0, #1
    650a:	d036      	beq.n	657a <rx_decode+0xe6>
		rx_finalize();
	}
	else
	{
		/* Schedule one more decode */
		tdma_schedule(1, rx_decode, 0, 0, 0, 0);
    650c:	2300      	movs	r3, #0
    650e:	4923      	ldr	r1, [pc, #140]	; (659c <rx_decode+0x108>)
    6510:	461a      	mov	r2, r3
    6512:	e9cd 3300 	strd	r3, r3, [sp]
    6516:	2001      	movs	r0, #1
    6518:	f7ff fc74 	bl	5e04 <tdma_schedule>
	}
	return 0;
}
    651c:	2000      	movs	r0, #0
    651e:	b003      	add	sp, #12
    6520:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		while(CLKN_OFFSET < WAIT_RX_MAX && size < rx_task.codec.air_bytes)
    6524:	f240 52db 	movw	r2, #1499	; 0x5db
    6528:	4e1d      	ldr	r6, [pc, #116]	; (65a0 <rx_decode+0x10c>)
    652a:	6831      	ldr	r1, [r6, #0]
    652c:	4291      	cmp	r1, r2
    652e:	d8dd      	bhi.n	64ec <rx_decode+0x58>
    6530:	4f1c      	ldr	r7, [pc, #112]	; (65a4 <rx_decode+0x110>)
    6532:	f8df 905c 	ldr.w	r9, [pc, #92]	; 6590 <rx_decode+0xfc>
    6536:	4598      	cmp	r8, r3
    6538:	d2d8      	bcs.n	64ec <rx_decode+0x58>
	unsigned i, size = dma_get_rx_offset();
    653a:	f003 f92d 	bl	9798 <dma_get_rx_offset>
	for(i=rx_task.rx_offset;i<size;i++)
    653e:	f8d5 3250 	ldr.w	r3, [r5, #592]	; 0x250
    6542:	4298      	cmp	r0, r3
    6544:	d909      	bls.n	655a <rx_decode+0xc6>
    6546:	333d      	adds	r3, #61	; 0x3d
    6548:	442b      	add	r3, r5
    654a:	1839      	adds	r1, r7, r0
		rx_task.rx_dma_buf[i] = reverse8(rx_task.rx_dma_buf[i]);
    654c:	781a      	ldrb	r2, [r3, #0]
    654e:	f819 2002 	ldrb.w	r2, [r9, r2]
    6552:	f803 2b01 	strb.w	r2, [r3], #1
	for(i=rx_task.rx_offset;i<size;i++)
    6556:	4299      	cmp	r1, r3
    6558:	d1f8      	bne.n	654c <rx_decode+0xb8>
	if (size > 4)
    655a:	2804      	cmp	r0, #4
	rx_task.rx_offset = size;
    655c:	f8c5 0250 	str.w	r0, [r5, #592]	; 0x250
	if (size > 4)
    6560:	d808      	bhi.n	6574 <rx_decode+0xe0>
	return 0;
    6562:	f04f 0800 	mov.w	r8, #0
		while(CLKN_OFFSET < WAIT_RX_MAX && size < rx_task.codec.air_bytes)
    6566:	f240 53db 	movw	r3, #1499	; 0x5db
    656a:	6832      	ldr	r2, [r6, #0]
    656c:	429a      	cmp	r2, r3
    656e:	d8bd      	bhi.n	64ec <rx_decode+0x58>
    6570:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    6572:	e7e0      	b.n	6536 <rx_decode+0xa2>
		return size-4;
    6574:	f1a0 0804 	sub.w	r8, r0, #4
    6578:	e7f5      	b.n	6566 <rx_decode+0xd2>
		rx_finalize();
    657a:	f7ff fe6d 	bl	6258 <rx_finalize>
}
    657e:	2000      	movs	r0, #0
    6580:	b003      	add	sp, #12
    6582:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return size-4;
    6586:	f1a0 0804 	sub.w	r8, r0, #4
    658a:	e7a9      	b.n	64e0 <rx_decode+0x4c>
    658c:	10000540 	.word	0x10000540
    6590:	0000d954 	.word	0x0000d954
    6594:	10000581 	.word	0x10000581
    6598:	10000550 	.word	0x10000550
    659c:	00006495 	.word	0x00006495
    65a0:	40004008 	.word	0x40004008
    65a4:	1000057d 	.word	0x1000057d

000065a8 <rx_task_reset>:
	SCHED_ITEM(rx_execute,  -3, 0, 0), 	SCHED_END_FRAME(),	// 2
	SCHED_END_SET()
};

void rx_task_reset(void)
{
    65a8:	b510      	push	{r4, lr}
	if (rx_task.rx_msg)
    65aa:	4c05      	ldr	r4, [pc, #20]	; (65c0 <rx_task_reset+0x18>)
    65ac:	68a0      	ldr	r0, [r4, #8]
    65ae:	b128      	cbz	r0, 65bc <rx_task_reset+0x14>
	btctl_mem_free(msg);
    65b0:	f001 fc5c 	bl	7e6c <mem_pool_free>
	{
		msg_free(rx_task.rx_msg);
		rx_task.rx_pkt = NULL;
		rx_task.rx_msg = NULL;
    65b4:	2200      	movs	r2, #0
    65b6:	2300      	movs	r3, #0
    65b8:	e9c4 2302 	strd	r2, r3, [r4, #8]
	}
}
    65bc:	bd10      	pop	{r4, pc}
    65be:	bf00      	nop
    65c0:	10000540 	.word	0x10000540

000065c4 <rx_task_schedule>:

void rx_task_schedule(unsigned delay, rx_task_cb_t cb, void*cbarg, unsigned flags)
{
    65c4:	b570      	push	{r4, r5, r6, lr}
	btctl_rx_pkt_t *pkt;

	/* Sanity check */
	if (rx_task.rx_msg)
    65c6:	4c0c      	ldr	r4, [pc, #48]	; (65f8 <rx_task_schedule+0x34>)
{
    65c8:	4615      	mov	r5, r2
	if (rx_task.rx_msg)
    65ca:	68a6      	ldr	r6, [r4, #8]
    65cc:	b986      	cbnz	r6, 65f0 <rx_task_schedule+0x2c>
	/* Does the packet have a payload ? (else it's an ID) */
	rx_task.do_rx_payload = flags & (1<<RX_F_PAYLOAD);
	/* Receive raw bursts for monitor state */
	rx_task.rx_raw = flags & (1<<RX_F_RAW);

	tdma_schedule_set(delay, rx_sched_set, 0);
    65ce:	4632      	mov	r2, r6
	rx_task.do_rx_payload = flags & (1<<RX_F_PAYLOAD);
    65d0:	f003 0601 	and.w	r6, r3, #1
	rx_task.rx_raw = flags & (1<<RX_F_RAW);
    65d4:	f003 0302 	and.w	r3, r3, #2
	rx_task.pkt_cb = cb;
    65d8:	6021      	str	r1, [r4, #0]
	rx_task.cb_arg = cbarg;
    65da:	6065      	str	r5, [r4, #4]
	rx_task.do_rx_payload = flags & (1<<RX_F_PAYLOAD);
    65dc:	f884 603c 	strb.w	r6, [r4, #60]	; 0x3c
	rx_task.rx_raw = flags & (1<<RX_F_RAW);
    65e0:	f884 3256 	strb.w	r3, [r4, #598]	; 0x256
	tdma_schedule_set(delay, rx_sched_set, 0);
    65e4:	4905      	ldr	r1, [pc, #20]	; (65fc <rx_task_schedule+0x38>)
    65e6:	b2c0      	uxtb	r0, r0
}
    65e8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	tdma_schedule_set(delay, rx_sched_set, 0);
    65ec:	f7ff bc3c 	b.w	5e68 <tdma_schedule_set>
		DIE("rx_schedule: rx_msg!=0");
    65f0:	4803      	ldr	r0, [pc, #12]	; (6600 <rx_task_schedule+0x3c>)
    65f2:	f001 fd0f 	bl	8014 <die>
    65f6:	bf00      	nop
    65f8:	10000540 	.word	0x10000540
    65fc:	0000dd0c 	.word	0x0000dd0c
    6600:	0000dcf0 	.word	0x0000dcf0

00006604 <inquiry_start_sync>:
		);
}

/* dummy tick handler to start TX'ing with a proper clock */
static int inquiry_start_sync(uint8_t p1, uint8_t p2, uint16_t p3)
{
    6604:	b530      	push	{r4, r5, lr}
    6606:	b083      	sub	sp, #12
	unsigned delay;

	/* Use the master clkn */
	btphy_cancel_clkn_delay();
    6608:	f7ff fad4 	bl	5bb4 <btphy_cancel_clkn_delay>
	delay = 4+(3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    660c:	4b14      	ldr	r3, [pc, #80]	; (6660 <inquiry_start_sync+0x5c>)
	inquiry_state.clkn_start = btphy.master_clkn+delay;
    660e:	4d15      	ldr	r5, [pc, #84]	; (6664 <inquiry_start_sync+0x60>)
	delay = 4+(3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    6610:	685a      	ldr	r2, [r3, #4]
    6612:	43d4      	mvns	r4, r2
    6614:	f004 0403 	and.w	r4, r4, #3
    6618:	1d20      	adds	r0, r4, #4
	inquiry_state.clkn_start = btphy.master_clkn+delay;
    661a:	1811      	adds	r1, r2, r0
	if (btphy.master_clkn >= inquiry_state.clkn_start + INQ_MAX_TICKS)
    661c:	f501 333b 	add.w	r3, r1, #191488	; 0x2ec00
    6620:	f503 7300 	add.w	r3, r3, #512	; 0x200
    6624:	429a      	cmp	r2, r3
	inquiry_state.clkn_start = btphy.master_clkn+delay;
    6626:	6029      	str	r1, [r5, #0]
	if (btphy.master_clkn >= inquiry_state.clkn_start + INQ_MAX_TICKS)
    6628:	d20f      	bcs.n	664a <inquiry_start_sync+0x46>
	tx_task_schedule(delay,
    662a:	2500      	movs	r5, #0
    662c:	462b      	mov	r3, r5
    662e:	462a      	mov	r2, r5
    6630:	4629      	mov	r1, r5
    6632:	9500      	str	r5, [sp, #0]
    6634:	f000 fc62 	bl	6efc <tx_task_schedule>
	rx_task_schedule(delay+2,
    6638:	1da0      	adds	r0, r4, #6
    663a:	462a      	mov	r2, r5
    663c:	2301      	movs	r3, #1
    663e:	490a      	ldr	r1, [pc, #40]	; (6668 <inquiry_start_sync+0x64>)
    6640:	f7ff ffc0 	bl	65c4 <rx_task_schedule>
	inquiry_schedule(delay);
	return 0;
}
    6644:	2000      	movs	r0, #0
    6646:	b003      	add	sp, #12
    6648:	bd30      	pop	{r4, r5, pc}
		cprintf("inquiry timeout\n");
    664a:	4808      	ldr	r0, [pc, #32]	; (666c <inquiry_start_sync+0x68>)
    664c:	f002 fde2 	bl	9214 <cprintf>
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
    6650:	2101      	movs	r1, #1
    6652:	2000      	movs	r0, #0
    6654:	f7ff f828 	bl	56a8 <btctl_set_state>
}
    6658:	2000      	movs	r0, #0
    665a:	b003      	add	sp, #12
    665c:	bd30      	pop	{r4, r5, pc}
    665e:	bf00      	nop
    6660:	100001b0 	.word	0x100001b0
    6664:	10000798 	.word	0x10000798
    6668:	00006671 	.word	0x00006671
    666c:	0000dd48 	.word	0x0000dd48

00006670 <inquiry_rx_cb>:
{
    6670:	b5f0      	push	{r4, r5, r6, r7, lr}
    6672:	b083      	sub	sp, #12
	return btctl.state;
    6674:	4b39      	ldr	r3, [pc, #228]	; (675c <inquiry_rx_cb+0xec>)
    6676:	4604      	mov	r4, r0
	if (inquiry_canceled())
    6678:	781e      	ldrb	r6, [r3, #0]
    667a:	2e01      	cmp	r6, #1
    667c:	d150      	bne.n	6720 <inquiry_rx_cb+0xb0>
	if (h->type != BTCTL_RX_PKT)
    667e:	7b03      	ldrb	r3, [r0, #12]
    6680:	2b28      	cmp	r3, #40	; 0x28
    6682:	d168      	bne.n	6756 <inquiry_rx_cb+0xe6>
	if (!BBPKT_GOOD_CRC(pkt))
    6684:	7d42      	ldrb	r2, [r0, #21]
    6686:	f012 0508 	ands.w	r5, r2, #8
    668a:	d02a      	beq.n	66e2 <inquiry_rx_cb+0x72>
		if (pkt->bb_hdr.type == BB_TYPE_FHS)
    668c:	7e40      	ldrb	r0, [r0, #25]
    668e:	2802      	cmp	r0, #2
    6690:	d05b      	beq.n	674a <inquiry_rx_cb+0xda>
	if (btphy.master_clkn >= inquiry_state.clkn_start + INQ_MAX_TICKS)
    6692:	4b33      	ldr	r3, [pc, #204]	; (6760 <inquiry_rx_cb+0xf0>)
			inquiry_schedule(3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    6694:	4a33      	ldr	r2, [pc, #204]	; (6764 <inquiry_rx_cb+0xf4>)
	if (btphy.master_clkn >= inquiry_state.clkn_start + INQ_MAX_TICKS)
    6696:	681b      	ldr	r3, [r3, #0]
			inquiry_schedule(3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    6698:	6850      	ldr	r0, [r2, #4]
	if (btphy.master_clkn >= inquiry_state.clkn_start + INQ_MAX_TICKS)
    669a:	f503 333b 	add.w	r3, r3, #191488	; 0x2ec00
    669e:	f503 7300 	add.w	r3, r3, #512	; 0x200
    66a2:	4298      	cmp	r0, r3
    66a4:	d241      	bcs.n	672a <inquiry_rx_cb+0xba>
			inquiry_schedule(3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    66a6:	43c0      	mvns	r0, r0
	tx_task_schedule(delay,
    66a8:	2700      	movs	r7, #0
			inquiry_schedule(3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    66aa:	f000 0503 	and.w	r5, r0, #3
	tx_task_schedule(delay,
    66ae:	4628      	mov	r0, r5
    66b0:	463b      	mov	r3, r7
    66b2:	463a      	mov	r2, r7
    66b4:	4639      	mov	r1, r7
    66b6:	9700      	str	r7, [sp, #0]
    66b8:	f000 fc20 	bl	6efc <tx_task_schedule>
	rx_task_schedule(delay+2,
    66bc:	4633      	mov	r3, r6
    66be:	463a      	mov	r2, r7
    66c0:	4929      	ldr	r1, [pc, #164]	; (6768 <inquiry_rx_cb+0xf8>)
    66c2:	1ca8      	adds	r0, r5, #2
    66c4:	f7ff ff7e 	bl	65c4 <rx_task_schedule>
	__asm__ __volatile__ (
    66c8:	f3ef 8510 	mrs	r5, PRIMASK
    66cc:	b672      	cpsid	i
	rc = msg_enqueue(q, msg);
    66ce:	4827      	ldr	r0, [pc, #156]	; (676c <inquiry_rx_cb+0xfc>)
    66d0:	4621      	mov	r1, r4
    66d2:	f001 fd29 	bl	8128 <msg_enqueue>
	__asm__ __volatile__ (
    66d6:	f385 8810 	msr	PRIMASK, r5
		if (btctl_tx_enqueue(msg))
    66da:	b318      	cbz	r0, 6724 <inquiry_rx_cb+0xb4>
			DIE("txq full in inquiry\n");
    66dc:	4824      	ldr	r0, [pc, #144]	; (6770 <inquiry_rx_cb+0x100>)
    66de:	f001 fc99 	bl	8014 <die>
    66e2:	f001 fbc3 	bl	7e6c <mem_pool_free>
	if (btphy.master_clkn >= inquiry_state.clkn_start + INQ_MAX_TICKS)
    66e6:	4b1e      	ldr	r3, [pc, #120]	; (6760 <inquiry_rx_cb+0xf0>)
		inquiry_schedule(3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));	// schedule tx in next slot
    66e8:	4a1e      	ldr	r2, [pc, #120]	; (6764 <inquiry_rx_cb+0xf4>)
	if (btphy.master_clkn >= inquiry_state.clkn_start + INQ_MAX_TICKS)
    66ea:	681b      	ldr	r3, [r3, #0]
		inquiry_schedule(3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));	// schedule tx in next slot
    66ec:	6850      	ldr	r0, [r2, #4]
	if (btphy.master_clkn >= inquiry_state.clkn_start + INQ_MAX_TICKS)
    66ee:	f503 333b 	add.w	r3, r3, #191488	; 0x2ec00
    66f2:	f503 7300 	add.w	r3, r3, #512	; 0x200
    66f6:	4298      	cmp	r0, r3
    66f8:	d21f      	bcs.n	673a <inquiry_rx_cb+0xca>
		inquiry_schedule(3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));	// schedule tx in next slot
    66fa:	43c0      	mvns	r0, r0
    66fc:	f000 0403 	and.w	r4, r0, #3
	tx_task_schedule(delay,
    6700:	4620      	mov	r0, r4
    6702:	462b      	mov	r3, r5
    6704:	462a      	mov	r2, r5
    6706:	4629      	mov	r1, r5
    6708:	9500      	str	r5, [sp, #0]
    670a:	f000 fbf7 	bl	6efc <tx_task_schedule>
	rx_task_schedule(delay+2,
    670e:	1ca0      	adds	r0, r4, #2
    6710:	4633      	mov	r3, r6
    6712:	462a      	mov	r2, r5
    6714:	4914      	ldr	r1, [pc, #80]	; (6768 <inquiry_rx_cb+0xf8>)
    6716:	f7ff ff55 	bl	65c4 <rx_task_schedule>
}
    671a:	2000      	movs	r0, #0
    671c:	b003      	add	sp, #12
    671e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6720:	f001 fba4 	bl	7e6c <mem_pool_free>
    6724:	2000      	movs	r0, #0
    6726:	b003      	add	sp, #12
    6728:	bdf0      	pop	{r4, r5, r6, r7, pc}
		cprintf("inquiry timeout\n");
    672a:	4812      	ldr	r0, [pc, #72]	; (6774 <inquiry_rx_cb+0x104>)
    672c:	f002 fd72 	bl	9214 <cprintf>
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
    6730:	4631      	mov	r1, r6
    6732:	2000      	movs	r0, #0
    6734:	f7fe ffb8 	bl	56a8 <btctl_set_state>
		return;
    6738:	e7c6      	b.n	66c8 <inquiry_rx_cb+0x58>
		cprintf("inquiry timeout\n");
    673a:	480e      	ldr	r0, [pc, #56]	; (6774 <inquiry_rx_cb+0x104>)
    673c:	f002 fd6a 	bl	9214 <cprintf>
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
    6740:	4631      	mov	r1, r6
    6742:	4628      	mov	r0, r5
    6744:	f7fe ffb0 	bl	56a8 <btctl_set_state>
		return;
    6748:	e7ec      	b.n	6724 <inquiry_rx_cb+0xb4>
			rx_task_schedule(2,
    674a:	4633      	mov	r3, r6
    674c:	2200      	movs	r2, #0
    674e:	4906      	ldr	r1, [pc, #24]	; (6768 <inquiry_rx_cb+0xf8>)
    6750:	f7ff ff38 	bl	65c4 <rx_task_schedule>
    6754:	e7b8      	b.n	66c8 <inquiry_rx_cb+0x58>
		DIE("paging : expect acl rx");
    6756:	4808      	ldr	r0, [pc, #32]	; (6778 <inquiry_rx_cb+0x108>)
    6758:	f001 fc5c 	bl	8014 <die>
    675c:	100023dc 	.word	0x100023dc
    6760:	10000798 	.word	0x10000798
    6764:	100001b0 	.word	0x100001b0
    6768:	00006671 	.word	0x00006671
    676c:	10002408 	.word	0x10002408
    6770:	0000dd78 	.word	0x0000dd78
    6774:	0000dd48 	.word	0x0000dd48
    6778:	0000dd5c 	.word	0x0000dd5c

0000677c <inquiry_state_setup>:

/*
 * Inquiry master
 */
void inquiry_state_setup(void)
{
    677c:	b510      	push	{r4, lr}
    677e:	b082      	sub	sp, #8
	/* Init only with the lap, DCI(0) is used as UAP */
	btphy_set_mode(BT_MODE_INQUIRY, GIAC, 0);
    6780:	2200      	movs	r2, #0
    6782:	490b      	ldr	r1, [pc, #44]	; (67b0 <inquiry_state_setup+0x34>)
    6784:	4610      	mov	r0, r2
    6786:	f7ff fa53 	bl	5c30 <btphy_set_mode>

	tdma_schedule(2, inquiry_start_sync, 0,0,0,-3);
    678a:	2400      	movs	r4, #0
    678c:	f06f 0302 	mvn.w	r3, #2
    6790:	4622      	mov	r2, r4
    6792:	e9cd 4300 	strd	r4, r3, [sp]
    6796:	4907      	ldr	r1, [pc, #28]	; (67b4 <inquiry_state_setup+0x38>)
    6798:	4623      	mov	r3, r4
    679a:	2002      	movs	r0, #2
    679c:	f7ff fb32 	bl	5e04 <tdma_schedule>
	btctl_set_state(BTCTL_STATE_INQUIRY, BTCTL_REASON_SUCCESS);
    67a0:	4621      	mov	r1, r4
    67a2:	2001      	movs	r0, #1
}
    67a4:	b002      	add	sp, #8
    67a6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	btctl_set_state(BTCTL_STATE_INQUIRY, BTCTL_REASON_SUCCESS);
    67aa:	f7fe bf7d 	b.w	56a8 <btctl_set_state>
    67ae:	bf00      	nop
    67b0:	009e8b33 	.word	0x009e8b33
    67b4:	00006605 	.word	0x00006605

000067b8 <paging_rx_cb>:
	return 0;
}

/* We received the ID(2) from paged device */
static int paging_rx_cb(msg_t *msg, void *arg, int time_offset)
{
    67b8:	b570      	push	{r4, r5, r6, lr}
    67ba:	b082      	sub	sp, #8
	return btctl.state;
    67bc:	4b27      	ldr	r3, [pc, #156]	; (685c <paging_rx_cb+0xa4>)
    67be:	4604      	mov	r4, r0
	btctl_hdr_t *h = (btctl_hdr_t*)msg->data;
	btctl_rx_pkt_t *pkt;
	unsigned delay; 

	if (paging_canceled())
    67c0:	781b      	ldrb	r3, [r3, #0]
    67c2:	2b02      	cmp	r3, #2
    67c4:	d11c      	bne.n	6800 <paging_rx_cb+0x48>
		goto end;
	pkt = (btctl_rx_pkt_t *)h->data;

	if (BBPKT_HAS_PKT(pkt))
    67c6:	7d43      	ldrb	r3, [r0, #21]
    67c8:	f013 0501 	ands.w	r5, r3, #1
    67cc:	d01e      	beq.n	680c <paging_rx_cb+0x54>
	{
		/* We received the slave's ID(2) at t'(k).
		 * Send FHS in next slot and start basic hopping
		 * The FHS shall be sent on chan f(k+1), following the std paging hop
		 * */
		delay = 3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX());
    67ce:	4b24      	ldr	r3, [pc, #144]	; (6860 <paging_rx_cb+0xa8>)

		/* Write clk27_2 in fhs payload
		 * Will tx at (clkn+1) */
		bbpkt_fhs_finalize_payload(paging_state.fhs_data, (btphy.master_clkn+delay+1)>>2);
    67d0:	4e24      	ldr	r6, [pc, #144]	; (6864 <paging_rx_cb+0xac>)
		delay = 3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX());
    67d2:	6859      	ldr	r1, [r3, #4]
		bbpkt_fhs_finalize_payload(paging_state.fhs_data, (btphy.master_clkn+delay+1)>>2);
    67d4:	4630      	mov	r0, r6
		delay = 3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX());
    67d6:	43cd      	mvns	r5, r1
		bbpkt_fhs_finalize_payload(paging_state.fhs_data, (btphy.master_clkn+delay+1)>>2);
    67d8:	3101      	adds	r1, #1
		delay = 3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX());
    67da:	f005 0503 	and.w	r5, r5, #3
		bbpkt_fhs_finalize_payload(paging_state.fhs_data, (btphy.master_clkn+delay+1)>>2);
    67de:	4429      	add	r1, r5
    67e0:	0889      	lsrs	r1, r1, #2
    67e2:	f7fd fd5b 	bl	429c <bbpkt_fhs_finalize_payload>

		/* Schedule tx masters's page response (FHS): */
		tx_task_schedule(delay, 	// must schedule tx_prepare now to start tx in next clkn
    67e6:	2200      	movs	r2, #0
    67e8:	4628      	mov	r0, r5
    67ea:	4611      	mov	r1, r2
    67ec:	1f33      	subs	r3, r6, #4
    67ee:	9600      	str	r6, [sp, #0]
    67f0:	f000 fb84 	bl	6efc <tx_task_schedule>
			NULL, NULL,
			/* skip 4 bytes of sw */
			&paging_state.fhs_hdr, paging_state.fhs_data);

		/* Schedule rx slave's ID(3) page response: */
		rx_task_schedule(delay+2,
    67f4:	2300      	movs	r3, #0
    67f6:	491c      	ldr	r1, [pc, #112]	; (6868 <paging_rx_cb+0xb0>)
    67f8:	461a      	mov	r2, r3
    67fa:	1ca8      	adds	r0, r5, #2
    67fc:	f7ff fee2 	bl	65c4 <rx_task_schedule>
    6800:	4620      	mov	r0, r4
    6802:	f001 fb33 	bl	7e6c <mem_pool_free>
		paging_schedule(3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
	}
end:
	msg_free(msg);
	return 0;
}
    6806:	2000      	movs	r0, #0
    6808:	b002      	add	sp, #8
    680a:	bd70      	pop	{r4, r5, r6, pc}

static void paging_schedule(unsigned delay)
{
	/* FIXME: wrap */
	if (btphy.master_clkn >= paging_state.clkn_start + PAGING_MAX_TICKS)
    680c:	4b17      	ldr	r3, [pc, #92]	; (686c <paging_rx_cb+0xb4>)
		paging_schedule(3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    680e:	4a14      	ldr	r2, [pc, #80]	; (6860 <paging_rx_cb+0xa8>)
	if (btphy.master_clkn >= paging_state.clkn_start + PAGING_MAX_TICKS)
    6810:	681b      	ldr	r3, [r3, #0]
		paging_schedule(3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    6812:	6850      	ldr	r0, [r2, #4]
	if (btphy.master_clkn >= paging_state.clkn_start + PAGING_MAX_TICKS)
    6814:	f503 330c 	add.w	r3, r3, #143360	; 0x23000
    6818:	f503 7320 	add.w	r3, r3, #640	; 0x280
    681c:	4298      	cmp	r0, r3
    681e:	d215      	bcs.n	684c <paging_rx_cb+0x94>
		paging_schedule(3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    6820:	43c0      	mvns	r0, r0
    6822:	f000 0603 	and.w	r6, r0, #3
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
		return;
	}

	/* Schedule TX ID(1) */
	tx_task_schedule(delay,
    6826:	4630      	mov	r0, r6
    6828:	462b      	mov	r3, r5
    682a:	462a      	mov	r2, r5
    682c:	4629      	mov	r1, r5
    682e:	9500      	str	r5, [sp, #0]
    6830:	f000 fb64 	bl	6efc <tx_task_schedule>
		NULL, NULL,	// no tx callback
		NULL, NULL); 	// no header / no payload

	/* Schedule rx ID(2): */
	rx_task_schedule(delay+2,
    6834:	462b      	mov	r3, r5
    6836:	462a      	mov	r2, r5
    6838:	490d      	ldr	r1, [pc, #52]	; (6870 <paging_rx_cb+0xb8>)
    683a:	1cb0      	adds	r0, r6, #2
    683c:	f7ff fec2 	bl	65c4 <rx_task_schedule>
    6840:	4620      	mov	r0, r4
    6842:	f001 fb13 	bl	7e6c <mem_pool_free>
}
    6846:	2000      	movs	r0, #0
    6848:	b002      	add	sp, #8
    684a:	bd70      	pop	{r4, r5, r6, pc}
		cprintf("paging timeout\n");
    684c:	4809      	ldr	r0, [pc, #36]	; (6874 <paging_rx_cb+0xbc>)
    684e:	f002 fce1 	bl	9214 <cprintf>
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
    6852:	4628      	mov	r0, r5
    6854:	2101      	movs	r1, #1
    6856:	f7fe ff27 	bl	56a8 <btctl_set_state>
		return;
    685a:	e7d1      	b.n	6800 <paging_rx_cb+0x48>
    685c:	100023dc 	.word	0x100023dc
    6860:	100001b0 	.word	0x100001b0
    6864:	100007a4 	.word	0x100007a4
    6868:	000068e5 	.word	0x000068e5
    686c:	1000079c 	.word	0x1000079c
    6870:	000067b9 	.word	0x000067b9
    6874:	0000dd94 	.word	0x0000dd94

00006878 <paging_start_sync>:
		);
}

/* dummy tick handler to start TX'ing with a proper clock */
static int paging_start_sync(uint8_t p1, uint8_t p2, uint16_t p3)
{
    6878:	b530      	push	{r4, r5, lr}
    687a:	b083      	sub	sp, #12
	unsigned delay;

	/* Use the master clkn */
	btphy_cancel_clkn_delay();
    687c:	f7ff f99a 	bl	5bb4 <btphy_cancel_clkn_delay>
	delay = 4+(3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    6880:	4b14      	ldr	r3, [pc, #80]	; (68d4 <paging_start_sync+0x5c>)
	paging_state.clkn_start = btphy.master_clkn+delay;
    6882:	4d15      	ldr	r5, [pc, #84]	; (68d8 <paging_start_sync+0x60>)
	delay = 4+(3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    6884:	685a      	ldr	r2, [r3, #4]
    6886:	43d4      	mvns	r4, r2
    6888:	f004 0403 	and.w	r4, r4, #3
    688c:	1d20      	adds	r0, r4, #4
	paging_state.clkn_start = btphy.master_clkn+delay;
    688e:	1811      	adds	r1, r2, r0
	if (btphy.master_clkn >= paging_state.clkn_start + PAGING_MAX_TICKS)
    6890:	f501 330c 	add.w	r3, r1, #143360	; 0x23000
    6894:	f503 7320 	add.w	r3, r3, #640	; 0x280
    6898:	429a      	cmp	r2, r3
	paging_state.clkn_start = btphy.master_clkn+delay;
    689a:	6029      	str	r1, [r5, #0]
	if (btphy.master_clkn >= paging_state.clkn_start + PAGING_MAX_TICKS)
    689c:	d20f      	bcs.n	68be <paging_start_sync+0x46>
	tx_task_schedule(delay,
    689e:	2500      	movs	r5, #0
    68a0:	462b      	mov	r3, r5
    68a2:	462a      	mov	r2, r5
    68a4:	4629      	mov	r1, r5
    68a6:	9500      	str	r5, [sp, #0]
    68a8:	f000 fb28 	bl	6efc <tx_task_schedule>
	rx_task_schedule(delay+2,
    68ac:	1da0      	adds	r0, r4, #6
    68ae:	462b      	mov	r3, r5
    68b0:	462a      	mov	r2, r5
    68b2:	490a      	ldr	r1, [pc, #40]	; (68dc <paging_start_sync+0x64>)
    68b4:	f7ff fe86 	bl	65c4 <rx_task_schedule>
	paging_schedule(delay);
	return 0;
}
    68b8:	2000      	movs	r0, #0
    68ba:	b003      	add	sp, #12
    68bc:	bd30      	pop	{r4, r5, pc}
		cprintf("paging timeout\n");
    68be:	4808      	ldr	r0, [pc, #32]	; (68e0 <paging_start_sync+0x68>)
    68c0:	f002 fca8 	bl	9214 <cprintf>
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
    68c4:	2101      	movs	r1, #1
    68c6:	2000      	movs	r0, #0
    68c8:	f7fe feee 	bl	56a8 <btctl_set_state>
}
    68cc:	2000      	movs	r0, #0
    68ce:	b003      	add	sp, #12
    68d0:	bd30      	pop	{r4, r5, pc}
    68d2:	bf00      	nop
    68d4:	100001b0 	.word	0x100001b0
    68d8:	1000079c 	.word	0x1000079c
    68dc:	000067b9 	.word	0x000067b9
    68e0:	0000dd94 	.word	0x0000dd94

000068e4 <paging_rx_ack_cb>:
{
    68e4:	b570      	push	{r4, r5, r6, lr}
    68e6:	b082      	sub	sp, #8
    68e8:	4b21      	ldr	r3, [pc, #132]	; (6970 <paging_rx_ack_cb+0x8c>)
    68ea:	4604      	mov	r4, r0
	if (paging_canceled())
    68ec:	781b      	ldrb	r3, [r3, #0]
    68ee:	2b02      	cmp	r3, #2
    68f0:	d120      	bne.n	6934 <paging_rx_ack_cb+0x50>
	if (BBPKT_HAS_PKT(pkt))
    68f2:	7d43      	ldrb	r3, [r0, #21]
    68f4:	f013 0501 	ands.w	r5, r3, #1
    68f8:	d122      	bne.n	6940 <paging_rx_ack_cb+0x5c>
		cprintf("no ID(3)\n");
    68fa:	481e      	ldr	r0, [pc, #120]	; (6974 <paging_rx_ack_cb+0x90>)
    68fc:	f002 fc8a 	bl	9214 <cprintf>
	if (btphy.master_clkn >= paging_state.clkn_start + PAGING_MAX_TICKS)
    6900:	4b1d      	ldr	r3, [pc, #116]	; (6978 <paging_rx_ack_cb+0x94>)
		paging_schedule(3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    6902:	4a1e      	ldr	r2, [pc, #120]	; (697c <paging_rx_ack_cb+0x98>)
	if (btphy.master_clkn >= paging_state.clkn_start + PAGING_MAX_TICKS)
    6904:	681b      	ldr	r3, [r3, #0]
		paging_schedule(3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    6906:	6850      	ldr	r0, [r2, #4]
	if (btphy.master_clkn >= paging_state.clkn_start + PAGING_MAX_TICKS)
    6908:	f503 330c 	add.w	r3, r3, #143360	; 0x23000
    690c:	f503 7320 	add.w	r3, r3, #640	; 0x280
    6910:	4298      	cmp	r0, r3
    6912:	d220      	bcs.n	6956 <paging_rx_ack_cb+0x72>
		paging_schedule(3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    6914:	43c0      	mvns	r0, r0
    6916:	f000 0603 	and.w	r6, r0, #3
	tx_task_schedule(delay,
    691a:	4630      	mov	r0, r6
    691c:	462b      	mov	r3, r5
    691e:	462a      	mov	r2, r5
    6920:	4629      	mov	r1, r5
    6922:	9500      	str	r5, [sp, #0]
    6924:	f000 faea 	bl	6efc <tx_task_schedule>
	rx_task_schedule(delay+2,
    6928:	462b      	mov	r3, r5
    692a:	462a      	mov	r2, r5
    692c:	4914      	ldr	r1, [pc, #80]	; (6980 <paging_rx_ack_cb+0x9c>)
    692e:	1cb0      	adds	r0, r6, #2
    6930:	f7ff fe48 	bl	65c4 <rx_task_schedule>
    6934:	4620      	mov	r0, r4
    6936:	f001 fa99 	bl	7e6c <mem_pool_free>
}
    693a:	2000      	movs	r0, #0
    693c:	b002      	add	sp, #8
    693e:	bd70      	pop	{r4, r5, r6, pc}
		cprintf("ID(3)\n");
    6940:	4810      	ldr	r0, [pc, #64]	; (6984 <paging_rx_ack_cb+0xa0>)
    6942:	f002 fc67 	bl	9214 <cprintf>
		master_state_init();
    6946:	f000 f8b7 	bl	6ab8 <master_state_init>
    694a:	4620      	mov	r0, r4
    694c:	f001 fa8e 	bl	7e6c <mem_pool_free>
}
    6950:	2000      	movs	r0, #0
    6952:	b002      	add	sp, #8
    6954:	bd70      	pop	{r4, r5, r6, pc}
		cprintf("paging timeout\n");
    6956:	480c      	ldr	r0, [pc, #48]	; (6988 <paging_rx_ack_cb+0xa4>)
    6958:	f002 fc5c 	bl	9214 <cprintf>
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
    695c:	4628      	mov	r0, r5
    695e:	2101      	movs	r1, #1
    6960:	f7fe fea2 	bl	56a8 <btctl_set_state>
    6964:	4620      	mov	r0, r4
    6966:	f001 fa81 	bl	7e6c <mem_pool_free>
}
    696a:	2000      	movs	r0, #0
    696c:	b002      	add	sp, #8
    696e:	bd70      	pop	{r4, r5, r6, pc}
    6970:	100023dc 	.word	0x100023dc
    6974:	0000ddac 	.word	0x0000ddac
    6978:	1000079c 	.word	0x1000079c
    697c:	100001b0 	.word	0x100001b0
    6980:	000067b9 	.word	0x000067b9
    6984:	0000dda4 	.word	0x0000dda4
    6988:	0000dd94 	.word	0x0000dd94

0000698c <paging_state_setup>:
 * k 4: Tx FHS packet with sw of paged device
 *	if contains master's (low_sw, lap, nap, uap, etc.), and clk27_2 sampled at start of tx.
 * k 6: Rx ID(3) from the slave, and start master task.
 */
void paging_state_setup(uint32_t lap, uint8_t uap)
{
    698c:	b530      	push	{r4, r5, lr}
    698e:	b087      	sub	sp, #28
    6990:	4603      	mov	r3, r0
	btphy_set_mode(BT_MODE_PAGING, lap, uap);

	/* A simple Header for our fhs */ 
	paging_state.fhs_hdr.lt_addr = 0;		//  This seems right
	paging_state.fhs_hdr.type = BB_TYPE_FHS;
	paging_state.fhs_hdr.flags = 0; 		// Depends on devices, some sends BTHDR_FLOW|BTHDR_SEQN, others send 0, both seems right
    6992:	2400      	movs	r4, #0
{
    6994:	460a      	mov	r2, r1
	btphy_set_mode(BT_MODE_PAGING, lap, uap);
    6996:	2001      	movs	r0, #1
    6998:	4619      	mov	r1, r3
    699a:	f7ff f949 	bl	5c30 <btphy_set_mode>

	/* Prepare constant part of FHS payload */
	bbpkt_fhs_prepare_payload(paging_state.fhs_data,
    699e:	2201      	movs	r2, #1
	paging_state.fhs_hdr.lt_addr = 0;		//  This seems right
    69a0:	f44f 7500 	mov.w	r5, #512	; 0x200
		btphy.my_sw&0xffffffff, 	// parity: low32 bits of master's sw
    69a4:	4b12      	ldr	r3, [pc, #72]	; (69f0 <paging_state_setup+0x64>)
	paging_state.fhs_hdr.lt_addr = 0;		//  This seems right
    69a6:	4913      	ldr	r1, [pc, #76]	; (69f4 <paging_state_setup+0x68>)
	bbpkt_fhs_prepare_payload(paging_state.fhs_data,
    69a8:	8f58      	ldrh	r0, [r3, #58]	; 0x3a
    69aa:	9405      	str	r4, [sp, #20]
    69ac:	9002      	str	r0, [sp, #8]
    69ae:	f893 0038 	ldrb.w	r0, [r3, #56]	; 0x38
    69b2:	9204      	str	r2, [sp, #16]
    69b4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    69b6:	9001      	str	r0, [sp, #4]
    69b8:	480f      	ldr	r0, [pc, #60]	; (69f8 <paging_state_setup+0x6c>)
    69ba:	9200      	str	r2, [sp, #0]
    69bc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    69be:	9003      	str	r0, [sp, #12]
    69c0:	4623      	mov	r3, r4
    69c2:	f101 0008 	add.w	r0, r1, #8
	paging_state.fhs_hdr.flags = 0; 		// Depends on devices, some sends BTHDR_FLOW|BTHDR_SEQN, others send 0, both seems right
    69c6:	718c      	strb	r4, [r1, #6]
	paging_state.fhs_hdr.lt_addr = 0;		//  This seems right
    69c8:	808d      	strh	r5, [r1, #4]
	bbpkt_fhs_prepare_payload(paging_state.fhs_data,
    69ca:	f7fd fc37 	bl	423c <bbpkt_fhs_prepare_payload>
		0x5A020C,		// class: FIXME make this configurable
		1,			// lt_addr: FIXME: fixed ltaddr = 1
		0 // No eir
		);

	tdma_schedule(2, paging_start_sync, 0,0,0,-3);
    69ce:	f06f 0102 	mvn.w	r1, #2
    69d2:	4623      	mov	r3, r4
    69d4:	9101      	str	r1, [sp, #4]
    69d6:	4622      	mov	r2, r4
    69d8:	4908      	ldr	r1, [pc, #32]	; (69fc <paging_state_setup+0x70>)
    69da:	9400      	str	r4, [sp, #0]
    69dc:	2002      	movs	r0, #2
    69de:	f7ff fa11 	bl	5e04 <tdma_schedule>
	btctl_set_state(BTCTL_STATE_PAGE, BTCTL_REASON_SUCCESS);
    69e2:	4621      	mov	r1, r4
    69e4:	2002      	movs	r0, #2
}
    69e6:	b007      	add	sp, #28
    69e8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	btctl_set_state(BTCTL_STATE_PAGE, BTCTL_REASON_SUCCESS);
    69ec:	f7fe be5c 	b.w	56a8 <btctl_set_state>
    69f0:	100001b0 	.word	0x100001b0
    69f4:	1000079c 	.word	0x1000079c
    69f8:	005a020c 	.word	0x005a020c
    69fc:	00006879 	.word	0x00006879

00006a00 <tx_done_cb>:
{
	/* Wait for next rx slot */
	unsigned delay = 4*skip_slots+(3&(RX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));

	/* Schedule rx: */
	rx_task_schedule(delay,
    6a00:	2301      	movs	r3, #1
	unsigned delay = 4*skip_slots+(3&(RX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    6a02:	4a04      	ldr	r2, [pc, #16]	; (6a14 <tx_done_cb+0x14>)
	rx_task_schedule(delay,
    6a04:	4904      	ldr	r1, [pc, #16]	; (6a18 <tx_done_cb+0x18>)
	unsigned delay = 4*skip_slots+(3&(RX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    6a06:	6850      	ldr	r0, [r2, #4]
	rx_task_schedule(delay,
    6a08:	2200      	movs	r2, #0
	unsigned delay = 4*skip_slots+(3&(RX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    6a0a:	1a18      	subs	r0, r3, r0
	rx_task_schedule(delay,
    6a0c:	f000 0003 	and.w	r0, r0, #3
    6a10:	f7ff bdd8 	b.w	65c4 <rx_task_schedule>
    6a14:	100001b0 	.word	0x100001b0
    6a18:	00006a1d 	.word	0x00006a1d

00006a1c <master_rx_cb>:
{
    6a1c:	b510      	push	{r4, lr}
    6a1e:	b084      	sub	sp, #16
    6a20:	4b20      	ldr	r3, [pc, #128]	; (6aa4 <master_rx_cb+0x88>)
    6a22:	4601      	mov	r1, r0
	if (master_canceled())
    6a24:	781b      	ldrb	r3, [r3, #0]
    6a26:	2b03      	cmp	r3, #3
    6a28:	d007      	beq.n	6a3a <master_rx_cb+0x1e>
    6a2a:	f001 fa1f 	bl	7e6c <mem_pool_free>
		ll_reset(&master_state.ll);
    6a2e:	481e      	ldr	r0, [pc, #120]	; (6aa8 <master_rx_cb+0x8c>)
    6a30:	f7fe ffc2 	bl	59b8 <ll_reset>
}
    6a34:	2000      	movs	r0, #0
    6a36:	b004      	add	sp, #16
    6a38:	bd10      	pop	{r4, pc}
	rc = ll_process_rx(&master_state.ll, msg);
    6a3a:	481b      	ldr	r0, [pc, #108]	; (6aa8 <master_rx_cb+0x8c>)
    6a3c:	f7fe fed4 	bl	57e8 <ll_process_rx>
	if (rc < 0)
    6a40:	1e04      	subs	r4, r0, #0
    6a42:	db0e      	blt.n	6a62 <master_rx_cb+0x46>
	else if (rc == 1)
    6a44:	2c01      	cmp	r4, #1
    6a46:	d017      	beq.n	6a78 <master_rx_cb+0x5c>
	rx_task_schedule(delay,
    6a48:	2301      	movs	r3, #1
	unsigned delay = 4*skip_slots+(3&(RX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    6a4a:	4a18      	ldr	r2, [pc, #96]	; (6aac <master_rx_cb+0x90>)
	rx_task_schedule(delay,
    6a4c:	4918      	ldr	r1, [pc, #96]	; (6ab0 <master_rx_cb+0x94>)
	unsigned delay = 4*skip_slots+(3&(RX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    6a4e:	6850      	ldr	r0, [r2, #4]
	rx_task_schedule(delay,
    6a50:	2200      	movs	r2, #0
	unsigned delay = 4*skip_slots+(3&(RX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    6a52:	1a18      	subs	r0, r3, r0
	rx_task_schedule(delay,
    6a54:	f000 0003 	and.w	r0, r0, #3
    6a58:	f7ff fdb4 	bl	65c4 <rx_task_schedule>
}
    6a5c:	2000      	movs	r0, #0
    6a5e:	b004      	add	sp, #16
    6a60:	bd10      	pop	{r4, pc}
		ll_reset(&master_state.ll);
    6a62:	4811      	ldr	r0, [pc, #68]	; (6aa8 <master_rx_cb+0x8c>)
    6a64:	f7fe ffa8 	bl	59b8 <ll_reset>
		btctl_set_state(BTCTL_STATE_STANDBY, -rc);
    6a68:	4261      	negs	r1, r4
    6a6a:	2000      	movs	r0, #0
    6a6c:	b2c9      	uxtb	r1, r1
    6a6e:	f7fe fe1b 	bl	56a8 <btctl_set_state>
}
    6a72:	2000      	movs	r0, #0
    6a74:	b004      	add	sp, #16
    6a76:	bd10      	pop	{r4, pc}
}

static void master_state_schedule_tx(unsigned skip_slots)
{
	/* Wait for next tx slot */
	unsigned delay = skip_slots * 4 + (3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    6a78:	4b0c      	ldr	r3, [pc, #48]	; (6aac <master_rx_cb+0x90>)
	bbhdr_t *tx_hdr;
	uint8_t *tx_data;

	ll_prepare_tx(&master_state.ll, &tx_hdr, &tx_data);
    6a7a:	aa03      	add	r2, sp, #12
	unsigned delay = skip_slots * 4 + (3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    6a7c:	685c      	ldr	r4, [r3, #4]
	ll_prepare_tx(&master_state.ll, &tx_hdr, &tx_data);
    6a7e:	a902      	add	r1, sp, #8
	unsigned delay = skip_slots * 4 + (3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    6a80:	43e4      	mvns	r4, r4
	ll_prepare_tx(&master_state.ll, &tx_hdr, &tx_data);
    6a82:	4809      	ldr	r0, [pc, #36]	; (6aa8 <master_rx_cb+0x8c>)
    6a84:	f7fe ff60 	bl	5948 <ll_prepare_tx>

	tx_task_schedule(delay,
    6a88:	9b03      	ldr	r3, [sp, #12]
	unsigned delay = skip_slots * 4 + (3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    6a8a:	f004 0403 	and.w	r4, r4, #3
	tx_task_schedule(delay,
    6a8e:	4620      	mov	r0, r4
    6a90:	9300      	str	r3, [sp, #0]
    6a92:	2200      	movs	r2, #0
    6a94:	9b02      	ldr	r3, [sp, #8]
    6a96:	4907      	ldr	r1, [pc, #28]	; (6ab4 <master_rx_cb+0x98>)
    6a98:	f000 fa30 	bl	6efc <tx_task_schedule>
}
    6a9c:	2000      	movs	r0, #0
    6a9e:	b004      	add	sp, #16
    6aa0:	bd10      	pop	{r4, pc}
    6aa2:	bf00      	nop
    6aa4:	100023dc 	.word	0x100023dc
    6aa8:	100007b8 	.word	0x100007b8
    6aac:	100001b0 	.word	0x100001b0
    6ab0:	00006a1d 	.word	0x00006a1d
    6ab4:	00006a01 	.word	0x00006a01

00006ab8 <master_state_init>:
		tx_hdr, tx_data);
}

/* Called by paging task once the slave acknowledged our FHS */
void master_state_init(void)
{
    6ab8:	b530      	push	{r4, r5, lr}
    6aba:	b085      	sub	sp, #20
	/* Initialize basic hopping from master's clock */
	btphy_set_mode(BT_MODE_MASTER, btphy.my_lap, btphy.my_uap);
    6abc:	4c13      	ldr	r4, [pc, #76]	; (6b0c <master_state_init+0x54>)
    6abe:	2004      	movs	r0, #4
    6ac0:	f894 2038 	ldrb.w	r2, [r4, #56]	; 0x38
    6ac4:	6b61      	ldr	r1, [r4, #52]	; 0x34
    6ac6:	f7ff f8b3 	bl	5c30 <btphy_set_mode>

	ll_init(&master_state.ll, 1, 1); // FIXME: fixed slave lt_addr = 1
    6aca:	2201      	movs	r2, #1
    6acc:	4d10      	ldr	r5, [pc, #64]	; (6b10 <master_state_init+0x58>)
    6ace:	4611      	mov	r1, r2
    6ad0:	4628      	mov	r0, r5
    6ad2:	f7fe ff7b 	bl	59cc <ll_init>

	/* We are already in sync, just schedule the first tx (in a while)*/
	cprintf("master started\n");
    6ad6:	480f      	ldr	r0, [pc, #60]	; (6b14 <master_state_init+0x5c>)
    6ad8:	f002 fb9c 	bl	9214 <cprintf>
	unsigned delay = skip_slots * 4 + (3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    6adc:	6864      	ldr	r4, [r4, #4]
	ll_prepare_tx(&master_state.ll, &tx_hdr, &tx_data);
    6ade:	4628      	mov	r0, r5
	unsigned delay = skip_slots * 4 + (3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    6ae0:	43e4      	mvns	r4, r4
	ll_prepare_tx(&master_state.ll, &tx_hdr, &tx_data);
    6ae2:	aa03      	add	r2, sp, #12
    6ae4:	a902      	add	r1, sp, #8
    6ae6:	f7fe ff2f 	bl	5948 <ll_prepare_tx>
	unsigned delay = skip_slots * 4 + (3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    6aea:	f004 0403 	and.w	r4, r4, #3
	tx_task_schedule(delay,
    6aee:	9b03      	ldr	r3, [sp, #12]
	unsigned delay = skip_slots * 4 + (3&(TX_PREPARE_IDX-CUR_MASTER_SLOT_IDX()));
    6af0:	3404      	adds	r4, #4
	tx_task_schedule(delay,
    6af2:	4620      	mov	r0, r4
    6af4:	2200      	movs	r2, #0
    6af6:	9300      	str	r3, [sp, #0]
    6af8:	4907      	ldr	r1, [pc, #28]	; (6b18 <master_state_init+0x60>)
    6afa:	9b02      	ldr	r3, [sp, #8]
    6afc:	f000 f9fe 	bl	6efc <tx_task_schedule>
	master_state_schedule_tx(1);
	btctl_set_state(BTCTL_STATE_CONNECTED, BTCTL_REASON_PAGED);
    6b00:	2102      	movs	r1, #2
    6b02:	2003      	movs	r0, #3
    6b04:	f7fe fdd0 	bl	56a8 <btctl_set_state>
}
    6b08:	b005      	add	sp, #20
    6b0a:	bd30      	pop	{r4, r5, pc}
    6b0c:	100001b0 	.word	0x100001b0
    6b10:	100007b8 	.word	0x100007b8
    6b14:	0000ddb8 	.word	0x0000ddb8
    6b18:	00006a01 	.word	0x00006a01

00006b1c <tx_done_cb>:
}

static void slave_state_schedule_rx(unsigned skip_slots)
{
	/* Wait for next rx slot */
	unsigned delay = 4*skip_slots+(3&(RX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX()));
    6b1c:	4a04      	ldr	r2, [pc, #16]	; (6b30 <tx_done_cb+0x14>)

	/* Schedule rx: */
	rx_task_schedule(delay,
    6b1e:	2301      	movs	r3, #1
	unsigned delay = 4*skip_slots+(3&(RX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX()));
    6b20:	6890      	ldr	r0, [r2, #8]
	rx_task_schedule(delay,
    6b22:	4904      	ldr	r1, [pc, #16]	; (6b34 <tx_done_cb+0x18>)
	unsigned delay = 4*skip_slots+(3&(RX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX()));
    6b24:	43c0      	mvns	r0, r0
	rx_task_schedule(delay,
    6b26:	2200      	movs	r2, #0
    6b28:	f000 0003 	and.w	r0, r0, #3
    6b2c:	f7ff bd4a 	b.w	65c4 <rx_task_schedule>
    6b30:	100001b0 	.word	0x100001b0
    6b34:	00006b39 	.word	0x00006b39

00006b38 <slave_rx_cb>:
{
    6b38:	b510      	push	{r4, lr}
    6b3a:	b084      	sub	sp, #16
    6b3c:	4b28      	ldr	r3, [pc, #160]	; (6be0 <slave_rx_cb+0xa8>)
    6b3e:	4604      	mov	r4, r0
	if (slave_state_canceled())
    6b40:	781b      	ldrb	r3, [r3, #0]
    6b42:	2b03      	cmp	r3, #3
    6b44:	d121      	bne.n	6b8a <slave_rx_cb+0x52>
	if (BBPKT_HAS_PKT(pkt))
    6b46:	7d43      	ldrb	r3, [r0, #21]
    6b48:	07db      	lsls	r3, r3, #31
    6b4a:	d414      	bmi.n	6b76 <slave_rx_cb+0x3e>
	rc = ll_process_rx(&slave_state.ll, msg);
    6b4c:	4621      	mov	r1, r4
    6b4e:	4825      	ldr	r0, [pc, #148]	; (6be4 <slave_rx_cb+0xac>)
    6b50:	f7fe fe4a 	bl	57e8 <ll_process_rx>
	if (rc < 0)
    6b54:	1e04      	subs	r4, r0, #0
    6b56:	db21      	blt.n	6b9c <slave_rx_cb+0x64>
	else if (rc == 1)
    6b58:	2c01      	cmp	r4, #1
    6b5a:	d02a      	beq.n	6bb2 <slave_rx_cb+0x7a>
	unsigned delay = 4*skip_slots+(3&(RX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX()));
    6b5c:	4a22      	ldr	r2, [pc, #136]	; (6be8 <slave_rx_cb+0xb0>)
	rx_task_schedule(delay,
    6b5e:	2301      	movs	r3, #1
	unsigned delay = 4*skip_slots+(3&(RX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX()));
    6b60:	6890      	ldr	r0, [r2, #8]
	rx_task_schedule(delay,
    6b62:	4922      	ldr	r1, [pc, #136]	; (6bec <slave_rx_cb+0xb4>)
	unsigned delay = 4*skip_slots+(3&(RX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX()));
    6b64:	43c0      	mvns	r0, r0
	rx_task_schedule(delay,
    6b66:	2200      	movs	r2, #0
    6b68:	f000 0003 	and.w	r0, r0, #3
    6b6c:	f7ff fd2a 	bl	65c4 <rx_task_schedule>
}
    6b70:	2000      	movs	r0, #0
    6b72:	b004      	add	sp, #16
    6b74:	bd10      	pop	{r4, pc}
		btphy_adj_clkn_delay(time_offset);
    6b76:	4610      	mov	r0, r2
    6b78:	f7ff f80a 	bl	5b90 <btphy_adj_clkn_delay>
	rc = ll_process_rx(&slave_state.ll, msg);
    6b7c:	4621      	mov	r1, r4
    6b7e:	4819      	ldr	r0, [pc, #100]	; (6be4 <slave_rx_cb+0xac>)
    6b80:	f7fe fe32 	bl	57e8 <ll_process_rx>
	if (rc < 0)
    6b84:	1e04      	subs	r4, r0, #0
    6b86:	dae7      	bge.n	6b58 <slave_rx_cb+0x20>
    6b88:	e008      	b.n	6b9c <slave_rx_cb+0x64>
		ll_reset(&slave_state.ll);
    6b8a:	4816      	ldr	r0, [pc, #88]	; (6be4 <slave_rx_cb+0xac>)
    6b8c:	f7fe ff14 	bl	59b8 <ll_reset>
    6b90:	4620      	mov	r0, r4
    6b92:	f001 f96b 	bl	7e6c <mem_pool_free>
}
    6b96:	2000      	movs	r0, #0
    6b98:	b004      	add	sp, #16
    6b9a:	bd10      	pop	{r4, pc}
		ll_reset(&slave_state.ll);
    6b9c:	4811      	ldr	r0, [pc, #68]	; (6be4 <slave_rx_cb+0xac>)
    6b9e:	f7fe ff0b 	bl	59b8 <ll_reset>
		btctl_set_state(BTCTL_STATE_STANDBY, -rc);
    6ba2:	4261      	negs	r1, r4
    6ba4:	2000      	movs	r0, #0
    6ba6:	b2c9      	uxtb	r1, r1
    6ba8:	f7fe fd7e 	bl	56a8 <btctl_set_state>
}
    6bac:	2000      	movs	r0, #0
    6bae:	b004      	add	sp, #16
    6bb0:	bd10      	pop	{r4, pc}
	unsigned delay = 4*skip_slots+(3&(TX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX()));
    6bb2:	4b0d      	ldr	r3, [pc, #52]	; (6be8 <slave_rx_cb+0xb0>)
	ll_prepare_tx(&slave_state.ll, &tx_hdr, &tx_data);
    6bb4:	aa03      	add	r2, sp, #12
	unsigned delay = 4*skip_slots+(3&(TX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX()));
    6bb6:	689c      	ldr	r4, [r3, #8]
	ll_prepare_tx(&slave_state.ll, &tx_hdr, &tx_data);
    6bb8:	a902      	add	r1, sp, #8
    6bba:	480a      	ldr	r0, [pc, #40]	; (6be4 <slave_rx_cb+0xac>)
    6bbc:	f7fe fec4 	bl	5948 <ll_prepare_tx>
	unsigned delay = 4*skip_slots+(3&(TX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX()));
    6bc0:	f1c4 0401 	rsb	r4, r4, #1
	tx_task_schedule(delay,
    6bc4:	9b03      	ldr	r3, [sp, #12]
	unsigned delay = 4*skip_slots+(3&(TX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX()));
    6bc6:	f004 0403 	and.w	r4, r4, #3
	tx_task_schedule(delay,
    6bca:	4620      	mov	r0, r4
    6bcc:	9300      	str	r3, [sp, #0]
    6bce:	2200      	movs	r2, #0
    6bd0:	9b02      	ldr	r3, [sp, #8]
    6bd2:	4907      	ldr	r1, [pc, #28]	; (6bf0 <slave_rx_cb+0xb8>)
    6bd4:	f000 f992 	bl	6efc <tx_task_schedule>
}
    6bd8:	2000      	movs	r0, #0
    6bda:	b004      	add	sp, #16
    6bdc:	bd10      	pop	{r4, pc}
    6bde:	bf00      	nop
    6be0:	100023dc 	.word	0x100023dc
    6be4:	100007ec 	.word	0x100007ec
    6be8:	100001b0 	.word	0x100001b0
    6bec:	00006b39 	.word	0x00006b39
    6bf0:	00006b1d 	.word	0x00006b1d

00006bf4 <slave_state_init>:
		1<<RX_F_PAYLOAD		// wait for header
	);
}

void slave_state_init(uint64_t master_bdaddr, uint8_t lt_addr)
{
    6bf4:	b570      	push	{r4, r5, r6, lr}
    6bf6:	4603      	mov	r3, r0
    6bf8:	4608      	mov	r0, r1
    6bfa:	4615      	mov	r5, r2
	slave_state.master_bdaddr = master_bdaddr;
    6bfc:	4c11      	ldr	r4, [pc, #68]	; (6c44 <slave_state_init+0x50>)
	slave_state.lt_addr = lt_addr;

	/* Initialize basic hopping from master's clock */
	btphy_set_mode(BT_MODE_SLAVE, master_bdaddr&0xffffff, 0xff & (master_bdaddr>>24));
    6bfe:	0e1a      	lsrs	r2, r3, #24
    6c00:	f023 417f 	bic.w	r1, r3, #4278190080	; 0xff000000
	slave_state.master_bdaddr = master_bdaddr;
    6c04:	6060      	str	r0, [r4, #4]
	btphy_set_mode(BT_MODE_SLAVE, master_bdaddr&0xffffff, 0xff & (master_bdaddr>>24));
    6c06:	2005      	movs	r0, #5
	slave_state.master_bdaddr = master_bdaddr;
    6c08:	6023      	str	r3, [r4, #0]
	slave_state.lt_addr = lt_addr;
    6c0a:	7225      	strb	r5, [r4, #8]
	btphy_set_mode(BT_MODE_SLAVE, master_bdaddr&0xffffff, 0xff & (master_bdaddr>>24));
    6c0c:	f7ff f810 	bl	5c30 <btphy_set_mode>

	ll_init(&slave_state.ll, 0, lt_addr);
    6c10:	462a      	mov	r2, r5
    6c12:	2100      	movs	r1, #0
    6c14:	f104 000c 	add.w	r0, r4, #12
    6c18:	f7fe fed8 	bl	59cc <ll_init>

	cprintf("slave started\n");
    6c1c:	480a      	ldr	r0, [pc, #40]	; (6c48 <slave_state_init+0x54>)
    6c1e:	f002 faf9 	bl	9214 <cprintf>
	btctl_set_state(BTCTL_STATE_CONNECTED, BTCTL_REASON_PAGED);
    6c22:	2102      	movs	r1, #2
    6c24:	2003      	movs	r0, #3
    6c26:	f7fe fd3f 	bl	56a8 <btctl_set_state>
	slave_state_schedule_rx(1);
}
    6c2a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	unsigned delay = 4*skip_slots+(3&(RX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX()));
    6c2e:	4a07      	ldr	r2, [pc, #28]	; (6c4c <slave_state_init+0x58>)
	rx_task_schedule(delay,
    6c30:	2301      	movs	r3, #1
	unsigned delay = 4*skip_slots+(3&(RX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX()));
    6c32:	6890      	ldr	r0, [r2, #8]
	rx_task_schedule(delay,
    6c34:	4906      	ldr	r1, [pc, #24]	; (6c50 <slave_state_init+0x5c>)
	unsigned delay = 4*skip_slots+(3&(RX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX()));
    6c36:	43c0      	mvns	r0, r0
    6c38:	f000 0003 	and.w	r0, r0, #3
	rx_task_schedule(delay,
    6c3c:	2200      	movs	r2, #0
    6c3e:	3004      	adds	r0, #4
    6c40:	f7ff bcc0 	b.w	65c4 <rx_task_schedule>
    6c44:	100007e0 	.word	0x100007e0
    6c48:	0000ddc8 	.word	0x0000ddc8
    6c4c:	100001b0 	.word	0x100001b0
    6c50:	00006b39 	.word	0x00006b39

00006c54 <tx_finalize>:
	return 0;
}

#define	TX_MAX_WAIT 1500
static int tx_finalize(uint8_t p1, uint8_t p2, uint16_t p3)
{
    6c54:	b538      	push	{r3, r4, r5, lr}
	/* Wait end of transmission .. */
	while (CLKN_OFFSET < TX_MAX_WAIT && (cc2400_get(FSMSTATE) & 0x1f) != STATE_STROBE_FS_ON);
    6c56:	f240 55db 	movw	r5, #1499	; 0x5db
    6c5a:	4c11      	ldr	r4, [pc, #68]	; (6ca0 <tx_finalize+0x4c>)
    6c5c:	e006      	b.n	6c6c <tx_finalize+0x18>
    6c5e:	200e      	movs	r0, #14
    6c60:	f002 feb4 	bl	99cc <cc2400_get>
    6c64:	f000 001f 	and.w	r0, r0, #31
    6c68:	280f      	cmp	r0, #15
    6c6a:	d002      	beq.n	6c72 <tx_finalize+0x1e>
    6c6c:	6823      	ldr	r3, [r4, #0]
    6c6e:	42ab      	cmp	r3, r5
    6c70:	d9f5      	bls.n	6c5e <tx_finalize+0xa>
	cc2400_strobe(SRFOFF);
    6c72:	2064      	movs	r0, #100	; 0x64
    6c74:	f002 febf 	bl	99f6 <cc2400_strobe>
	TXLED_CLR;
    6c78:	f44f 7180 	mov.w	r1, #256	; 0x100
	RXLED_CLR;
    6c7c:	2210      	movs	r2, #16
	TXLED_CLR;
    6c7e:	4b09      	ldr	r3, [pc, #36]	; (6ca4 <tx_finalize+0x50>)
    6c80:	6019      	str	r1, [r3, #0]
	RXLED_CLR;
    6c82:	601a      	str	r2, [r3, #0]
	SCHED_END_SET()
};

void tx_task_reset(void)
{
	btphy_rf_disable_int();
    6c84:	f000 ff3e 	bl	7b04 <btphy_rf_disable_int>
	tx_task.user_hdr = NULL;
    6c88:	2200      	movs	r2, #0
    6c8a:	4b07      	ldr	r3, [pc, #28]	; (6ca8 <tx_finalize+0x54>)
	if(tx_task.cb)
    6c8c:	6819      	ldr	r1, [r3, #0]
	tx_task.user_hdr = NULL;
    6c8e:	609a      	str	r2, [r3, #8]
	tx_task.user_data = NULL;
    6c90:	639a      	str	r2, [r3, #56]	; 0x38
	tx_task.p = NULL;
    6c92:	f8c3 224c 	str.w	r2, [r3, #588]	; 0x24c
	if(tx_task.cb)
    6c96:	b109      	cbz	r1, 6c9c <tx_finalize+0x48>
		tx_task.cb(tx_task.cb_arg);
    6c98:	6858      	ldr	r0, [r3, #4]
    6c9a:	4788      	blx	r1
}
    6c9c:	2000      	movs	r0, #0
    6c9e:	bd38      	pop	{r3, r4, r5, pc}
    6ca0:	40004008 	.word	0x40004008
    6ca4:	2009c03c 	.word	0x2009c03c
    6ca8:	10000810 	.word	0x10000810

00006cac <tx_prepare>:
{
    6cac:	b5f0      	push	{r4, r5, r6, r7, lr}
    6cae:	b083      	sub	sp, #12
    6cb0:	4e44      	ldr	r6, [pc, #272]	; (6dc4 <tx_prepare+0x118>)
    6cb2:	7833      	ldrb	r3, [r6, #0]
    6cb4:	2b03      	cmp	r3, #3
    6cb6:	d87c      	bhi.n	6db2 <tx_prepare+0x106>
    6cb8:	2b01      	cmp	r3, #1
    6cba:	d87c      	bhi.n	6db6 <tx_prepare+0x10a>
		return btphy.master_clkn;
    6cbc:	6875      	ldr	r5, [r6, #4]
	if (btphy.mode == BT_MODE_INQUIRY || btphy.mode == BT_MODE_PAGING)
    6cbe:	2b01      	cmp	r3, #1
	uint32_t tx_clkn = btphy_cur_clkn()+1;
    6cc0:	f105 0501 	add.w	r5, r5, #1
	if (btphy.mode == BT_MODE_INQUIRY || btphy.mode == BT_MODE_PAGING)
    6cc4:	d803      	bhi.n	6cce <tx_prepare+0x22>
	hop_state.x++;
    6cc6:	4a40      	ldr	r2, [pc, #256]	; (6dc8 <tx_prepare+0x11c>)
    6cc8:	7993      	ldrb	r3, [r2, #6]
    6cca:	3301      	adds	r3, #1
    6ccc:	7193      	strb	r3, [r2, #6]
	chan = hop_channel(tx_clkn);
    6cce:	4628      	mov	r0, r5
    6cd0:	f000 fcfe 	bl	76d0 <hop_channel>
	btphy_rf_tune_chan(2402+chan, 1);
    6cd4:	f600 1062 	addw	r0, r0, #2402	; 0x962
    6cd8:	2101      	movs	r1, #1
    6cda:	b280      	uxth	r0, r0
    6cdc:	f001 f846 	bl	7d6c <btphy_rf_tune_chan>
	cc2400_strobe(SFSON);
    6ce0:	2061      	movs	r0, #97	; 0x61
    6ce2:	f002 fe88 	bl	99f6 <cc2400_strobe>
}

/* cc2400 configure for buffered tx */
static inline void btphy_rf_cfg_tx(void)
{
	cc2400_set(GRMDM,   0x0CE1);
    6ce6:	f640 41e1 	movw	r1, #3297	; 0xce1
    6cea:	2020      	movs	r0, #32
    6cec:	f002 fe77 	bl	99de <cc2400_set>
	if (tx_task.user_hdr)
    6cf0:	4c36      	ldr	r4, [pc, #216]	; (6dcc <tx_prepare+0x120>)
	//      |  | |   |  +--------> CRC off
	//      |  | |   +-----------> sync word: 32 MSB bits of SYNC_WORD
	//      |  | +---------------> 1 preamble bytes of (0)1010101
	//      |  +-----------------> packet mode / sync word detection
	//      +--------------------> buffered mode
	cc2400_set(IOCFG, 0x170|(GIO_FIFO_EMPTY<<9));
    6cf2:	f644 5170 	movw	r1, #19824	; 0x4d70
    6cf6:	2008      	movs	r0, #8
    6cf8:	f002 fe71 	bl	99de <cc2400_set>
	btphy_rf_fifo_write(btphy.chan_sw_hi, 4);
    6cfc:	2104      	movs	r1, #4
    6cfe:	4834      	ldr	r0, [pc, #208]	; (6dd0 <tx_prepare+0x124>)
    6d00:	f000 ffba 	bl	7c78 <btphy_rf_fifo_write>
	if (tx_task.user_hdr)
    6d04:	68a3      	ldr	r3, [r4, #8]
    6d06:	2b00      	cmp	r3, #0
    6d08:	d059      	beq.n	6dbe <tx_prepare+0x112>
			btphy_whiten_seed(tx_clkn),
    6d0a:	4628      	mov	r0, r5
    6d0c:	f7fe ff74 	bl	5bf8 <btphy_whiten_seed>
	codec->use_whiten = use_whiten;
    6d10:	2501      	movs	r5, #1
	codec->rx_raw = rx_raw;
    6d12:	2100      	movs	r1, #0
		bbcodec_init(&tx_task.codec,
    6d14:	7e32      	ldrb	r2, [r6, #24]
    6d16:	4b2f      	ldr	r3, [pc, #188]	; (6dd4 <tx_prepare+0x128>)
		memset(tx_task.air_data, 0, sizeof(tx_task.air_data));
    6d18:	f104 0740 	add.w	r7, r4, #64	; 0x40
	codec->crc_state = reverse8(uap)<<8;
    6d1c:	5c9b      	ldrb	r3, [r3, r2]
	codec->payload_length = 0;
    6d1e:	e9c4 1108 	strd	r1, r1, [r4, #32]
	codec->crc_state = reverse8(uap)<<8;
    6d22:	021b      	lsls	r3, r3, #8
	codec->coded_total = 0;
    6d24:	e9c4 110a 	strd	r1, r1, [r4, #40]	; 0x28
	codec->whiten_state = whiten_init;
    6d28:	7620      	strb	r0, [r4, #24]
	codec->uap = uap;
    6d2a:	7322      	strb	r2, [r4, #12]
	codec->crc_state = reverse8(uap)<<8;
    6d2c:	8363      	strh	r3, [r4, #26]
    6d2e:	f44f 7203 	mov.w	r2, #524	; 0x20c
	codec->rx_raw = rx_raw;
    6d32:	6161      	str	r1, [r4, #20]
	codec->crc_pos = 0;
    6d34:	83a1      	strh	r1, [r4, #28]
	codec->air_off_b = 0;
    6d36:	6321      	str	r1, [r4, #48]	; 0x30
	codec->coded_pos = 0;
    6d38:	6361      	str	r1, [r4, #52]	; 0x34
	codec->use_whiten = use_whiten;
    6d3a:	6125      	str	r5, [r4, #16]
    6d3c:	4638      	mov	r0, r7
    6d3e:	f7fd fa2d 	bl	419c <memset>
		bbcodec_encode_header(&tx_task.codec, tx_task.air_data, tx_task.user_hdr, btphy.chan_trailer, tx_task.user_data);
    6d42:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    6d44:	f896 3028 	ldrb.w	r3, [r6, #40]	; 0x28
    6d48:	9200      	str	r2, [sp, #0]
    6d4a:	68a2      	ldr	r2, [r4, #8]
    6d4c:	4639      	mov	r1, r7
    6d4e:	f104 000c 	add.w	r0, r4, #12
    6d52:	f7fd fbd1 	bl	44f8 <bbcodec_encode_header>
		tx_task.data_size = tx_task.codec.air_bytes;
    6d56:	6aa6      	ldr	r6, [r4, #40]	; 0x28
		nslots = tx_task.codec.t->nslots;
    6d58:	6a22      	ldr	r2, [r4, #32]
		if (tx_task.user_data)
    6d5a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
		tx_task.p = tx_task.air_data;
    6d5c:	f8c4 724c 	str.w	r7, [r4, #588]	; 0x24c
		tx_task.data_size = tx_task.codec.air_bytes;
    6d60:	63e6      	str	r6, [r4, #60]	; 0x3c
		nslots = tx_task.codec.t->nslots;
    6d62:	7815      	ldrb	r5, [r2, #0]
		if (tx_task.user_data)
    6d64:	b34b      	cbz	r3, 6dba <tx_prepare+0x10e>
			bbcodec_encode_chunk(&tx_task.codec, tx_task.air_data, tx_task.user_hdr, tx_task.user_data);
    6d66:	f104 000c 	add.w	r0, r4, #12
    6d6a:	4639      	mov	r1, r7
    6d6c:	68a2      	ldr	r2, [r4, #8]
    6d6e:	f7fd fc5f 	bl	4630 <bbcodec_encode_chunk>
    6d72:	6be6      	ldr	r6, [r4, #60]	; 0x3c
    6d74:	f8d4 024c 	ldr.w	r0, [r4, #588]	; 0x24c
		len = MIN(32-4, tx_task.data_size);
    6d78:	2e1c      	cmp	r6, #28
    6d7a:	bf28      	it	cs
    6d7c:	261c      	movcs	r6, #28
		btphy_rf_fifo_write(tx_task.p, len);
    6d7e:	4631      	mov	r1, r6
    6d80:	f000 ff7a 	bl	7c78 <btphy_rf_fifo_write>
		tx_task.p += len;
    6d84:	f8d4 324c 	ldr.w	r3, [r4, #588]	; 0x24c
		tx_task.data_size -= len;
    6d88:	6be1      	ldr	r1, [r4, #60]	; 0x3c
    6d8a:	0068      	lsls	r0, r5, #1
		tx_task.p += len;
    6d8c:	4433      	add	r3, r6
		tx_task.data_size -= len;
    6d8e:	1b89      	subs	r1, r1, r6
    6d90:	b2c0      	uxtb	r0, r0
		tx_task.p += len;
    6d92:	f8c4 324c 	str.w	r3, [r4, #588]	; 0x24c
		tx_task.data_size -= len;
    6d96:	63e1      	str	r1, [r4, #60]	; 0x3c
	tdma_schedule(2*nslots, tx_finalize, 0, 0, 0, -3);
    6d98:	2400      	movs	r4, #0
    6d9a:	f06f 0302 	mvn.w	r3, #2
    6d9e:	4622      	mov	r2, r4
    6da0:	e9cd 4300 	strd	r4, r3, [sp]
    6da4:	490c      	ldr	r1, [pc, #48]	; (6dd8 <tx_prepare+0x12c>)
    6da6:	4623      	mov	r3, r4
    6da8:	f7ff f82c 	bl	5e04 <tdma_schedule>
}
    6dac:	4620      	mov	r0, r4
    6dae:	b003      	add	sp, #12
    6db0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch(btphy.mode)
    6db2:	2b05      	cmp	r3, #5
    6db4:	d182      	bne.n	6cbc <tx_prepare+0x10>
		return btphy.slave_clkn;
    6db6:	68b5      	ldr	r5, [r6, #8]
    6db8:	e781      	b.n	6cbe <tx_prepare+0x12>
    6dba:	4638      	mov	r0, r7
    6dbc:	e7dc      	b.n	6d78 <tx_prepare+0xcc>
    6dbe:	2002      	movs	r0, #2
    6dc0:	e7ea      	b.n	6d98 <tx_prepare+0xec>
    6dc2:	bf00      	nop
    6dc4:	100001b0 	.word	0x100001b0
    6dc8:	10002520 	.word	0x10002520
    6dcc:	10000810 	.word	0x10000810
    6dd0:	100001dd 	.word	0x100001dd
    6dd4:	0000d954 	.word	0x0000d954
    6dd8:	00006c55 	.word	0x00006c55

00006ddc <tx_fifo_cb>:
{
    6ddc:	b570      	push	{r4, r5, r6, lr}
	if (tx_task.p == NULL)
    6dde:	4c13      	ldr	r4, [pc, #76]	; (6e2c <tx_fifo_cb+0x50>)
    6de0:	f8d4 024c 	ldr.w	r0, [r4, #588]	; 0x24c
    6de4:	b1e8      	cbz	r0, 6e22 <tx_fifo_cb+0x46>
	len = MIN(tx_task.data_size, PHY_FIFO_THRESHOLD); // (128usec of tx)
    6de6:	6be5      	ldr	r5, [r4, #60]	; 0x3c
    6de8:	2d10      	cmp	r5, #16
    6dea:	bf28      	it	cs
    6dec:	2510      	movcs	r5, #16
	btphy_rf_fifo_write(tx_task.p, len);
    6dee:	4629      	mov	r1, r5
    6df0:	f000 ff42 	bl	7c78 <btphy_rf_fifo_write>
	tx_task.p += len;
    6df4:	f8d4 324c 	ldr.w	r3, [r4, #588]	; 0x24c
	tx_task.data_size -= len;
    6df8:	6be1      	ldr	r1, [r4, #60]	; 0x3c
	tx_task.p += len;
    6dfa:	442b      	add	r3, r5
	tx_task.data_size -= len;
    6dfc:	1b4d      	subs	r5, r1, r5
	tx_task.p += len;
    6dfe:	f8c4 324c 	str.w	r3, [r4, #588]	; 0x24c
	tx_task.data_size -= len;
    6e02:	63e5      	str	r5, [r4, #60]	; 0x3c
	if (tx_task.data_size == 0)
    6e04:	b91d      	cbnz	r5, 6e0e <tx_fifo_cb+0x32>
}
    6e06:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		btphy_rf_disable_int();
    6e0a:	f000 be7b 	b.w	7b04 <btphy_rf_disable_int>
		bbcodec_encode_chunk(&tx_task.codec, tx_task.air_data, tx_task.user_hdr, tx_task.user_data);
    6e0e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    6e10:	68a2      	ldr	r2, [r4, #8]
    6e12:	f104 0140 	add.w	r1, r4, #64	; 0x40
    6e16:	f104 000c 	add.w	r0, r4, #12
}
    6e1a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		bbcodec_encode_chunk(&tx_task.codec, tx_task.air_data, tx_task.user_hdr, tx_task.user_data);
    6e1e:	f7fd bc07 	b.w	4630 <bbcodec_encode_chunk>
		DIE("No p in tx_fifo_cb (size %d)\n", tx_task.data_size);
    6e22:	6be1      	ldr	r1, [r4, #60]	; 0x3c
    6e24:	4802      	ldr	r0, [pc, #8]	; (6e30 <tx_fifo_cb+0x54>)
    6e26:	f001 f8f5 	bl	8014 <die>
    6e2a:	bf00      	nop
    6e2c:	10000810 	.word	0x10000810
    6e30:	0000ddd8 	.word	0x0000ddd8

00006e34 <tx_execute>:
{
    6e34:	b510      	push	{r4, lr}
	if (!FS_TUNED())
    6e36:	f002 fdd7 	bl	99e8 <cc2400_status>
    6e3a:	f010 0404 	ands.w	r4, r0, #4
    6e3e:	d022      	beq.n	6e86 <tx_execute+0x52>
	cc2400_strobe(STX);
    6e40:	2063      	movs	r0, #99	; 0x63
    6e42:	f002 fdd8 	bl	99f6 <cc2400_strobe>
	TXLED_SET;
    6e46:	f44f 7180 	mov.w	r1, #256	; 0x100
	if (tx_task.data_size)
    6e4a:	4b1f      	ldr	r3, [pc, #124]	; (6ec8 <tx_execute+0x94>)
    6e4c:	4a1f      	ldr	r2, [pc, #124]	; (6ecc <tx_execute+0x98>)
    6e4e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    6e50:	6011      	str	r1, [r2, #0]
    6e52:	b973      	cbnz	r3, 6e72 <tx_execute+0x3e>
	switch(btphy.mode)
    6e54:	4a1e      	ldr	r2, [pc, #120]	; (6ed0 <tx_execute+0x9c>)
    6e56:	7813      	ldrb	r3, [r2, #0]
    6e58:	2b03      	cmp	r3, #3
    6e5a:	d806      	bhi.n	6e6a <tx_execute+0x36>
    6e5c:	2b01      	cmp	r3, #1
    6e5e:	d806      	bhi.n	6e6e <tx_execute+0x3a>
		return btphy.master_clkn;
    6e60:	6851      	ldr	r1, [r2, #4]
	if (btphy_cur_clkn() & 1)
    6e62:	07c9      	lsls	r1, r1, #31
    6e64:	d424      	bmi.n	6eb0 <tx_execute+0x7c>
}
    6e66:	2000      	movs	r0, #0
    6e68:	bd10      	pop	{r4, pc}
	switch(btphy.mode)
    6e6a:	2b05      	cmp	r3, #5
    6e6c:	d1f8      	bne.n	6e60 <tx_execute+0x2c>
		return btphy.slave_clkn;
    6e6e:	6891      	ldr	r1, [r2, #8]
    6e70:	e7f7      	b.n	6e62 <tx_execute+0x2e>
		btphy_rf_enable_int(tx_fifo_cb, NULL, 1);
    6e72:	2201      	movs	r2, #1
    6e74:	2100      	movs	r1, #0
    6e76:	4817      	ldr	r0, [pc, #92]	; (6ed4 <tx_execute+0xa0>)
    6e78:	f000 fe18 	bl	7aac <btphy_rf_enable_int>
	switch(btphy.mode)
    6e7c:	4a14      	ldr	r2, [pc, #80]	; (6ed0 <tx_execute+0x9c>)
    6e7e:	7813      	ldrb	r3, [r2, #0]
    6e80:	2b03      	cmp	r3, #3
    6e82:	d8f2      	bhi.n	6e6a <tx_execute+0x36>
    6e84:	e7ea      	b.n	6e5c <tx_execute+0x28>
		cprintf("TX: RF not FS_ON\n");
    6e86:	4814      	ldr	r0, [pc, #80]	; (6ed8 <tx_execute+0xa4>)
    6e88:	f002 f9c4 	bl	9214 <cprintf>
	btphy_rf_disable_int();
    6e8c:	f000 fe3a 	bl	7b04 <btphy_rf_disable_int>
	tx_task.user_hdr = NULL;
    6e90:	4b0d      	ldr	r3, [pc, #52]	; (6ec8 <tx_execute+0x94>)
	cc2400_strobe(SRFOFF);
    6e92:	2064      	movs	r0, #100	; 0x64
    6e94:	609c      	str	r4, [r3, #8]
	tx_task.user_data = NULL;
    6e96:	639c      	str	r4, [r3, #56]	; 0x38
	tx_task.p = NULL;
    6e98:	f8c3 424c 	str.w	r4, [r3, #588]	; 0x24c
    6e9c:	f002 fdab 	bl	99f6 <cc2400_strobe>
	TXLED_CLR;
    6ea0:	f44f 7180 	mov.w	r1, #256	; 0x100
	RXLED_CLR;
    6ea4:	2210      	movs	r2, #16
	TXLED_CLR;
    6ea6:	4b0d      	ldr	r3, [pc, #52]	; (6edc <tx_execute+0xa8>)
}
    6ea8:	2000      	movs	r0, #0
    6eaa:	6019      	str	r1, [r3, #0]
	RXLED_CLR;
    6eac:	601a      	str	r2, [r3, #0]
    6eae:	bd10      	pop	{r4, pc}
    6eb0:	2b03      	cmp	r3, #3
    6eb2:	d805      	bhi.n	6ec0 <tx_execute+0x8c>
    6eb4:	2b01      	cmp	r3, #1
    6eb6:	d805      	bhi.n	6ec4 <tx_execute+0x90>
		return btphy.master_clkn;
    6eb8:	6851      	ldr	r1, [r2, #4]
		DIE("txe: wrong clkn %x", btphy_cur_clkn());
    6eba:	4809      	ldr	r0, [pc, #36]	; (6ee0 <tx_execute+0xac>)
    6ebc:	f001 f8aa 	bl	8014 <die>
	switch(btphy.mode)
    6ec0:	2b05      	cmp	r3, #5
    6ec2:	d1f9      	bne.n	6eb8 <tx_execute+0x84>
		return btphy.slave_clkn;
    6ec4:	6891      	ldr	r1, [r2, #8]
    6ec6:	e7f8      	b.n	6eba <tx_execute+0x86>
    6ec8:	10000810 	.word	0x10000810
    6ecc:	2009c038 	.word	0x2009c038
    6ed0:	100001b0 	.word	0x100001b0
    6ed4:	00006ddd 	.word	0x00006ddd
    6ed8:	0000ddfc 	.word	0x0000ddfc
    6edc:	2009c03c 	.word	0x2009c03c
    6ee0:	0000de10 	.word	0x0000de10

00006ee4 <tx_task_reset>:
{
    6ee4:	b508      	push	{r3, lr}
	btphy_rf_disable_int();
    6ee6:	f000 fe0d 	bl	7b04 <btphy_rf_disable_int>
	tx_task.user_hdr = NULL;
    6eea:	2200      	movs	r2, #0
    6eec:	4b02      	ldr	r3, [pc, #8]	; (6ef8 <tx_task_reset+0x14>)
    6eee:	609a      	str	r2, [r3, #8]
	tx_task.user_data = NULL;
    6ef0:	639a      	str	r2, [r3, #56]	; 0x38
	tx_task.p = NULL;
    6ef2:	f8c3 224c 	str.w	r2, [r3, #588]	; 0x24c
}
    6ef6:	bd08      	pop	{r3, pc}
    6ef8:	10000810 	.word	0x10000810

00006efc <tx_task_schedule>:

void tx_task_schedule(unsigned delay, tx_task_cb_t cb, void*cbarg, bbhdr_t *hdr, uint8_t *data)
{
    6efc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	unsigned bitsize = 0;
	if (tx_task.user_hdr)
    6efe:	4c0b      	ldr	r4, [pc, #44]	; (6f2c <tx_task_schedule+0x30>)
{
    6f00:	460e      	mov	r6, r1
	if (tx_task.user_hdr)
    6f02:	68a7      	ldr	r7, [r4, #8]
{
    6f04:	4615      	mov	r5, r2
    6f06:	f8dd c018 	ldr.w	ip, [sp, #24]
	if (tx_task.user_hdr)
    6f0a:	b95f      	cbnz	r7, 6f24 <tx_task_schedule+0x28>
		DIE("txs: already got pkt");
	tx_task.cb = cb;
	tx_task.cb_arg = cbarg;
	tx_task.user_hdr = hdr;
	tx_task.user_data = data;
	tdma_schedule_set(delay, tx_sched_set, 0);
    6f0c:	463a      	mov	r2, r7
	tx_task.cb_arg = cbarg;
    6f0e:	e9c4 6500 	strd	r6, r5, [r4]
	tx_task.user_hdr = hdr;
    6f12:	60a3      	str	r3, [r4, #8]
	tx_task.user_data = data;
    6f14:	f8c4 c038 	str.w	ip, [r4, #56]	; 0x38
	tdma_schedule_set(delay, tx_sched_set, 0);
    6f18:	4905      	ldr	r1, [pc, #20]	; (6f30 <tx_task_schedule+0x34>)
    6f1a:	b2c0      	uxtb	r0, r0
}
    6f1c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	tdma_schedule_set(delay, tx_sched_set, 0);
    6f20:	f7fe bfa2 	b.w	5e68 <tdma_schedule_set>
		DIE("txs: already got pkt");
    6f24:	4803      	ldr	r0, [pc, #12]	; (6f34 <tx_task_schedule+0x38>)
    6f26:	f001 f875 	bl	8014 <die>
    6f2a:	bf00      	nop
    6f2c:	10000810 	.word	0x10000810
    6f30:	0000de44 	.word	0x0000de44
    6f34:	0000de28 	.word	0x0000de28

00006f38 <scan_wait>:
	/* Call user callback */
	scan_task.cb(scan_task.pkt_received, scan_task.cb_arg);
}

static void scan_wait(void)
{
    6f38:	b510      	push	{r4, lr}
    6f3a:	b082      	sub	sp, #8
	int clkn_delay;

	/* Wait for packet.. */
	while (CLKN_OFFSET < SCAN_WAIT_SYNCWORD)
    6f3c:	4a1f      	ldr	r2, [pc, #124]	; (6fbc <scan_wait+0x84>)
	{
		/* PKT strobe goes low if a syncword is detected */
		if (GIO6 == 0)
    6f3e:	4920      	ldr	r1, [pc, #128]	; (6fc0 <scan_wait+0x88>)
	while (CLKN_OFFSET < SCAN_WAIT_SYNCWORD)
    6f40:	e002      	b.n	6f48 <scan_wait+0x10>
		if (GIO6 == 0)
    6f42:	680b      	ldr	r3, [r1, #0]
    6f44:	075b      	lsls	r3, r3, #29
    6f46:	d515      	bpl.n	6f74 <scan_wait+0x3c>
	while (CLKN_OFFSET < SCAN_WAIT_SYNCWORD)
    6f48:	6813      	ldr	r3, [r2, #0]
    6f4a:	2bf9      	cmp	r3, #249	; 0xf9
    6f4c:	d9f9      	bls.n	6f42 <scan_wait+0xa>
    6f4e:	4c1d      	ldr	r4, [pc, #116]	; (6fc4 <scan_wait+0x8c>)
			scan_task.pkt_time = CLKN_OFFSET;
			scan_task.pkt_received = 1;
			break;
		}
	}
	scan_task.num_slots ++;
    6f50:	68e2      	ldr	r2, [r4, #12]
    6f52:	7aa3      	ldrb	r3, [r4, #10]
    6f54:	3201      	adds	r2, #1
    6f56:	60e2      	str	r2, [r4, #12]
	if (scan_task.pkt_received)
    6f58:	b9a3      	cbnz	r3, 6f84 <scan_wait+0x4c>
		/* finalize */
		scan_finalize();
	}
	else
	{
		if (scan_task.num_slots == SCAN_MAX_SLOTS)
    6f5a:	2a08      	cmp	r2, #8
    6f5c:	d01a      	beq.n	6f94 <scan_wait+0x5c>
			scan_finalize();
		}
		else
		{
			/* Wait one more slot */
			tdma_schedule(1, scan_wait_more, 0, 0, 0, -3);
    6f5e:	f06f 0202 	mvn.w	r2, #2
    6f62:	4919      	ldr	r1, [pc, #100]	; (6fc8 <scan_wait+0x90>)
    6f64:	e9cd 3200 	strd	r3, r2, [sp]
    6f68:	2001      	movs	r0, #1
    6f6a:	461a      	mov	r2, r3
    6f6c:	f7fe ff4a 	bl	5e04 <tdma_schedule>
		}
	}
}
    6f70:	b002      	add	sp, #8
    6f72:	bd10      	pop	{r4, pc}
			scan_task.pkt_received = 1;
    6f74:	2101      	movs	r1, #1
			scan_task.pkt_time = CLKN_OFFSET;
    6f76:	4c13      	ldr	r4, [pc, #76]	; (6fc4 <scan_wait+0x8c>)
    6f78:	6812      	ldr	r2, [r2, #0]
	scan_task.num_slots ++;
    6f7a:	68e3      	ldr	r3, [r4, #12]
			scan_task.pkt_time = CLKN_OFFSET;
    6f7c:	8122      	strh	r2, [r4, #8]
	scan_task.num_slots ++;
    6f7e:	440b      	add	r3, r1
			scan_task.pkt_received = 1;
    6f80:	72a1      	strb	r1, [r4, #10]
	scan_task.num_slots ++;
    6f82:	60e3      	str	r3, [r4, #12]
		btphy.slave_clkn = 0;
    6f84:	2200      	movs	r2, #0
		clkn_delay = scan_task.pkt_time - RF_EXPECTED_RX_CLKN_OFFSET;
    6f86:	8920      	ldrh	r0, [r4, #8]
		btphy.slave_clkn = 0;
    6f88:	4b10      	ldr	r3, [pc, #64]	; (6fcc <scan_wait+0x94>)
		btphy_adj_clkn_delay(clkn_delay);
    6f8a:	f2a0 2062 	subw	r0, r0, #610	; 0x262
		btphy.slave_clkn = 0;
    6f8e:	609a      	str	r2, [r3, #8]
		btphy_adj_clkn_delay(clkn_delay);
    6f90:	f7fe fdfe 	bl	5b90 <btphy_adj_clkn_delay>
	cc2400_strobe(SRFOFF);
    6f94:	2064      	movs	r0, #100	; 0x64
    6f96:	f002 fd2e 	bl	99f6 <cc2400_strobe>
	TXLED_CLR;
    6f9a:	f44f 7080 	mov.w	r0, #256	; 0x100
	RXLED_CLR;
    6f9e:	2110      	movs	r1, #16
	TXLED_CLR;
    6fa0:	4a0b      	ldr	r2, [pc, #44]	; (6fd0 <scan_wait+0x98>)
	if (scan_task.cb == NULL)
    6fa2:	6823      	ldr	r3, [r4, #0]
    6fa4:	6010      	str	r0, [r2, #0]
	RXLED_CLR;
    6fa6:	6011      	str	r1, [r2, #0]
    6fa8:	b12b      	cbz	r3, 6fb6 <scan_wait+0x7e>
	scan_task.cb(scan_task.pkt_received, scan_task.cb_arg);
    6faa:	6861      	ldr	r1, [r4, #4]
    6fac:	7aa0      	ldrb	r0, [r4, #10]
}
    6fae:	b002      	add	sp, #8
    6fb0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	scan_task.cb(scan_task.pkt_received, scan_task.cb_arg);
    6fb4:	4718      	bx	r3
		DIE("no cb in scan task\n");
    6fb6:	4807      	ldr	r0, [pc, #28]	; (6fd4 <scan_wait+0x9c>)
    6fb8:	f001 f82c 	bl	8014 <die>
    6fbc:	40004008 	.word	0x40004008
    6fc0:	2009c054 	.word	0x2009c054
    6fc4:	10000a60 	.word	0x10000a60
    6fc8:	0000704d 	.word	0x0000704d
    6fcc:	100001b0 	.word	0x100001b0
    6fd0:	2009c03c 	.word	0x2009c03c
    6fd4:	0000de80 	.word	0x0000de80

00006fd8 <scan_start>:
	scan_wait();
	return 0;
}

static int scan_start(uint8_t p1, uint8_t p2, uint16_t p3)
{
    6fd8:	b508      	push	{r3, lr}
	uint8_t chan;

	chan = hop_channel(0);	// Assume clk1 = 0 = master tx
    6fda:	2000      	movs	r0, #0
    6fdc:	f000 fb78 	bl	76d0 <hop_channel>

	/* Tune to chan & start RX */
	btphy_rf_tune_chan(2402+chan, 0);
    6fe0:	f600 1062 	addw	r0, r0, #2402	; 0x962
    6fe4:	2100      	movs	r1, #0
    6fe6:	b280      	uxth	r0, r0
    6fe8:	f000 fec0 	bl	7d6c <btphy_rf_tune_chan>

	scan_task.pkt_received = 0;
    6fec:	2200      	movs	r2, #0
    6fee:	4b14      	ldr	r3, [pc, #80]	; (7040 <scan_start+0x68>)
	scan_task.pkt_time = 0;
	scan_task.num_slots = 0;

	/* Here i must strobe SRX before & after GRMDM cfg. why ? */
	cc2400_strobe(SFSON);
    6ff0:	2061      	movs	r0, #97	; 0x61
	scan_task.pkt_received = 0;
    6ff2:	729a      	strb	r2, [r3, #10]
	scan_task.pkt_time = 0;
    6ff4:	811a      	strh	r2, [r3, #8]
	scan_task.num_slots = 0;
    6ff6:	60da      	str	r2, [r3, #12]
	cc2400_strobe(SFSON);
    6ff8:	f002 fcfd 	bl	99f6 <cc2400_strobe>
	cc2400_set(GRMDM,   0x4E1|(rf_state.max_ac_errors<<13));
    6ffc:	f240 41e1 	movw	r1, #1249	; 0x4e1
    7000:	4b10      	ldr	r3, [pc, #64]	; (7044 <scan_start+0x6c>)
    7002:	2020      	movs	r0, #32
    7004:	885b      	ldrh	r3, [r3, #2]
    7006:	b29b      	uxth	r3, r3
    7008:	ea41 3143 	orr.w	r1, r1, r3, lsl #13
    700c:	b289      	uxth	r1, r1
    700e:	f002 fce6 	bl	99de <cc2400_set>
	cc2400_set(IOCFG, 0x170|(GIO_PKT<<9));
    7012:	f44f 6157 	mov.w	r1, #3440	; 0xd70
    7016:	2008      	movs	r0, #8
    7018:	f002 fce1 	bl	99de <cc2400_set>
	cc2400_strobe(SRX);
    701c:	2062      	movs	r0, #98	; 0x62
    701e:	f002 fcea 	bl	99f6 <cc2400_strobe>
	RXLED_SET;
    7022:	2210      	movs	r2, #16
    7024:	4b08      	ldr	r3, [pc, #32]	; (7048 <scan_start+0x70>)
    7026:	601a      	str	r2, [r3, #0]
	btphy_rf_cfg_rx();
	btphy_rf_rx();
	while ((cc2400_get(FSMSTATE) & 0x1f) != STATE_STROBE_RX);
    7028:	200e      	movs	r0, #14
    702a:	f002 fccf 	bl	99cc <cc2400_get>
    702e:	f000 001f 	and.w	r0, r0, #31
    7032:	2810      	cmp	r0, #16
    7034:	d1f8      	bne.n	7028 <scan_start+0x50>

	scan_wait();
    7036:	f7ff ff7f 	bl	6f38 <scan_wait>

	return 0; 
}
    703a:	2000      	movs	r0, #0
    703c:	bd08      	pop	{r3, pc}
    703e:	bf00      	nop
    7040:	10000a60 	.word	0x10000a60
    7044:	10000a8c 	.word	0x10000a8c
    7048:	2009c038 	.word	0x2009c038

0000704c <scan_wait_more>:
{
    704c:	b508      	push	{r3, lr}
	scan_wait();
    704e:	f7ff ff73 	bl	6f38 <scan_wait>
}
    7052:	2000      	movs	r0, #0
    7054:	bd08      	pop	{r3, pc}
    7056:	bf00      	nop

00007058 <scan_task_schedule>:

void scan_task_schedule(unsigned delay, scan_task_cb_t cb, void*cbarg)
{
    7058:	b570      	push	{r4, r5, r6, lr}
    705a:	b082      	sub	sp, #8

	/* In inquiry/paging scan , hop.x must be incremented before
	 * master TX */
	hop_increment();

	tdma_schedule(1, scan_start, 0, 0, 0, -3);
    705c:	f06f 0402 	mvn.w	r4, #2
    7060:	2300      	movs	r3, #0
{
    7062:	4616      	mov	r6, r2
    7064:	4d07      	ldr	r5, [pc, #28]	; (7084 <scan_task_schedule+0x2c>)
	tdma_schedule(1, scan_start, 0, 0, 0, -3);
    7066:	9401      	str	r4, [sp, #4]
	scan_task.cb = cb;
    7068:	4807      	ldr	r0, [pc, #28]	; (7088 <scan_task_schedule+0x30>)
    706a:	79ac      	ldrb	r4, [r5, #6]
	tdma_schedule(1, scan_start, 0, 0, 0, -3);
    706c:	9300      	str	r3, [sp, #0]
    706e:	461a      	mov	r2, r3
	scan_task.cb = cb;
    7070:	6001      	str	r1, [r0, #0]
	scan_task.cb_arg = cbarg;
    7072:	6046      	str	r6, [r0, #4]
	tdma_schedule(1, scan_start, 0, 0, 0, -3);
    7074:	4905      	ldr	r1, [pc, #20]	; (708c <scan_task_schedule+0x34>)
    7076:	3401      	adds	r4, #1
    7078:	2001      	movs	r0, #1
    707a:	71ac      	strb	r4, [r5, #6]
    707c:	f7fe fec2 	bl	5e04 <tdma_schedule>
}
    7080:	b002      	add	sp, #8
    7082:	bd70      	pop	{r4, r5, r6, pc}
    7084:	10002520 	.word	0x10002520
    7088:	10000a60 	.word	0x10000a60
    708c:	00006fd9 	.word	0x00006fd9

00007090 <tx_fhs_cb>:
{
	inquiry_scan_schedule(1);
}

static void tx_fhs_cb(void *arg)
{
    7090:	b500      	push	{lr}
    7092:	b085      	sub	sp, #20
	return btctl.eir_pkt;
    7094:	4b18      	ldr	r3, [pc, #96]	; (70f8 <tx_fhs_cb+0x68>)
    7096:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
	btctl_tx_pkt_t *eir_pkt = btctl_get_eir();
	if (eir_pkt)
    709a:	b173      	cbz	r3, 70ba <tx_fhs_cb+0x2a>
	{
		tx_task_schedule(3&(TX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX()),
    709c:	4917      	ldr	r1, [pc, #92]	; (70fc <tx_fhs_cb+0x6c>)
			tx_eir_cb, NULL,
			&eir_pkt->bb_hdr, eir_pkt->bt_data);
    709e:	1d1a      	adds	r2, r3, #4
		tx_task_schedule(3&(TX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX()),
    70a0:	6888      	ldr	r0, [r1, #8]
    70a2:	9200      	str	r2, [sp, #0]
    70a4:	f1c0 0001 	rsb	r0, r0, #1
    70a8:	2200      	movs	r2, #0
    70aa:	4915      	ldr	r1, [pc, #84]	; (7100 <tx_fhs_cb+0x70>)
    70ac:	f000 0003 	and.w	r0, r0, #3
    70b0:	f7ff ff24 	bl	6efc <tx_task_schedule>
	}
	else
	{
		inquiry_scan_schedule(1);
	}
}
    70b4:	b005      	add	sp, #20
    70b6:	f85d fb04 	ldr.w	pc, [sp], #4
	}
}

static void inquiry_scan_schedule(unsigned delay)
{
	if (MASTER_CLKN >= inquiry_scan_state.clkn_start + INQ_SCAN_MAX_TICKS)
    70ba:	4a12      	ldr	r2, [pc, #72]	; (7104 <tx_fhs_cb+0x74>)
    70bc:	4912      	ldr	r1, [pc, #72]	; (7108 <tx_fhs_cb+0x78>)
    70be:	6812      	ldr	r2, [r2, #0]
    70c0:	6809      	ldr	r1, [r1, #0]
    70c2:	f502 323b 	add.w	r2, r2, #191488	; 0x2ec00
    70c6:	f502 7200 	add.w	r2, r2, #512	; 0x200
    70ca:	4291      	cmp	r1, r2
    70cc:	d207      	bcs.n	70de <tx_fhs_cb+0x4e>
	{
		cprintf("inquiry scan timeout\n");
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
		return;
	}
	scan_task_schedule(delay, inquiry_scan_rx_cb, NULL);
    70ce:	461a      	mov	r2, r3
    70d0:	2001      	movs	r0, #1
    70d2:	490e      	ldr	r1, [pc, #56]	; (710c <tx_fhs_cb+0x7c>)
}
    70d4:	b005      	add	sp, #20
    70d6:	f85d eb04 	ldr.w	lr, [sp], #4
	scan_task_schedule(delay, inquiry_scan_rx_cb, NULL);
    70da:	f7ff bfbd 	b.w	7058 <scan_task_schedule>
		cprintf("inquiry scan timeout\n");
    70de:	480c      	ldr	r0, [pc, #48]	; (7110 <tx_fhs_cb+0x80>)
    70e0:	9303      	str	r3, [sp, #12]
    70e2:	f002 f897 	bl	9214 <cprintf>
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
    70e6:	9b03      	ldr	r3, [sp, #12]
    70e8:	2101      	movs	r1, #1
    70ea:	4618      	mov	r0, r3
}
    70ec:	b005      	add	sp, #20
    70ee:	f85d eb04 	ldr.w	lr, [sp], #4
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
    70f2:	f7fe bad9 	b.w	56a8 <btctl_set_state>
    70f6:	bf00      	nop
    70f8:	100023dc 	.word	0x100023dc
    70fc:	100001b0 	.word	0x100001b0
    7100:	00007115 	.word	0x00007115
    7104:	10000a70 	.word	0x10000a70
    7108:	40008008 	.word	0x40008008
    710c:	0000715d 	.word	0x0000715d
    7110:	0000de9c 	.word	0x0000de9c

00007114 <tx_eir_cb>:
{
    7114:	b508      	push	{r3, lr}
	if (MASTER_CLKN >= inquiry_scan_state.clkn_start + INQ_SCAN_MAX_TICKS)
    7116:	4b0d      	ldr	r3, [pc, #52]	; (714c <tx_eir_cb+0x38>)
    7118:	4a0d      	ldr	r2, [pc, #52]	; (7150 <tx_eir_cb+0x3c>)
    711a:	681b      	ldr	r3, [r3, #0]
    711c:	6812      	ldr	r2, [r2, #0]
    711e:	f503 333b 	add.w	r3, r3, #191488	; 0x2ec00
    7122:	f503 7300 	add.w	r3, r3, #512	; 0x200
    7126:	429a      	cmp	r2, r3
    7128:	d206      	bcs.n	7138 <tx_eir_cb+0x24>
}
    712a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	scan_task_schedule(delay, inquiry_scan_rx_cb, NULL);
    712e:	2200      	movs	r2, #0
    7130:	2001      	movs	r0, #1
    7132:	4908      	ldr	r1, [pc, #32]	; (7154 <tx_eir_cb+0x40>)
    7134:	f7ff bf90 	b.w	7058 <scan_task_schedule>
		cprintf("inquiry scan timeout\n");
    7138:	4807      	ldr	r0, [pc, #28]	; (7158 <tx_eir_cb+0x44>)
    713a:	f002 f86b 	bl	9214 <cprintf>
}
    713e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
    7142:	2101      	movs	r1, #1
    7144:	2000      	movs	r0, #0
    7146:	f7fe baaf 	b.w	56a8 <btctl_set_state>
    714a:	bf00      	nop
    714c:	10000a70 	.word	0x10000a70
    7150:	40008008 	.word	0x40008008
    7154:	0000715d 	.word	0x0000715d
    7158:	0000de9c 	.word	0x0000de9c

0000715c <inquiry_scan_rx_cb>:
{
    715c:	b530      	push	{r4, r5, lr}
    715e:	b083      	sub	sp, #12
	return btctl.state;
    7160:	4b1f      	ldr	r3, [pc, #124]	; (71e0 <inquiry_scan_rx_cb+0x84>)
    7162:	4604      	mov	r4, r0
	if (inquiry_scan_canceled())
    7164:	781b      	ldrb	r3, [r3, #0]
    7166:	2b04      	cmp	r3, #4
    7168:	d129      	bne.n	71be <inquiry_scan_rx_cb+0x62>
	if (sw_detected)
    716a:	b980      	cbnz	r0, 718e <inquiry_scan_rx_cb+0x32>
	if (MASTER_CLKN >= inquiry_scan_state.clkn_start + INQ_SCAN_MAX_TICKS)
    716c:	4b1d      	ldr	r3, [pc, #116]	; (71e4 <inquiry_scan_rx_cb+0x88>)
    716e:	4a1e      	ldr	r2, [pc, #120]	; (71e8 <inquiry_scan_rx_cb+0x8c>)
    7170:	681b      	ldr	r3, [r3, #0]
    7172:	6812      	ldr	r2, [r2, #0]
    7174:	f503 333b 	add.w	r3, r3, #191488	; 0x2ec00
    7178:	f503 7300 	add.w	r3, r3, #512	; 0x200
    717c:	429a      	cmp	r2, r3
    717e:	d224      	bcs.n	71ca <inquiry_scan_rx_cb+0x6e>
	scan_task_schedule(delay, inquiry_scan_rx_cb, NULL);
    7180:	4602      	mov	r2, r0
    7182:	491a      	ldr	r1, [pc, #104]	; (71ec <inquiry_scan_rx_cb+0x90>)
}
    7184:	b003      	add	sp, #12
    7186:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	scan_task_schedule(delay, inquiry_scan_rx_cb, NULL);
    718a:	f7ff bf65 	b.w	7058 <scan_task_schedule>
		bbpkt_fhs_finalize_payload(inquiry_scan_state.fhs_data, (btphy.master_clkn+2)>>2);
    718e:	4d18      	ldr	r5, [pc, #96]	; (71f0 <inquiry_scan_rx_cb+0x94>)
		console_putc('!');
    7190:	2021      	movs	r0, #33	; 0x21
    7192:	f000 fea9 	bl	7ee8 <console_putc>
		bbpkt_fhs_finalize_payload(inquiry_scan_state.fhs_data, (btphy.master_clkn+2)>>2);
    7196:	6869      	ldr	r1, [r5, #4]
    7198:	4c16      	ldr	r4, [pc, #88]	; (71f4 <inquiry_scan_rx_cb+0x98>)
    719a:	3102      	adds	r1, #2
    719c:	4620      	mov	r0, r4
    719e:	0889      	lsrs	r1, r1, #2
    71a0:	f7fd f87c 	bl	429c <bbpkt_fhs_finalize_payload>
		tx_task_schedule(3&(TX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX()),
    71a4:	68a8      	ldr	r0, [r5, #8]
    71a6:	2200      	movs	r2, #0
    71a8:	f1c0 0001 	rsb	r0, r0, #1
    71ac:	4912      	ldr	r1, [pc, #72]	; (71f8 <inquiry_scan_rx_cb+0x9c>)
    71ae:	9400      	str	r4, [sp, #0]
    71b0:	f000 0003 	and.w	r0, r0, #3
    71b4:	1f23      	subs	r3, r4, #4
    71b6:	f7ff fea1 	bl	6efc <tx_task_schedule>
}
    71ba:	b003      	add	sp, #12
    71bc:	bd30      	pop	{r4, r5, pc}
		cprintf("inq scan canceled\n");
    71be:	480f      	ldr	r0, [pc, #60]	; (71fc <inquiry_scan_rx_cb+0xa0>)
}
    71c0:	b003      	add	sp, #12
    71c2:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		cprintf("inq scan canceled\n");
    71c6:	f002 b825 	b.w	9214 <cprintf>
		cprintf("inquiry scan timeout\n");
    71ca:	480d      	ldr	r0, [pc, #52]	; (7200 <inquiry_scan_rx_cb+0xa4>)
    71cc:	f002 f822 	bl	9214 <cprintf>
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
    71d0:	4620      	mov	r0, r4
    71d2:	2101      	movs	r1, #1
}
    71d4:	b003      	add	sp, #12
    71d6:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
    71da:	f7fe ba65 	b.w	56a8 <btctl_set_state>
    71de:	bf00      	nop
    71e0:	100023dc 	.word	0x100023dc
    71e4:	10000a70 	.word	0x10000a70
    71e8:	40008008 	.word	0x40008008
    71ec:	0000715d 	.word	0x0000715d
    71f0:	100001b0 	.word	0x100001b0
    71f4:	10000a78 	.word	0x10000a78
    71f8:	00007091 	.word	0x00007091
    71fc:	0000deb4 	.word	0x0000deb4
    7200:	0000de9c 	.word	0x0000de9c

00007204 <inquiry_scan_state_setup>:

/*
 * Inquiry slave
 */
void inquiry_scan_state_setup(void)
{
    7204:	b570      	push	{r4, r5, r6, lr}
    7206:	b086      	sub	sp, #24
	btctl_set_state(BTCTL_STATE_INQUIRY_SCAN, BTCTL_REASON_SUCCESS);

	/* A simple Header for our fhs */ 
	inquiry_scan_state.fhs_hdr.lt_addr = 0;
	inquiry_scan_state.fhs_hdr.type = BB_TYPE_FHS;
	inquiry_scan_state.fhs_hdr.flags = 0; 		// Depends on devices, some sends BTHDR_FLOW|BTHDR_SEQN, others send 0, both seems right
    7208:	2400      	movs	r4, #0
	btphy_set_mode(BT_MODE_INQUIRY_SCAN, GIAC, 0);
    720a:	2200      	movs	r2, #0
    720c:	2002      	movs	r0, #2
    720e:	4920      	ldr	r1, [pc, #128]	; (7290 <inquiry_scan_state_setup+0x8c>)
    7210:	f7fe fd0e 	bl	5c30 <btphy_set_mode>
	btctl_set_state(BTCTL_STATE_INQUIRY_SCAN, BTCTL_REASON_SUCCESS);
    7214:	2100      	movs	r1, #0
    7216:	2004      	movs	r0, #4
    7218:	f7fe fa46 	bl	56a8 <btctl_set_state>
	return btctl.eir_pkt;
    721c:	4b1d      	ldr	r3, [pc, #116]	; (7294 <inquiry_scan_state_setup+0x90>)
	inquiry_scan_state.fhs_hdr.lt_addr = 0;
    721e:	f44f 7100 	mov.w	r1, #512	; 0x200

	/* Prepare constant part of FHS payload */
	bbpkt_fhs_prepare_payload(inquiry_scan_state.fhs_data,
    7222:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
		btphy.my_sw&0xffffffff,	// parity: low32 bits of master's sw
    7226:	4b1c      	ldr	r3, [pc, #112]	; (7298 <inquiry_scan_state_setup+0x94>)
	bbpkt_fhs_prepare_payload(inquiry_scan_state.fhs_data,
    7228:	1b12      	subs	r2, r2, r4
    722a:	bf18      	it	ne
    722c:	2201      	movne	r2, #1
    722e:	8f58      	ldrh	r0, [r3, #58]	; 0x3a
    7230:	f893 6038 	ldrb.w	r6, [r3, #56]	; 0x38
    7234:	9205      	str	r2, [sp, #20]
    7236:	6b5a      	ldr	r2, [r3, #52]	; 0x34
	inquiry_scan_state.fhs_hdr.lt_addr = 0;
    7238:	4d18      	ldr	r5, [pc, #96]	; (729c <inquiry_scan_state_setup+0x98>)
	bbpkt_fhs_prepare_payload(inquiry_scan_state.fhs_data,
    723a:	e9cd 2600 	strd	r2, r6, [sp]
    723e:	9002      	str	r0, [sp, #8]
    7240:	4817      	ldr	r0, [pc, #92]	; (72a0 <inquiry_scan_state_setup+0x9c>)
    7242:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    7244:	4623      	mov	r3, r4
    7246:	9003      	str	r0, [sp, #12]
    7248:	9404      	str	r4, [sp, #16]
    724a:	f105 0008 	add.w	r0, r5, #8
	inquiry_scan_state.fhs_hdr.lt_addr = 0;
    724e:	80a9      	strh	r1, [r5, #4]
	inquiry_scan_state.fhs_hdr.flags = 0; 		// Depends on devices, some sends BTHDR_FLOW|BTHDR_SEQN, others send 0, both seems right
    7250:	71ac      	strb	r4, [r5, #6]
	bbpkt_fhs_prepare_payload(inquiry_scan_state.fhs_data,
    7252:	f7fc fff3 	bl	423c <bbpkt_fhs_prepare_payload>
		0x5A020C,		// class: FIXME: make this configurable
		0,			// lt_addr
		btctl_get_eir() != NULL
		);

	inquiry_scan_state.clkn_start = MASTER_CLKN+1;
    7256:	4b13      	ldr	r3, [pc, #76]	; (72a4 <inquiry_scan_state_setup+0xa0>)
    7258:	681a      	ldr	r2, [r3, #0]
    725a:	1c51      	adds	r1, r2, #1
    725c:	6029      	str	r1, [r5, #0]
	if (MASTER_CLKN >= inquiry_scan_state.clkn_start + INQ_SCAN_MAX_TICKS)
    725e:	681b      	ldr	r3, [r3, #0]
    7260:	f502 323b 	add.w	r2, r2, #191488	; 0x2ec00
    7264:	f202 2201 	addw	r2, r2, #513	; 0x201
    7268:	4293      	cmp	r3, r2
    726a:	d207      	bcs.n	727c <inquiry_scan_state_setup+0x78>
	scan_task_schedule(delay, inquiry_scan_rx_cb, NULL);
    726c:	4622      	mov	r2, r4
    726e:	2001      	movs	r0, #1
    7270:	490d      	ldr	r1, [pc, #52]	; (72a8 <inquiry_scan_state_setup+0xa4>)
	inquiry_scan_schedule(1);
}
    7272:	b006      	add	sp, #24
    7274:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	scan_task_schedule(delay, inquiry_scan_rx_cb, NULL);
    7278:	f7ff beee 	b.w	7058 <scan_task_schedule>
		cprintf("inquiry scan timeout\n");
    727c:	480b      	ldr	r0, [pc, #44]	; (72ac <inquiry_scan_state_setup+0xa8>)
    727e:	f001 ffc9 	bl	9214 <cprintf>
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
    7282:	4620      	mov	r0, r4
    7284:	2101      	movs	r1, #1
}
    7286:	b006      	add	sp, #24
    7288:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
    728c:	f7fe ba0c 	b.w	56a8 <btctl_set_state>
    7290:	009e8b33 	.word	0x009e8b33
    7294:	100023dc 	.word	0x100023dc
    7298:	100001b0 	.word	0x100001b0
    729c:	10000a70 	.word	0x10000a70
    72a0:	005a020c 	.word	0x005a020c
    72a4:	40008008 	.word	0x40008008
    72a8:	0000715d 	.word	0x0000715d
    72ac:	0000de9c 	.word	0x0000de9c

000072b0 <start_monitor2>:
{
	return btctl_get_state() != BTCTL_STATE_PAGE_SCAN;
}

static int start_monitor2(uint8_t p1, uint8_t p2, uint16_t p3)
{
    72b0:	b510      	push	{r4, lr}
    72b2:	b082      	sub	sp, #8
	cprintf("fhs: ba=%llx clk27_2=%x lta=%d\n",
    72b4:	4c08      	ldr	r4, [pc, #32]	; (72d8 <start_monitor2+0x28>)
    72b6:	4809      	ldr	r0, [pc, #36]	; (72dc <start_monitor2+0x2c>)
    72b8:	7b22      	ldrb	r2, [r4, #12]
    72ba:	68a3      	ldr	r3, [r4, #8]
    72bc:	e9cd 3200 	strd	r3, r2, [sp]
    72c0:	e9d4 2300 	ldrd	r2, r3, [r4]
    72c4:	f001 ffa6 	bl	9214 <cprintf>
		monitor1_state.fhs_info.bdaddr,
		monitor1_state.fhs_info.clk27_2,
		monitor1_state.fhs_info.lt_addr);

	monitor2_state_init(monitor1_state.fhs_info.bdaddr);
    72c8:	e9d4 0100 	ldrd	r0, r1, [r4]
    72cc:	f000 faa8 	bl	7820 <monitor2_state_init>
	return 0;
}
    72d0:	2000      	movs	r0, #0
    72d2:	b002      	add	sp, #8
    72d4:	bd10      	pop	{r4, pc}
    72d6:	bf00      	nop
    72d8:	10002508 	.word	0x10002508
    72dc:	0000dec8 	.word	0x0000dec8

000072e0 <monitor1_rx_fhs_cb>:

/* RX FHS cb */
static int monitor1_rx_fhs_cb(msg_t *msg, void *arg, int time_offset)
{
    72e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    72e2:	b083      	sub	sp, #12
	return btctl.state;
    72e4:	4d2d      	ldr	r5, [pc, #180]	; (739c <monitor1_rx_fhs_cb+0xbc>)
    72e6:	4604      	mov	r4, r0
	btctl_hdr_t *h = (btctl_hdr_t*)msg->data;
	btctl_rx_pkt_t *pkt;

	if (monitor1_canceled())
    72e8:	782b      	ldrb	r3, [r5, #0]
    72ea:	2b05      	cmp	r3, #5
    72ec:	d126      	bne.n	733c <monitor1_rx_fhs_cb+0x5c>
	{
		cprintf("monitor1 canceled\n");
		goto end;
	}
	pkt = (btctl_rx_pkt_t *)h->data;
	if (BBPKT_GOOD_CRC(pkt))
    72ee:	7d43      	ldrb	r3, [r0, #21]
    72f0:	071a      	lsls	r2, r3, #28
    72f2:	d50b      	bpl.n	730c <monitor1_rx_fhs_cb+0x2c>
	{
		if (pkt->bb_hdr.type != BB_TYPE_FHS)
    72f4:	7e41      	ldrb	r1, [r0, #25]
    72f6:	2902      	cmp	r1, #2
    72f8:	d02c      	beq.n	7354 <monitor1_rx_fhs_cb+0x74>
		{
			cprintf("(bad type %d)", pkt->bb_hdr.type);
    72fa:	4829      	ldr	r0, [pc, #164]	; (73a0 <monitor1_rx_fhs_cb+0xc0>)
    72fc:	f001 ff8a 	bl	9214 <cprintf>
    7300:	4620      	mov	r0, r4
    7302:	f000 fdb3 	bl	7e6c <mem_pool_free>
	}
end:
	msg_free(msg);
end_nofree:
	return 0;
}
    7306:	2000      	movs	r0, #0
    7308:	b003      	add	sp, #12
    730a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (BBPKT_HAS_HDR(pkt) && pkt->bb_hdr.type)
    730c:	079b      	lsls	r3, r3, #30
    730e:	d505      	bpl.n	731c <monitor1_rx_fhs_cb+0x3c>
    7310:	7e40      	ldrb	r0, [r0, #25]
    7312:	b118      	cbz	r0, 731c <monitor1_rx_fhs_cb+0x3c>
			console_putc('0'+pkt->bb_hdr.type);
    7314:	3030      	adds	r0, #48	; 0x30
    7316:	b2c0      	uxtb	r0, r0
    7318:	f000 fde6 	bl	7ee8 <console_putc>
	}
}

static void monitor1_schedule(unsigned delay)
{
	if (MASTER_CLKN >= monitor1_state.clkn_start + PAGE_SCAN_MAX_TICKS)
    731c:	4b21      	ldr	r3, [pc, #132]	; (73a4 <monitor1_rx_fhs_cb+0xc4>)
    731e:	4a22      	ldr	r2, [pc, #136]	; (73a8 <monitor1_rx_fhs_cb+0xc8>)
    7320:	691b      	ldr	r3, [r3, #16]
    7322:	6812      	ldr	r2, [r2, #0]
    7324:	f503 333b 	add.w	r3, r3, #191488	; 0x2ec00
    7328:	f503 7300 	add.w	r3, r3, #512	; 0x200
    732c:	429a      	cmp	r2, r3
    732e:	d209      	bcs.n	7344 <monitor1_rx_fhs_cb+0x64>
	{
		cprintf("monitor1 timeout\n");
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
		return;
	}
	scan_task_schedule(delay, monitor1_rx_id_cb, NULL);
    7330:	2200      	movs	r2, #0
    7332:	491e      	ldr	r1, [pc, #120]	; (73ac <monitor1_rx_fhs_cb+0xcc>)
    7334:	4610      	mov	r0, r2
    7336:	f7ff fe8f 	bl	7058 <scan_task_schedule>
    733a:	e7e1      	b.n	7300 <monitor1_rx_fhs_cb+0x20>
		cprintf("monitor1 canceled\n");
    733c:	481c      	ldr	r0, [pc, #112]	; (73b0 <monitor1_rx_fhs_cb+0xd0>)
    733e:	f001 ff69 	bl	9214 <cprintf>
		goto end;
    7342:	e7dd      	b.n	7300 <monitor1_rx_fhs_cb+0x20>
		cprintf("monitor1 timeout\n");
    7344:	481b      	ldr	r0, [pc, #108]	; (73b4 <monitor1_rx_fhs_cb+0xd4>)
    7346:	f001 ff65 	bl	9214 <cprintf>
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
    734a:	2101      	movs	r1, #1
    734c:	2000      	movs	r0, #0
    734e:	f7fe f9ab 	bl	56a8 <btctl_set_state>
		return;
    7352:	e7d5      	b.n	7300 <monitor1_rx_fhs_cb+0x20>
		bbpkt_decode_fhs(pkt->bt_data, &monitor1_state.fhs_info);
    7354:	4f13      	ldr	r7, [pc, #76]	; (73a4 <monitor1_rx_fhs_cb+0xc4>)
    7356:	301c      	adds	r0, #28
    7358:	4639      	mov	r1, r7
    735a:	f7fc ffaf 	bl	42bc <bbpkt_decode_fhs>
		tdma_schedule(1, start_monitor2, 0, 0, 0, -3);
    735e:	f06f 0002 	mvn.w	r0, #2
    7362:	2300      	movs	r3, #0
		btphy.slave_clkn = (monitor1_state.fhs_info.clk27_2<<2)
    7364:	4e14      	ldr	r6, [pc, #80]	; (73b8 <monitor1_rx_fhs_cb+0xd8>)
    7366:	68b9      	ldr	r1, [r7, #8]
				 + (btphy.slave_clkn-pkt->clkn);
    7368:	68b2      	ldr	r2, [r6, #8]
		tdma_schedule(1, start_monitor2, 0, 0, 0, -3);
    736a:	9001      	str	r0, [sp, #4]
				 + (btphy.slave_clkn-pkt->clkn);
    736c:	6920      	ldr	r0, [r4, #16]
    736e:	eb02 0281 	add.w	r2, r2, r1, lsl #2
    7372:	1a10      	subs	r0, r2, r0
		tdma_schedule(1, start_monitor2, 0, 0, 0, -3);
    7374:	9300      	str	r3, [sp, #0]
    7376:	461a      	mov	r2, r3
		btphy.slave_clkn = (monitor1_state.fhs_info.clk27_2<<2)
    7378:	60b0      	str	r0, [r6, #8]
		tdma_schedule(1, start_monitor2, 0, 0, 0, -3);
    737a:	4910      	ldr	r1, [pc, #64]	; (73bc <monitor1_rx_fhs_cb+0xdc>)
    737c:	2001      	movs	r0, #1
    737e:	f7fe fd41 	bl	5e04 <tdma_schedule>
	__asm__ __volatile__ (
    7382:	f3ef 8610 	mrs	r6, PRIMASK
    7386:	b672      	cpsid	i
	rc = msg_enqueue(q, msg);
    7388:	4621      	mov	r1, r4
    738a:	f105 002c 	add.w	r0, r5, #44	; 0x2c
    738e:	f000 fecb 	bl	8128 <msg_enqueue>
	__asm__ __volatile__ (
    7392:	f386 8810 	msr	PRIMASK, r6
}
    7396:	2000      	movs	r0, #0
    7398:	b003      	add	sp, #12
    739a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    739c:	100023dc 	.word	0x100023dc
    73a0:	0000defc 	.word	0x0000defc
    73a4:	10002508 	.word	0x10002508
    73a8:	40008008 	.word	0x40008008
    73ac:	000073c1 	.word	0x000073c1
    73b0:	0000dee8 	.word	0x0000dee8
    73b4:	0000df0c 	.word	0x0000df0c
    73b8:	100001b0 	.word	0x100001b0
    73bc:	000072b1 	.word	0x000072b1

000073c0 <monitor1_rx_id_cb>:
{
    73c0:	b530      	push	{r4, r5, lr}
    73c2:	b083      	sub	sp, #12
	return btctl.state;
    73c4:	4b20      	ldr	r3, [pc, #128]	; (7448 <monitor1_rx_id_cb+0x88>)
    73c6:	4604      	mov	r4, r0
	if(monitor1_canceled())
    73c8:	781b      	ldrb	r3, [r3, #0]
    73ca:	2b05      	cmp	r3, #5
    73cc:	d12b      	bne.n	7426 <monitor1_rx_id_cb+0x66>
	if (sw_detected)
    73ce:	b980      	cbnz	r0, 73f2 <monitor1_rx_id_cb+0x32>
	if (MASTER_CLKN >= monitor1_state.clkn_start + PAGE_SCAN_MAX_TICKS)
    73d0:	4b1e      	ldr	r3, [pc, #120]	; (744c <monitor1_rx_id_cb+0x8c>)
    73d2:	4a1f      	ldr	r2, [pc, #124]	; (7450 <monitor1_rx_id_cb+0x90>)
    73d4:	691b      	ldr	r3, [r3, #16]
    73d6:	6812      	ldr	r2, [r2, #0]
    73d8:	f503 333b 	add.w	r3, r3, #191488	; 0x2ec00
    73dc:	f503 7300 	add.w	r3, r3, #512	; 0x200
    73e0:	429a      	cmp	r2, r3
    73e2:	d226      	bcs.n	7432 <monitor1_rx_id_cb+0x72>
	scan_task_schedule(delay, monitor1_rx_id_cb, NULL);
    73e4:	4602      	mov	r2, r0
    73e6:	491b      	ldr	r1, [pc, #108]	; (7454 <monitor1_rx_id_cb+0x94>)
}
    73e8:	b003      	add	sp, #12
    73ea:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	scan_task_schedule(delay, monitor1_rx_id_cb, NULL);
    73ee:	f7ff be33 	b.w	7058 <scan_task_schedule>
		tx_task_schedule(delay,
    73f2:	2500      	movs	r5, #0
		console_putc('!');
    73f4:	2021      	movs	r0, #33	; 0x21
    73f6:	f000 fd77 	bl	7ee8 <console_putc>
		delay = 3&(TX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX());
    73fa:	4b17      	ldr	r3, [pc, #92]	; (7458 <monitor1_rx_id_cb+0x98>)
		tx_task_schedule(delay,
    73fc:	9500      	str	r5, [sp, #0]
		delay = 3&(TX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX());
    73fe:	689c      	ldr	r4, [r3, #8]
		tx_task_schedule(delay,
    7400:	462a      	mov	r2, r5
		delay = 3&(TX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX());
    7402:	f1c4 0401 	rsb	r4, r4, #1
    7406:	f004 0403 	and.w	r4, r4, #3
		tx_task_schedule(delay,
    740a:	462b      	mov	r3, r5
    740c:	4620      	mov	r0, r4
    740e:	4629      	mov	r1, r5
    7410:	f7ff fd74 	bl	6efc <tx_task_schedule>
		rx_task_schedule(delay+2,
    7414:	462a      	mov	r2, r5
    7416:	2301      	movs	r3, #1
    7418:	4910      	ldr	r1, [pc, #64]	; (745c <monitor1_rx_id_cb+0x9c>)
    741a:	1ca0      	adds	r0, r4, #2
}
    741c:	b003      	add	sp, #12
    741e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		rx_task_schedule(delay+2,
    7422:	f7ff b8cf 	b.w	65c4 <rx_task_schedule>
		cprintf("monitor1 canceled\n");
    7426:	480e      	ldr	r0, [pc, #56]	; (7460 <monitor1_rx_id_cb+0xa0>)
}
    7428:	b003      	add	sp, #12
    742a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		cprintf("monitor1 canceled\n");
    742e:	f001 bef1 	b.w	9214 <cprintf>
		cprintf("monitor1 timeout\n");
    7432:	480c      	ldr	r0, [pc, #48]	; (7464 <monitor1_rx_id_cb+0xa4>)
    7434:	f001 feee 	bl	9214 <cprintf>
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
    7438:	4620      	mov	r0, r4
    743a:	2101      	movs	r1, #1
}
    743c:	b003      	add	sp, #12
    743e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
    7442:	f7fe b931 	b.w	56a8 <btctl_set_state>
    7446:	bf00      	nop
    7448:	100023dc 	.word	0x100023dc
    744c:	10002508 	.word	0x10002508
    7450:	40008008 	.word	0x40008008
    7454:	000073c1 	.word	0x000073c1
    7458:	100001b0 	.word	0x100001b0
    745c:	000072e1 	.word	0x000072e1
    7460:	0000dee8 	.word	0x0000dee8
    7464:	0000df0c 	.word	0x0000df0c

00007468 <monitor1_state_setup>:
 * 3 - Receive FHS, do not send ID(3) (thats the trick!!)
 * 4 - Start hopping on piconet and wait for real connection to establish
 * 5 - Sniff all timeslots
 */
void monitor1_state_setup(uint64_t slave_bdaddr)
{
    7468:	b508      	push	{r3, lr}
	btphy_set_bdaddr(slave_bdaddr);
    746a:	f7fe fc31 	bl	5cd0 <btphy_set_bdaddr>
	btphy_set_mode(BT_MODE_PAGE_SCAN, btphy.my_lap, btphy.my_uap);
    746e:	4b13      	ldr	r3, [pc, #76]	; (74bc <monitor1_state_setup+0x54>)
    7470:	2003      	movs	r0, #3
    7472:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
    7476:	6b59      	ldr	r1, [r3, #52]	; 0x34
    7478:	f7fe fbda 	bl	5c30 <btphy_set_mode>
	btctl_set_state(BTCTL_STATE_PAGE_SCAN, BTCTL_REASON_SUCCESS);
    747c:	2100      	movs	r1, #0
    747e:	2005      	movs	r0, #5
    7480:	f7fe f912 	bl	56a8 <btctl_set_state>
	monitor1_state.clkn_start = MASTER_CLKN+1;
    7484:	4a0e      	ldr	r2, [pc, #56]	; (74c0 <monitor1_state_setup+0x58>)
    7486:	480f      	ldr	r0, [pc, #60]	; (74c4 <monitor1_state_setup+0x5c>)
    7488:	6813      	ldr	r3, [r2, #0]
	if (MASTER_CLKN >= monitor1_state.clkn_start + PAGE_SCAN_MAX_TICKS)
    748a:	6811      	ldr	r1, [r2, #0]
    748c:	f503 323b 	add.w	r2, r3, #191488	; 0x2ec00
    7490:	f202 2201 	addw	r2, r2, #513	; 0x201
	monitor1_state.clkn_start = MASTER_CLKN+1;
    7494:	3301      	adds	r3, #1
	if (MASTER_CLKN >= monitor1_state.clkn_start + PAGE_SCAN_MAX_TICKS)
    7496:	4291      	cmp	r1, r2
	monitor1_state.clkn_start = MASTER_CLKN+1;
    7498:	6103      	str	r3, [r0, #16]
	if (MASTER_CLKN >= monitor1_state.clkn_start + PAGE_SCAN_MAX_TICKS)
    749a:	d206      	bcs.n	74aa <monitor1_state_setup+0x42>
	monitor1_schedule(1);
}
    749c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	scan_task_schedule(delay, monitor1_rx_id_cb, NULL);
    74a0:	2200      	movs	r2, #0
    74a2:	2001      	movs	r0, #1
    74a4:	4908      	ldr	r1, [pc, #32]	; (74c8 <monitor1_state_setup+0x60>)
    74a6:	f7ff bdd7 	b.w	7058 <scan_task_schedule>
		cprintf("monitor1 timeout\n");
    74aa:	4808      	ldr	r0, [pc, #32]	; (74cc <monitor1_state_setup+0x64>)
    74ac:	f001 feb2 	bl	9214 <cprintf>
}
    74b0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
    74b4:	2101      	movs	r1, #1
    74b6:	2000      	movs	r0, #0
    74b8:	f7fe b8f6 	b.w	56a8 <btctl_set_state>
    74bc:	100001b0 	.word	0x100001b0
    74c0:	40008008 	.word	0x40008008
    74c4:	10002508 	.word	0x10002508
    74c8:	000073c1 	.word	0x000073c1
    74cc:	0000df0c 	.word	0x0000df0c

000074d0 <hop_init>:

hop_state_t hop_state;

/* do all of the one time precalculation */
void hop_init(uint32_t address)
{
    74d0:	b4f0      	push	{r4, r5, r6, r7}
    74d2:	2200      	movs	r2, #0
    74d4:	492c      	ldr	r1, [pc, #176]	; (7588 <hop_init+0xb8>)
	uint8_t i;

	/* populate frequency register bank */
	for (i = 0; i < NUM_BREDR_CHANNELS; i++)
	{
		hop_state.basic_bank[i] = ((i * 2) % NUM_BREDR_CHANNELS);
    74d6:	4e2d      	ldr	r6, [pc, #180]	; (758c <hop_init+0xbc>)
    74d8:	f101 054f 	add.w	r5, r1, #79	; 0x4f
    74dc:	fba6 4302 	umull	r4, r3, r6, r2
    74e0:	099b      	lsrs	r3, r3, #6
    74e2:	eb03 0483 	add.w	r4, r3, r3, lsl #2
    74e6:	ebc3 1304 	rsb	r3, r3, r4, lsl #4
    74ea:	1ad3      	subs	r3, r2, r3
    74ec:	f801 3f01 	strb.w	r3, [r1, #1]!
	for (i = 0; i < NUM_BREDR_CHANNELS; i++)
    74f0:	428d      	cmp	r5, r1
    74f2:	f102 0202 	add.w	r2, r2, #2
    74f6:	d1f1      	bne.n	74dc <hop_init+0xc>
			((address >> 5) & 0x10) +
			((address >> 4) & 0x08) +
			((address >> 3) & 0x04) +
			((address >> 2) & 0x02) +
			((address >> 1) & 0x01);
	hop_state.x = 0;
    74f8:	2400      	movs	r4, #0
	hop_state.afh_enabled = 0;
	hop_state.bank = hop_state.basic_bank;
	hop_state.chan_count = NUM_BREDR_CHANNELS;
    74fa:	254f      	movs	r5, #79	; 0x4f
			((address >> 3) & 0x08) |
    74fc:	f3c0 03c7 	ubfx	r3, r0, #3, #8
	hop_state.C = ((address >> 4) & 0x10) |
    7500:	f3c0 1607 	ubfx	r6, r0, #4, #8
    7504:	f006 0210 	and.w	r2, r6, #16
			((address >> 3) & 0x08) |
    7508:	f003 0c08 	and.w	ip, r3, #8
			((address >> 2) & 0x04) |
    750c:	f3c0 0787 	ubfx	r7, r0, #2, #8
			((address >> 3) & 0x04) +
    7510:	f003 0104 	and.w	r1, r3, #4
	hop_state.C = ((address >> 4) & 0x10) |
    7514:	ea42 030c 	orr.w	r3, r2, ip
			(address & 0x01);
    7518:	f000 0201 	and.w	r2, r0, #1
			((address >> 1) & 0x02) |
    751c:	f3c0 0c47 	ubfx	ip, r0, #1, #8
    7520:	4313      	orrs	r3, r2
			((address >> 2) & 0x04) |
    7522:	f007 0204 	and.w	r2, r7, #4
			((address >> 2) & 0x02) +
    7526:	f007 0702 	and.w	r7, r7, #2
    752a:	4339      	orrs	r1, r7
			((address >> 1) & 0x02) |
    752c:	f00c 0702 	and.w	r7, ip, #2
			((address >> 1) & 0x01);
    7530:	f00c 0c01 	and.w	ip, ip, #1
			((address >> 1) & 0x02) |
    7534:	4313      	orrs	r3, r2
			((address >> 2) & 0x02) +
    7536:	4461      	add	r1, ip
	hop_state.E =	((address >> 7) & 0x40) +
    7538:	09c2      	lsrs	r2, r0, #7
			((address >> 6) & 0x20) +
    753a:	ea4f 1c90 	mov.w	ip, r0, lsr #6
	hop_state.E =	((address >> 7) & 0x40) +
    753e:	f002 0240 	and.w	r2, r2, #64	; 0x40
			((address >> 6) & 0x20) +
    7542:	f00c 0c20 	and.w	ip, ip, #32
	hop_state.E =	((address >> 7) & 0x40) +
    7546:	ea42 020c 	orr.w	r2, r2, ip
			((address >> 2) & 0x02) +
    754a:	440a      	add	r2, r1
			((address >> 5) & 0x10) +
    754c:	0941      	lsrs	r1, r0, #5
			((address >> 4) & 0x08) +
    754e:	f006 0608 	and.w	r6, r6, #8
			((address >> 5) & 0x10) +
    7552:	f001 0110 	and.w	r1, r1, #16
			((address >> 2) & 0x02) +
    7556:	4331      	orrs	r1, r6
			((address >> 1) & 0x02) |
    7558:	431f      	orrs	r7, r3
	hop_state.a27_23 = (address >> 23) & 0x1f;
    755a:	4b0d      	ldr	r3, [pc, #52]	; (7590 <hop_init+0xc0>)
			((address >> 2) & 0x02) +
    755c:	440a      	add	r2, r1
	hop_state.a27_23 = (address >> 23) & 0x1f;
    755e:	f3c0 56c4 	ubfx	r6, r0, #23, #5
	hop_state.a22_19 = (address >> 19) & 0x0f; 	// Addr22_19
    7562:	f3c0 41c3 	ubfx	r1, r0, #19, #4
	hop_state.E =	((address >> 7) & 0x40) +
    7566:	70da      	strb	r2, [r3, #3]
	hop_state.C = ((address >> 4) & 0x10) |
    7568:	709f      	strb	r7, [r3, #2]
	hop_state.a18_10 = (address >> 10) & 0x1ff;
    756a:	f3c0 2088 	ubfx	r0, r0, #10, #9
	hop_state.bank = hop_state.basic_bank;
    756e:	1dda      	adds	r2, r3, #7
	hop_state.a27_23 = (address >> 23) & 0x1f;
    7570:	701e      	strb	r6, [r3, #0]
	hop_state.a22_19 = (address >> 19) & 0x0f; 	// Addr22_19
    7572:	7059      	strb	r1, [r3, #1]
	hop_state.chan_count = NUM_BREDR_CHANNELS;
    7574:	f883 50ac 	strb.w	r5, [r3, #172]	; 0xac
	hop_state.x = 0;
    7578:	719c      	strb	r4, [r3, #6]
	hop_state.afh_enabled = 0;
    757a:	f883 40a6 	strb.w	r4, [r3, #166]	; 0xa6
	hop_state.a18_10 = (address >> 10) & 0x1ff;
    757e:	8098      	strh	r0, [r3, #4]
	hop_state.bank = hop_state.basic_bank;
    7580:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
}
    7584:	bcf0      	pop	{r4, r5, r6, r7}
    7586:	4770      	bx	lr
    7588:	10002526 	.word	0x10002526
    758c:	cf6474a9 	.word	0xcf6474a9
    7590:	10002520 	.word	0x10002520

00007594 <hop_cfg_afh>:
	}
	hop_state.afh_chan_count = count;
}

void hop_cfg_afh(uint8_t* buf)
{
    7594:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint8_t enabled = buf[0] & 1;
    7598:	f890 8000 	ldrb.w	r8, [r0]
{
    759c:	4681      	mov	r9, r0
	uint8_t *map = buf+1;

	if (enabled)
    759e:	f018 0801 	ands.w	r8, r8, #1
    75a2:	d023      	beq.n	75ec <hop_cfg_afh+0x58>
	for (i = 0, count=0; i < NUM_BREDR_CHANNELS; i++) {
    75a4:	2400      	movs	r4, #0
	{
		cprintf("(+afh)");
    75a6:	4818      	ldr	r0, [pc, #96]	; (7608 <hop_cfg_afh+0x74>)
    75a8:	f001 fe34 	bl	9214 <cprintf>
	for (i = 0, count=0; i < NUM_BREDR_CHANNELS; i++) {
    75ac:	4917      	ldr	r1, [pc, #92]	; (760c <hop_cfg_afh+0x78>)
    75ae:	f101 004f 	add.w	r0, r1, #79	; 0x4f
    75b2:	1f8f      	subs	r7, r1, #6
		chan = hop_state.basic_bank[i];
    75b4:	f811 2f01 	ldrb.w	r2, [r1, #1]!
			hop_state.afh_bank[count++] = chan;
    75b8:	193e      	adds	r6, r7, r4
		if(afh_map[chan/8] & (0x1 << (chan%8)))
    75ba:	eb09 03d2 	add.w	r3, r9, r2, lsr #3
    75be:	785b      	ldrb	r3, [r3, #1]
    75c0:	f002 0507 	and.w	r5, r2, #7
    75c4:	412b      	asrs	r3, r5
    75c6:	07db      	lsls	r3, r3, #31
			hop_state.afh_bank[count++] = chan;
    75c8:	bf44      	itt	mi
    75ca:	f886 2056 	strbmi.w	r2, [r6, #86]	; 0x56
    75ce:	3401      	addmi	r4, #1
	for (i = 0, count=0; i < NUM_BREDR_CHANNELS; i++) {
    75d0:	4288      	cmp	r0, r1
    75d2:	d1ef      	bne.n	75b4 <hop_cfg_afh+0x20>
	hop_state.afh_chan_count = count;
    75d4:	b2e4      	uxtb	r4, r4
		hop_set_afh_map(map);
		hop_state.bank = hop_state.afh_bank;
    75d6:	4b0e      	ldr	r3, [pc, #56]	; (7610 <hop_cfg_afh+0x7c>)
	hop_state.afh_chan_count = count;
    75d8:	f887 40a5 	strb.w	r4, [r7, #165]	; 0xa5
		hop_state.chan_count = hop_state.afh_chan_count;
    75dc:	f887 40ac 	strb.w	r4, [r7, #172]	; 0xac
	{
		cprintf("(-afh)");
		hop_state.bank = hop_state.basic_bank;
		hop_state.chan_count = NUM_BREDR_CHANNELS;
	}
	hop_state.afh_enabled = enabled;
    75e0:	f887 80a6 	strb.w	r8, [r7, #166]	; 0xa6
		hop_state.bank = hop_state.afh_bank;
    75e4:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
}
    75e8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		cprintf("(-afh)");
    75ec:	4809      	ldr	r0, [pc, #36]	; (7614 <hop_cfg_afh+0x80>)
    75ee:	f001 fe11 	bl	9214 <cprintf>
		hop_state.chan_count = NUM_BREDR_CHANNELS;
    75f2:	234f      	movs	r3, #79	; 0x4f
		hop_state.bank = hop_state.basic_bank;
    75f4:	4f08      	ldr	r7, [pc, #32]	; (7618 <hop_cfg_afh+0x84>)
    75f6:	1dfa      	adds	r2, r7, #7
		hop_state.chan_count = NUM_BREDR_CHANNELS;
    75f8:	f887 30ac 	strb.w	r3, [r7, #172]	; 0xac
	hop_state.afh_enabled = enabled;
    75fc:	f887 80a6 	strb.w	r8, [r7, #166]	; 0xa6
		hop_state.bank = hop_state.basic_bank;
    7600:	f8c7 20a8 	str.w	r2, [r7, #168]	; 0xa8
}
    7604:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    7608:	0000df20 	.word	0x0000df20
    760c:	10002526 	.word	0x10002526
    7610:	10002576 	.word	0x10002576
    7614:	0000df28 	.word	0x0000df28
    7618:	10002520 	.word	0x10002520

0000761c <hop_basic>:

uint8_t hop_basic(uint32_t clk)
{
    761c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t clk1, sel;

	// Same-channel mechanism for AFH (FIXME: is this correct ?)
	if (hop_state.afh_enabled)
    7620:	4d28      	ldr	r5, [pc, #160]	; (76c4 <hop_basic+0xa8>)
    7622:	f895 30a6 	ldrb.w	r3, [r5, #166]	; 0xa6
    7626:	2b00      	cmp	r3, #0
    7628:	d148      	bne.n	76bc <hop_basic+0xa0>
		clk1 = 0;
	else
		clk1 = 1&(clk>>1);
    762a:	f3c0 0440 	ubfx	r4, r0, #1, #1
    762e:	4263      	negs	r3, r4
    7630:	b2db      	uxtb	r3, r3
    7632:	0164      	lsls	r4, r4, #5
		hop_state.a27_23^(0x1f&(clk>>21)),	// A = A27_23 ^ clk25_21
		hop_state.a22_19,			// B = A22_19
		hop_state.C^(0x1f&(clk>>16)),		// C = A8,6,4,2,0 ^ clk20_16
		hop_state.a18_10^(0x1ff&(clk>>7)),	// D = a18_10 ^ clk15_7
		hop_state.E,				// E = A13,11,9,7,5,3,1
		((clk>>(7-4))&(0x1fffff<<4))%hop_state.chan_count	// F = 16*clk27_7 % 79
    7634:	4e24      	ldr	r6, [pc, #144]	; (76c8 <hop_basic+0xac>)
    7636:	f895 70ac 	ldrb.w	r7, [r5, #172]	; 0xac
    763a:	ea06 0cd0 	and.w	ip, r6, r0, lsr #3
    763e:	fbbc f6f7 	udiv	r6, ip, r7
	sel = hop_selection_kernel(
    7642:	78aa      	ldrb	r2, [r5, #2]
    7644:	88a9      	ldrh	r1, [r5, #4]
		hop_state.C^(0x1f&(clk>>16)),		// C = A8,6,4,2,0 ^ clk20_16
    7646:	f3c0 4e04 	ubfx	lr, r0, #16, #5
	sel = hop_selection_kernel(
    764a:	ea8e 0e02 	eor.w	lr, lr, r2
    764e:	f895 8000 	ldrb.w	r8, [r5]
		hop_state.a18_10^(0x1ff&(clk>>7)),	// D = a18_10 ^ clk15_7
    7652:	f3c0 12c8 	ubfx	r2, r0, #7, #9
	sel = hop_selection_kernel(
    7656:	404a      	eors	r2, r1
		hop_state.a27_23^(0x1f&(clk>>21)),	// A = A27_23 ^ clk25_21
    7658:	f3c0 5144 	ubfx	r1, r0, #21, #5
	uint16_t p = (p_low&0x1ff)|((p_high&0x1f)<<9);
    765c:	ea83 030e 	eor.w	r3, r3, lr
	sel = hop_selection_kernel(
    7660:	ea81 0108 	eor.w	r1, r1, r8
    7664:	f3c0 0084 	ubfx	r0, r0, #2, #5
	return (perm5((a+x)^b, y1^c, d) + e + f + y2);
    7668:	4401      	add	r1, r0
    766a:	025b      	lsls	r3, r3, #9
    766c:	7868      	ldrb	r0, [r5, #1]
    766e:	f3c2 0208 	ubfx	r2, r2, #0, #9
    7672:	f403 5378 	and.w	r3, r3, #15872	; 0x3e00
	z = perm5_lut[0][(((p>>7))<<5)|z];
    7676:	4313      	orrs	r3, r2
    7678:	4041      	eors	r1, r0
    767a:	f001 011f 	and.w	r1, r1, #31
    767e:	09db      	lsrs	r3, r3, #7
    7680:	ea41 1343 	orr.w	r3, r1, r3, lsl #5
    7684:	4911      	ldr	r1, [pc, #68]	; (76cc <hop_basic+0xb0>)
	z = perm5_lut[1][((0x7f&(p>>0))<<5)|z];
    7686:	0152      	lsls	r2, r2, #5
    7688:	5ccb      	ldrb	r3, [r1, r3]
		((clk>>(7-4))&(0x1fffff<<4))%hop_state.chan_count	// F = 16*clk27_7 % 79
    768a:	fb07 c616 	mls	r6, r7, r6, ip
    768e:	f402 627e 	and.w	r2, r2, #4064	; 0xfe0
    7692:	431a      	orrs	r2, r3
	return (perm5((a+x)^b, y1^c, d) + e + f + y2);
    7694:	f895 c003 	ldrb.w	ip, [r5, #3]
    7698:	440a      	add	r2, r1
    769a:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    769e:	7813      	ldrb	r3, [r2, #0]
    76a0:	4466      	add	r6, ip
    76a2:	4434      	add	r4, r6
    76a4:	441c      	add	r4, r3
		);
	return hop_state.bank[sel%hop_state.chan_count];
    76a6:	b2e4      	uxtb	r4, r4
    76a8:	fbb4 f3f7 	udiv	r3, r4, r7
    76ac:	fb07 4713 	mls	r7, r7, r3, r4
    76b0:	f8d5 30a8 	ldr.w	r3, [r5, #168]	; 0xa8
    76b4:	b2ff      	uxtb	r7, r7
}
    76b6:	5dd8      	ldrb	r0, [r3, r7]
    76b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    76bc:	2300      	movs	r3, #0
    76be:	461c      	mov	r4, r3
    76c0:	e7b8      	b.n	7634 <hop_basic+0x18>
    76c2:	bf00      	nop
    76c4:	10002520 	.word	0x10002520
    76c8:	01fffff0 	.word	0x01fffff0
    76cc:	0000a80c 	.word	0x0000a80c

000076d0 <hop_channel>:

uint8_t hop_channel(uint32_t clk)
{
    76d0:	b538      	push	{r3, r4, r5, lr}
	switch(btphy.mode)
    76d2:	4a21      	ldr	r2, [pc, #132]	; (7758 <hop_channel+0x88>)
{
    76d4:	4605      	mov	r5, r0
	switch(btphy.mode)
    76d6:	7811      	ldrb	r1, [r2, #0]
    76d8:	2903      	cmp	r1, #3
    76da:	d833      	bhi.n	7744 <hop_channel+0x74>
	sel = hop_selection_kernel(
    76dc:	4c1f      	ldr	r4, [pc, #124]	; (775c <hop_channel+0x8c>)
	y1 = ~(y1-1);
    76de:	f340 0340 	sbfx	r3, r0, #1, #1
	return (perm5((a+x)^b, y1^c, d) + e + f + y2);
    76e2:	78a2      	ldrb	r2, [r4, #2]
    76e4:	7820      	ldrb	r0, [r4, #0]
    76e6:	405a      	eors	r2, r3
    76e8:	79a3      	ldrb	r3, [r4, #6]
	uint16_t p = (p_low&0x1ff)|((p_high&0x1f)<<9);
    76ea:	88a1      	ldrh	r1, [r4, #4]
    76ec:	4403      	add	r3, r0
    76ee:	0252      	lsls	r2, r2, #9
    76f0:	7860      	ldrb	r0, [r4, #1]
    76f2:	f3c1 0108 	ubfx	r1, r1, #0, #9
    76f6:	f402 5278 	and.w	r2, r2, #15872	; 0x3e00
	z = perm5_lut[0][(((p>>7))<<5)|z];
    76fa:	430a      	orrs	r2, r1
    76fc:	4043      	eors	r3, r0
    76fe:	f003 031f 	and.w	r3, r3, #31
    7702:	4817      	ldr	r0, [pc, #92]	; (7760 <hop_channel+0x90>)
    7704:	09d2      	lsrs	r2, r2, #7
    7706:	ea43 1242 	orr.w	r2, r3, r2, lsl #5
	z = perm5_lut[1][((0x7f&(p>>0))<<5)|z];
    770a:	5c83      	ldrb	r3, [r0, r2]
    770c:	0149      	lsls	r1, r1, #5
    770e:	f401 617e 	and.w	r1, r1, #4064	; 0xfe0
    7712:	4319      	orrs	r1, r3
    7714:	4401      	add	r1, r0
    7716:	f501 5180 	add.w	r1, r1, #4096	; 0x1000
    771a:	78e3      	ldrb	r3, [r4, #3]
    771c:	780a      	ldrb	r2, [r1, #0]
	clk1 = 1&(clk>>1);
    771e:	f3c5 0540 	ubfx	r5, r5, #1, #1
	return (perm5((a+x)^b, y1^c, d) + e + f + y2);
    7722:	eb03 1345 	add.w	r3, r3, r5, lsl #5
    7726:	4413      	add	r3, r2
	sel = hop_selection_kernel(
    7728:	4a0e      	ldr	r2, [pc, #56]	; (7764 <hop_channel+0x94>)
    772a:	b2db      	uxtb	r3, r3
    772c:	fba2 1203 	umull	r1, r2, r2, r3
    7730:	0992      	lsrs	r2, r2, #6
    7732:	eb02 0182 	add.w	r1, r2, r2, lsl #2
    7736:	ebc2 1201 	rsb	r2, r2, r1, lsl #4
    773a:	1a9b      	subs	r3, r3, r2
	return hop_state.basic_bank[sel];
    773c:	b2db      	uxtb	r3, r3
    773e:	4423      	add	r3, r4
    7740:	79d8      	ldrb	r0, [r3, #7]
	case BT_MODE_SLAVE:
		return hop_basic(clk);
	default:
		DIE("Invalid hop mode %d\n", btphy.mode);
	}
}
    7742:	bd38      	pop	{r3, r4, r5, pc}
	switch(btphy.mode)
    7744:	1f0b      	subs	r3, r1, #4
    7746:	2b01      	cmp	r3, #1
    7748:	d803      	bhi.n	7752 <hop_channel+0x82>
}
    774a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return hop_basic(clk);
    774e:	f7ff bf65 	b.w	761c <hop_basic>
		DIE("Invalid hop mode %d\n", btphy.mode);
    7752:	4805      	ldr	r0, [pc, #20]	; (7768 <hop_channel+0x98>)
    7754:	f000 fc5e 	bl	8014 <die>
    7758:	100001b0 	.word	0x100001b0
    775c:	10002520 	.word	0x10002520
    7760:	0000a80c 	.word	0x0000a80c
    7764:	cf6474a9 	.word	0xcf6474a9
    7768:	0000df30 	.word	0x0000df30

0000776c <monitor2_rx_cb>:
{
	return btctl_get_state() != BTCTL_STATE_CONNECTED;
}

static int monitor2_rx_cb(msg_t *msg, void *arg, int time_offset)
{
    776c:	b538      	push	{r3, r4, r5, lr}
    776e:	4b24      	ldr	r3, [pc, #144]	; (7800 <monitor2_rx_cb+0x94>)
    7770:	4604      	mov	r4, r0
	btctl_hdr_t *h = (btctl_hdr_t*)msg->data;
	btctl_rx_pkt_t *pkt;
	int rc;

	if (monitor2_state_canceled())
    7772:	781b      	ldrb	r3, [r3, #0]
    7774:	2b03      	cmp	r3, #3
    7776:	d11e      	bne.n	77b6 <monitor2_rx_cb+0x4a>
	{
		msg_free(msg);
		return 0;
	}
	/* Check if a packet was received, to adjust clock if needed */
	if (h->type != BTCTL_RX_PKT)
    7778:	7b03      	ldrb	r3, [r0, #12]
    777a:	2b28      	cmp	r3, #40	; 0x28
    777c:	d13c      	bne.n	77f8 <monitor2_rx_cb+0x8c>
		DIE("rx : expect acl rx");
	pkt = (btctl_rx_pkt_t *)h->data;

	if (!BBPKT_HAS_PKT(pkt))
    777e:	7d43      	ldrb	r3, [r0, #21]
    7780:	07d8      	lsls	r0, r3, #31
    7782:	d509      	bpl.n	7798 <monitor2_rx_cb+0x2c>
	{
		//console_putc('N');
		goto end;
	}

	if ((pkt->clkn&2) == 0) // Packet from master
    7784:	6921      	ldr	r1, [r4, #16]
    7786:	0789      	lsls	r1, r1, #30
    7788:	d531      	bpl.n	77ee <monitor2_rx_cb+0x82>
	{
		/* Resync to master */
		btphy_adj_clkn_delay(time_offset);
	}

	if (!BBPKT_HAS_HDR(pkt))
    778a:	079a      	lsls	r2, r3, #30
    778c:	d504      	bpl.n	7798 <monitor2_rx_cb+0x2c>
	{
		goto end;
	}
#if 1
	if (pkt->bb_hdr.type < 3) // NULL / POLL / FHS
    778e:	7e61      	ldrb	r1, [r4, #25]
    7790:	2902      	cmp	r1, #2
    7792:	d922      	bls.n	77da <monitor2_rx_cb+0x6e>
	{
		cprintf("(%c,%x,%x)","NPF"[pkt->bb_hdr.type], pkt->clkn&0xff,pkt->bb_hdr.flags);
	}
#endif
	if (BBPKT_HAS_CRC(pkt))
    7794:	075b      	lsls	r3, r3, #29
    7796:	d412      	bmi.n	77be <monitor2_rx_cb+0x52>
    7798:	4620      	mov	r0, r4
    779a:	f000 fb67 	bl	7e6c <mem_pool_free>
}

static void monitor2_state_schedule_rx(unsigned skip_slots)
{
	/* Listen for a packet in next rx slot */
	unsigned delay = 2*skip_slots + (1&(RX_PREPARE_IDX - (btphy.slave_clkn&1)));
    779e:	4a19      	ldr	r2, [pc, #100]	; (7804 <monitor2_rx_cb+0x98>)

	/* Schedule rx: */
	rx_task_schedule(delay,
    77a0:	2303      	movs	r3, #3
    77a2:	6890      	ldr	r0, [r2, #8]
    77a4:	4918      	ldr	r1, [pc, #96]	; (7808 <monitor2_rx_cb+0x9c>)
    77a6:	43c0      	mvns	r0, r0
    77a8:	2200      	movs	r2, #0
    77aa:	f000 0001 	and.w	r0, r0, #1
    77ae:	f7fe ff09 	bl	65c4 <rx_task_schedule>
}
    77b2:	2000      	movs	r0, #0
    77b4:	bd38      	pop	{r3, r4, r5, pc}
    77b6:	f000 fb59 	bl	7e6c <mem_pool_free>
    77ba:	2000      	movs	r0, #0
    77bc:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ __volatile__ (
    77be:	f3ef 8510 	mrs	r5, PRIMASK
    77c2:	b672      	cpsid	i
	rc = msg_enqueue(q, msg);
    77c4:	4811      	ldr	r0, [pc, #68]	; (780c <monitor2_rx_cb+0xa0>)
    77c6:	4621      	mov	r1, r4
    77c8:	f000 fcae 	bl	8128 <msg_enqueue>
	__asm__ __volatile__ (
    77cc:	f385 8810 	msr	PRIMASK, r5
		if(btctl_tx_enqueue(msg) != 0)
    77d0:	2800      	cmp	r0, #0
    77d2:	d0e4      	beq.n	779e <monitor2_rx_cb+0x32>
			DIE("mon2: txq full");
    77d4:	480e      	ldr	r0, [pc, #56]	; (7810 <monitor2_rx_cb+0xa4>)
    77d6:	f000 fc1d 	bl	8014 <die>
		cprintf("(%c,%x,%x)","NPF"[pkt->bb_hdr.type], pkt->clkn&0xff,pkt->bb_hdr.flags);
    77da:	6922      	ldr	r2, [r4, #16]
    77dc:	4b0d      	ldr	r3, [pc, #52]	; (7814 <monitor2_rx_cb+0xa8>)
    77de:	480e      	ldr	r0, [pc, #56]	; (7818 <monitor2_rx_cb+0xac>)
    77e0:	5c59      	ldrb	r1, [r3, r1]
    77e2:	b2d2      	uxtb	r2, r2
    77e4:	7ea3      	ldrb	r3, [r4, #26]
    77e6:	f001 fd15 	bl	9214 <cprintf>
    77ea:	7d63      	ldrb	r3, [r4, #21]
    77ec:	e7d2      	b.n	7794 <monitor2_rx_cb+0x28>
		btphy_adj_clkn_delay(time_offset);
    77ee:	4610      	mov	r0, r2
    77f0:	f7fe f9ce 	bl	5b90 <btphy_adj_clkn_delay>
    77f4:	7d63      	ldrb	r3, [r4, #21]
    77f6:	e7c8      	b.n	778a <monitor2_rx_cb+0x1e>
		DIE("rx : expect acl rx");
    77f8:	4808      	ldr	r0, [pc, #32]	; (781c <monitor2_rx_cb+0xb0>)
    77fa:	f000 fc0b 	bl	8014 <die>
    77fe:	bf00      	nop
    7800:	100023dc 	.word	0x100023dc
    7804:	100001b0 	.word	0x100001b0
    7808:	0000776d 	.word	0x0000776d
    780c:	10002408 	.word	0x10002408
    7810:	0000df70 	.word	0x0000df70
    7814:	0000df84 	.word	0x0000df84
    7818:	0000df64 	.word	0x0000df64
    781c:	0000df4c 	.word	0x0000df4c

00007820 <monitor2_state_init>:
		(1<<RX_F_PAYLOAD)	// wait for header 
		|(1<<RX_F_RAW));	// ignore size and crc in payload
}

void monitor2_state_init(uint64_t master_bdaddr)
{
    7820:	b510      	push	{r4, lr}
    7822:	4601      	mov	r1, r0
	monitor2_state.master_bdaddr = master_bdaddr;

	/* Initialize basic hopping from master's clock */
	btphy_set_mode(BT_MODE_SLAVE, master_bdaddr&0xffffff, 0xff & (master_bdaddr>>24));
    7824:	2005      	movs	r0, #5
    7826:	0e0a      	lsrs	r2, r1, #24
    7828:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
    782c:	f7fe fa00 	bl	5c30 <btphy_set_mode>

	cprintf("monitor2 started\n");
    7830:	4809      	ldr	r0, [pc, #36]	; (7858 <monitor2_state_init+0x38>)
    7832:	f001 fcef 	bl	9214 <cprintf>
	btctl_set_state(BTCTL_STATE_CONNECTED, BTCTL_REASON_PAGED);
    7836:	2102      	movs	r1, #2
    7838:	2003      	movs	r0, #3
    783a:	f7fd ff35 	bl	56a8 <btctl_set_state>
	monitor2_state_schedule_rx(1);
}
    783e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	unsigned delay = 2*skip_slots + (1&(RX_PREPARE_IDX - (btphy.slave_clkn&1)));
    7842:	4a06      	ldr	r2, [pc, #24]	; (785c <monitor2_state_init+0x3c>)
	rx_task_schedule(delay,
    7844:	2303      	movs	r3, #3
	unsigned delay = 2*skip_slots + (1&(RX_PREPARE_IDX - (btphy.slave_clkn&1)));
    7846:	6890      	ldr	r0, [r2, #8]
	rx_task_schedule(delay,
    7848:	4905      	ldr	r1, [pc, #20]	; (7860 <monitor2_state_init+0x40>)
	unsigned delay = 2*skip_slots + (1&(RX_PREPARE_IDX - (btphy.slave_clkn&1)));
    784a:	43c0      	mvns	r0, r0
    784c:	f000 0001 	and.w	r0, r0, #1
	rx_task_schedule(delay,
    7850:	2200      	movs	r2, #0
    7852:	3002      	adds	r0, #2
    7854:	f7fe beb6 	b.w	65c4 <rx_task_schedule>
    7858:	0000df88 	.word	0x0000df88
    785c:	100001b0 	.word	0x100001b0
    7860:	0000776d 	.word	0x0000776d

00007864 <page_scan_tx_cb>:
{
	return btctl_get_state() != BTCTL_STATE_PAGE_SCAN;
}

static void page_scan_tx_cb(void *arg)
{
    7864:	b510      	push	{r4, lr}
    7866:	b082      	sub	sp, #8
	cprintf("fhs: ba=%llx clk27_2=%x lta=%d\n",
    7868:	4c08      	ldr	r4, [pc, #32]	; (788c <page_scan_tx_cb+0x28>)
    786a:	4809      	ldr	r0, [pc, #36]	; (7890 <page_scan_tx_cb+0x2c>)
    786c:	7b22      	ldrb	r2, [r4, #12]
    786e:	68a3      	ldr	r3, [r4, #8]
    7870:	e9cd 3200 	strd	r3, r2, [sp]
    7874:	e9d4 2300 	ldrd	r2, r3, [r4]
    7878:	f001 fccc 	bl	9214 <cprintf>
		page_scan_state.fhs_info.bdaddr,
		page_scan_state.fhs_info.clk27_2,
		page_scan_state.fhs_info.lt_addr);

	slave_state_init(page_scan_state.fhs_info.bdaddr,
    787c:	e9d4 0100 	ldrd	r0, r1, [r4]
    7880:	7b22      	ldrb	r2, [r4, #12]
			page_scan_state.fhs_info.lt_addr);
}
    7882:	b002      	add	sp, #8
    7884:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	slave_state_init(page_scan_state.fhs_info.bdaddr,
    7888:	f7ff b9b4 	b.w	6bf4 <slave_state_init>
    788c:	100025d0 	.word	0x100025d0
    7890:	0000dec8 	.word	0x0000dec8

00007894 <page_scan_rx_fhs_cb>:

/* RX FHS cb */
static int page_scan_rx_fhs_cb(msg_t *msg, void *arg, int time_offset)
{
    7894:	b570      	push	{r4, r5, r6, lr}
    7896:	b082      	sub	sp, #8
	return btctl.state;
    7898:	4b2c      	ldr	r3, [pc, #176]	; (794c <page_scan_rx_fhs_cb+0xb8>)
    789a:	4604      	mov	r4, r0
	btctl_hdr_t *h = (btctl_hdr_t*)msg->data;
	btctl_rx_pkt_t *pkt;

	if (page_scan_canceled())
    789c:	781b      	ldrb	r3, [r3, #0]
    789e:	2b05      	cmp	r3, #5
    78a0:	d124      	bne.n	78ec <page_scan_rx_fhs_cb+0x58>
	{
		cprintf("page scan canceled\n");
		goto end;
	}
	pkt = (btctl_rx_pkt_t *)h->data;
	if (BBPKT_GOOD_CRC(pkt))
    78a2:	7d42      	ldrb	r2, [r0, #21]
    78a4:	f012 0508 	ands.w	r5, r2, #8
    78a8:	d00b      	beq.n	78c2 <page_scan_rx_fhs_cb+0x2e>
	{
		if (pkt->bb_hdr.type != BB_TYPE_FHS)
    78aa:	7e41      	ldrb	r1, [r0, #25]
    78ac:	2902      	cmp	r1, #2
    78ae:	d026      	beq.n	78fe <page_scan_rx_fhs_cb+0x6a>
		{
			cprintf("(bad type %d)", pkt->bb_hdr.type);
    78b0:	4827      	ldr	r0, [pc, #156]	; (7950 <page_scan_rx_fhs_cb+0xbc>)
    78b2:	f001 fcaf 	bl	9214 <cprintf>
    78b6:	4620      	mov	r0, r4
    78b8:	f000 fad8 	bl	7e6c <mem_pool_free>
		page_scan_schedule(0);
	}
end:
	msg_free(msg);
	return 0;
}
    78bc:	2000      	movs	r0, #0
    78be:	b002      	add	sp, #8
    78c0:	bd70      	pop	{r4, r5, r6, pc}
	}
}

static void page_scan_schedule(unsigned delay)
{
	if (MASTER_CLKN >= page_scan_state.clkn_start + PAGE_SCAN_MAX_TICKS)
    78c2:	4b24      	ldr	r3, [pc, #144]	; (7954 <page_scan_rx_fhs_cb+0xc0>)
    78c4:	4a24      	ldr	r2, [pc, #144]	; (7958 <page_scan_rx_fhs_cb+0xc4>)
    78c6:	691b      	ldr	r3, [r3, #16]
    78c8:	6812      	ldr	r2, [r2, #0]
    78ca:	f503 333b 	add.w	r3, r3, #191488	; 0x2ec00
    78ce:	f503 7300 	add.w	r3, r3, #512	; 0x200
    78d2:	429a      	cmp	r2, r3
    78d4:	d231      	bcs.n	793a <page_scan_rx_fhs_cb+0xa6>
	{
		cprintf("page scan timeout\n");
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
		return;
	}
	scan_task_schedule(delay, page_scan_rx_id_cb, NULL);
    78d6:	462a      	mov	r2, r5
    78d8:	4628      	mov	r0, r5
    78da:	4920      	ldr	r1, [pc, #128]	; (795c <page_scan_rx_fhs_cb+0xc8>)
    78dc:	f7ff fbbc 	bl	7058 <scan_task_schedule>
    78e0:	4620      	mov	r0, r4
    78e2:	f000 fac3 	bl	7e6c <mem_pool_free>
}
    78e6:	2000      	movs	r0, #0
    78e8:	b002      	add	sp, #8
    78ea:	bd70      	pop	{r4, r5, r6, pc}
		cprintf("page scan canceled\n");
    78ec:	481c      	ldr	r0, [pc, #112]	; (7960 <page_scan_rx_fhs_cb+0xcc>)
    78ee:	f001 fc91 	bl	9214 <cprintf>
    78f2:	4620      	mov	r0, r4
    78f4:	f000 faba 	bl	7e6c <mem_pool_free>
}
    78f8:	2000      	movs	r0, #0
    78fa:	b002      	add	sp, #8
    78fc:	bd70      	pop	{r4, r5, r6, pc}
		bbpkt_decode_fhs(pkt->bt_data, &page_scan_state.fhs_info);
    78fe:	4e15      	ldr	r6, [pc, #84]	; (7954 <page_scan_rx_fhs_cb+0xc0>)
    7900:	301c      	adds	r0, #28
    7902:	4631      	mov	r1, r6
    7904:	f7fc fcda 	bl	42bc <bbpkt_decode_fhs>
		tx_task_schedule(3&(TX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX()),
    7908:	2300      	movs	r3, #0
				 + (btphy.slave_clkn-pkt->clkn);
    790a:	4d16      	ldr	r5, [pc, #88]	; (7964 <page_scan_rx_fhs_cb+0xd0>)
		btphy.slave_clkn = (page_scan_state.fhs_info.clk27_2<<2)
    790c:	68b0      	ldr	r0, [r6, #8]
    790e:	68aa      	ldr	r2, [r5, #8]
				 + (btphy.slave_clkn-pkt->clkn);
    7910:	6921      	ldr	r1, [r4, #16]
    7912:	eb02 0280 	add.w	r2, r2, r0, lsl #2
		tx_task_schedule(3&(TX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX()),
    7916:	f1c2 0001 	rsb	r0, r2, #1
    791a:	4408      	add	r0, r1
				 + (btphy.slave_clkn-pkt->clkn);
    791c:	1a51      	subs	r1, r2, r1
		tx_task_schedule(3&(TX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX()),
    791e:	9300      	str	r3, [sp, #0]
    7920:	461a      	mov	r2, r3
		btphy.slave_clkn = (page_scan_state.fhs_info.clk27_2<<2)
    7922:	60a9      	str	r1, [r5, #8]
		tx_task_schedule(3&(TX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX()),
    7924:	f000 0003 	and.w	r0, r0, #3
    7928:	490f      	ldr	r1, [pc, #60]	; (7968 <page_scan_rx_fhs_cb+0xd4>)
    792a:	f7ff fae7 	bl	6efc <tx_task_schedule>
    792e:	4620      	mov	r0, r4
    7930:	f000 fa9c 	bl	7e6c <mem_pool_free>
}
    7934:	2000      	movs	r0, #0
    7936:	b002      	add	sp, #8
    7938:	bd70      	pop	{r4, r5, r6, pc}
		cprintf("page scan timeout\n");
    793a:	480c      	ldr	r0, [pc, #48]	; (796c <page_scan_rx_fhs_cb+0xd8>)
    793c:	f001 fc6a 	bl	9214 <cprintf>
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
    7940:	4628      	mov	r0, r5
    7942:	2101      	movs	r1, #1
    7944:	f7fd feb0 	bl	56a8 <btctl_set_state>
		return;
    7948:	e7b5      	b.n	78b6 <page_scan_rx_fhs_cb+0x22>
    794a:	bf00      	nop
    794c:	100023dc 	.word	0x100023dc
    7950:	0000defc 	.word	0x0000defc
    7954:	100025d0 	.word	0x100025d0
    7958:	40008008 	.word	0x40008008
    795c:	00007971 	.word	0x00007971
    7960:	0000df9c 	.word	0x0000df9c
    7964:	100001b0 	.word	0x100001b0
    7968:	00007865 	.word	0x00007865
    796c:	0000dfb0 	.word	0x0000dfb0

00007970 <page_scan_rx_id_cb>:
{
    7970:	b530      	push	{r4, r5, lr}
    7972:	b083      	sub	sp, #12
    7974:	4b20      	ldr	r3, [pc, #128]	; (79f8 <page_scan_rx_id_cb+0x88>)
    7976:	4604      	mov	r4, r0
	if(page_scan_canceled())
    7978:	781b      	ldrb	r3, [r3, #0]
    797a:	2b05      	cmp	r3, #5
    797c:	d12b      	bne.n	79d6 <page_scan_rx_id_cb+0x66>
	if (sw_detected)
    797e:	b980      	cbnz	r0, 79a2 <page_scan_rx_id_cb+0x32>
	if (MASTER_CLKN >= page_scan_state.clkn_start + PAGE_SCAN_MAX_TICKS)
    7980:	4b1e      	ldr	r3, [pc, #120]	; (79fc <page_scan_rx_id_cb+0x8c>)
    7982:	4a1f      	ldr	r2, [pc, #124]	; (7a00 <page_scan_rx_id_cb+0x90>)
    7984:	691b      	ldr	r3, [r3, #16]
    7986:	6812      	ldr	r2, [r2, #0]
    7988:	f503 333b 	add.w	r3, r3, #191488	; 0x2ec00
    798c:	f503 7300 	add.w	r3, r3, #512	; 0x200
    7990:	429a      	cmp	r2, r3
    7992:	d226      	bcs.n	79e2 <page_scan_rx_id_cb+0x72>
	scan_task_schedule(delay, page_scan_rx_id_cb, NULL);
    7994:	4602      	mov	r2, r0
    7996:	491b      	ldr	r1, [pc, #108]	; (7a04 <page_scan_rx_id_cb+0x94>)
}
    7998:	b003      	add	sp, #12
    799a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	scan_task_schedule(delay, page_scan_rx_id_cb, NULL);
    799e:	f7ff bb5b 	b.w	7058 <scan_task_schedule>
		tx_task_schedule(delay,
    79a2:	2500      	movs	r5, #0
		console_putc('!');
    79a4:	2021      	movs	r0, #33	; 0x21
    79a6:	f000 fa9f 	bl	7ee8 <console_putc>
		delay = 3&(TX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX());
    79aa:	4b17      	ldr	r3, [pc, #92]	; (7a08 <page_scan_rx_id_cb+0x98>)
		tx_task_schedule(delay,
    79ac:	9500      	str	r5, [sp, #0]
		delay = 3&(TX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX());
    79ae:	689c      	ldr	r4, [r3, #8]
		tx_task_schedule(delay,
    79b0:	462a      	mov	r2, r5
		delay = 3&(TX_PREPARE_IDX-CUR_SLAVE_SLOT_IDX());
    79b2:	f1c4 0401 	rsb	r4, r4, #1
    79b6:	f004 0403 	and.w	r4, r4, #3
		tx_task_schedule(delay,
    79ba:	462b      	mov	r3, r5
    79bc:	4620      	mov	r0, r4
    79be:	4629      	mov	r1, r5
    79c0:	f7ff fa9c 	bl	6efc <tx_task_schedule>
		rx_task_schedule(delay+2,
    79c4:	462a      	mov	r2, r5
    79c6:	2301      	movs	r3, #1
    79c8:	4910      	ldr	r1, [pc, #64]	; (7a0c <page_scan_rx_id_cb+0x9c>)
    79ca:	1ca0      	adds	r0, r4, #2
}
    79cc:	b003      	add	sp, #12
    79ce:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		rx_task_schedule(delay+2,
    79d2:	f7fe bdf7 	b.w	65c4 <rx_task_schedule>
		cprintf("page scan canceled\n");
    79d6:	480e      	ldr	r0, [pc, #56]	; (7a10 <page_scan_rx_id_cb+0xa0>)
}
    79d8:	b003      	add	sp, #12
    79da:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		cprintf("page scan canceled\n");
    79de:	f001 bc19 	b.w	9214 <cprintf>
		cprintf("page scan timeout\n");
    79e2:	480c      	ldr	r0, [pc, #48]	; (7a14 <page_scan_rx_id_cb+0xa4>)
    79e4:	f001 fc16 	bl	9214 <cprintf>
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
    79e8:	4620      	mov	r0, r4
    79ea:	2101      	movs	r1, #1
}
    79ec:	b003      	add	sp, #12
    79ee:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
    79f2:	f7fd be59 	b.w	56a8 <btctl_set_state>
    79f6:	bf00      	nop
    79f8:	100023dc 	.word	0x100023dc
    79fc:	100025d0 	.word	0x100025d0
    7a00:	40008008 	.word	0x40008008
    7a04:	00007971 	.word	0x00007971
    7a08:	100001b0 	.word	0x100001b0
    7a0c:	00007895 	.word	0x00007895
    7a10:	0000df9c 	.word	0x0000df9c
    7a14:	0000dfb0 	.word	0x0000dfb0

00007a18 <page_scan_state_setup>:

/*
 * Page slave
 */
void page_scan_state_setup(void)
{
    7a18:	b508      	push	{r3, lr}
	btphy_set_mode(BT_MODE_PAGE_SCAN, btphy.my_lap, btphy.my_uap);
    7a1a:	4b13      	ldr	r3, [pc, #76]	; (7a68 <page_scan_state_setup+0x50>)
    7a1c:	2003      	movs	r0, #3
    7a1e:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
    7a22:	6b59      	ldr	r1, [r3, #52]	; 0x34
    7a24:	f7fe f904 	bl	5c30 <btphy_set_mode>
	btctl_set_state(BTCTL_STATE_PAGE_SCAN, BTCTL_REASON_SUCCESS);
    7a28:	2100      	movs	r1, #0
    7a2a:	2005      	movs	r0, #5
    7a2c:	f7fd fe3c 	bl	56a8 <btctl_set_state>
	page_scan_state.clkn_start = MASTER_CLKN+1;
    7a30:	4a0e      	ldr	r2, [pc, #56]	; (7a6c <page_scan_state_setup+0x54>)
    7a32:	480f      	ldr	r0, [pc, #60]	; (7a70 <page_scan_state_setup+0x58>)
    7a34:	6813      	ldr	r3, [r2, #0]
	if (MASTER_CLKN >= page_scan_state.clkn_start + PAGE_SCAN_MAX_TICKS)
    7a36:	6811      	ldr	r1, [r2, #0]
    7a38:	f503 323b 	add.w	r2, r3, #191488	; 0x2ec00
    7a3c:	f202 2201 	addw	r2, r2, #513	; 0x201
	page_scan_state.clkn_start = MASTER_CLKN+1;
    7a40:	3301      	adds	r3, #1
	if (MASTER_CLKN >= page_scan_state.clkn_start + PAGE_SCAN_MAX_TICKS)
    7a42:	4291      	cmp	r1, r2
	page_scan_state.clkn_start = MASTER_CLKN+1;
    7a44:	6103      	str	r3, [r0, #16]
	if (MASTER_CLKN >= page_scan_state.clkn_start + PAGE_SCAN_MAX_TICKS)
    7a46:	d206      	bcs.n	7a56 <page_scan_state_setup+0x3e>
	page_scan_schedule(1);
}
    7a48:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	scan_task_schedule(delay, page_scan_rx_id_cb, NULL);
    7a4c:	2200      	movs	r2, #0
    7a4e:	2001      	movs	r0, #1
    7a50:	4908      	ldr	r1, [pc, #32]	; (7a74 <page_scan_state_setup+0x5c>)
    7a52:	f7ff bb01 	b.w	7058 <scan_task_schedule>
		cprintf("page scan timeout\n");
    7a56:	4808      	ldr	r0, [pc, #32]	; (7a78 <page_scan_state_setup+0x60>)
    7a58:	f001 fbdc 	bl	9214 <cprintf>
}
    7a5c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		btctl_set_state(BTCTL_STATE_STANDBY, BTCTL_REASON_TIMEOUT);
    7a60:	2101      	movs	r1, #1
    7a62:	2000      	movs	r0, #0
    7a64:	f7fd be20 	b.w	56a8 <btctl_set_state>
    7a68:	100001b0 	.word	0x100001b0
    7a6c:	40008008 	.word	0x40008008
    7a70:	100025d0 	.word	0x100025d0
    7a74:	00007971 	.word	0x00007971
    7a78:	0000dfb0 	.word	0x0000dfb0

00007a7c <EINT3_IRQHandler>:

volatile rf_state_t rf_state = {0};

/* Interrupt handler for GIO6 */
void EINT3_IRQHandler(void)
{
    7a7c:	b510      	push	{r4, lr}
	/* Clear interrupt */
	IO2IntClr |= PIN_GIO6;
    7a7e:	4908      	ldr	r1, [pc, #32]	; (7aa0 <EINT3_IRQHandler+0x24>)

	if (!rf_state.int_handler)
    7a80:	4a08      	ldr	r2, [pc, #32]	; (7aa4 <EINT3_IRQHandler+0x28>)
	IO2IntClr |= PIN_GIO6;
    7a82:	680b      	ldr	r3, [r1, #0]
    7a84:	f043 0304 	orr.w	r3, r3, #4
    7a88:	600b      	str	r3, [r1, #0]
	if (!rf_state.int_handler)
    7a8a:	6853      	ldr	r3, [r2, #4]
    7a8c:	b123      	cbz	r3, 7a98 <EINT3_IRQHandler+0x1c>
	{
		DIE("No phy int handler");
	}
	rf_state.int_handler(rf_state.int_arg);
}
    7a8e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	rf_state.int_handler(rf_state.int_arg);
    7a92:	6853      	ldr	r3, [r2, #4]
    7a94:	6890      	ldr	r0, [r2, #8]
    7a96:	4718      	bx	r3
		DIE("No phy int handler");
    7a98:	4803      	ldr	r0, [pc, #12]	; (7aa8 <EINT3_IRQHandler+0x2c>)
    7a9a:	f000 fabb 	bl	8014 <die>
    7a9e:	bf00      	nop
    7aa0:	400280ac 	.word	0x400280ac
    7aa4:	10000a8c 	.word	0x10000a8c
    7aa8:	0000dfc4 	.word	0x0000dfc4

00007aac <btphy_rf_enable_int>:

void btphy_rf_enable_int(btbr_int_cb_t cb, void*cb_arg, int tx)
{
    7aac:	b430      	push	{r4, r5}
	/* clear pending */
	ICPR0 = ISER0_ISE_EINT3;
    7aae:	f44f 1400 	mov.w	r4, #2097152	; 0x200000
    7ab2:	4b0e      	ldr	r3, [pc, #56]	; (7aec <btphy_rf_enable_int+0x40>)
	IO2IntClr |= PIN_GIO6;
    7ab4:	4d0e      	ldr	r5, [pc, #56]	; (7af0 <btphy_rf_enable_int+0x44>)
	ICPR0 = ISER0_ISE_EINT3;
    7ab6:	601c      	str	r4, [r3, #0]
	IO2IntClr |= PIN_GIO6;
    7ab8:	682b      	ldr	r3, [r5, #0]

	rf_state.int_handler = cb;
    7aba:	4c0e      	ldr	r4, [pc, #56]	; (7af4 <btphy_rf_enable_int+0x48>)
	IO2IntClr |= PIN_GIO6;
    7abc:	f043 0304 	orr.w	r3, r3, #4
    7ac0:	602b      	str	r3, [r5, #0]
	rf_state.int_handler = cb;
    7ac2:	6060      	str	r0, [r4, #4]
	rf_state.int_arg = cb_arg;
    7ac4:	60a1      	str	r1, [r4, #8]

	/* Configure interrupt on GIO6 rising edge */
	if (tx)
    7ac6:	b152      	cbz	r2, 7ade <btphy_rf_enable_int+0x32>
		IO2IntEnR |= PIN_GIO6;
    7ac8:	4a0b      	ldr	r2, [pc, #44]	; (7af8 <btphy_rf_enable_int+0x4c>)
    7aca:	6813      	ldr	r3, [r2, #0]
    7acc:	f043 0304 	orr.w	r3, r3, #4
    7ad0:	6013      	str	r3, [r2, #0]
	else
		IO2IntEnF |= PIN_GIO6;

	/* Enable */
	ISER0 = ISER0_ISE_EINT3;
    7ad2:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
}
    7ad6:	bc30      	pop	{r4, r5}
	ISER0 = ISER0_ISE_EINT3;
    7ad8:	4b08      	ldr	r3, [pc, #32]	; (7afc <btphy_rf_enable_int+0x50>)
    7ada:	601a      	str	r2, [r3, #0]
}
    7adc:	4770      	bx	lr
		IO2IntEnF |= PIN_GIO6;
    7ade:	4a08      	ldr	r2, [pc, #32]	; (7b00 <btphy_rf_enable_int+0x54>)
    7ae0:	6813      	ldr	r3, [r2, #0]
    7ae2:	f043 0304 	orr.w	r3, r3, #4
    7ae6:	6013      	str	r3, [r2, #0]
    7ae8:	e7f3      	b.n	7ad2 <btphy_rf_enable_int+0x26>
    7aea:	bf00      	nop
    7aec:	e000e280 	.word	0xe000e280
    7af0:	400280ac 	.word	0x400280ac
    7af4:	10000a8c 	.word	0x10000a8c
    7af8:	400280b0 	.word	0x400280b0
    7afc:	e000e100 	.word	0xe000e100
    7b00:	400280b4 	.word	0x400280b4

00007b04 <btphy_rf_disable_int>:

void btphy_rf_disable_int(void)
{
	/* Mask interrupt */
	ICER0 = ISER0_ISE_EINT3;
    7b04:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    7b08:	4b0a      	ldr	r3, [pc, #40]	; (7b34 <btphy_rf_disable_int+0x30>)

	IO2IntEnR &= ~PIN_GIO6;
    7b0a:	490b      	ldr	r1, [pc, #44]	; (7b38 <btphy_rf_disable_int+0x34>)
	ICER0 = ISER0_ISE_EINT3;
    7b0c:	601a      	str	r2, [r3, #0]
	IO2IntEnR &= ~PIN_GIO6;
    7b0e:	680b      	ldr	r3, [r1, #0]
	IO2IntEnF &= ~PIN_GIO6;
    7b10:	480a      	ldr	r0, [pc, #40]	; (7b3c <btphy_rf_disable_int+0x38>)
	IO2IntEnR &= ~PIN_GIO6;
    7b12:	f023 0304 	bic.w	r3, r3, #4
    7b16:	600b      	str	r3, [r1, #0]
	IO2IntEnF &= ~PIN_GIO6;
    7b18:	6803      	ldr	r3, [r0, #0]
    7b1a:	f023 0304 	bic.w	r3, r3, #4
    7b1e:	6003      	str	r3, [r0, #0]

	/* Clear pending interrupt */
	IO2IntClr |= PIN_GIO6;
    7b20:	f851 3c04 	ldr.w	r3, [r1, #-4]
	ICPR0 = ISER0_ISE_EINT3;
    7b24:	4806      	ldr	r0, [pc, #24]	; (7b40 <btphy_rf_disable_int+0x3c>)
	IO2IntClr |= PIN_GIO6;
    7b26:	f043 0304 	orr.w	r3, r3, #4
    7b2a:	f841 3c04 	str.w	r3, [r1, #-4]
	ICPR0 = ISER0_ISE_EINT3;
    7b2e:	6002      	str	r2, [r0, #0]
}
    7b30:	4770      	bx	lr
    7b32:	bf00      	nop
    7b34:	e000e180 	.word	0xe000e180
    7b38:	400280b0 	.word	0x400280b0
    7b3c:	400280b4 	.word	0x400280b4
    7b40:	e000e280 	.word	0xe000e280

00007b44 <btphy_rf_set_freq_off>:

void btphy_rf_set_freq_off(uint8_t off)
{
    7b44:	b538      	push	{r3, r4, r5, lr}
	__asm__ __volatile__ (
    7b46:	f3ef 8510 	mrs	r5, PRIMASK
    7b4a:	b672      	cpsid	i
	uint32_t flags = irq_save_disable();

	rf_state.freq_off_reg = off;
    7b4c:	4c0a      	ldr	r4, [pc, #40]	; (7b78 <btphy_rf_set_freq_off+0x34>)
    7b4e:	b280      	uxth	r0, r0
    7b50:	8020      	strh	r0, [r4, #0]
	cc2400_set(MDMCTRL, 0x0029|(rf_state.freq_off_reg<<7)); // 160 kHz frequency deviation
    7b52:	8821      	ldrh	r1, [r4, #0]
    7b54:	2003      	movs	r0, #3
    7b56:	b289      	uxth	r1, r1
    7b58:	01c9      	lsls	r1, r1, #7
    7b5a:	f041 0129 	orr.w	r1, r1, #41	; 0x29
    7b5e:	b289      	uxth	r1, r1
    7b60:	f001 ff3d 	bl	99de <cc2400_set>
	__asm__ __volatile__ (
    7b64:	f385 8810 	msr	PRIMASK, r5
	irq_restore(flags);
	cprintf("freq off reg: %d\n", rf_state.freq_off_reg);
    7b68:	8821      	ldrh	r1, [r4, #0]
    7b6a:	4804      	ldr	r0, [pc, #16]	; (7b7c <btphy_rf_set_freq_off+0x38>)
    7b6c:	b289      	uxth	r1, r1
}
    7b6e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	cprintf("freq off reg: %d\n", rf_state.freq_off_reg);
    7b72:	f001 bb4f 	b.w	9214 <cprintf>
    7b76:	bf00      	nop
    7b78:	10000a8c 	.word	0x10000a8c
    7b7c:	0000dfdc 	.word	0x0000dfdc

00007b80 <btphy_rf_set_max_ac_errors>:

void btphy_rf_set_max_ac_errors(uint8_t max_ac_errors)
{
	rf_state.max_ac_errors = max_ac_errors;
    7b80:	4603      	mov	r3, r0
    7b82:	4a03      	ldr	r2, [pc, #12]	; (7b90 <btphy_rf_set_max_ac_errors+0x10>)
	cprintf("max ac errors: %d\n", rf_state.max_ac_errors);
    7b84:	4803      	ldr	r0, [pc, #12]	; (7b94 <btphy_rf_set_max_ac_errors+0x14>)
	rf_state.max_ac_errors = max_ac_errors;
    7b86:	8053      	strh	r3, [r2, #2]
	cprintf("max ac errors: %d\n", rf_state.max_ac_errors);
    7b88:	8851      	ldrh	r1, [r2, #2]
    7b8a:	b289      	uxth	r1, r1
    7b8c:	f001 bb42 	b.w	9214 <cprintf>
    7b90:	10000a8c 	.word	0x10000a8c
    7b94:	0000dff0 	.word	0x0000dff0

00007b98 <btphy_rf_cfg_sync>:
}

void btphy_rf_cfg_sync(uint32_t sync)
{
    7b98:	b510      	push	{r4, lr}
    7b9a:	4604      	mov	r4, r0
	cc2400_set(SYNCL,   sync & 0xffff);
    7b9c:	202c      	movs	r0, #44	; 0x2c
    7b9e:	b2a1      	uxth	r1, r4
    7ba0:	f001 ff1d 	bl	99de <cc2400_set>
	cc2400_set(SYNCH,   (sync >> 16) & 0xffff);
    7ba4:	0c21      	lsrs	r1, r4, #16
    7ba6:	202d      	movs	r0, #45	; 0x2d
}
    7ba8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	cc2400_set(SYNCH,   (sync >> 16) & 0xffff);
    7bac:	f001 bf17 	b.w	99de <cc2400_set>

00007bb0 <btphy_rf_init>:

void btphy_rf_init(void)
{
    7bb0:	b538      	push	{r3, r4, r5, lr}
	uint32_t mdmtst0, iocfg;

	/* Initialize dma here */
	dma_poweron();
    7bb2:	f001 fd37 	bl	9624 <dma_poweron>
	dio_ssp_init();
    7bb6:	f001 fe81 	bl	98bc <dio_ssp_init>

	rf_state.max_ac_errors = MAX_AC_ERRORS_DEFAULT;
    7bba:	2301      	movs	r3, #1
    7bbc:	4c27      	ldr	r4, [pc, #156]	; (7c5c <btphy_rf_init+0xac>)
	cc2400_strobe(SRFOFF);
    7bbe:	2064      	movs	r0, #100	; 0x64
    7bc0:	8063      	strh	r3, [r4, #2]
    7bc2:	f001 ff18 	bl	99f6 <cc2400_strobe>
	TXLED_CLR;
    7bc6:	f44f 7180 	mov.w	r1, #256	; 0x100
	RXLED_CLR;
    7bca:	2210      	movs	r2, #16
	TXLED_CLR;
    7bcc:	4b24      	ldr	r3, [pc, #144]	; (7c60 <btphy_rf_init+0xb0>)
    7bce:	6019      	str	r1, [r3, #0]
	RXLED_CLR;
    7bd0:	601a      	str	r2, [r3, #0]

	btphy_rf_idle();
	WAIT_CC2400_STATE(STATE_IDLE);
    7bd2:	200e      	movs	r0, #14
    7bd4:	f001 fefa 	bl	99cc <cc2400_get>
    7bd8:	f000 001f 	and.w	r0, r0, #31
    7bdc:	2801      	cmp	r0, #1
    7bde:	d1f8      	bne.n	7bd2 <btphy_rf_init+0x22>

	// Bluetooth-like modulation
	cc2400_set(MANAND,  0x7fff);
    7be0:	f647 71ff 	movw	r1, #32767	; 0x7fff
    7be4:	200d      	movs	r0, #13
    7be6:	f001 fefa 	bl	99de <cc2400_set>
	cc2400_set(LMTST,   0x2b22);    // LNA and receive mixers test register
    7bea:	f642 3122 	movw	r1, #11042	; 0x2b22
    7bee:	2012      	movs	r0, #18
    7bf0:	f001 fef5 	bl	99de <cc2400_set>
	//    | +------------------> TX IF freq 1 0Hz
	//    +--------------------> PRNG off
	//
	// ref: CC2400 datasheet page 67
	// AFC settling explained page 41/42
	cc2400_set(MDMTST0, mdmtst0);
    7bf4:	f241 314b 	movw	r1, #4939	; 0x134b
    7bf8:	2014      	movs	r0, #20
    7bfa:	f001 fef0 	bl	99de <cc2400_set>
	cc2400_set(FREND,   0b1011);	// Amplifier level (-7 dBm, picked from hat)
    7bfe:	210b      	movs	r1, #11
    7c00:	2005      	movs	r0, #5
    7c02:	f001 feec 	bl	99de <cc2400_set>
	cc2400_set(MDMCTRL, 0x0029|(rf_state.freq_off_reg<<7)); // 160 kHz frequency deviation
    7c06:	8821      	ldrh	r1, [r4, #0]
    7c08:	2003      	movs	r0, #3
    7c0a:	b289      	uxth	r1, r1
    7c0c:	01c9      	lsls	r1, r1, #7
    7c0e:	f041 0129 	orr.w	r1, r1, #41	; 0x29
    7c12:	b289      	uxth	r1, r1
    7c14:	f001 fee3 	bl	99de <cc2400_set>
	cc2400_set(INT,     PHY_FIFO_THRESHOLD);	// FIFO_THRESHOLD
    7c18:	2110      	movs	r1, #16
    7c1a:	2023      	movs	r0, #35	; 0x23
    7c1c:	f001 fedf 	bl	99de <cc2400_set>
	ICER0 = ISER0_ISE_EINT3;
    7c20:	f44f 1200 	mov.w	r2, #2097152	; 0x200000

	btphy_rf_disable_int();

#ifdef UBERTOOTH_ONE
	PAEN_SET;
    7c24:	2580      	movs	r5, #128	; 0x80
	HGM_SET;
    7c26:	f44f 7480 	mov.w	r4, #256	; 0x100
	ICER0 = ISER0_ISE_EINT3;
    7c2a:	4b0e      	ldr	r3, [pc, #56]	; (7c64 <btphy_rf_init+0xb4>)
	IO2IntEnR &= ~PIN_GIO6;
    7c2c:	490e      	ldr	r1, [pc, #56]	; (7c68 <btphy_rf_init+0xb8>)
	ICER0 = ISER0_ISE_EINT3;
    7c2e:	601a      	str	r2, [r3, #0]
	IO2IntEnR &= ~PIN_GIO6;
    7c30:	680b      	ldr	r3, [r1, #0]
	IO2IntEnF &= ~PIN_GIO6;
    7c32:	480e      	ldr	r0, [pc, #56]	; (7c6c <btphy_rf_init+0xbc>)
	IO2IntEnR &= ~PIN_GIO6;
    7c34:	f023 0304 	bic.w	r3, r3, #4
    7c38:	600b      	str	r3, [r1, #0]
	IO2IntEnF &= ~PIN_GIO6;
    7c3a:	6803      	ldr	r3, [r0, #0]
    7c3c:	f023 0304 	bic.w	r3, r3, #4
    7c40:	6003      	str	r3, [r0, #0]
	IO2IntClr |= PIN_GIO6;
    7c42:	f851 3c04 	ldr.w	r3, [r1, #-4]
	ICPR0 = ISER0_ISE_EINT3;
    7c46:	480a      	ldr	r0, [pc, #40]	; (7c70 <btphy_rf_init+0xc0>)
	IO2IntClr |= PIN_GIO6;
    7c48:	f043 0304 	orr.w	r3, r3, #4
    7c4c:	f841 3c04 	str.w	r3, [r1, #-4]
	PAEN_SET;
    7c50:	4b08      	ldr	r3, [pc, #32]	; (7c74 <btphy_rf_init+0xc4>)
	ICPR0 = ISER0_ISE_EINT3;
    7c52:	6002      	str	r2, [r0, #0]
	PAEN_SET;
    7c54:	601d      	str	r5, [r3, #0]
	HGM_SET;
    7c56:	601c      	str	r4, [r3, #0]
#endif
}
    7c58:	bd38      	pop	{r3, r4, r5, pc}
    7c5a:	bf00      	nop
    7c5c:	10000a8c 	.word	0x10000a8c
    7c60:	2009c03c 	.word	0x2009c03c
    7c64:	e000e180 	.word	0xe000e180
    7c68:	400280b0 	.word	0x400280b0
    7c6c:	400280b4 	.word	0x400280b4
    7c70:	e000e280 	.word	0xe000e280
    7c74:	2009c058 	.word	0x2009c058

00007c78 <btphy_rf_fifo_write>:
	/* end transaction by raising CSN */
	CSN_SET;
}

void btphy_rf_fifo_write(uint8_t *data, unsigned len)
{
    7c78:	b4f0      	push	{r4, r5, r6, r7}
    7c7a:	b082      	sub	sp, #8
		SCLK_SET;
    7c7c:	2510      	movs	r5, #16
			MOSI_CLR;
    7c7e:	2401      	movs	r4, #1
	CSN_CLR;
    7c80:	2620      	movs	r6, #32
    7c82:	4b38      	ldr	r3, [pc, #224]	; (7d64 <btphy_rf_fifo_write+0xec>)
		SCLK_SET;
    7c84:	4a38      	ldr	r2, [pc, #224]	; (7d68 <btphy_rf_fifo_write+0xf0>)
	for (i = 0; i < len; ++i) {
    7c86:	f011 01ff 	ands.w	r1, r1, #255	; 0xff
	CSN_CLR;
    7c8a:	601e      	str	r6, [r3, #0]
			MOSI_CLR;
    7c8c:	601c      	str	r4, [r3, #0]
		SCLK_SET;
    7c8e:	6015      	str	r5, [r2, #0]
		SCLK_CLR;
    7c90:	601d      	str	r5, [r3, #0]
			MOSI_SET;
    7c92:	6014      	str	r4, [r2, #0]
		SCLK_SET;
    7c94:	6015      	str	r5, [r2, #0]
		SCLK_CLR;
    7c96:	601d      	str	r5, [r3, #0]
			MOSI_SET;
    7c98:	6014      	str	r4, [r2, #0]
		SCLK_SET;
    7c9a:	6015      	str	r5, [r2, #0]
		SCLK_CLR;
    7c9c:	601d      	str	r5, [r3, #0]
			MOSI_SET;
    7c9e:	6014      	str	r4, [r2, #0]
		SCLK_SET;
    7ca0:	6015      	str	r5, [r2, #0]
		SCLK_CLR;
    7ca2:	601d      	str	r5, [r3, #0]
			MOSI_CLR;
    7ca4:	601c      	str	r4, [r3, #0]
		SCLK_SET;
    7ca6:	6015      	str	r5, [r2, #0]
		SCLK_CLR;
    7ca8:	601d      	str	r5, [r3, #0]
			MOSI_CLR;
    7caa:	601c      	str	r4, [r3, #0]
		SCLK_SET;
    7cac:	6015      	str	r5, [r2, #0]
		SCLK_CLR;
    7cae:	601d      	str	r5, [r3, #0]
			MOSI_CLR;
    7cb0:	601c      	str	r4, [r3, #0]
		SCLK_SET;
    7cb2:	6015      	str	r5, [r2, #0]
		SCLK_CLR;
    7cb4:	601d      	str	r5, [r3, #0]
			MOSI_CLR;
    7cb6:	601c      	str	r4, [r3, #0]
		SCLK_SET;
    7cb8:	6015      	str	r5, [r2, #0]
		SCLK_CLR;
    7cba:	601d      	str	r5, [r3, #0]
	for (i = 0; i < len; ++i) {
    7cbc:	d03e      	beq.n	7d3c <btphy_rf_fifo_write+0xc4>
			SCLK_SET;
    7cbe:	462e      	mov	r6, r5
    7cc0:	3901      	subs	r1, #1
    7cc2:	b2c9      	uxtb	r1, r1
    7cc4:	4401      	add	r1, r0
    7cc6:	3801      	subs	r0, #1
		temp = data[i];
    7cc8:	f810 7f01 	ldrb.w	r7, [r0, #1]!
			if (temp & 1)
    7ccc:	f017 0f01 	tst.w	r7, #1
				MOSI_CLR;
    7cd0:	bf0c      	ite	eq
    7cd2:	601c      	streq	r4, [r3, #0]
				MOSI_SET;
    7cd4:	6014      	strne	r4, [r2, #0]
			if (temp & 1)
    7cd6:	f017 0f02 	tst.w	r7, #2
			SCLK_SET;
    7cda:	6016      	str	r6, [r2, #0]
			SCLK_CLR;
    7cdc:	601e      	str	r6, [r3, #0]
				MOSI_CLR;
    7cde:	bf0c      	ite	eq
    7ce0:	601c      	streq	r4, [r3, #0]
				MOSI_SET;
    7ce2:	6014      	strne	r4, [r2, #0]
			if (temp & 1)
    7ce4:	f017 0f04 	tst.w	r7, #4
			SCLK_SET;
    7ce8:	6016      	str	r6, [r2, #0]
			SCLK_CLR;
    7cea:	601e      	str	r6, [r3, #0]
				MOSI_CLR;
    7cec:	bf0c      	ite	eq
    7cee:	601c      	streq	r4, [r3, #0]
				MOSI_SET;
    7cf0:	6014      	strne	r4, [r2, #0]
			if (temp & 1)
    7cf2:	f017 0f08 	tst.w	r7, #8
			SCLK_SET;
    7cf6:	6016      	str	r6, [r2, #0]
			SCLK_CLR;
    7cf8:	601e      	str	r6, [r3, #0]
				MOSI_CLR;
    7cfa:	bf0c      	ite	eq
    7cfc:	601c      	streq	r4, [r3, #0]
				MOSI_SET;
    7cfe:	6014      	strne	r4, [r2, #0]
			if (temp & 1)
    7d00:	f017 0f10 	tst.w	r7, #16
			SCLK_SET;
    7d04:	6016      	str	r6, [r2, #0]
			SCLK_CLR;
    7d06:	601e      	str	r6, [r3, #0]
				MOSI_CLR;
    7d08:	bf0c      	ite	eq
    7d0a:	601c      	streq	r4, [r3, #0]
				MOSI_SET;
    7d0c:	6014      	strne	r4, [r2, #0]
			if (temp & 1)
    7d0e:	f017 0f20 	tst.w	r7, #32
			SCLK_SET;
    7d12:	6016      	str	r6, [r2, #0]
			SCLK_CLR;
    7d14:	601e      	str	r6, [r3, #0]
				MOSI_CLR;
    7d16:	bf0c      	ite	eq
    7d18:	601c      	streq	r4, [r3, #0]
				MOSI_SET;
    7d1a:	6014      	strne	r4, [r2, #0]
			if (temp & 1)
    7d1c:	f017 0f40 	tst.w	r7, #64	; 0x40
			SCLK_SET;
    7d20:	6016      	str	r6, [r2, #0]
			SCLK_CLR;
    7d22:	601e      	str	r6, [r3, #0]
				MOSI_CLR;
    7d24:	bf0c      	ite	eq
    7d26:	601c      	streq	r4, [r3, #0]
				MOSI_SET;
    7d28:	6014      	strne	r4, [r2, #0]
			if (temp & 1)
    7d2a:	09ff      	lsrs	r7, r7, #7
			SCLK_SET;
    7d2c:	6016      	str	r6, [r2, #0]
			SCLK_CLR;
    7d2e:	601e      	str	r6, [r3, #0]
			if (temp & 1)
    7d30:	d111      	bne.n	7d56 <btphy_rf_fifo_write+0xde>
	for (i = 0; i < len; ++i) {
    7d32:	4288      	cmp	r0, r1
				MOSI_CLR;
    7d34:	601c      	str	r4, [r3, #0]
			SCLK_SET;
    7d36:	6015      	str	r5, [r2, #0]
			SCLK_CLR;
    7d38:	601d      	str	r5, [r3, #0]
	for (i = 0; i < len; ++i) {
    7d3a:	d1c5      	bne.n	7cc8 <btphy_rf_fifo_write+0x50>
	delay_counter = 10;
    7d3c:	230a      	movs	r3, #10
    7d3e:	9301      	str	r3, [sp, #4]
	while (--delay_counter);
    7d40:	9b01      	ldr	r3, [sp, #4]
    7d42:	3b01      	subs	r3, #1
    7d44:	9301      	str	r3, [sp, #4]
    7d46:	2b00      	cmp	r3, #0
    7d48:	d1fa      	bne.n	7d40 <btphy_rf_fifo_write+0xc8>
	CSN_SET;
    7d4a:	2220      	movs	r2, #32
    7d4c:	4b06      	ldr	r3, [pc, #24]	; (7d68 <btphy_rf_fifo_write+0xf0>)
    7d4e:	601a      	str	r2, [r3, #0]
	/* Bufferize message  */
	btphy_rf_cc2400_fifo_write(len, data);
}
    7d50:	b002      	add	sp, #8
    7d52:	bcf0      	pop	{r4, r5, r6, r7}
    7d54:	4770      	bx	lr
	for (i = 0; i < len; ++i) {
    7d56:	4288      	cmp	r0, r1
				MOSI_SET;
    7d58:	6014      	str	r4, [r2, #0]
			SCLK_SET;
    7d5a:	6015      	str	r5, [r2, #0]
			SCLK_CLR;
    7d5c:	601d      	str	r5, [r3, #0]
	for (i = 0; i < len; ++i) {
    7d5e:	d1b3      	bne.n	7cc8 <btphy_rf_fifo_write+0x50>
    7d60:	e7ec      	b.n	7d3c <btphy_rf_fifo_write+0xc4>
    7d62:	bf00      	nop
    7d64:	2009c05c 	.word	0x2009c05c
    7d68:	2009c058 	.word	0x2009c058

00007d6c <btphy_rf_tune_chan>:
	HGM_CLR;
#endif
}

void btphy_rf_tune_chan(uint16_t channel, int tx)
{
    7d6c:	b538      	push	{r3, r4, r5, lr}
    7d6e:	4604      	mov	r4, r0
    7d70:	460d      	mov	r5, r1
	/* Wait for state IDLE before changing FSDIV */
	WAIT_CC2400_STATE(STATE_IDLE);
    7d72:	200e      	movs	r0, #14
    7d74:	f001 fe2a 	bl	99cc <cc2400_get>
    7d78:	f000 001f 	and.w	r0, r0, #31
    7d7c:	2801      	cmp	r0, #1
    7d7e:	d1f8      	bne.n	7d72 <btphy_rf_tune_chan+0x6>

	/* Retune */
#ifdef USE_TX_1MHZ_OFF
	channel -= 1;
#else
	if (!tx)
    7d80:	b90d      	cbnz	r5, 7d86 <btphy_rf_tune_chan+0x1a>
		channel -= 1;
    7d82:	3c01      	subs	r4, #1
    7d84:	b2a4      	uxth	r4, r4
#endif
	cc2400_set(FSDIV, channel);
    7d86:	4621      	mov	r1, r4
}
    7d88:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	cc2400_set(FSDIV, channel);
    7d8c:	2002      	movs	r0, #2
    7d8e:	f001 be26 	b.w	99de <cc2400_set>
    7d92:	bf00      	nop

00007d94 <mem_pool_init>:
	pool_el_t *li;
	pool_el_t el[BUF_NUM];
} pool = {0};

void mem_pool_init(void)
{
    7d94:	b430      	push	{r4, r5}

	for(i=0;i<BUF_NUM-1;i++)
		pool.el[i].li = &pool.el[i+1];
	pool.el[BUF_NUM-1].li = NULL;
	pool.li = pool.el;
	pool.init = 1;
    7d96:	2101      	movs	r1, #1
	pool.el[BUF_NUM-1].li = NULL;
    7d98:	2500      	movs	r5, #0
		pool.el[i].li = &pool.el[i+1];
    7d9a:	4b1e      	ldr	r3, [pc, #120]	; (7e14 <mem_pool_init+0x80>)
    7d9c:	4c1e      	ldr	r4, [pc, #120]	; (7e18 <mem_pool_init+0x84>)
    7d9e:	f503 72c0 	add.w	r2, r3, #384	; 0x180
    7da2:	609a      	str	r2, [r3, #8]
    7da4:	f503 723e 	add.w	r2, r3, #760	; 0x2f8
    7da8:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    7dac:	f503 628e 	add.w	r2, r3, #1136	; 0x470
    7db0:	f8c3 22f8 	str.w	r2, [r3, #760]	; 0x2f8
    7db4:	f503 62bd 	add.w	r2, r3, #1512	; 0x5e8
    7db8:	f8c3 2470 	str.w	r2, [r3, #1136]	; 0x470
    7dbc:	f503 62ec 	add.w	r2, r3, #1888	; 0x760
    7dc0:	f8c3 25e8 	str.w	r2, [r3, #1512]	; 0x5e8
    7dc4:	f603 02d8 	addw	r2, r3, #2264	; 0x8d8
    7dc8:	f8c3 2760 	str.w	r2, [r3, #1888]	; 0x760
    7dcc:	f503 6225 	add.w	r2, r3, #2640	; 0xa50
    7dd0:	f8c3 28d8 	str.w	r2, [r3, #2264]	; 0x8d8
    7dd4:	f603 32c8 	addw	r2, r3, #3016	; 0xbc8
    7dd8:	f8c3 2a50 	str.w	r2, [r3, #2640]	; 0xa50
    7ddc:	f503 6254 	add.w	r2, r3, #3392	; 0xd40
    7de0:	f8c3 2bc8 	str.w	r2, [r3, #3016]	; 0xbc8
    7de4:	f603 62b8 	addw	r2, r3, #3768	; 0xeb8
    7de8:	f8c3 2d40 	str.w	r2, [r3, #3392]	; 0xd40
	pool.li = pool.el;
    7dec:	f103 0208 	add.w	r2, r3, #8
	pool.init = 1;
    7df0:	6019      	str	r1, [r3, #0]
	pool.li = pool.el;
    7df2:	605a      	str	r2, [r3, #4]
		pool.el[i].li = &pool.el[i+1];
    7df4:	f503 5199 	add.w	r1, r3, #4896	; 0x1320
    7df8:	4a08      	ldr	r2, [pc, #32]	; (7e1c <mem_pool_init+0x88>)
    7dfa:	f8c3 4eb8 	str.w	r4, [r3, #3768]	; 0xeb8
    7dfe:	4b08      	ldr	r3, [pc, #32]	; (7e20 <mem_pool_init+0x8c>)
    7e00:	f504 70bc 	add.w	r0, r4, #376	; 0x178
    7e04:	6020      	str	r0, [r4, #0]
    7e06:	f8c4 1178 	str.w	r1, [r4, #376]	; 0x178
	pool.el[BUF_NUM-1].li = NULL;
    7e0a:	601d      	str	r5, [r3, #0]
		pool.el[i].li = &pool.el[i+1];
    7e0c:	600a      	str	r2, [r1, #0]
    7e0e:	6013      	str	r3, [r2, #0]
}
    7e10:	bc30      	pop	{r4, r5}
    7e12:	4770      	bx	lr
    7e14:	10000a98 	.word	0x10000a98
    7e18:	10001ac8 	.word	0x10001ac8
    7e1c:	10001f30 	.word	0x10001f30
    7e20:	100020a8 	.word	0x100020a8

00007e24 <mem_pool_alloc>:

void *mem_pool_alloc(unsigned size)
{
    7e24:	b508      	push	{r3, lr}
	__asm__ __volatile__ (
    7e26:	f3ef 8110 	mrs	r1, PRIMASK
    7e2a:	b672      	cpsid	i
	uint32_t flags = irq_save_disable();
	pool_el_t *el;
	void *buf;

	if (!pool.init)
    7e2c:	4b0b      	ldr	r3, [pc, #44]	; (7e5c <mem_pool_alloc+0x38>)
    7e2e:	681a      	ldr	r2, [r3, #0]
    7e30:	b152      	cbz	r2, 7e48 <mem_pool_alloc+0x24>
		DIE("pool ny initalized\n");

	if (size > BUF_SIZE)
    7e32:	f5b0 7fba 	cmp.w	r0, #372	; 0x174
    7e36:	d80d      	bhi.n	7e54 <mem_pool_alloc+0x30>
		DIE("Cannot alloc %d\n", size);

	if ((el = pool.li) == NULL)
    7e38:	6858      	ldr	r0, [r3, #4]
    7e3a:	b140      	cbz	r0, 7e4e <mem_pool_alloc+0x2a>
#ifdef MEM_DEBUG
	if (el->allocated)
		DIE("el already allocated\n");
#endif

	pool.li = el->li;
    7e3c:	f850 2b04 	ldr.w	r2, [r0], #4
    7e40:	605a      	str	r2, [r3, #4]
	__asm__ __volatile__ (
    7e42:	f381 8810 	msr	PRIMASK, r1
	el->allocated = 1;
#endif
	irq_restore(flags);

	return &el->buf;
}
    7e46:	bd08      	pop	{r3, pc}
		DIE("pool ny initalized\n");
    7e48:	4805      	ldr	r0, [pc, #20]	; (7e60 <mem_pool_alloc+0x3c>)
    7e4a:	f000 f8e3 	bl	8014 <die>
		DIE("No more buffers\n");
    7e4e:	4805      	ldr	r0, [pc, #20]	; (7e64 <mem_pool_alloc+0x40>)
    7e50:	f000 f8e0 	bl	8014 <die>
		DIE("Cannot alloc %d\n", size);
    7e54:	4601      	mov	r1, r0
    7e56:	4804      	ldr	r0, [pc, #16]	; (7e68 <mem_pool_alloc+0x44>)
    7e58:	f000 f8dc 	bl	8014 <die>
    7e5c:	10000a98 	.word	0x10000a98
    7e60:	0000e004 	.word	0x0000e004
    7e64:	0000e038 	.word	0x0000e038
    7e68:	0000e020 	.word	0x0000e020

00007e6c <mem_pool_free>:

void mem_pool_free(void *p)
{
    7e6c:	b410      	push	{r4}
#ifdef MEM_DEBUG
	uint32_t lr = get_lr();
#endif
	pool_el_t * el = (pool_el_t*)((unsigned long)p-offsetof(pool_el_t, buf));
    7e6e:	1f01      	subs	r1, r0, #4
	__asm__ __volatile__ (
    7e70:	f3ef 8210 	mrs	r2, PRIMASK
    7e74:	b672      	cpsid	i
	if (el->allocated != 1)
		DIE("el not allocated %08x|%d\n",lr,el->allocated);
	el->allocated = 0;
#endif

	el->li = pool.li;
    7e76:	4b04      	ldr	r3, [pc, #16]	; (7e88 <mem_pool_free+0x1c>)
    7e78:	685c      	ldr	r4, [r3, #4]
    7e7a:	f840 4c04 	str.w	r4, [r0, #-4]
	pool.li = el;
    7e7e:	6059      	str	r1, [r3, #4]
	__asm__ __volatile__ (
    7e80:	f382 8810 	msr	PRIMASK, r2

	irq_restore(flags);
}
    7e84:	bc10      	pop	{r4}
    7e86:	4770      	bx	lr
    7e88:	10000a98 	.word	0x10000a98

00007e8c <console_flush>:
#include <ubtbr/system.h>

static msg_t *cur_msg = NULL;

void console_flush(void)
{
    7e8c:	b570      	push	{r4, r5, r6, lr}
	__asm__ __volatile__ (
    7e8e:	f3ef 8510 	mrs	r5, PRIMASK
    7e92:	b672      	cpsid	i
#ifdef USE_CONSOLE
	uint32_t flags = irq_save_disable();
	char *p;
	if (!cur_msg)
    7e94:	4c10      	ldr	r4, [pc, #64]	; (7ed8 <console_flush+0x4c>)
    7e96:	6821      	ldr	r1, [r4, #0]
    7e98:	b1a9      	cbz	r1, 7ec6 <console_flush+0x3a>
        uint8_t *tmp = msg->write;
    7e9a:	6888      	ldr	r0, [r1, #8]
        return msg->data_len - msg_write_len(msg);
    7e9c:	884a      	ldrh	r2, [r1, #2]
	return (int)(msg->write - msg->data);
    7e9e:	f101 030c 	add.w	r3, r1, #12
    7ea2:	1ac3      	subs	r3, r0, r3
        return msg->data_len - msg_write_len(msg);
    7ea4:	1ad3      	subs	r3, r2, r3
        if (msg_write_avail(msg) < (int) len)
    7ea6:	2b00      	cmp	r3, #0
    7ea8:	dd10      	ble.n	7ecc <console_flush+0x40>
		goto end;
	p = (char*)msg_put(cur_msg, 1);
	*p = 0;
    7eaa:	2300      	movs	r3, #0
        msg->write += len;
    7eac:	1c42      	adds	r2, r0, #1
    7eae:	608a      	str	r2, [r1, #8]
    7eb0:	7003      	strb	r3, [r0, #0]
    7eb2:	f3ef 8610 	mrs	r6, PRIMASK
    7eb6:	b672      	cpsid	i
	rc = msg_enqueue(q, msg);
    7eb8:	4808      	ldr	r0, [pc, #32]	; (7edc <console_flush+0x50>)
    7eba:	f000 f935 	bl	8128 <msg_enqueue>
	__asm__ __volatile__ (
    7ebe:	f386 8810 	msr	PRIMASK, r6
	if (btctl_tx_enqueue(cur_msg))
    7ec2:	b930      	cbnz	r0, 7ed2 <console_flush+0x46>
	{
		DIE("txq full in console\n");
	}
	cur_msg = NULL;
    7ec4:	6020      	str	r0, [r4, #0]
    7ec6:	f385 8810 	msr	PRIMASK, r5
end:
	irq_restore(flags);
#endif
}
    7eca:	bd70      	pop	{r4, r5, r6, pc}
		DIE("msg_put: short buf\n");
    7ecc:	4804      	ldr	r0, [pc, #16]	; (7ee0 <console_flush+0x54>)
    7ece:	f000 f8a1 	bl	8014 <die>
		DIE("txq full in console\n");
    7ed2:	4804      	ldr	r0, [pc, #16]	; (7ee4 <console_flush+0x58>)
    7ed4:	f000 f89e 	bl	8014 <die>
    7ed8:	10002220 	.word	0x10002220
    7edc:	10002408 	.word	0x10002408
    7ee0:	0000da98 	.word	0x0000da98
    7ee4:	0000e050 	.word	0x0000e050

00007ee8 <console_putc>:

void console_putc(char c)
{
    7ee8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7eea:	4604      	mov	r4, r0
	__asm__ __volatile__ (
    7eec:	f3ef 8510 	mrs	r5, PRIMASK
    7ef0:	b672      	cpsid	i
#ifdef USE_CONSOLE
	uint32_t flags = irq_save_disable();
	char *p;

	if (cur_msg == NULL)
    7ef2:	4e19      	ldr	r6, [pc, #100]	; (7f58 <console_putc+0x70>)
    7ef4:	6833      	ldr	r3, [r6, #0]
    7ef6:	b1d3      	cbz	r3, 7f2e <console_putc+0x46>
    7ef8:	689a      	ldr	r2, [r3, #8]
    7efa:	8859      	ldrh	r1, [r3, #2]
    7efc:	f103 000c 	add.w	r0, r3, #12
	return (int)(msg->write - msg->data);
    7f00:	1a16      	subs	r6, r2, r0
        return msg->data_len - msg_write_len(msg);
    7f02:	1b89      	subs	r1, r1, r6
        if (msg_write_avail(msg) < (int) len)
    7f04:	2900      	cmp	r1, #0
    7f06:	dd24      	ble.n	7f52 <console_putc+0x6a>
        msg->write += len;
    7f08:	1c51      	adds	r1, r2, #1
		cur_msg = btctl_msg_alloc(BTCTL_DEBUG);
	}
	p = (char*)msg_put(cur_msg, 1);
	*p = c;

	if (c == '\n' || msg_write_avail(cur_msg) == 1)
    7f0a:	2c0a      	cmp	r4, #10
    7f0c:	6099      	str	r1, [r3, #8]
	*p = c;
    7f0e:	7014      	strb	r4, [r2, #0]
	if (c == '\n' || msg_write_avail(cur_msg) == 1)
    7f10:	d008      	beq.n	7f24 <console_putc+0x3c>
	return (int)(msg->write - msg->data);
    7f12:	689a      	ldr	r2, [r3, #8]
        return msg->data_len - msg_write_len(msg);
    7f14:	885b      	ldrh	r3, [r3, #2]
	return (int)(msg->write - msg->data);
    7f16:	1a12      	subs	r2, r2, r0
        return msg->data_len - msg_write_len(msg);
    7f18:	1a9b      	subs	r3, r3, r2
    7f1a:	2b01      	cmp	r3, #1
    7f1c:	d002      	beq.n	7f24 <console_putc+0x3c>
	__asm__ __volatile__ (
    7f1e:	f385 8810 	msr	PRIMASK, r5
	{
		console_flush();
	}
	irq_restore(flags);
#endif
}
    7f22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		console_flush();
    7f24:	f7ff ffb2 	bl	7e8c <console_flush>
    7f28:	f385 8810 	msr	PRIMASK, r5
}
    7f2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	msg_t *msg = (msg_t*)btctl_mem_alloc(sizeof(msg_t)+size);
    7f2e:	f44f 70ba 	mov.w	r0, #372	; 0x174
    7f32:	f7ff ff77 	bl	7e24 <mem_pool_alloc>
	hdr->type = type;
    7f36:	2200      	movs	r2, #0
    7f38:	4603      	mov	r3, r0
	msg->data_len = size;
    7f3a:	f44f 77b4 	mov.w	r7, #360	; 0x168
		cur_msg = btctl_msg_alloc(BTCTL_DEBUG);
    7f3e:	6030      	str	r0, [r6, #0]
    7f40:	731a      	strb	r2, [r3, #12]
	msg->write = msg->data;
    7f42:	300c      	adds	r0, #12
        msg->write += len;
    7f44:	f103 0210 	add.w	r2, r3, #16
    7f48:	4639      	mov	r1, r7
    7f4a:	e9c3 0201 	strd	r0, r2, [r3, #4]
	msg->data_len = size;
    7f4e:	805f      	strh	r7, [r3, #2]
	return msg;
    7f50:	e7d6      	b.n	7f00 <console_putc+0x18>
		DIE("msg_put: short buf\n");
    7f52:	4802      	ldr	r0, [pc, #8]	; (7f5c <console_putc+0x74>)
    7f54:	f000 f85e 	bl	8014 <die>
    7f58:	10002220 	.word	0x10002220
    7f5c:	0000da98 	.word	0x0000da98

00007f60 <dump_debug_registers>:
		flash_leds(5, 100);
	}
}

static void dump_debug_registers(void)
{
    7f60:	b5f0      	push	{r4, r5, r6, r7, lr}
    7f62:	b085      	sub	sp, #20
	int i;
	extern uint32_t _StackTop;
	volatile uint32_t _stk[1] = {0xdeadbeef}, *stk;
    7f64:	4b1c      	ldr	r3, [pc, #112]	; (7fd8 <dump_debug_registers+0x78>)
	early_printf("CFSR=%08x\n", SCB_CFSR);
    7f66:	4c1d      	ldr	r4, [pc, #116]	; (7fdc <dump_debug_registers+0x7c>)
	volatile uint32_t _stk[1] = {0xdeadbeef}, *stk;
    7f68:	9303      	str	r3, [sp, #12]
	early_printf("CFSR=%08x\n", SCB_CFSR);
    7f6a:	6821      	ldr	r1, [r4, #0]
    7f6c:	481c      	ldr	r0, [pc, #112]	; (7fe0 <dump_debug_registers+0x80>)
    7f6e:	f001 f963 	bl	9238 <early_printf>
	early_printf("HFSR=%08x\n", SCB_HFSR);
    7f72:	4b1c      	ldr	r3, [pc, #112]	; (7fe4 <dump_debug_registers+0x84>)
    7f74:	481c      	ldr	r0, [pc, #112]	; (7fe8 <dump_debug_registers+0x88>)
    7f76:	6819      	ldr	r1, [r3, #0]
    7f78:	f001 f95e 	bl	9238 <early_printf>
	early_printf("MMSR=%08x\n", SCB_MMSR);
    7f7c:	7821      	ldrb	r1, [r4, #0]
    7f7e:	481b      	ldr	r0, [pc, #108]	; (7fec <dump_debug_registers+0x8c>)
    7f80:	f001 f95a 	bl	9238 <early_printf>
	early_printf("BFSR=%08x\n", SCB_BFSR);
    7f84:	4b1a      	ldr	r3, [pc, #104]	; (7ff0 <dump_debug_registers+0x90>)
    7f86:	481b      	ldr	r0, [pc, #108]	; (7ff4 <dump_debug_registers+0x94>)
    7f88:	7819      	ldrb	r1, [r3, #0]
    7f8a:	f001 f955 	bl	9238 <early_printf>
	early_printf("UFSR=%08x\n", SCB_UFSR);
    7f8e:	4b1a      	ldr	r3, [pc, #104]	; (7ff8 <dump_debug_registers+0x98>)
    7f90:	481a      	ldr	r0, [pc, #104]	; (7ffc <dump_debug_registers+0x9c>)
    7f92:	8819      	ldrh	r1, [r3, #0]
	early_printf("BFAR=%08x\n", SCB_BFAR);

	early_printf("\nStack dump (~%p):\n", _stk);
    7f94:	ad03      	add	r5, sp, #12
	early_printf("UFSR=%08x\n", SCB_UFSR);
    7f96:	b289      	uxth	r1, r1
    7f98:	f001 f94e 	bl	9238 <early_printf>
	early_printf("BFAR=%08x\n", SCB_BFAR);
    7f9c:	4b18      	ldr	r3, [pc, #96]	; (8000 <dump_debug_registers+0xa0>)
    7f9e:	4819      	ldr	r0, [pc, #100]	; (8004 <dump_debug_registers+0xa4>)
    7fa0:	6819      	ldr	r1, [r3, #0]
	for (stk=(uint32_t*)((uint32_t)&_stk&~0xf);stk<&_StackTop;stk+=4)
    7fa2:	4e19      	ldr	r6, [pc, #100]	; (8008 <dump_debug_registers+0xa8>)
	early_printf("BFAR=%08x\n", SCB_BFAR);
    7fa4:	f001 f948 	bl	9238 <early_printf>
	for (stk=(uint32_t*)((uint32_t)&_stk&~0xf);stk<&_StackTop;stk+=4)
    7fa8:	f025 040f 	bic.w	r4, r5, #15
	early_printf("\nStack dump (~%p):\n", _stk);
    7fac:	4629      	mov	r1, r5
    7fae:	4817      	ldr	r0, [pc, #92]	; (800c <dump_debug_registers+0xac>)
    7fb0:	f001 f942 	bl	9238 <early_printf>
	for (stk=(uint32_t*)((uint32_t)&_stk&~0xf);stk<&_StackTop;stk+=4)
    7fb4:	42b4      	cmp	r4, r6
    7fb6:	d20d      	bcs.n	7fd4 <dump_debug_registers+0x74>
	{
		early_printf("%p: %08x %08x %08x %08x\n",
    7fb8:	4f15      	ldr	r7, [pc, #84]	; (8010 <dump_debug_registers+0xb0>)
    7fba:	6822      	ldr	r2, [r4, #0]
    7fbc:	6863      	ldr	r3, [r4, #4]
    7fbe:	68a5      	ldr	r5, [r4, #8]
    7fc0:	68e1      	ldr	r1, [r4, #12]
    7fc2:	4638      	mov	r0, r7
    7fc4:	e9cd 5100 	strd	r5, r1, [sp]
    7fc8:	4621      	mov	r1, r4
	for (stk=(uint32_t*)((uint32_t)&_stk&~0xf);stk<&_StackTop;stk+=4)
    7fca:	3410      	adds	r4, #16
		early_printf("%p: %08x %08x %08x %08x\n",
    7fcc:	f001 f934 	bl	9238 <early_printf>
	for (stk=(uint32_t*)((uint32_t)&_stk&~0xf);stk<&_StackTop;stk+=4)
    7fd0:	42b4      	cmp	r4, r6
    7fd2:	d3f2      	bcc.n	7fba <dump_debug_registers+0x5a>
			stk, stk[0], stk[1], stk[2], stk[3]);
	}
}
    7fd4:	b005      	add	sp, #20
    7fd6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7fd8:	deadbeef 	.word	0xdeadbeef
    7fdc:	e000ed28 	.word	0xe000ed28
    7fe0:	0000e06c 	.word	0x0000e06c
    7fe4:	e000ed2c 	.word	0xe000ed2c
    7fe8:	0000e078 	.word	0x0000e078
    7fec:	0000e084 	.word	0x0000e084
    7ff0:	e000ed29 	.word	0xe000ed29
    7ff4:	0000e090 	.word	0x0000e090
    7ff8:	e000ed2a 	.word	0xe000ed2a
    7ffc:	0000e09c 	.word	0x0000e09c
    8000:	e000ed38 	.word	0xe000ed38
    8004:	0000e0a8 	.word	0x0000e0a8
    8008:	10003fe0 	.word	0x10003fe0
    800c:	0000e0b4 	.word	0x0000e0b4
    8010:	0000e0c8 	.word	0x0000e0c8

00008014 <die>:
{
    8014:	b40f      	push	{r0, r1, r2, r3}
    8016:	b500      	push	{lr}
    8018:	b093      	sub	sp, #76	; 0x4c
	char buf[64] = {0};
    801a:	2100      	movs	r1, #0
    801c:	223c      	movs	r2, #60	; 0x3c
{
    801e:	ac14      	add	r4, sp, #80	; 0x50
	char buf[64] = {0};
    8020:	a803      	add	r0, sp, #12
{
    8022:	f854 6b04 	ldr.w	r6, [r4], #4
	char buf[64] = {0};
    8026:	9102      	str	r1, [sp, #8]
    8028:	f7fc f8b8 	bl	419c <memset>
	__asm__ __volatile__ (
    802c:	f3ef 8310 	mrs	r3, PRIMASK
    8030:	b672      	cpsid	i
	buf[0] = BTUSB_EARLY_PRINT;
    8032:	2550      	movs	r5, #80	; 0x50
	len = tfp_vsnprintf(buf+1, sizeof(buf)-1, fmt, ap);
    8034:	213f      	movs	r1, #63	; 0x3f
    8036:	4632      	mov	r2, r6
    8038:	4623      	mov	r3, r4
    803a:	f10d 0009 	add.w	r0, sp, #9
	va_start(ap, fmt);
    803e:	9401      	str	r4, [sp, #4]
	buf[0] = BTUSB_EARLY_PRINT;
    8040:	f88d 5008 	strb.w	r5, [sp, #8]
	len = tfp_vsnprintf(buf+1, sizeof(buf)-1, fmt, ap);
    8044:	f001 f8c8 	bl	91d8 <tfp_vsnprintf>
	usb_send_sync((void*)buf, 1+len);
    8048:	1c41      	adds	r1, r0, #1
    804a:	a802      	add	r0, sp, #8
    804c:	f001 fa14 	bl	9478 <usb_send_sync>
		flash_leds(5, 100);
    8050:	2164      	movs	r1, #100	; 0x64
    8052:	2005      	movs	r0, #5
    8054:	f001 f916 	bl	9284 <flash_leds>
	while (1)
    8058:	e7fa      	b.n	8050 <die+0x3c>
    805a:	bf00      	nop

0000805c <HardFault_Handler>:

void HardFault_Handler(void)
{
    805c:	b508      	push	{r3, lr}

static inline unsigned get_lr(void)
{
	uint32_t lr;

	__asm__ __volatile__ (
    805e:	4671      	mov	r1, lr
	early_printf("HardFault at 0x%x\n", get_lr());
    8060:	4807      	ldr	r0, [pc, #28]	; (8080 <HardFault_Handler+0x24>)
    8062:	f001 f8e9 	bl	9238 <early_printf>
	dump_debug_registers();
    8066:	f7ff ff7b 	bl	7f60 <dump_debug_registers>
	while (1) {
		flash_leds(2,500);
    806a:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
    806e:	2002      	movs	r0, #2
    8070:	f001 f908 	bl	9284 <flash_leds>
		flash_leds(25,100);
    8074:	2164      	movs	r1, #100	; 0x64
    8076:	2019      	movs	r0, #25
    8078:	f001 f904 	bl	9284 <flash_leds>
	while (1) {
    807c:	e7f5      	b.n	806a <HardFault_Handler+0xe>
    807e:	bf00      	nop
    8080:	0000e0e4 	.word	0x0000e0e4

00008084 <MemManagement_Handler>:
	}
}

void MemManagement_Handler(void)
{
    8084:	b508      	push	{r3, lr}
    8086:	4671      	mov	r1, lr
	early_printf("MMFault at 0x%x\n", get_lr());
    8088:	4807      	ldr	r0, [pc, #28]	; (80a8 <MemManagement_Handler+0x24>)
    808a:	f001 f8d5 	bl	9238 <early_printf>
	dump_debug_registers();
    808e:	f7ff ff67 	bl	7f60 <dump_debug_registers>
	while (1) {
		flash_leds(4,500);
    8092:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
    8096:	2004      	movs	r0, #4
    8098:	f001 f8f4 	bl	9284 <flash_leds>
		flash_leds(12,100);
    809c:	2164      	movs	r1, #100	; 0x64
    809e:	200c      	movs	r0, #12
    80a0:	f001 f8f0 	bl	9284 <flash_leds>
	while (1) {
    80a4:	e7f5      	b.n	8092 <MemManagement_Handler+0xe>
    80a6:	bf00      	nop
    80a8:	0000e0f8 	.word	0x0000e0f8

000080ac <BusFault_Handler>:
	}
}

void BusFault_Handler(void)
{
    80ac:	b508      	push	{r3, lr}
    80ae:	4671      	mov	r1, lr
	early_printf("BusFault at %x\n", get_lr());
    80b0:	4807      	ldr	r0, [pc, #28]	; (80d0 <BusFault_Handler+0x24>)
    80b2:	f001 f8c1 	bl	9238 <early_printf>
	dump_debug_registers();
    80b6:	f7ff ff53 	bl	7f60 <dump_debug_registers>
	while (1) {
		flash_leds(8,500);
    80ba:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
    80be:	2008      	movs	r0, #8
    80c0:	f001 f8e0 	bl	9284 <flash_leds>
		flash_leds(6,100);
    80c4:	2164      	movs	r1, #100	; 0x64
    80c6:	2006      	movs	r0, #6
    80c8:	f001 f8dc 	bl	9284 <flash_leds>
	while (1) {
    80cc:	e7f5      	b.n	80ba <BusFault_Handler+0xe>
    80ce:	bf00      	nop
    80d0:	0000e10c 	.word	0x0000e10c

000080d4 <UsageFault_Handler>:
	}
}

void UsageFault_Handler(void)
{
    80d4:	b508      	push	{r3, lr}
    80d6:	4671      	mov	r1, lr
	early_printf("UsageFault at %x\n", get_lr());
    80d8:	4807      	ldr	r0, [pc, #28]	; (80f8 <UsageFault_Handler+0x24>)
    80da:	f001 f8ad 	bl	9238 <early_printf>
	dump_debug_registers();
    80de:	f7ff ff3f 	bl	7f60 <dump_debug_registers>
	while (1) {
		flash_leds(8,500);
    80e2:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
    80e6:	2008      	movs	r0, #8
    80e8:	f001 f8cc 	bl	9284 <flash_leds>
		flash_leds(6,100);
    80ec:	2164      	movs	r1, #100	; 0x64
    80ee:	2006      	movs	r0, #6
    80f0:	f001 f8c8 	bl	9284 <flash_leds>
	while (1) {
    80f4:	e7f5      	b.n	80e2 <UsageFault_Handler+0xe>
    80f6:	bf00      	nop
    80f8:	0000e11c 	.word	0x0000e11c

000080fc <msg_dequeue>:

msg_t *msg_dequeue(msg_queue_t*q)
{
	msg_t *p = NULL;

	if (!msg_queue_empty(q))
    80fc:	e9d0 1200 	ldrd	r1, r2, [r0]
    8100:	4291      	cmp	r1, r2
{
    8102:	4603      	mov	r3, r0
	if (!msg_queue_empty(q))
    8104:	d00d      	beq.n	8122 <msg_dequeue+0x26>
	{
		p = q->msg[q->head];
		q->head = (q->head+1)%MSG_QUEUE_SIZE;
    8106:	1c4a      	adds	r2, r1, #1
    8108:	4250      	negs	r0, r2
    810a:	f000 0007 	and.w	r0, r0, #7
    810e:	f002 0207 	and.w	r2, r2, #7
		p = q->msg[q->head];
    8112:	f101 0102 	add.w	r1, r1, #2
		q->head = (q->head+1)%MSG_QUEUE_SIZE;
    8116:	bf58      	it	pl
    8118:	4242      	negpl	r2, r0
		p = q->msg[q->head];
    811a:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
		q->head = (q->head+1)%MSG_QUEUE_SIZE;
    811e:	601a      	str	r2, [r3, #0]
    8120:	4770      	bx	lr
	msg_t *p = NULL;
    8122:	2000      	movs	r0, #0
	}

	return p;
}
    8124:	4770      	bx	lr
    8126:	bf00      	nop

00008128 <msg_enqueue>:

int msg_enqueue(msg_queue_t *q, msg_t *p)
{
    8128:	b430      	push	{r4, r5}
    812a:	4602      	mov	r2, r0
	if (msg_queue_full(q))
    812c:	6840      	ldr	r0, [r0, #4]
    812e:	6815      	ldr	r5, [r2, #0]
	return q->head == q->tail;
}

static inline int msg_queue_full(msg_queue_t *q)
{
	return (q->tail+1)%MSG_QUEUE_SIZE == q->head;
    8130:	1c43      	adds	r3, r0, #1
    8132:	425c      	negs	r4, r3
    8134:	f004 0407 	and.w	r4, r4, #7
    8138:	f003 0307 	and.w	r3, r3, #7
    813c:	bf58      	it	pl
    813e:	4263      	negpl	r3, r4
    8140:	429d      	cmp	r5, r3
    8142:	d006      	beq.n	8152 <msg_enqueue+0x2a>
		return -1;

	q->msg[q->tail] = p;
    8144:	3002      	adds	r0, #2
    8146:	f842 1020 	str.w	r1, [r2, r0, lsl #2]
	q->tail = (q->tail+1)%MSG_QUEUE_SIZE;

	return 0;
    814a:	2000      	movs	r0, #0
	q->tail = (q->tail+1)%MSG_QUEUE_SIZE;
    814c:	6053      	str	r3, [r2, #4]
}
    814e:	bc30      	pop	{r4, r5}
    8150:	4770      	bx	lr
		return -1;
    8152:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    8156:	e7fa      	b.n	814e <msg_enqueue+0x26>

00008158 <msg_queue_init>:

void msg_queue_init(msg_queue_t *q)
{
	q->head = q->tail = 0;
    8158:	2300      	movs	r3, #0
    815a:	e9c0 3300 	strd	r3, r3, [r0]
}
    815e:	4770      	bx	lr

00008160 <ulli2a>:


#ifdef PRINTF_LONG_LONG_SUPPORT
static void _TFP_GCC_NO_INLINE_ ulli2a(
    unsigned long long int num, struct param *p)
{
    8160:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8164:	b085      	sub	sp, #20
    int n = 0;
    unsigned long long int d = 1;
    char *bf = p->bf;
    while (num / d >= p->base)
    8166:	2700      	movs	r7, #0
    8168:	68d3      	ldr	r3, [r2, #12]
    816a:	42b9      	cmp	r1, r7
    816c:	bf08      	it	eq
    816e:	4298      	cmpeq	r0, r3
{
    8170:	4682      	mov	sl, r0
    8172:	468b      	mov	fp, r1
    while (num / d >= p->base)
    8174:	461e      	mov	r6, r3
    unsigned long long int d = 1;
    8176:	f04f 0401 	mov.w	r4, #1
    817a:	f04f 0500 	mov.w	r5, #0
    char *bf = p->bf;
    817e:	f8d2 9010 	ldr.w	r9, [r2, #16]
{
    8182:	9203      	str	r2, [sp, #12]
    while (num / d >= p->base)
    8184:	9302      	str	r3, [sp, #8]
    8186:	d313      	bcc.n	81b0 <ulli2a+0x50>
        d *= p->base;
    8188:	fb04 f307 	mul.w	r3, r4, r7
    818c:	fb06 3305 	mla	r3, r6, r5, r3
    8190:	fba4 4506 	umull	r4, r5, r4, r6
    8194:	441d      	add	r5, r3
    while (num / d >= p->base)
    8196:	4622      	mov	r2, r4
    8198:	462b      	mov	r3, r5
    819a:	4650      	mov	r0, sl
    819c:	4659      	mov	r1, fp
    819e:	f002 f915 	bl	a3cc <__aeabi_uldivmod>
    81a2:	42b9      	cmp	r1, r7
    81a4:	bf08      	it	eq
    81a6:	42b0      	cmpeq	r0, r6
    81a8:	d2ee      	bcs.n	8188 <ulli2a+0x28>
    while (d != 0) {
    81aa:	ea54 0305 	orrs.w	r3, r4, r5
    81ae:	d03f      	beq.n	8230 <ulli2a+0xd0>
    int n = 0;
    81b0:	2300      	movs	r3, #0
    81b2:	9301      	str	r3, [sp, #4]
    81b4:	e018      	b.n	81e8 <ulli2a+0x88>
        int dgt = num / d;
        num %= d;
        d /= p->base;
        if (n || dgt > 0 || d == 0) {
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    81b6:	9b03      	ldr	r3, [sp, #12]
    81b8:	781b      	ldrb	r3, [r3, #0]
    81ba:	f013 0f04 	tst.w	r3, #4
    81be:	bf14      	ite	ne
    81c0:	2337      	movne	r3, #55	; 0x37
    81c2:	2357      	moveq	r3, #87	; 0x57
    81c4:	4498      	add	r8, r3
            ++n;
    81c6:	9b01      	ldr	r3, [sp, #4]
    while (d != 0) {
    81c8:	42bd      	cmp	r5, r7
            ++n;
    81ca:	f103 0301 	add.w	r3, r3, #1
    while (d != 0) {
    81ce:	bf08      	it	eq
    81d0:	42b4      	cmpeq	r4, r6
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    81d2:	f809 8b01 	strb.w	r8, [r9], #1
            ++n;
    81d6:	9301      	str	r3, [sp, #4]
    while (d != 0) {
    81d8:	d32a      	bcc.n	8230 <ulli2a+0xd0>
    81da:	9b03      	ldr	r3, [sp, #12]
    81dc:	68db      	ldr	r3, [r3, #12]
    81de:	9302      	str	r3, [sp, #8]
    int n = 0;
    81e0:	4604      	mov	r4, r0
    81e2:	460d      	mov	r5, r1
    81e4:	461e      	mov	r6, r3
    81e6:	2700      	movs	r7, #0
        int dgt = num / d;
    81e8:	4650      	mov	r0, sl
    81ea:	4659      	mov	r1, fp
    81ec:	4622      	mov	r2, r4
    81ee:	462b      	mov	r3, r5
    81f0:	f002 f8ec 	bl	a3cc <__aeabi_uldivmod>
    81f4:	4619      	mov	r1, r3
    81f6:	4680      	mov	r8, r0
        d /= p->base;
    81f8:	463b      	mov	r3, r7
        num %= d;
    81fa:	4692      	mov	sl, r2
    81fc:	468b      	mov	fp, r1
        d /= p->base;
    81fe:	4632      	mov	r2, r6
    8200:	4620      	mov	r0, r4
    8202:	4629      	mov	r1, r5
    8204:	f002 f8e2 	bl	a3cc <__aeabi_uldivmod>
        if (n || dgt > 0 || d == 0) {
    8208:	9a01      	ldr	r2, [sp, #4]
        int dgt = num / d;
    820a:	4643      	mov	r3, r8
        if (n || dgt > 0 || d == 0) {
    820c:	b912      	cbnz	r2, 8214 <ulli2a+0xb4>
    820e:	f1b8 0f00 	cmp.w	r8, #0
    8212:	dd04      	ble.n	821e <ulli2a+0xbe>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8214:	f1b8 0f09 	cmp.w	r8, #9
    8218:	dccd      	bgt.n	81b6 <ulli2a+0x56>
    821a:	2330      	movs	r3, #48	; 0x30
    821c:	e7d2      	b.n	81c4 <ulli2a+0x64>
        if (n || dgt > 0 || d == 0) {
    821e:	42bd      	cmp	r5, r7
    8220:	bf08      	it	eq
    8222:	42b4      	cmpeq	r4, r6
    8224:	d301      	bcc.n	822a <ulli2a+0xca>
    8226:	9b02      	ldr	r3, [sp, #8]
    8228:	e7da      	b.n	81e0 <ulli2a+0x80>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    822a:	3330      	adds	r3, #48	; 0x30
    822c:	f809 3b01 	strb.w	r3, [r9], #1
        }
    }
    *bf = 0;
    8230:	2300      	movs	r3, #0
    8232:	f889 3000 	strb.w	r3, [r9]
}
    8236:	b005      	add	sp, #20
    8238:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000823c <putchw>:
    *nump = num;
    return ch;
}

static void putchw(void *putp, putcf putf, struct param *p)
{
    823c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8240:	4690      	mov	r8, r2
    char ch;
    int n = p->width;
    char *bf = p->bf;

    /* Number of filling characters */
    while (*bf++ && n > 0)
    8242:	6913      	ldr	r3, [r2, #16]
{
    8244:	4605      	mov	r5, r0
    while (*bf++ && n > 0)
    8246:	f813 2b01 	ldrb.w	r2, [r3], #1
{
    824a:	460e      	mov	r6, r1
    int n = p->width;
    824c:	f8d8 4004 	ldr.w	r4, [r8, #4]
    while (*bf++ && n > 0)
    8250:	b142      	cbz	r2, 8264 <putchw+0x28>
    8252:	2c00      	cmp	r4, #0
    8254:	dc01      	bgt.n	825a <putchw+0x1e>
    8256:	e005      	b.n	8264 <putchw+0x28>
    8258:	b124      	cbz	r4, 8264 <putchw+0x28>
    825a:	f813 1b01 	ldrb.w	r1, [r3], #1
        n--;
    825e:	3c01      	subs	r4, #1
    while (*bf++ && n > 0)
    8260:	2900      	cmp	r1, #0
    8262:	d1f9      	bne.n	8258 <putchw+0x1c>
    if (p->sign)
    8264:	f898 1008 	ldrb.w	r1, [r8, #8]
    8268:	b101      	cbz	r1, 826c <putchw+0x30>
        n--;
    826a:	3c01      	subs	r4, #1
    if (p->alt && p->base == 16)
    826c:	f898 3000 	ldrb.w	r3, [r8]
    8270:	079f      	lsls	r7, r3, #30
    8272:	d507      	bpl.n	8284 <putchw+0x48>
    8274:	f8d8 200c 	ldr.w	r2, [r8, #12]
    8278:	2a10      	cmp	r2, #16
    827a:	d05a      	beq.n	8332 <putchw+0xf6>
        n -= 2;
    else if (p->alt && p->base == 8)
    827c:	2a08      	cmp	r2, #8
        n--;
    827e:	bf08      	it	eq
    8280:	f104 34ff 	addeq.w	r4, r4, #4294967295	; 0xffffffff

    /* Fill with space to align to the right, before alternate or sign */
    if (!p->lz && !p->align_left) {
    8284:	f013 0f09 	tst.w	r3, #9
    8288:	d10c      	bne.n	82a4 <putchw+0x68>
        while (n-- > 0)
    828a:	2c00      	cmp	r4, #0
    828c:	f104 37ff 	add.w	r7, r4, #4294967295	; 0xffffffff
    8290:	dd57      	ble.n	8342 <putchw+0x106>
            putf(putp, ' ');
    8292:	2120      	movs	r1, #32
    8294:	4628      	mov	r0, r5
        while (n-- > 0)
    8296:	3f01      	subs	r7, #1
            putf(putp, ' ');
    8298:	47b0      	blx	r6
        while (n-- > 0)
    829a:	1c7c      	adds	r4, r7, #1
    829c:	d1f9      	bne.n	8292 <putchw+0x56>
    829e:	463c      	mov	r4, r7
    82a0:	f898 1008 	ldrb.w	r1, [r8, #8]
    }

    /* print sign */
    if (p->sign)
    82a4:	b109      	cbz	r1, 82aa <putchw+0x6e>
        putf(putp, p->sign);
    82a6:	4628      	mov	r0, r5
    82a8:	47b0      	blx	r6

    /* Alternate */
    if (p->alt && p->base == 16) {
    82aa:	f898 3000 	ldrb.w	r3, [r8]
    82ae:	0798      	lsls	r0, r3, #30
    82b0:	d505      	bpl.n	82be <putchw+0x82>
    82b2:	f8d8 200c 	ldr.w	r2, [r8, #12]
    82b6:	2a10      	cmp	r2, #16
    82b8:	d02c      	beq.n	8314 <putchw+0xd8>
        putf(putp, '0');
        putf(putp, (p->uc ? 'X' : 'x'));
    } else if (p->alt && p->base == 8) {
    82ba:	2a08      	cmp	r2, #8
    82bc:	d03b      	beq.n	8336 <putchw+0xfa>
        putf(putp, '0');
    }

    /* Fill with zeros, after alternate or sign */
    if (p->lz) {
    82be:	07d9      	lsls	r1, r3, #31
    82c0:	d509      	bpl.n	82d6 <putchw+0x9a>
        while (n-- > 0)
    82c2:	1e63      	subs	r3, r4, #1
    82c4:	2c00      	cmp	r4, #0
    82c6:	461c      	mov	r4, r3
    82c8:	dd05      	ble.n	82d6 <putchw+0x9a>
            putf(putp, '0');
    82ca:	2130      	movs	r1, #48	; 0x30
    82cc:	4628      	mov	r0, r5
        while (n-- > 0)
    82ce:	3c01      	subs	r4, #1
            putf(putp, '0');
    82d0:	47b0      	blx	r6
        while (n-- > 0)
    82d2:	1c62      	adds	r2, r4, #1
    82d4:	d1f9      	bne.n	82ca <putchw+0x8e>
    }

    /* Put actual buffer */
    bf = p->bf;
    while ((ch = *bf++))
    82d6:	f8d8 7010 	ldr.w	r7, [r8, #16]
    82da:	f817 1b01 	ldrb.w	r1, [r7], #1
    82de:	b129      	cbz	r1, 82ec <putchw+0xb0>
        putf(putp, ch);
    82e0:	4628      	mov	r0, r5
    82e2:	47b0      	blx	r6
    while ((ch = *bf++))
    82e4:	f817 1b01 	ldrb.w	r1, [r7], #1
    82e8:	2900      	cmp	r1, #0
    82ea:	d1f9      	bne.n	82e0 <putchw+0xa4>

    /* Fill with space to align to the left, after string */
    if (!p->lz && p->align_left) {
    82ec:	f898 3000 	ldrb.w	r3, [r8]
    82f0:	f003 0309 	and.w	r3, r3, #9
    82f4:	2b08      	cmp	r3, #8
    82f6:	d001      	beq.n	82fc <putchw+0xc0>
        while (n-- > 0)
            putf(putp, ' ');
    }
}
    82f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        while (n-- > 0)
    82fc:	2c00      	cmp	r4, #0
    82fe:	f104 37ff 	add.w	r7, r4, #4294967295	; 0xffffffff
    8302:	ddf9      	ble.n	82f8 <putchw+0xbc>
            putf(putp, ' ');
    8304:	2120      	movs	r1, #32
    8306:	4628      	mov	r0, r5
        while (n-- > 0)
    8308:	3f01      	subs	r7, #1
            putf(putp, ' ');
    830a:	47b0      	blx	r6
        while (n-- > 0)
    830c:	1c7b      	adds	r3, r7, #1
    830e:	d1f9      	bne.n	8304 <putchw+0xc8>
}
    8310:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        putf(putp, '0');
    8314:	2130      	movs	r1, #48	; 0x30
    8316:	4628      	mov	r0, r5
    8318:	47b0      	blx	r6
        putf(putp, (p->uc ? 'X' : 'x'));
    831a:	f898 3000 	ldrb.w	r3, [r8]
    831e:	4628      	mov	r0, r5
    8320:	f013 0f04 	tst.w	r3, #4
    8324:	bf14      	ite	ne
    8326:	2158      	movne	r1, #88	; 0x58
    8328:	2178      	moveq	r1, #120	; 0x78
    832a:	47b0      	blx	r6
    832c:	f898 3000 	ldrb.w	r3, [r8]
    8330:	e7c5      	b.n	82be <putchw+0x82>
        n -= 2;
    8332:	3c02      	subs	r4, #2
    8334:	e7a6      	b.n	8284 <putchw+0x48>
        putf(putp, '0');
    8336:	2130      	movs	r1, #48	; 0x30
    8338:	4628      	mov	r0, r5
    833a:	47b0      	blx	r6
    833c:	f898 3000 	ldrb.w	r3, [r8]
    8340:	e7bd      	b.n	82be <putchw+0x82>
        while (n-- > 0)
    8342:	463c      	mov	r4, r7
    8344:	e7ae      	b.n	82a4 <putchw+0x68>
    8346:	bf00      	nop

00008348 <putchw.constprop.1>:
static void putchw(void *putp, putcf putf, struct param *p)
    8348:	b470      	push	{r4, r5, r6}
    while (*bf++ && n > 0)
    834a:	690b      	ldr	r3, [r1, #16]
    int n = p->width;
    834c:	684a      	ldr	r2, [r1, #4]
    while (*bf++ && n > 0)
    834e:	f813 4b01 	ldrb.w	r4, [r3], #1
    8352:	b144      	cbz	r4, 8366 <putchw.constprop.1+0x1e>
    8354:	2a00      	cmp	r2, #0
    8356:	dc01      	bgt.n	835c <putchw.constprop.1+0x14>
    8358:	e005      	b.n	8366 <putchw.constprop.1+0x1e>
    835a:	b122      	cbz	r2, 8366 <putchw.constprop.1+0x1e>
    835c:	f813 4b01 	ldrb.w	r4, [r3], #1
        n--;
    8360:	3a01      	subs	r2, #1
    while (*bf++ && n > 0)
    8362:	2c00      	cmp	r4, #0
    8364:	d1f9      	bne.n	835a <putchw.constprop.1+0x12>
    if (p->sign)
    8366:	7a0b      	ldrb	r3, [r1, #8]
    8368:	b103      	cbz	r3, 836c <putchw.constprop.1+0x24>
        n--;
    836a:	3a01      	subs	r2, #1
    if (p->alt && p->base == 16)
    836c:	780c      	ldrb	r4, [r1, #0]
    836e:	07a5      	lsls	r5, r4, #30
    8370:	d507      	bpl.n	8382 <putchw.constprop.1+0x3a>
    8372:	68cd      	ldr	r5, [r1, #12]
    8374:	2d10      	cmp	r5, #16
    8376:	f000 80a5 	beq.w	84c4 <putchw.constprop.1+0x17c>
    else if (p->alt && p->base == 8)
    837a:	2d08      	cmp	r5, #8
        n--;
    837c:	bf08      	it	eq
    837e:	f102 32ff 	addeq.w	r2, r2, #4294967295	; 0xffffffff
    if (!p->lz && !p->align_left) {
    8382:	f014 0f09 	tst.w	r4, #9
    8386:	d11b      	bne.n	83c0 <putchw.constprop.1+0x78>
        while (n-- > 0)
    8388:	2a00      	cmp	r2, #0
    838a:	f102 35ff 	add.w	r5, r2, #4294967295	; 0xffffffff
    838e:	f340 80a5 	ble.w	84dc <putchw.constprop.1+0x194>

static void _vsnprintf_putcf(void *p, char c)
{
  struct _vsnprintf_putcf_data *data = (struct _vsnprintf_putcf_data*)p;
  if (data->num_chars < data->dest_capacity)
    data->dest[data->num_chars] = c;
    8392:	2620      	movs	r6, #32
    8394:	6883      	ldr	r3, [r0, #8]
    8396:	e008      	b.n	83aa <putchw.constprop.1+0x62>
    8398:	6842      	ldr	r2, [r0, #4]
        while (n-- > 0)
    839a:	3d01      	subs	r5, #1
    data->dest[data->num_chars] = c;
    839c:	54d6      	strb	r6, [r2, r3]
  data->num_chars ++;
    839e:	6883      	ldr	r3, [r0, #8]
        while (n-- > 0)
    83a0:	1c6c      	adds	r4, r5, #1
  data->num_chars ++;
    83a2:	f103 0301 	add.w	r3, r3, #1
    83a6:	6083      	str	r3, [r0, #8]
        while (n-- > 0)
    83a8:	d007      	beq.n	83ba <putchw.constprop.1+0x72>
    83aa:	6804      	ldr	r4, [r0, #0]
  if (data->num_chars < data->dest_capacity)
    83ac:	429c      	cmp	r4, r3
    83ae:	d8f3      	bhi.n	8398 <putchw.constprop.1+0x50>
        while (n-- > 0)
    83b0:	3d01      	subs	r5, #1
  data->num_chars ++;
    83b2:	3301      	adds	r3, #1
        while (n-- > 0)
    83b4:	1c6a      	adds	r2, r5, #1
  data->num_chars ++;
    83b6:	6083      	str	r3, [r0, #8]
        while (n-- > 0)
    83b8:	d1f8      	bne.n	83ac <putchw.constprop.1+0x64>
    83ba:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    83be:	7a0b      	ldrb	r3, [r1, #8]
    if (p->sign)
    83c0:	b12b      	cbz	r3, 83ce <putchw.constprop.1+0x86>
  if (data->num_chars < data->dest_capacity)
    83c2:	6885      	ldr	r5, [r0, #8]
    83c4:	6804      	ldr	r4, [r0, #0]
    83c6:	42a5      	cmp	r5, r4
    83c8:	d343      	bcc.n	8452 <putchw.constprop.1+0x10a>
  data->num_chars ++;
    83ca:	3501      	adds	r5, #1
    83cc:	6085      	str	r5, [r0, #8]
    if (p->alt && p->base == 16) {
    83ce:	780b      	ldrb	r3, [r1, #0]
    83d0:	079c      	lsls	r4, r3, #30
    83d2:	d504      	bpl.n	83de <putchw.constprop.1+0x96>
    83d4:	68cc      	ldr	r4, [r1, #12]
    83d6:	2c10      	cmp	r4, #16
    83d8:	d059      	beq.n	848e <putchw.constprop.1+0x146>
    } else if (p->alt && p->base == 8) {
    83da:	2c08      	cmp	r4, #8
    83dc:	d074      	beq.n	84c8 <putchw.constprop.1+0x180>
    if (p->lz) {
    83de:	07dd      	lsls	r5, r3, #31
    83e0:	d519      	bpl.n	8416 <putchw.constprop.1+0xce>
        while (n-- > 0)
    83e2:	2a00      	cmp	r2, #0
    83e4:	f102 35ff 	add.w	r5, r2, #4294967295	; 0xffffffff
    83e8:	dd7a      	ble.n	84e0 <putchw.constprop.1+0x198>
    data->dest[data->num_chars] = c;
    83ea:	2630      	movs	r6, #48	; 0x30
    83ec:	6883      	ldr	r3, [r0, #8]
    83ee:	e008      	b.n	8402 <putchw.constprop.1+0xba>
    83f0:	6842      	ldr	r2, [r0, #4]
        while (n-- > 0)
    83f2:	3d01      	subs	r5, #1
    data->dest[data->num_chars] = c;
    83f4:	54d6      	strb	r6, [r2, r3]
  data->num_chars ++;
    83f6:	6883      	ldr	r3, [r0, #8]
        while (n-- > 0)
    83f8:	1c6c      	adds	r4, r5, #1
  data->num_chars ++;
    83fa:	f103 0301 	add.w	r3, r3, #1
    83fe:	6083      	str	r3, [r0, #8]
        while (n-- > 0)
    8400:	d007      	beq.n	8412 <putchw.constprop.1+0xca>
    8402:	6804      	ldr	r4, [r0, #0]
  if (data->num_chars < data->dest_capacity)
    8404:	429c      	cmp	r4, r3
    8406:	d8f3      	bhi.n	83f0 <putchw.constprop.1+0xa8>
        while (n-- > 0)
    8408:	3d01      	subs	r5, #1
  data->num_chars ++;
    840a:	3301      	adds	r3, #1
        while (n-- > 0)
    840c:	1c6a      	adds	r2, r5, #1
  data->num_chars ++;
    840e:	6083      	str	r3, [r0, #8]
        while (n-- > 0)
    8410:	d1f8      	bne.n	8404 <putchw.constprop.1+0xbc>
    8412:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    while ((ch = *bf++))
    8416:	690e      	ldr	r6, [r1, #16]
    8418:	f816 5b01 	ldrb.w	r5, [r6], #1
    841c:	b195      	cbz	r5, 8444 <putchw.constprop.1+0xfc>
    841e:	6883      	ldr	r3, [r0, #8]
    8420:	e007      	b.n	8432 <putchw.constprop.1+0xea>
    data->dest[data->num_chars] = c;
    8422:	6844      	ldr	r4, [r0, #4]
    8424:	54e5      	strb	r5, [r4, r3]
  data->num_chars ++;
    8426:	6883      	ldr	r3, [r0, #8]
    8428:	3301      	adds	r3, #1
    842a:	6083      	str	r3, [r0, #8]
    while ((ch = *bf++))
    842c:	f816 5b01 	ldrb.w	r5, [r6], #1
    8430:	b145      	cbz	r5, 8444 <putchw.constprop.1+0xfc>
    8432:	6804      	ldr	r4, [r0, #0]
  if (data->num_chars < data->dest_capacity)
    8434:	429c      	cmp	r4, r3
    8436:	d8f4      	bhi.n	8422 <putchw.constprop.1+0xda>
  data->num_chars ++;
    8438:	3301      	adds	r3, #1
    843a:	6083      	str	r3, [r0, #8]
    while ((ch = *bf++))
    843c:	f816 5b01 	ldrb.w	r5, [r6], #1
    8440:	2d00      	cmp	r5, #0
    8442:	d1f7      	bne.n	8434 <putchw.constprop.1+0xec>
    if (!p->lz && p->align_left) {
    8444:	780b      	ldrb	r3, [r1, #0]
    8446:	f003 0309 	and.w	r3, r3, #9
    844a:	2b08      	cmp	r3, #8
    844c:	d005      	beq.n	845a <putchw.constprop.1+0x112>
}
    844e:	bc70      	pop	{r4, r5, r6}
    8450:	4770      	bx	lr
    data->dest[data->num_chars] = c;
    8452:	6844      	ldr	r4, [r0, #4]
    8454:	5563      	strb	r3, [r4, r5]
    8456:	6885      	ldr	r5, [r0, #8]
    8458:	e7b7      	b.n	83ca <putchw.constprop.1+0x82>
        while (n-- > 0)
    845a:	2a00      	cmp	r2, #0
    845c:	f102 31ff 	add.w	r1, r2, #4294967295	; 0xffffffff
    8460:	ddf5      	ble.n	844e <putchw.constprop.1+0x106>
    data->dest[data->num_chars] = c;
    8462:	2520      	movs	r5, #32
    8464:	6883      	ldr	r3, [r0, #8]
    8466:	e008      	b.n	847a <putchw.constprop.1+0x132>
    8468:	6842      	ldr	r2, [r0, #4]
        while (n-- > 0)
    846a:	3901      	subs	r1, #1
    data->dest[data->num_chars] = c;
    846c:	54d5      	strb	r5, [r2, r3]
  data->num_chars ++;
    846e:	6883      	ldr	r3, [r0, #8]
        while (n-- > 0)
    8470:	1c4c      	adds	r4, r1, #1
  data->num_chars ++;
    8472:	f103 0301 	add.w	r3, r3, #1
    8476:	6083      	str	r3, [r0, #8]
        while (n-- > 0)
    8478:	d0e9      	beq.n	844e <putchw.constprop.1+0x106>
    847a:	6804      	ldr	r4, [r0, #0]
  if (data->num_chars < data->dest_capacity)
    847c:	429c      	cmp	r4, r3
    847e:	d8f3      	bhi.n	8468 <putchw.constprop.1+0x120>
        while (n-- > 0)
    8480:	3901      	subs	r1, #1
  data->num_chars ++;
    8482:	3301      	adds	r3, #1
        while (n-- > 0)
    8484:	1c4a      	adds	r2, r1, #1
  data->num_chars ++;
    8486:	6083      	str	r3, [r0, #8]
        while (n-- > 0)
    8488:	d1f8      	bne.n	847c <putchw.constprop.1+0x134>
}
    848a:	bc70      	pop	{r4, r5, r6}
    848c:	4770      	bx	lr
  if (data->num_chars < data->dest_capacity)
    848e:	6885      	ldr	r5, [r0, #8]
    8490:	6804      	ldr	r4, [r0, #0]
    8492:	42a5      	cmp	r5, r4
    8494:	d205      	bcs.n	84a2 <putchw.constprop.1+0x15a>
    data->dest[data->num_chars] = c;
    8496:	2430      	movs	r4, #48	; 0x30
    8498:	6843      	ldr	r3, [r0, #4]
    849a:	555c      	strb	r4, [r3, r5]
    849c:	780b      	ldrb	r3, [r1, #0]
    849e:	6885      	ldr	r5, [r0, #8]
    84a0:	6804      	ldr	r4, [r0, #0]
        putf(putp, (p->uc ? 'X' : 'x'));
    84a2:	f013 0f04 	tst.w	r3, #4
  data->num_chars ++;
    84a6:	f105 0501 	add.w	r5, r5, #1
        putf(putp, (p->uc ? 'X' : 'x'));
    84aa:	bf0c      	ite	eq
    84ac:	2678      	moveq	r6, #120	; 0x78
    84ae:	2658      	movne	r6, #88	; 0x58
  if (data->num_chars < data->dest_capacity)
    84b0:	42a5      	cmp	r5, r4
  data->num_chars ++;
    84b2:	6085      	str	r5, [r0, #8]
  if (data->num_chars < data->dest_capacity)
    84b4:	d203      	bcs.n	84be <putchw.constprop.1+0x176>
    data->dest[data->num_chars] = c;
    84b6:	6843      	ldr	r3, [r0, #4]
    84b8:	555e      	strb	r6, [r3, r5]
    84ba:	6885      	ldr	r5, [r0, #8]
    84bc:	780b      	ldrb	r3, [r1, #0]
  data->num_chars ++;
    84be:	3501      	adds	r5, #1
    84c0:	6085      	str	r5, [r0, #8]
}
    84c2:	e78c      	b.n	83de <putchw.constprop.1+0x96>
        n -= 2;
    84c4:	3a02      	subs	r2, #2
    84c6:	e75c      	b.n	8382 <putchw.constprop.1+0x3a>
  if (data->num_chars < data->dest_capacity)
    84c8:	6885      	ldr	r5, [r0, #8]
    84ca:	6804      	ldr	r4, [r0, #0]
    84cc:	42a5      	cmp	r5, r4
    84ce:	d2f6      	bcs.n	84be <putchw.constprop.1+0x176>
    data->dest[data->num_chars] = c;
    84d0:	2430      	movs	r4, #48	; 0x30
    84d2:	6843      	ldr	r3, [r0, #4]
    84d4:	555c      	strb	r4, [r3, r5]
    84d6:	6885      	ldr	r5, [r0, #8]
    84d8:	780b      	ldrb	r3, [r1, #0]
    84da:	e7f0      	b.n	84be <putchw.constprop.1+0x176>
        while (n-- > 0)
    84dc:	462a      	mov	r2, r5
    84de:	e76f      	b.n	83c0 <putchw.constprop.1+0x78>
        while (n-- > 0)
    84e0:	462a      	mov	r2, r5
    84e2:	e798      	b.n	8416 <putchw.constprop.1+0xce>

000084e4 <tfp_format.constprop.0>:
void tfp_format(void *putp, putcf putf, const char *fmt, va_list va)
    84e4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    84e8:	b08d      	sub	sp, #52	; 0x34
    while ((ch = *(fmt++))) {
    84ea:	460c      	mov	r4, r1
    84ec:	f814 6b01 	ldrb.w	r6, [r4], #1
    p.bf = bf;
    84f0:	ab06      	add	r3, sp, #24
void tfp_format(void *putp, putcf putf, const char *fmt, va_list va)
    84f2:	4605      	mov	r5, r0
    84f4:	4617      	mov	r7, r2
    p.bf = bf;
    84f6:	9305      	str	r3, [sp, #20]
    while ((ch = *(fmt++))) {
    84f8:	2e00      	cmp	r6, #0
    84fa:	f000 80be 	beq.w	867a <tfp_format.constprop.0+0x196>
            p.width = 0;
    84fe:	f04f 0800 	mov.w	r8, #0
    8502:	e00b      	b.n	851c <tfp_format.constprop.0+0x38>
  if (data->num_chars < data->dest_capacity)
    8504:	4293      	cmp	r3, r2
    8506:	d202      	bcs.n	850e <tfp_format.constprop.0+0x2a>
    data->dest[data->num_chars] = c;
    8508:	686a      	ldr	r2, [r5, #4]
    850a:	54d6      	strb	r6, [r2, r3]
    850c:	68ab      	ldr	r3, [r5, #8]
  data->num_chars ++;
    850e:	3301      	adds	r3, #1
    8510:	60ab      	str	r3, [r5, #8]
    while ((ch = *(fmt++))) {
    8512:	f814 6b01 	ldrb.w	r6, [r4], #1
    8516:	2e00      	cmp	r6, #0
    8518:	f000 80af 	beq.w	867a <tfp_format.constprop.0+0x196>
        if (ch != '%') {
    851c:	2e25      	cmp	r6, #37	; 0x25
    851e:	d00d      	beq.n	853c <tfp_format.constprop.0+0x58>
			if (ch == '\n')
    8520:	2e0a      	cmp	r6, #10
  if (data->num_chars < data->dest_capacity)
    8522:	68ab      	ldr	r3, [r5, #8]
    8524:	682a      	ldr	r2, [r5, #0]
			if (ch == '\n')
    8526:	d1ed      	bne.n	8504 <tfp_format.constprop.0+0x20>
  if (data->num_chars < data->dest_capacity)
    8528:	4293      	cmp	r3, r2
    852a:	d204      	bcs.n	8536 <tfp_format.constprop.0+0x52>
    data->dest[data->num_chars] = c;
    852c:	210d      	movs	r1, #13
    852e:	686a      	ldr	r2, [r5, #4]
    8530:	54d1      	strb	r1, [r2, r3]
    8532:	68ab      	ldr	r3, [r5, #8]
    8534:	682a      	ldr	r2, [r5, #0]
  data->num_chars ++;
    8536:	3301      	adds	r3, #1
    8538:	60ab      	str	r3, [r5, #8]
}
    853a:	e7e3      	b.n	8504 <tfp_format.constprop.0+0x20>
            p.lz = 0;
    853c:	f89d 2004 	ldrb.w	r2, [sp, #4]
            while ((ch = *(fmt++))) {
    8540:	f814 3b01 	ldrb.w	r3, [r4], #1
            p.lz = 0;
    8544:	f022 020b 	bic.w	r2, r2, #11
            p.width = 0;
    8548:	f8cd 8008 	str.w	r8, [sp, #8]
            p.sign = 0;
    854c:	f88d 800c 	strb.w	r8, [sp, #12]
            p.lz = 0;
    8550:	f88d 2004 	strb.w	r2, [sp, #4]
            while ((ch = *(fmt++))) {
    8554:	2b00      	cmp	r3, #0
    8556:	f000 8090 	beq.w	867a <tfp_format.constprop.0+0x196>
    855a:	2200      	movs	r2, #0
    855c:	4610      	mov	r0, r2
    855e:	4611      	mov	r1, r2
                switch (ch) {
    8560:	2b2d      	cmp	r3, #45	; 0x2d
    8562:	f000 809e 	beq.w	86a2 <tfp_format.constprop.0+0x1be>
    8566:	2b30      	cmp	r3, #48	; 0x30
    8568:	f000 808a 	beq.w	8680 <tfp_format.constprop.0+0x19c>
    856c:	2b23      	cmp	r3, #35	; 0x23
    856e:	d071      	beq.n	8654 <tfp_format.constprop.0+0x170>
    8570:	b129      	cbz	r1, 857e <tfp_format.constprop.0+0x9a>
    8572:	f89d 1004 	ldrb.w	r1, [sp, #4]
    8576:	f041 0108 	orr.w	r1, r1, #8
    857a:	f88d 1004 	strb.w	r1, [sp, #4]
    857e:	b128      	cbz	r0, 858c <tfp_format.constprop.0+0xa8>
    8580:	f89d 1004 	ldrb.w	r1, [sp, #4]
    8584:	f041 0101 	orr.w	r1, r1, #1
    8588:	f88d 1004 	strb.w	r1, [sp, #4]
    858c:	b12a      	cbz	r2, 859a <tfp_format.constprop.0+0xb6>
    858e:	f89d 2004 	ldrb.w	r2, [sp, #4]
    8592:	f042 0202 	orr.w	r2, r2, #2
    8596:	f88d 2004 	strb.w	r2, [sp, #4]
            if (ch >= '0' && ch <= '9') {
    859a:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
    859e:	b2d1      	uxtb	r1, r2
    85a0:	2909      	cmp	r1, #9
    85a2:	f240 8084 	bls.w	86ae <tfp_format.constprop.0+0x1ca>
            if (ch == '.') {
    85a6:	2b2e      	cmp	r3, #46	; 0x2e
    85a8:	f000 80a3 	beq.w	86f2 <tfp_format.constprop.0+0x20e>
            if (ch == 'z') {
    85ac:	2b7a      	cmp	r3, #122	; 0x7a
    85ae:	d07a      	beq.n	86a6 <tfp_format.constprop.0+0x1c2>
            if (ch == 'l') {
    85b0:	2b6c      	cmp	r3, #108	; 0x6c
    85b2:	f000 81e3 	beq.w	897c <tfp_format.constprop.0+0x498>
            char lng = 0;  /* 1 for long, 2 for long long */
    85b6:	2600      	movs	r6, #0
            switch (ch) {
    85b8:	2b78      	cmp	r3, #120	; 0x78
    85ba:	d8aa      	bhi.n	8512 <tfp_format.constprop.0+0x2e>
    85bc:	2b57      	cmp	r3, #87	; 0x57
    85be:	d961      	bls.n	8684 <tfp_format.constprop.0+0x1a0>
    85c0:	f1a3 0258 	sub.w	r2, r3, #88	; 0x58
    85c4:	2a20      	cmp	r2, #32
    85c6:	d8a4      	bhi.n	8512 <tfp_format.constprop.0+0x2e>
    85c8:	a101      	add	r1, pc, #4	; (adr r1, 85d0 <tfp_format.constprop.0+0xec>)
    85ca:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
    85ce:	bf00      	nop
    85d0:	00008913 	.word	0x00008913
    85d4:	00008513 	.word	0x00008513
    85d8:	00008513 	.word	0x00008513
    85dc:	00008513 	.word	0x00008513
    85e0:	00008513 	.word	0x00008513
    85e4:	00008513 	.word	0x00008513
    85e8:	00008513 	.word	0x00008513
    85ec:	00008513 	.word	0x00008513
    85f0:	00008513 	.word	0x00008513
    85f4:	00008513 	.word	0x00008513
    85f8:	00008513 	.word	0x00008513
    85fc:	00008945 	.word	0x00008945
    8600:	00008887 	.word	0x00008887
    8604:	00008513 	.word	0x00008513
    8608:	00008513 	.word	0x00008513
    860c:	00008513 	.word	0x00008513
    8610:	00008513 	.word	0x00008513
    8614:	00008887 	.word	0x00008887
    8618:	00008513 	.word	0x00008513
    861c:	00008513 	.word	0x00008513
    8620:	00008513 	.word	0x00008513
    8624:	00008513 	.word	0x00008513
    8628:	00008513 	.word	0x00008513
    862c:	00008817 	.word	0x00008817
    8630:	00008799 	.word	0x00008799
    8634:	00008513 	.word	0x00008513
    8638:	00008513 	.word	0x00008513
    863c:	00008785 	.word	0x00008785
    8640:	00008513 	.word	0x00008513
    8644:	0000870d 	.word	0x0000870d
    8648:	00008513 	.word	0x00008513
    864c:	00008513 	.word	0x00008513
    8650:	00008913 	.word	0x00008913
                    p.alt = 1;
    8654:	2201      	movs	r2, #1
            while ((ch = *(fmt++))) {
    8656:	f814 3b01 	ldrb.w	r3, [r4], #1
    865a:	2b00      	cmp	r3, #0
    865c:	d180      	bne.n	8560 <tfp_format.constprop.0+0x7c>
    865e:	b129      	cbz	r1, 866c <tfp_format.constprop.0+0x188>
    8660:	f89d 3004 	ldrb.w	r3, [sp, #4]
    8664:	f043 0308 	orr.w	r3, r3, #8
    8668:	f88d 3004 	strb.w	r3, [sp, #4]
    866c:	b128      	cbz	r0, 867a <tfp_format.constprop.0+0x196>
    866e:	f89d 3004 	ldrb.w	r3, [sp, #4]
    8672:	f043 0301 	orr.w	r3, r3, #1
    8676:	f88d 3004 	strb.w	r3, [sp, #4]
}
    867a:	b00d      	add	sp, #52	; 0x34
    867c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
                    p.lz = 1;
    8680:	2001      	movs	r0, #1
    8682:	e7e8      	b.n	8656 <tfp_format.constprop.0+0x172>
            switch (ch) {
    8684:	2b00      	cmp	r3, #0
    8686:	d0f8      	beq.n	867a <tfp_format.constprop.0+0x196>
    8688:	2b25      	cmp	r3, #37	; 0x25
    868a:	f47f af42 	bne.w	8512 <tfp_format.constprop.0+0x2e>
  if (data->num_chars < data->dest_capacity)
    868e:	68aa      	ldr	r2, [r5, #8]
    8690:	6829      	ldr	r1, [r5, #0]
    8692:	428a      	cmp	r2, r1
    8694:	d202      	bcs.n	869c <tfp_format.constprop.0+0x1b8>
    data->dest[data->num_chars] = c;
    8696:	6869      	ldr	r1, [r5, #4]
    8698:	548b      	strb	r3, [r1, r2]
    869a:	68aa      	ldr	r2, [r5, #8]
  data->num_chars ++;
    869c:	3201      	adds	r2, #1
    869e:	60aa      	str	r2, [r5, #8]
}
    86a0:	e737      	b.n	8512 <tfp_format.constprop.0+0x2e>
                switch (ch) {
    86a2:	2101      	movs	r1, #1
    86a4:	e7d7      	b.n	8656 <tfp_format.constprop.0+0x172>
                    lng = 1;
    86a6:	2601      	movs	r6, #1
                ch = *(fmt++);
    86a8:	f814 3b01 	ldrb.w	r3, [r4], #1
                    lng = 1;
    86ac:	e784      	b.n	85b8 <tfp_format.constprop.0+0xd4>
    unsigned int num = 0;
    86ae:	2100      	movs	r1, #0
    86b0:	e00e      	b.n	86d0 <tfp_format.constprop.0+0x1ec>
    else if (ch >= 'A' && ch <= 'F')
    86b2:	f1bc 0f05 	cmp.w	ip, #5
    86b6:	d818      	bhi.n	86ea <tfp_format.constprop.0+0x206>
        return ch - 'A' + 10;
    86b8:	f1a3 0237 	sub.w	r2, r3, #55	; 0x37
        if (digit > base)
    86bc:	2a0a      	cmp	r2, #10
    86be:	d114      	bne.n	86ea <tfp_format.constprop.0+0x206>
        ch = *p++;
    86c0:	f814 3b01 	ldrb.w	r3, [r4], #1
        num = num * base + digit;
    86c4:	eb01 0181 	add.w	r1, r1, r1, lsl #2
    86c8:	eb02 0141 	add.w	r1, r2, r1, lsl #1
        ch = *p++;
    86cc:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
    if (ch >= '0' && ch <= '9')
    86d0:	b2d0      	uxtb	r0, r2
    86d2:	2809      	cmp	r0, #9
    else if (ch >= 'a' && ch <= 'f')
    86d4:	f1a3 0661 	sub.w	r6, r3, #97	; 0x61
    else if (ch >= 'A' && ch <= 'F')
    86d8:	f1a3 0c41 	sub.w	ip, r3, #65	; 0x41
    if (ch >= '0' && ch <= '9')
    86dc:	d9f0      	bls.n	86c0 <tfp_format.constprop.0+0x1dc>
    else if (ch >= 'a' && ch <= 'f')
    86de:	2e05      	cmp	r6, #5
    86e0:	d8e7      	bhi.n	86b2 <tfp_format.constprop.0+0x1ce>
        return ch - 'a' + 10;
    86e2:	f1a3 0257 	sub.w	r2, r3, #87	; 0x57
        if (digit > base)
    86e6:	2a0a      	cmp	r2, #10
    86e8:	d0ea      	beq.n	86c0 <tfp_format.constprop.0+0x1dc>
            if (ch == '.') {
    86ea:	2b2e      	cmp	r3, #46	; 0x2e
    *nump = num;
    86ec:	9102      	str	r1, [sp, #8]
            if (ch == '.') {
    86ee:	f47f af5d 	bne.w	85ac <tfp_format.constprop.0+0xc8>
              p.lz = 1;  /* zero-padding */
    86f2:	f89d 3004 	ldrb.w	r3, [sp, #4]
    86f6:	f043 0301 	orr.w	r3, r3, #1
    86fa:	f88d 3004 	strb.w	r3, [sp, #4]
                ch = *(fmt++);
    86fe:	f814 3b01 	ldrb.w	r3, [r4], #1
              } while ((ch >= '0') && (ch <= '9'));
    8702:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
    8706:	2a09      	cmp	r2, #9
    8708:	d9f9      	bls.n	86fe <tfp_format.constprop.0+0x21a>
    870a:	e74f      	b.n	85ac <tfp_format.constprop.0+0xc8>
                p.base = 10;
    870c:	230a      	movs	r3, #10
                if (2 == lng)
    870e:	2e02      	cmp	r6, #2
                p.base = 10;
    8710:	9304      	str	r3, [sp, #16]
                if (2 == lng)
    8712:	f000 810d 	beq.w	8930 <tfp_format.constprop.0+0x44c>
                  if (1 == lng)
    8716:	2e01      	cmp	r6, #1
    8718:	f000 819e 	beq.w	8a58 <tfp_format.constprop.0+0x574>
                    ui2a(va_arg(va, unsigned int), &p);
    871c:	f857 eb04 	ldr.w	lr, [r7], #4
    unsigned int d = 1;
    8720:	2101      	movs	r1, #1
    while (num / d >= p->base)
    8722:	f1be 0f09 	cmp.w	lr, #9
    char *bf = p->bf;
    8726:	f8dd c014 	ldr.w	ip, [sp, #20]
    while (num / d >= p->base)
    872a:	d909      	bls.n	8740 <tfp_format.constprop.0+0x25c>
        d *= p->base;
    872c:	eb01 0181 	add.w	r1, r1, r1, lsl #2
    8730:	0049      	lsls	r1, r1, #1
    while (num / d >= p->base)
    8732:	fbbe f3f1 	udiv	r3, lr, r1
    8736:	2b09      	cmp	r3, #9
    8738:	d8f8      	bhi.n	872c <tfp_format.constprop.0+0x248>
    while (d != 0) {
    873a:	2900      	cmp	r1, #0
    873c:	f000 817a 	beq.w	8a34 <tfp_format.constprop.0+0x550>
    unsigned int d = 1;
    8740:	260a      	movs	r6, #10
    int n = 0;
    8742:	2200      	movs	r2, #0
    8744:	e010      	b.n	8768 <tfp_format.constprop.0+0x284>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8746:	f89d 0004 	ldrb.w	r0, [sp, #4]
    874a:	f010 0f04 	tst.w	r0, #4
    874e:	bf0c      	ite	eq
    8750:	2057      	moveq	r0, #87	; 0x57
    8752:	2037      	movne	r0, #55	; 0x37
    8754:	4403      	add	r3, r0
    while (d != 0) {
    8756:	42b1      	cmp	r1, r6
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8758:	f80c 3b01 	strb.w	r3, [ip], #1
            ++n;
    875c:	f102 0201 	add.w	r2, r2, #1
    while (d != 0) {
    8760:	f0c0 8168 	bcc.w	8a34 <tfp_format.constprop.0+0x550>
    int n = 0;
    8764:	4649      	mov	r1, r9
    8766:	9e04      	ldr	r6, [sp, #16]
        int dgt = num / d;
    8768:	fbbe f3f1 	udiv	r3, lr, r1
        d /= p->base;
    876c:	fbb1 f9f6 	udiv	r9, r1, r6
        num %= d;
    8770:	fb01 ee13 	mls	lr, r1, r3, lr
        if (n || dgt > 0 || d == 0) {
    8774:	b912      	cbnz	r2, 877c <tfp_format.constprop.0+0x298>
    8776:	2b00      	cmp	r3, #0
    8778:	f340 8156 	ble.w	8a28 <tfp_format.constprop.0+0x544>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    877c:	2b09      	cmp	r3, #9
    877e:	dce2      	bgt.n	8746 <tfp_format.constprop.0+0x262>
    8780:	2030      	movs	r0, #48	; 0x30
    8782:	e7e7      	b.n	8754 <tfp_format.constprop.0+0x270>
                p.bf = va_arg(va, char *);
    8784:	f857 3b04 	ldr.w	r3, [r7], #4
                putchw(putp, putf, &p);
    8788:	4628      	mov	r0, r5
    878a:	a901      	add	r1, sp, #4
                p.bf = va_arg(va, char *);
    878c:	9305      	str	r3, [sp, #20]
                putchw(putp, putf, &p);
    878e:	f7ff fddb 	bl	8348 <putchw.constprop.1>
                p.bf = bf;
    8792:	ab06      	add	r3, sp, #24
    8794:	9305      	str	r3, [sp, #20]
                break;
    8796:	e6bc      	b.n	8512 <tfp_format.constprop.0+0x2e>
                p.base = 16;
    8798:	2210      	movs	r2, #16
                p.alt = 1;
    879a:	f89d 3004 	ldrb.w	r3, [sp, #4]
                p.base = 16;
    879e:	9204      	str	r2, [sp, #16]
                p.alt = 1;
    87a0:	f023 0306 	bic.w	r3, r3, #6
    87a4:	f043 0302 	orr.w	r3, r3, #2
    87a8:	f88d 3004 	strb.w	r3, [sp, #4]
                    ui2a(va_arg(va, unsigned int), &p);
    87ac:	46be      	mov	lr, r7
    87ae:	f85e 2b04 	ldr.w	r2, [lr], #4
    unsigned int d = 1;
    87b2:	2601      	movs	r6, #1
    while (num / d >= p->base)
    87b4:	2a0f      	cmp	r2, #15
    char *bf = p->bf;
    87b6:	9805      	ldr	r0, [sp, #20]
    while (num / d >= p->base)
    87b8:	f240 81d7 	bls.w	8b6a <tfp_format.constprop.0+0x686>
        d *= p->base;
    87bc:	0136      	lsls	r6, r6, #4
    while (num / d >= p->base)
    87be:	fbb2 f3f6 	udiv	r3, r2, r6
    87c2:	2b0f      	cmp	r3, #15
    87c4:	d8fa      	bhi.n	87bc <tfp_format.constprop.0+0x2d8>
    while (d != 0) {
    87c6:	2e00      	cmp	r6, #0
    87c8:	f000 80cf 	beq.w	896a <tfp_format.constprop.0+0x486>
    unsigned int d = 1;
    87cc:	2710      	movs	r7, #16
    int n = 0;
    87ce:	f04f 0c00 	mov.w	ip, #0
    87d2:	e012      	b.n	87fa <tfp_format.constprop.0+0x316>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    87d4:	f89d 1004 	ldrb.w	r1, [sp, #4]
    87d8:	f011 0f04 	tst.w	r1, #4
    87dc:	bf0c      	ite	eq
    87de:	2157      	moveq	r1, #87	; 0x57
    87e0:	2137      	movne	r1, #55	; 0x37
    87e2:	440b      	add	r3, r1
    while (d != 0) {
    87e4:	42be      	cmp	r6, r7
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    87e6:	f800 3b01 	strb.w	r3, [r0], #1
            ++n;
    87ea:	f10c 0c01 	add.w	ip, ip, #1
    while (d != 0) {
    87ee:	f0c0 80bc 	bcc.w	896a <tfp_format.constprop.0+0x486>
    int n = 0;
    87f2:	464e      	mov	r6, r9
    87f4:	fbb2 f3f9 	udiv	r3, r2, r9
    87f8:	9f04      	ldr	r7, [sp, #16]
        d /= p->base;
    87fa:	fbb6 f9f7 	udiv	r9, r6, r7
        num %= d;
    87fe:	fb06 2213 	mls	r2, r6, r3, r2
        if (n || dgt > 0 || d == 0) {
    8802:	f1bc 0f00 	cmp.w	ip, #0
    8806:	d102      	bne.n	880e <tfp_format.constprop.0+0x32a>
    8808:	2b00      	cmp	r3, #0
    880a:	f340 80a8 	ble.w	895e <tfp_format.constprop.0+0x47a>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    880e:	2b09      	cmp	r3, #9
    8810:	dce0      	bgt.n	87d4 <tfp_format.constprop.0+0x2f0>
    8812:	2130      	movs	r1, #48	; 0x30
    8814:	e7e5      	b.n	87e2 <tfp_format.constprop.0+0x2fe>
                p.base = 8;
    8816:	2308      	movs	r3, #8
                ui2a(va_arg(va, unsigned int), &p);
    8818:	f857 2b04 	ldr.w	r2, [r7], #4
    unsigned int d = 1;
    881c:	2601      	movs	r6, #1
    while (num / d >= p->base)
    881e:	2a07      	cmp	r2, #7
    char *bf = p->bf;
    8820:	9905      	ldr	r1, [sp, #20]
                p.base = 8;
    8822:	9304      	str	r3, [sp, #16]
    while (num / d >= p->base)
    8824:	f240 815b 	bls.w	8ade <tfp_format.constprop.0+0x5fa>
        d *= p->base;
    8828:	00f6      	lsls	r6, r6, #3
    while (num / d >= p->base)
    882a:	fbb2 f3f6 	udiv	r3, r2, r6
    882e:	2b07      	cmp	r3, #7
    8830:	d8fa      	bhi.n	8828 <tfp_format.constprop.0+0x344>
    while (d != 0) {
    8832:	2e00      	cmp	r6, #0
    8834:	f000 80ef 	beq.w	8a16 <tfp_format.constprop.0+0x532>
    unsigned int d = 1;
    8838:	f04f 0c08 	mov.w	ip, #8
    int n = 0;
    883c:	f04f 0e00 	mov.w	lr, #0
    8840:	e013      	b.n	886a <tfp_format.constprop.0+0x386>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8842:	f89d 0004 	ldrb.w	r0, [sp, #4]
    8846:	f010 0f04 	tst.w	r0, #4
    884a:	bf0c      	ite	eq
    884c:	2057      	moveq	r0, #87	; 0x57
    884e:	2037      	movne	r0, #55	; 0x37
    8850:	4403      	add	r3, r0
    while (d != 0) {
    8852:	4566      	cmp	r6, ip
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8854:	f801 3b01 	strb.w	r3, [r1], #1
            ++n;
    8858:	f10e 0e01 	add.w	lr, lr, #1
    while (d != 0) {
    885c:	f0c0 80db 	bcc.w	8a16 <tfp_format.constprop.0+0x532>
    int n = 0;
    8860:	464e      	mov	r6, r9
    8862:	fbb2 f3f9 	udiv	r3, r2, r9
    8866:	f8dd c010 	ldr.w	ip, [sp, #16]
        d /= p->base;
    886a:	fbb6 f9fc 	udiv	r9, r6, ip
        num %= d;
    886e:	fb06 2213 	mls	r2, r6, r3, r2
        if (n || dgt > 0 || d == 0) {
    8872:	f1be 0f00 	cmp.w	lr, #0
    8876:	d102      	bne.n	887e <tfp_format.constprop.0+0x39a>
    8878:	2b00      	cmp	r3, #0
    887a:	f340 80c6 	ble.w	8a0a <tfp_format.constprop.0+0x526>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    887e:	2b09      	cmp	r3, #9
    8880:	dcdf      	bgt.n	8842 <tfp_format.constprop.0+0x35e>
    8882:	2030      	movs	r0, #48	; 0x30
    8884:	e7e4      	b.n	8850 <tfp_format.constprop.0+0x36c>
                p.base = 10;
    8886:	230a      	movs	r3, #10
                if (2 == lng)
    8888:	2e02      	cmp	r6, #2
                p.base = 10;
    888a:	9304      	str	r3, [sp, #16]
                if (2 == lng)
    888c:	f000 80af 	beq.w	89ee <tfp_format.constprop.0+0x50a>
                  if (1 == lng)
    8890:	2e01      	cmp	r6, #1
    8892:	f000 8126 	beq.w	8ae2 <tfp_format.constprop.0+0x5fe>
                    i2a(va_arg(va, int), &p);
    8896:	f857 2b04 	ldr.w	r2, [r7], #4
    if (num < 0) {
    889a:	2a00      	cmp	r2, #0
    889c:	da03      	bge.n	88a6 <tfp_format.constprop.0+0x3c2>
        p->sign = '-';
    889e:	232d      	movs	r3, #45	; 0x2d
        num = -num;
    88a0:	4252      	negs	r2, r2
        p->sign = '-';
    88a2:	f88d 300c 	strb.w	r3, [sp, #12]
    while (num / d >= p->base)
    88a6:	2a09      	cmp	r2, #9
    ui2a(num, p);
    88a8:	4696      	mov	lr, r2
    unsigned int d = 1;
    88aa:	f04f 0101 	mov.w	r1, #1
    char *bf = p->bf;
    88ae:	f8dd c014 	ldr.w	ip, [sp, #20]
    while (num / d >= p->base)
    88b2:	dd09      	ble.n	88c8 <tfp_format.constprop.0+0x3e4>
        d *= p->base;
    88b4:	eb01 0181 	add.w	r1, r1, r1, lsl #2
    88b8:	0049      	lsls	r1, r1, #1
    while (num / d >= p->base)
    88ba:	fbb2 f3f1 	udiv	r3, r2, r1
    88be:	2b09      	cmp	r3, #9
    88c0:	d8f8      	bhi.n	88b4 <tfp_format.constprop.0+0x3d0>
    while (d != 0) {
    88c2:	2900      	cmp	r1, #0
    88c4:	f000 80b6 	beq.w	8a34 <tfp_format.constprop.0+0x550>
    unsigned int d = 1;
    88c8:	220a      	movs	r2, #10
    int n = 0;
    88ca:	2000      	movs	r0, #0
    88cc:	e013      	b.n	88f6 <tfp_format.constprop.0+0x412>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    88ce:	2b09      	cmp	r3, #9
    88d0:	f240 80a8 	bls.w	8a24 <tfp_format.constprop.0+0x540>
    88d4:	f89d 6004 	ldrb.w	r6, [sp, #4]
    88d8:	f016 0f04 	tst.w	r6, #4
    88dc:	bf0c      	ite	eq
    88de:	2657      	moveq	r6, #87	; 0x57
    88e0:	2637      	movne	r6, #55	; 0x37
    88e2:	4433      	add	r3, r6
    while (d != 0) {
    88e4:	4291      	cmp	r1, r2
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    88e6:	f80c 3b01 	strb.w	r3, [ip], #1
            ++n;
    88ea:	f100 0001 	add.w	r0, r0, #1
    while (d != 0) {
    88ee:	f0c0 80a1 	bcc.w	8a34 <tfp_format.constprop.0+0x550>
    int n = 0;
    88f2:	4649      	mov	r1, r9
    88f4:	9a04      	ldr	r2, [sp, #16]
        int dgt = num / d;
    88f6:	fbbe f3f1 	udiv	r3, lr, r1
        if (n || dgt > 0 || d == 0) {
    88fa:	ea50 0603 	orrs.w	r6, r0, r3
        d /= p->base;
    88fe:	fbb1 f9f2 	udiv	r9, r1, r2
        num %= d;
    8902:	fb01 ee13 	mls	lr, r1, r3, lr
        if (n || dgt > 0 || d == 0) {
    8906:	d1e2      	bne.n	88ce <tfp_format.constprop.0+0x3ea>
    8908:	4291      	cmp	r1, r2
    890a:	f0c0 8090 	bcc.w	8a2e <tfp_format.constprop.0+0x54a>
    890e:	4630      	mov	r0, r6
    8910:	e7ef      	b.n	88f2 <tfp_format.constprop.0+0x40e>
                p.uc = (ch == 'X')?1:0;
    8912:	f1a3 0358 	sub.w	r3, r3, #88	; 0x58
    8916:	fab3 f383 	clz	r3, r3
                p.base = 16;
    891a:	2110      	movs	r1, #16
                p.uc = (ch == 'X')?1:0;
    891c:	f89d 2004 	ldrb.w	r2, [sp, #4]
    8920:	095b      	lsrs	r3, r3, #5
    8922:	f363 0282 	bfi	r2, r3, #2, #1
                if (2 == lng)
    8926:	2e02      	cmp	r6, #2
                p.base = 16;
    8928:	9104      	str	r1, [sp, #16]
                p.uc = (ch == 'X')?1:0;
    892a:	f88d 2004 	strb.w	r2, [sp, #4]
                if (2 == lng)
    892e:	d12b      	bne.n	8988 <tfp_format.constprop.0+0x4a4>
                    ulli2a(va_arg(va, unsigned long long int), &p);
    8930:	3707      	adds	r7, #7
    8932:	f027 0707 	bic.w	r7, r7, #7
    8936:	ae01      	add	r6, sp, #4
    8938:	4632      	mov	r2, r6
    893a:	e8f7 0102 	ldrd	r0, r1, [r7], #8
    893e:	f7ff fc0f 	bl	8160 <ulli2a>
    8942:	e016      	b.n	8972 <tfp_format.constprop.0+0x48e>
  if (data->num_chars < data->dest_capacity)
    8944:	68ab      	ldr	r3, [r5, #8]
    8946:	6829      	ldr	r1, [r5, #0]
                putf(putp, (char)(va_arg(va, int)));
    8948:	1d3a      	adds	r2, r7, #4
  if (data->num_chars < data->dest_capacity)
    894a:	428b      	cmp	r3, r1
    894c:	d203      	bcs.n	8956 <tfp_format.constprop.0+0x472>
                putf(putp, (char)(va_arg(va, int)));
    894e:	6838      	ldr	r0, [r7, #0]
    data->dest[data->num_chars] = c;
    8950:	6869      	ldr	r1, [r5, #4]
                putf(putp, (char)(va_arg(va, int)));
    8952:	54c8      	strb	r0, [r1, r3]
    8954:	68ab      	ldr	r3, [r5, #8]
  data->num_chars ++;
    8956:	3301      	adds	r3, #1
                putf(putp, (char)(va_arg(va, int)));
    8958:	4617      	mov	r7, r2
  data->num_chars ++;
    895a:	60ab      	str	r3, [r5, #8]
}
    895c:	e5d9      	b.n	8512 <tfp_format.constprop.0+0x2e>
        if (n || dgt > 0 || d == 0) {
    895e:	42be      	cmp	r6, r7
    8960:	f4bf af47 	bcs.w	87f2 <tfp_format.constprop.0+0x30e>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8964:	3330      	adds	r3, #48	; 0x30
    8966:	f800 3b01 	strb.w	r3, [r0], #1
                    ui2a(va_arg(va, unsigned int), &p);
    896a:	4677      	mov	r7, lr
    *bf = 0;
    896c:	f880 8000 	strb.w	r8, [r0]
    8970:	ae01      	add	r6, sp, #4
                putchw(putp, putf, &p);
    8972:	4631      	mov	r1, r6
    8974:	4628      	mov	r0, r5
    8976:	f7ff fce7 	bl	8348 <putchw.constprop.1>
                break;
    897a:	e5ca      	b.n	8512 <tfp_format.constprop.0+0x2e>
                ch = *(fmt++);
    897c:	7823      	ldrb	r3, [r4, #0]
                if (ch == 'l') {
    897e:	2b6c      	cmp	r3, #108	; 0x6c
    8980:	d066      	beq.n	8a50 <tfp_format.constprop.0+0x56c>
                lng = 1;
    8982:	2601      	movs	r6, #1
                ch = *(fmt++);
    8984:	3401      	adds	r4, #1
    8986:	e617      	b.n	85b8 <tfp_format.constprop.0+0xd4>
                  if (1 == lng)
    8988:	2e01      	cmp	r6, #1
    898a:	f47f af0f 	bne.w	87ac <tfp_format.constprop.0+0x2c8>
                    uli2a(va_arg(va, unsigned long int), &p);
    898e:	46bc      	mov	ip, r7
    8990:	f85c eb04 	ldr.w	lr, [ip], #4
    unsigned long int d = 1;
    8994:	4633      	mov	r3, r6
    while (num / d >= p->base)
    8996:	f1be 0f0f 	cmp.w	lr, #15
    char *bf = p->bf;
    899a:	9805      	ldr	r0, [sp, #20]
    while (num / d >= p->base)
    899c:	f240 80e7 	bls.w	8b6e <tfp_format.constprop.0+0x68a>
        d *= p->base;
    89a0:	011b      	lsls	r3, r3, #4
    while (num / d >= p->base)
    89a2:	fbbe f1f3 	udiv	r1, lr, r3
    89a6:	290f      	cmp	r1, #15
    89a8:	d8fa      	bhi.n	89a0 <tfp_format.constprop.0+0x4bc>
    while (d != 0) {
    89aa:	2b00      	cmp	r3, #0
    89ac:	d04b      	beq.n	8a46 <tfp_format.constprop.0+0x562>
    unsigned long int d = 1;
    89ae:	2210      	movs	r2, #16
    int n = 0;
    89b0:	2700      	movs	r7, #0
    89b2:	e011      	b.n	89d8 <tfp_format.constprop.0+0x4f4>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    89b4:	f89d 6004 	ldrb.w	r6, [sp, #4]
    89b8:	f016 0f04 	tst.w	r6, #4
    89bc:	bf0c      	ite	eq
    89be:	2657      	moveq	r6, #87	; 0x57
    89c0:	2637      	movne	r6, #55	; 0x37
    89c2:	4431      	add	r1, r6
    while (d != 0) {
    89c4:	4293      	cmp	r3, r2
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    89c6:	f800 1b01 	strb.w	r1, [r0], #1
            ++n;
    89ca:	f107 0701 	add.w	r7, r7, #1
    while (d != 0) {
    89ce:	d33a      	bcc.n	8a46 <tfp_format.constprop.0+0x562>
    int n = 0;
    89d0:	464b      	mov	r3, r9
    89d2:	fbbe f1f9 	udiv	r1, lr, r9
    89d6:	9a04      	ldr	r2, [sp, #16]
        d /= p->base;
    89d8:	fbb3 f9f2 	udiv	r9, r3, r2
        num %= d;
    89dc:	fb03 ee11 	mls	lr, r3, r1, lr
        if (n || dgt > 0 || d == 0) {
    89e0:	b90f      	cbnz	r7, 89e6 <tfp_format.constprop.0+0x502>
    89e2:	2900      	cmp	r1, #0
    89e4:	dd2a      	ble.n	8a3c <tfp_format.constprop.0+0x558>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    89e6:	2909      	cmp	r1, #9
    89e8:	dce4      	bgt.n	89b4 <tfp_format.constprop.0+0x4d0>
    89ea:	2630      	movs	r6, #48	; 0x30
    89ec:	e7e9      	b.n	89c2 <tfp_format.constprop.0+0x4de>
                    lli2a(va_arg(va, long long int), &p);
    89ee:	3707      	adds	r7, #7
    89f0:	f027 0707 	bic.w	r7, r7, #7
    89f4:	e8f7 0102 	ldrd	r0, r1, [r7], #8
    if (num < 0) {
    89f8:	2800      	cmp	r0, #0
    89fa:	f171 0300 	sbcs.w	r3, r1, #0
    89fe:	db67      	blt.n	8ad0 <tfp_format.constprop.0+0x5ec>
    ulli2a(num, p);
    8a00:	ae01      	add	r6, sp, #4
    8a02:	4632      	mov	r2, r6
    8a04:	f7ff fbac 	bl	8160 <ulli2a>
}
    8a08:	e7b3      	b.n	8972 <tfp_format.constprop.0+0x48e>
        if (n || dgt > 0 || d == 0) {
    8a0a:	4566      	cmp	r6, ip
    8a0c:	f4bf af28 	bcs.w	8860 <tfp_format.constprop.0+0x37c>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8a10:	3330      	adds	r3, #48	; 0x30
    8a12:	f801 3b01 	strb.w	r3, [r1], #1
    *bf = 0;
    8a16:	f881 8000 	strb.w	r8, [r1]
                putchw(putp, putf, &p);
    8a1a:	4628      	mov	r0, r5
    8a1c:	a901      	add	r1, sp, #4
    8a1e:	f7ff fc93 	bl	8348 <putchw.constprop.1>
                break;
    8a22:	e576      	b.n	8512 <tfp_format.constprop.0+0x2e>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8a24:	2630      	movs	r6, #48	; 0x30
    8a26:	e75c      	b.n	88e2 <tfp_format.constprop.0+0x3fe>
        if (n || dgt > 0 || d == 0) {
    8a28:	42b1      	cmp	r1, r6
    8a2a:	f4bf ae9b 	bcs.w	8764 <tfp_format.constprop.0+0x280>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8a2e:	3330      	adds	r3, #48	; 0x30
    8a30:	f80c 3b01 	strb.w	r3, [ip], #1
    *bf = 0;
    8a34:	f88c 8000 	strb.w	r8, [ip]
    8a38:	ae01      	add	r6, sp, #4
}
    8a3a:	e79a      	b.n	8972 <tfp_format.constprop.0+0x48e>
        if (n || dgt > 0 || d == 0) {
    8a3c:	4293      	cmp	r3, r2
    8a3e:	d2c7      	bcs.n	89d0 <tfp_format.constprop.0+0x4ec>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8a40:	3130      	adds	r1, #48	; 0x30
    8a42:	f800 1b01 	strb.w	r1, [r0], #1
                    uli2a(va_arg(va, unsigned long int), &p);
    8a46:	4667      	mov	r7, ip
    *bf = 0;
    8a48:	f880 8000 	strb.w	r8, [r0]
    8a4c:	ae01      	add	r6, sp, #4
}
    8a4e:	e790      	b.n	8972 <tfp_format.constprop.0+0x48e>
                  lng = 2;
    8a50:	2602      	movs	r6, #2
                  ch = *(fmt++);
    8a52:	7863      	ldrb	r3, [r4, #1]
    8a54:	4434      	add	r4, r6
    8a56:	e5af      	b.n	85b8 <tfp_format.constprop.0+0xd4>
                    uli2a(va_arg(va, unsigned long int), &p);
    8a58:	46bc      	mov	ip, r7
    8a5a:	f85c 2b04 	ldr.w	r2, [ip], #4
    unsigned long int d = 1;
    8a5e:	4633      	mov	r3, r6
    while (num / d >= p->base)
    8a60:	2a09      	cmp	r2, #9
    char *bf = p->bf;
    8a62:	9905      	ldr	r1, [sp, #20]
    while (num / d >= p->base)
    8a64:	d907      	bls.n	8a76 <tfp_format.constprop.0+0x592>
        d *= p->base;
    8a66:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    8a6a:	005b      	lsls	r3, r3, #1
    while (num / d >= p->base)
    8a6c:	fbb2 f0f3 	udiv	r0, r2, r3
    8a70:	2809      	cmp	r0, #9
    8a72:	d8f8      	bhi.n	8a66 <tfp_format.constprop.0+0x582>
    while (d != 0) {
    8a74:	b33b      	cbz	r3, 8ac6 <tfp_format.constprop.0+0x5e2>
    unsigned long int d = 1;
    8a76:	270a      	movs	r7, #10
    int n = 0;
    8a78:	f04f 0e00 	mov.w	lr, #0
    8a7c:	e00f      	b.n	8a9e <tfp_format.constprop.0+0x5ba>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8a7e:	f89d 6004 	ldrb.w	r6, [sp, #4]
    8a82:	f016 0f04 	tst.w	r6, #4
    8a86:	bf0c      	ite	eq
    8a88:	2657      	moveq	r6, #87	; 0x57
    8a8a:	2637      	movne	r6, #55	; 0x37
    8a8c:	4430      	add	r0, r6
    while (d != 0) {
    8a8e:	42bb      	cmp	r3, r7
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8a90:	f801 0b01 	strb.w	r0, [r1], #1
            ++n;
    8a94:	f10e 0e01 	add.w	lr, lr, #1
    while (d != 0) {
    8a98:	d315      	bcc.n	8ac6 <tfp_format.constprop.0+0x5e2>
    int n = 0;
    8a9a:	464b      	mov	r3, r9
    8a9c:	9f04      	ldr	r7, [sp, #16]
        int dgt = num / d;
    8a9e:	fbb2 f0f3 	udiv	r0, r2, r3
        d /= p->base;
    8aa2:	fbb3 f9f7 	udiv	r9, r3, r7
        num %= d;
    8aa6:	fb03 2210 	mls	r2, r3, r0, r2
        if (n || dgt > 0 || d == 0) {
    8aaa:	f1be 0f00 	cmp.w	lr, #0
    8aae:	d101      	bne.n	8ab4 <tfp_format.constprop.0+0x5d0>
    8ab0:	2800      	cmp	r0, #0
    8ab2:	dd03      	ble.n	8abc <tfp_format.constprop.0+0x5d8>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8ab4:	2809      	cmp	r0, #9
    8ab6:	dce2      	bgt.n	8a7e <tfp_format.constprop.0+0x59a>
    8ab8:	2630      	movs	r6, #48	; 0x30
    8aba:	e7e7      	b.n	8a8c <tfp_format.constprop.0+0x5a8>
        if (n || dgt > 0 || d == 0) {
    8abc:	42bb      	cmp	r3, r7
    8abe:	d2ec      	bcs.n	8a9a <tfp_format.constprop.0+0x5b6>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8ac0:	3030      	adds	r0, #48	; 0x30
    8ac2:	f801 0b01 	strb.w	r0, [r1], #1
                    uli2a(va_arg(va, unsigned long int), &p);
    8ac6:	4667      	mov	r7, ip
    *bf = 0;
    8ac8:	f881 8000 	strb.w	r8, [r1]
    8acc:	ae01      	add	r6, sp, #4
}
    8ace:	e750      	b.n	8972 <tfp_format.constprop.0+0x48e>
        p->sign = '-';
    8ad0:	232d      	movs	r3, #45	; 0x2d
        num = -num;
    8ad2:	4240      	negs	r0, r0
    8ad4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
        p->sign = '-';
    8ad8:	f88d 300c 	strb.w	r3, [sp, #12]
    8adc:	e790      	b.n	8a00 <tfp_format.constprop.0+0x51c>
    8ade:	4613      	mov	r3, r2
    8ae0:	e6aa      	b.n	8838 <tfp_format.constprop.0+0x354>
                    li2a(va_arg(va, long int), &p);
    8ae2:	f857 1b04 	ldr.w	r1, [r7], #4
    if (num < 0) {
    8ae6:	2900      	cmp	r1, #0
    8ae8:	da03      	bge.n	8af2 <tfp_format.constprop.0+0x60e>
        p->sign = '-';
    8aea:	232d      	movs	r3, #45	; 0x2d
        num = -num;
    8aec:	4249      	negs	r1, r1
        p->sign = '-';
    8aee:	f88d 300c 	strb.w	r3, [sp, #12]
    while (num / d >= p->base)
    8af2:	2909      	cmp	r1, #9
    uli2a(num, p);
    8af4:	468c      	mov	ip, r1
    unsigned long int d = 1;
    8af6:	f04f 0301 	mov.w	r3, #1
    char *bf = p->bf;
    8afa:	9e05      	ldr	r6, [sp, #20]
    while (num / d >= p->base)
    8afc:	dd07      	ble.n	8b0e <tfp_format.constprop.0+0x62a>
        d *= p->base;
    8afe:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    8b02:	005b      	lsls	r3, r3, #1
    while (num / d >= p->base)
    8b04:	fbb1 f2f3 	udiv	r2, r1, r3
    8b08:	2a09      	cmp	r2, #9
    8b0a:	d8f8      	bhi.n	8afe <tfp_format.constprop.0+0x61a>
    while (d != 0) {
    8b0c:	b34b      	cbz	r3, 8b62 <tfp_format.constprop.0+0x67e>
    unsigned long int d = 1;
    8b0e:	220a      	movs	r2, #10
    int n = 0;
    8b10:	2000      	movs	r0, #0
    8b12:	e013      	b.n	8b3c <tfp_format.constprop.0+0x658>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8b14:	2909      	cmp	r1, #9
    8b16:	d91e      	bls.n	8b56 <tfp_format.constprop.0+0x672>
    8b18:	f89d e004 	ldrb.w	lr, [sp, #4]
    8b1c:	f01e 0f04 	tst.w	lr, #4
    8b20:	bf0c      	ite	eq
    8b22:	f04f 0e57 	moveq.w	lr, #87	; 0x57
    8b26:	f04f 0e37 	movne.w	lr, #55	; 0x37
    8b2a:	4471      	add	r1, lr
    while (d != 0) {
    8b2c:	4293      	cmp	r3, r2
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8b2e:	f806 1b01 	strb.w	r1, [r6], #1
            ++n;
    8b32:	f100 0001 	add.w	r0, r0, #1
    while (d != 0) {
    8b36:	d314      	bcc.n	8b62 <tfp_format.constprop.0+0x67e>
    int n = 0;
    8b38:	464b      	mov	r3, r9
    8b3a:	9a04      	ldr	r2, [sp, #16]
        int dgt = num / d;
    8b3c:	fbbc f1f3 	udiv	r1, ip, r3
        if (n || dgt > 0 || d == 0) {
    8b40:	ea50 0e01 	orrs.w	lr, r0, r1
        d /= p->base;
    8b44:	fbb3 f9f2 	udiv	r9, r3, r2
        num %= d;
    8b48:	fb03 cc11 	mls	ip, r3, r1, ip
        if (n || dgt > 0 || d == 0) {
    8b4c:	d1e2      	bne.n	8b14 <tfp_format.constprop.0+0x630>
    8b4e:	4293      	cmp	r3, r2
    8b50:	d304      	bcc.n	8b5c <tfp_format.constprop.0+0x678>
    8b52:	4670      	mov	r0, lr
    8b54:	e7f0      	b.n	8b38 <tfp_format.constprop.0+0x654>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8b56:	f04f 0e30 	mov.w	lr, #48	; 0x30
    8b5a:	e7e6      	b.n	8b2a <tfp_format.constprop.0+0x646>
    8b5c:	3130      	adds	r1, #48	; 0x30
    8b5e:	f806 1b01 	strb.w	r1, [r6], #1
    *bf = 0;
    8b62:	f886 8000 	strb.w	r8, [r6]
    8b66:	ae01      	add	r6, sp, #4
}
    8b68:	e703      	b.n	8972 <tfp_format.constprop.0+0x48e>
    8b6a:	4613      	mov	r3, r2
    8b6c:	e62e      	b.n	87cc <tfp_format.constprop.0+0x2e8>
    8b6e:	4671      	mov	r1, lr
    8b70:	e71d      	b.n	89ae <tfp_format.constprop.0+0x4ca>
    8b72:	bf00      	nop

00008b74 <tfp_format>:
{
    8b74:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8b78:	b08d      	sub	sp, #52	; 0x34
    while ((ch = *(fmt++))) {
    8b7a:	4614      	mov	r4, r2
    8b7c:	f814 5b01 	ldrb.w	r5, [r4], #1
{
    8b80:	4698      	mov	r8, r3
    p.bf = bf;
    8b82:	ab06      	add	r3, sp, #24
{
    8b84:	4606      	mov	r6, r0
    8b86:	460f      	mov	r7, r1
    p.bf = bf;
    8b88:	9305      	str	r3, [sp, #20]
    while ((ch = *(fmt++))) {
    8b8a:	2d00      	cmp	r5, #0
    8b8c:	f000 80af 	beq.w	8cee <tfp_format+0x17a>
            p.width = 0;
    8b90:	f04f 0900 	mov.w	r9, #0
    8b94:	e00c      	b.n	8bb0 <tfp_format+0x3c>
			if (ch == '\n')
    8b96:	2d0a      	cmp	r5, #10
    8b98:	d102      	bne.n	8ba0 <tfp_format+0x2c>
				putf(putp, '\r');
    8b9a:	210d      	movs	r1, #13
    8b9c:	4630      	mov	r0, r6
    8b9e:	47b8      	blx	r7
            putf(putp, ch);
    8ba0:	4629      	mov	r1, r5
    8ba2:	4630      	mov	r0, r6
    8ba4:	47b8      	blx	r7
    while ((ch = *(fmt++))) {
    8ba6:	f814 5b01 	ldrb.w	r5, [r4], #1
    8baa:	2d00      	cmp	r5, #0
    8bac:	f000 809f 	beq.w	8cee <tfp_format+0x17a>
        if (ch != '%') {
    8bb0:	2d25      	cmp	r5, #37	; 0x25
    8bb2:	d1f0      	bne.n	8b96 <tfp_format+0x22>
            p.lz = 0;
    8bb4:	f89d 3004 	ldrb.w	r3, [sp, #4]
            while ((ch = *(fmt++))) {
    8bb8:	f814 1b01 	ldrb.w	r1, [r4], #1
            p.lz = 0;
    8bbc:	f023 030b 	bic.w	r3, r3, #11
            p.width = 0;
    8bc0:	f8cd 9008 	str.w	r9, [sp, #8]
            p.sign = 0;
    8bc4:	f88d 900c 	strb.w	r9, [sp, #12]
            p.lz = 0;
    8bc8:	f88d 3004 	strb.w	r3, [sp, #4]
            while ((ch = *(fmt++))) {
    8bcc:	2900      	cmp	r1, #0
    8bce:	f000 808e 	beq.w	8cee <tfp_format+0x17a>
    8bd2:	2300      	movs	r3, #0
    8bd4:	4618      	mov	r0, r3
    8bd6:	461a      	mov	r2, r3
                switch (ch) {
    8bd8:	292d      	cmp	r1, #45	; 0x2d
    8bda:	f000 8095 	beq.w	8d08 <tfp_format+0x194>
    8bde:	2930      	cmp	r1, #48	; 0x30
    8be0:	f000 8088 	beq.w	8cf4 <tfp_format+0x180>
    8be4:	2923      	cmp	r1, #35	; 0x23
    8be6:	d06f      	beq.n	8cc8 <tfp_format+0x154>
    8be8:	b12a      	cbz	r2, 8bf6 <tfp_format+0x82>
    8bea:	f89d 2004 	ldrb.w	r2, [sp, #4]
    8bee:	f042 0208 	orr.w	r2, r2, #8
    8bf2:	f88d 2004 	strb.w	r2, [sp, #4]
    8bf6:	b128      	cbz	r0, 8c04 <tfp_format+0x90>
    8bf8:	f89d 2004 	ldrb.w	r2, [sp, #4]
    8bfc:	f042 0201 	orr.w	r2, r2, #1
    8c00:	f88d 2004 	strb.w	r2, [sp, #4]
    8c04:	b12b      	cbz	r3, 8c12 <tfp_format+0x9e>
    8c06:	f89d 3004 	ldrb.w	r3, [sp, #4]
    8c0a:	f043 0302 	orr.w	r3, r3, #2
    8c0e:	f88d 3004 	strb.w	r3, [sp, #4]
            if (ch >= '0' && ch <= '9') {
    8c12:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
    8c16:	b2da      	uxtb	r2, r3
    8c18:	2a09      	cmp	r2, #9
    8c1a:	d97b      	bls.n	8d14 <tfp_format+0x1a0>
            if (ch == '.') {
    8c1c:	292e      	cmp	r1, #46	; 0x2e
    8c1e:	f000 809b 	beq.w	8d58 <tfp_format+0x1e4>
            if (ch == 'z') {
    8c22:	297a      	cmp	r1, #122	; 0x7a
    8c24:	d072      	beq.n	8d0c <tfp_format+0x198>
            if (ch == 'l') {
    8c26:	296c      	cmp	r1, #108	; 0x6c
    8c28:	f000 81dc 	beq.w	8fe4 <tfp_format+0x470>
            char lng = 0;  /* 1 for long, 2 for long long */
    8c2c:	2000      	movs	r0, #0
            switch (ch) {
    8c2e:	2978      	cmp	r1, #120	; 0x78
    8c30:	d8b9      	bhi.n	8ba6 <tfp_format+0x32>
    8c32:	2957      	cmp	r1, #87	; 0x57
    8c34:	d960      	bls.n	8cf8 <tfp_format+0x184>
    8c36:	f1a1 0358 	sub.w	r3, r1, #88	; 0x58
    8c3a:	2b20      	cmp	r3, #32
    8c3c:	d8b3      	bhi.n	8ba6 <tfp_format+0x32>
    8c3e:	a201      	add	r2, pc, #4	; (adr r2, 8c44 <tfp_format+0xd0>)
    8c40:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    8c44:	00008f93 	.word	0x00008f93
    8c48:	00008ba7 	.word	0x00008ba7
    8c4c:	00008ba7 	.word	0x00008ba7
    8c50:	00008ba7 	.word	0x00008ba7
    8c54:	00008ba7 	.word	0x00008ba7
    8c58:	00008ba7 	.word	0x00008ba7
    8c5c:	00008ba7 	.word	0x00008ba7
    8c60:	00008ba7 	.word	0x00008ba7
    8c64:	00008ba7 	.word	0x00008ba7
    8c68:	00008ba7 	.word	0x00008ba7
    8c6c:	00008ba7 	.word	0x00008ba7
    8c70:	00008f87 	.word	0x00008f87
    8c74:	00008efd 	.word	0x00008efd
    8c78:	00008ba7 	.word	0x00008ba7
    8c7c:	00008ba7 	.word	0x00008ba7
    8c80:	00008ba7 	.word	0x00008ba7
    8c84:	00008ba7 	.word	0x00008ba7
    8c88:	00008efd 	.word	0x00008efd
    8c8c:	00008ba7 	.word	0x00008ba7
    8c90:	00008ba7 	.word	0x00008ba7
    8c94:	00008ba7 	.word	0x00008ba7
    8c98:	00008ba7 	.word	0x00008ba7
    8c9c:	00008ba7 	.word	0x00008ba7
    8ca0:	00008e8d 	.word	0x00008e8d
    8ca4:	00008e0b 	.word	0x00008e0b
    8ca8:	00008ba7 	.word	0x00008ba7
    8cac:	00008ba7 	.word	0x00008ba7
    8cb0:	00008df5 	.word	0x00008df5
    8cb4:	00008ba7 	.word	0x00008ba7
    8cb8:	00008d73 	.word	0x00008d73
    8cbc:	00008ba7 	.word	0x00008ba7
    8cc0:	00008ba7 	.word	0x00008ba7
    8cc4:	00008f93 	.word	0x00008f93
                    p.alt = 1;
    8cc8:	2301      	movs	r3, #1
            while ((ch = *(fmt++))) {
    8cca:	f814 1b01 	ldrb.w	r1, [r4], #1
    8cce:	2900      	cmp	r1, #0
    8cd0:	d182      	bne.n	8bd8 <tfp_format+0x64>
    8cd2:	b12a      	cbz	r2, 8ce0 <tfp_format+0x16c>
    8cd4:	f89d 2004 	ldrb.w	r2, [sp, #4]
    8cd8:	f042 0208 	orr.w	r2, r2, #8
    8cdc:	f88d 2004 	strb.w	r2, [sp, #4]
    8ce0:	b128      	cbz	r0, 8cee <tfp_format+0x17a>
    8ce2:	f89d 2004 	ldrb.w	r2, [sp, #4]
    8ce6:	f042 0201 	orr.w	r2, r2, #1
    8cea:	f88d 2004 	strb.w	r2, [sp, #4]
}
    8cee:	b00d      	add	sp, #52	; 0x34
    8cf0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    p.lz = 1;
    8cf4:	2001      	movs	r0, #1
    8cf6:	e7e8      	b.n	8cca <tfp_format+0x156>
            switch (ch) {
    8cf8:	2900      	cmp	r1, #0
    8cfa:	d0f8      	beq.n	8cee <tfp_format+0x17a>
    8cfc:	2925      	cmp	r1, #37	; 0x25
    8cfe:	f47f af52 	bne.w	8ba6 <tfp_format+0x32>
                putf(putp, ch);
    8d02:	4630      	mov	r0, r6
    8d04:	47b8      	blx	r7
    8d06:	e74e      	b.n	8ba6 <tfp_format+0x32>
                switch (ch) {
    8d08:	2201      	movs	r2, #1
    8d0a:	e7de      	b.n	8cca <tfp_format+0x156>
                    lng = 1;
    8d0c:	2001      	movs	r0, #1
                ch = *(fmt++);
    8d0e:	f814 1b01 	ldrb.w	r1, [r4], #1
                    lng = 1;
    8d12:	e78c      	b.n	8c2e <tfp_format+0xba>
    unsigned int num = 0;
    8d14:	2200      	movs	r2, #0
    8d16:	e00e      	b.n	8d36 <tfp_format+0x1c2>
    else if (ch >= 'A' && ch <= 'F')
    8d18:	f1bc 0f05 	cmp.w	ip, #5
    8d1c:	d818      	bhi.n	8d50 <tfp_format+0x1dc>
        return ch - 'A' + 10;
    8d1e:	f1a1 0337 	sub.w	r3, r1, #55	; 0x37
        if (digit > base)
    8d22:	2b0a      	cmp	r3, #10
    8d24:	d114      	bne.n	8d50 <tfp_format+0x1dc>
        ch = *p++;
    8d26:	f814 1b01 	ldrb.w	r1, [r4], #1
        num = num * base + digit;
    8d2a:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    8d2e:	eb03 0242 	add.w	r2, r3, r2, lsl #1
        ch = *p++;
    8d32:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
    if (ch >= '0' && ch <= '9')
    8d36:	b2d8      	uxtb	r0, r3
    8d38:	2809      	cmp	r0, #9
    else if (ch >= 'a' && ch <= 'f')
    8d3a:	f1a1 0561 	sub.w	r5, r1, #97	; 0x61
    else if (ch >= 'A' && ch <= 'F')
    8d3e:	f1a1 0c41 	sub.w	ip, r1, #65	; 0x41
    if (ch >= '0' && ch <= '9')
    8d42:	d9f0      	bls.n	8d26 <tfp_format+0x1b2>
    else if (ch >= 'a' && ch <= 'f')
    8d44:	2d05      	cmp	r5, #5
    8d46:	d8e7      	bhi.n	8d18 <tfp_format+0x1a4>
        return ch - 'a' + 10;
    8d48:	f1a1 0357 	sub.w	r3, r1, #87	; 0x57
        if (digit > base)
    8d4c:	2b0a      	cmp	r3, #10
    8d4e:	d0ea      	beq.n	8d26 <tfp_format+0x1b2>
            if (ch == '.') {
    8d50:	292e      	cmp	r1, #46	; 0x2e
    *nump = num;
    8d52:	9202      	str	r2, [sp, #8]
            if (ch == '.') {
    8d54:	f47f af65 	bne.w	8c22 <tfp_format+0xae>
              p.lz = 1;  /* zero-padding */
    8d58:	f89d 3004 	ldrb.w	r3, [sp, #4]
    8d5c:	f043 0301 	orr.w	r3, r3, #1
    8d60:	f88d 3004 	strb.w	r3, [sp, #4]
                ch = *(fmt++);
    8d64:	f814 1b01 	ldrb.w	r1, [r4], #1
              } while ((ch >= '0') && (ch <= '9'));
    8d68:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
    8d6c:	2b09      	cmp	r3, #9
    8d6e:	d9f9      	bls.n	8d64 <tfp_format+0x1f0>
    8d70:	e757      	b.n	8c22 <tfp_format+0xae>
                p.base = 10;
    8d72:	230a      	movs	r3, #10
                if (2 == lng)
    8d74:	2802      	cmp	r0, #2
                p.base = 10;
    8d76:	9304      	str	r3, [sp, #16]
                if (2 == lng)
    8d78:	f000 811a 	beq.w	8fb0 <tfp_format+0x43c>
                  if (1 == lng)
    8d7c:	2801      	cmp	r0, #1
                    uli2a(va_arg(va, unsigned long int), &p);
    8d7e:	f858 5b04 	ldr.w	r5, [r8], #4
                  if (1 == lng)
    8d82:	f000 819f 	beq.w	90c4 <tfp_format+0x550>
    while (num / d >= p->base)
    8d86:	2d09      	cmp	r5, #9
    unsigned int d = 1;
    8d88:	f04f 0201 	mov.w	r2, #1
    char *bf = p->bf;
    8d8c:	9805      	ldr	r0, [sp, #20]
    while (num / d >= p->base)
    8d8e:	d909      	bls.n	8da4 <tfp_format+0x230>
        d *= p->base;
    8d90:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    8d94:	0052      	lsls	r2, r2, #1
    while (num / d >= p->base)
    8d96:	fbb5 f3f2 	udiv	r3, r5, r2
    8d9a:	2b09      	cmp	r3, #9
    8d9c:	d8f8      	bhi.n	8d90 <tfp_format+0x21c>
    while (d != 0) {
    8d9e:	2a00      	cmp	r2, #0
    8da0:	f000 8117 	beq.w	8fd2 <tfp_format+0x45e>
    unsigned int d = 1;
    8da4:	230a      	movs	r3, #10
    int n = 0;
    8da6:	f04f 0e00 	mov.w	lr, #0
    8daa:	e012      	b.n	8dd2 <tfp_format+0x25e>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8dac:	f89d c004 	ldrb.w	ip, [sp, #4]
    8db0:	f01c 0f04 	tst.w	ip, #4
    8db4:	bf0c      	ite	eq
    8db6:	f04f 0c57 	moveq.w	ip, #87	; 0x57
    8dba:	f04f 0c37 	movne.w	ip, #55	; 0x37
    8dbe:	4461      	add	r1, ip
    while (d != 0) {
    8dc0:	429a      	cmp	r2, r3
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8dc2:	f800 1b01 	strb.w	r1, [r0], #1
            ++n;
    8dc6:	f10e 0e01 	add.w	lr, lr, #1
    while (d != 0) {
    8dca:	f0c0 8102 	bcc.w	8fd2 <tfp_format+0x45e>
    int n = 0;
    8dce:	4652      	mov	r2, sl
    8dd0:	9b04      	ldr	r3, [sp, #16]
        int dgt = num / d;
    8dd2:	fbb5 f1f2 	udiv	r1, r5, r2
        d /= p->base;
    8dd6:	fbb2 faf3 	udiv	sl, r2, r3
        num %= d;
    8dda:	fb02 5511 	mls	r5, r2, r1, r5
        if (n || dgt > 0 || d == 0) {
    8dde:	f1be 0f00 	cmp.w	lr, #0
    8de2:	d102      	bne.n	8dea <tfp_format+0x276>
    8de4:	2900      	cmp	r1, #0
    8de6:	f340 815b 	ble.w	90a0 <tfp_format+0x52c>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8dea:	2909      	cmp	r1, #9
    8dec:	dcde      	bgt.n	8dac <tfp_format+0x238>
    8dee:	f04f 0c30 	mov.w	ip, #48	; 0x30
    8df2:	e7e4      	b.n	8dbe <tfp_format+0x24a>
                p.bf = va_arg(va, char *);
    8df4:	f858 3b04 	ldr.w	r3, [r8], #4
                putchw(putp, putf, &p);
    8df8:	4639      	mov	r1, r7
    8dfa:	4630      	mov	r0, r6
    8dfc:	aa01      	add	r2, sp, #4
                p.bf = va_arg(va, char *);
    8dfe:	9305      	str	r3, [sp, #20]
                putchw(putp, putf, &p);
    8e00:	f7ff fa1c 	bl	823c <putchw>
                p.bf = bf;
    8e04:	ab06      	add	r3, sp, #24
    8e06:	9305      	str	r3, [sp, #20]
                break;
    8e08:	e6cd      	b.n	8ba6 <tfp_format+0x32>
                p.base = 16;
    8e0a:	2210      	movs	r2, #16
                p.alt = 1;
    8e0c:	f89d 3004 	ldrb.w	r3, [sp, #4]
                p.base = 16;
    8e10:	9204      	str	r2, [sp, #16]
                p.alt = 1;
    8e12:	f023 0306 	bic.w	r3, r3, #6
    8e16:	f043 0302 	orr.w	r3, r3, #2
    8e1a:	f88d 3004 	strb.w	r3, [sp, #4]
                    ui2a(va_arg(va, unsigned int), &p);
    8e1e:	f858 5b04 	ldr.w	r5, [r8], #4
    unsigned int d = 1;
    8e22:	2101      	movs	r1, #1
    while (num / d >= p->base)
    8e24:	2d0f      	cmp	r5, #15
    char *bf = p->bf;
    8e26:	9805      	ldr	r0, [sp, #20]
    while (num / d >= p->base)
    8e28:	f240 81cf 	bls.w	91ca <tfp_format+0x656>
        d *= p->base;
    8e2c:	0109      	lsls	r1, r1, #4
    while (num / d >= p->base)
    8e2e:	fbb5 f2f1 	udiv	r2, r5, r1
    8e32:	2a0f      	cmp	r2, #15
    8e34:	d8fa      	bhi.n	8e2c <tfp_format+0x2b8>
    while (d != 0) {
    8e36:	2900      	cmp	r1, #0
    8e38:	f000 80cb 	beq.w	8fd2 <tfp_format+0x45e>
    unsigned int d = 1;
    8e3c:	2310      	movs	r3, #16
    int n = 0;
    8e3e:	f04f 0e00 	mov.w	lr, #0
    8e42:	e014      	b.n	8e6e <tfp_format+0x2fa>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8e44:	f89d c004 	ldrb.w	ip, [sp, #4]
    8e48:	f01c 0f04 	tst.w	ip, #4
    8e4c:	bf0c      	ite	eq
    8e4e:	f04f 0c57 	moveq.w	ip, #87	; 0x57
    8e52:	f04f 0c37 	movne.w	ip, #55	; 0x37
    8e56:	4462      	add	r2, ip
    while (d != 0) {
    8e58:	4299      	cmp	r1, r3
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8e5a:	f800 2b01 	strb.w	r2, [r0], #1
            ++n;
    8e5e:	f10e 0e01 	add.w	lr, lr, #1
    while (d != 0) {
    8e62:	f0c0 80b6 	bcc.w	8fd2 <tfp_format+0x45e>
    int n = 0;
    8e66:	4651      	mov	r1, sl
    8e68:	fbb5 f2fa 	udiv	r2, r5, sl
    8e6c:	9b04      	ldr	r3, [sp, #16]
        d /= p->base;
    8e6e:	fbb1 faf3 	udiv	sl, r1, r3
        num %= d;
    8e72:	fb01 5512 	mls	r5, r1, r2, r5
        if (n || dgt > 0 || d == 0) {
    8e76:	f1be 0f00 	cmp.w	lr, #0
    8e7a:	d102      	bne.n	8e82 <tfp_format+0x30e>
    8e7c:	2a00      	cmp	r2, #0
    8e7e:	f340 80a2 	ble.w	8fc6 <tfp_format+0x452>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8e82:	2a09      	cmp	r2, #9
    8e84:	dcde      	bgt.n	8e44 <tfp_format+0x2d0>
    8e86:	f04f 0c30 	mov.w	ip, #48	; 0x30
    8e8a:	e7e4      	b.n	8e56 <tfp_format+0x2e2>
                p.base = 8;
    8e8c:	2308      	movs	r3, #8
                ui2a(va_arg(va, unsigned int), &p);
    8e8e:	f858 5b04 	ldr.w	r5, [r8], #4
    unsigned int d = 1;
    8e92:	2101      	movs	r1, #1
    while (num / d >= p->base)
    8e94:	2d07      	cmp	r5, #7
    char *bf = p->bf;
    8e96:	9805      	ldr	r0, [sp, #20]
                p.base = 8;
    8e98:	9304      	str	r3, [sp, #16]
    while (num / d >= p->base)
    8e9a:	f240 8155 	bls.w	9148 <tfp_format+0x5d4>
        d *= p->base;
    8e9e:	00c9      	lsls	r1, r1, #3
    while (num / d >= p->base)
    8ea0:	fbb5 f2f1 	udiv	r2, r5, r1
    8ea4:	2a07      	cmp	r2, #7
    8ea6:	d8fa      	bhi.n	8e9e <tfp_format+0x32a>
    while (d != 0) {
    8ea8:	2900      	cmp	r1, #0
    8eaa:	f000 80f1 	beq.w	9090 <tfp_format+0x51c>
    unsigned int d = 1;
    8eae:	f04f 0c08 	mov.w	ip, #8
    int n = 0;
    8eb2:	f04f 0e00 	mov.w	lr, #0
    8eb6:	e013      	b.n	8ee0 <tfp_format+0x36c>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8eb8:	f89d 3004 	ldrb.w	r3, [sp, #4]
    8ebc:	f013 0f04 	tst.w	r3, #4
    8ec0:	bf0c      	ite	eq
    8ec2:	2357      	moveq	r3, #87	; 0x57
    8ec4:	2337      	movne	r3, #55	; 0x37
    8ec6:	441a      	add	r2, r3
    while (d != 0) {
    8ec8:	458c      	cmp	ip, r1
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8eca:	f800 2b01 	strb.w	r2, [r0], #1
            ++n;
    8ece:	f10e 0e01 	add.w	lr, lr, #1
    while (d != 0) {
    8ed2:	f200 80dd 	bhi.w	9090 <tfp_format+0x51c>
    int n = 0;
    8ed6:	4651      	mov	r1, sl
    8ed8:	fbb5 f2fa 	udiv	r2, r5, sl
    8edc:	f8dd c010 	ldr.w	ip, [sp, #16]
        d /= p->base;
    8ee0:	fbb1 fafc 	udiv	sl, r1, ip
        num %= d;
    8ee4:	fb01 5512 	mls	r5, r1, r2, r5
        if (n || dgt > 0 || d == 0) {
    8ee8:	f1be 0f00 	cmp.w	lr, #0
    8eec:	d102      	bne.n	8ef4 <tfp_format+0x380>
    8eee:	2a00      	cmp	r2, #0
    8ef0:	f340 80c8 	ble.w	9084 <tfp_format+0x510>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8ef4:	2a09      	cmp	r2, #9
    8ef6:	dcdf      	bgt.n	8eb8 <tfp_format+0x344>
    8ef8:	2330      	movs	r3, #48	; 0x30
    8efa:	e7e4      	b.n	8ec6 <tfp_format+0x352>
                p.base = 10;
    8efc:	230a      	movs	r3, #10
                if (2 == lng)
    8efe:	2802      	cmp	r0, #2
                p.base = 10;
    8f00:	9304      	str	r3, [sp, #16]
                if (2 == lng)
    8f02:	f000 80b0 	beq.w	9066 <tfp_format+0x4f2>
                  if (1 == lng)
    8f06:	2801      	cmp	r0, #1
                    li2a(va_arg(va, long int), &p);
    8f08:	f858 1b04 	ldr.w	r1, [r8], #4
                  if (1 == lng)
    8f0c:	f000 811e 	beq.w	914c <tfp_format+0x5d8>
    if (num < 0) {
    8f10:	2900      	cmp	r1, #0
    8f12:	da03      	bge.n	8f1c <tfp_format+0x3a8>
        p->sign = '-';
    8f14:	232d      	movs	r3, #45	; 0x2d
        num = -num;
    8f16:	4249      	negs	r1, r1
        p->sign = '-';
    8f18:	f88d 300c 	strb.w	r3, [sp, #12]
    while (num / d >= p->base)
    8f1c:	2909      	cmp	r1, #9
    ui2a(num, p);
    8f1e:	468e      	mov	lr, r1
    unsigned int d = 1;
    8f20:	f04f 0201 	mov.w	r2, #1
    char *bf = p->bf;
    8f24:	9805      	ldr	r0, [sp, #20]
    while (num / d >= p->base)
    8f26:	dd08      	ble.n	8f3a <tfp_format+0x3c6>
        d *= p->base;
    8f28:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    8f2c:	0052      	lsls	r2, r2, #1
    while (num / d >= p->base)
    8f2e:	fbb1 f3f2 	udiv	r3, r1, r2
    8f32:	2b09      	cmp	r3, #9
    8f34:	d8f8      	bhi.n	8f28 <tfp_format+0x3b4>
    while (d != 0) {
    8f36:	2a00      	cmp	r2, #0
    8f38:	d04b      	beq.n	8fd2 <tfp_format+0x45e>
    unsigned int d = 1;
    8f3a:	230a      	movs	r3, #10
    int n = 0;
    8f3c:	2500      	movs	r5, #0
    8f3e:	e014      	b.n	8f6a <tfp_format+0x3f6>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8f40:	2909      	cmp	r1, #9
    8f42:	f240 80b4 	bls.w	90ae <tfp_format+0x53a>
    8f46:	f89d c004 	ldrb.w	ip, [sp, #4]
    8f4a:	f01c 0f04 	tst.w	ip, #4
    8f4e:	bf0c      	ite	eq
    8f50:	f04f 0c57 	moveq.w	ip, #87	; 0x57
    8f54:	f04f 0c37 	movne.w	ip, #55	; 0x37
    8f58:	4461      	add	r1, ip
    while (d != 0) {
    8f5a:	429a      	cmp	r2, r3
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8f5c:	f800 1b01 	strb.w	r1, [r0], #1
            ++n;
    8f60:	f105 0501 	add.w	r5, r5, #1
    while (d != 0) {
    8f64:	d335      	bcc.n	8fd2 <tfp_format+0x45e>
    int n = 0;
    8f66:	4652      	mov	r2, sl
    8f68:	9b04      	ldr	r3, [sp, #16]
        int dgt = num / d;
    8f6a:	fbbe f1f2 	udiv	r1, lr, r2
        if (n || dgt > 0 || d == 0) {
    8f6e:	ea55 0c01 	orrs.w	ip, r5, r1
        d /= p->base;
    8f72:	fbb2 faf3 	udiv	sl, r2, r3
        num %= d;
    8f76:	fb02 ee11 	mls	lr, r2, r1, lr
        if (n || dgt > 0 || d == 0) {
    8f7a:	d1e1      	bne.n	8f40 <tfp_format+0x3cc>
    8f7c:	429a      	cmp	r2, r3
    8f7e:	f0c0 8092 	bcc.w	90a6 <tfp_format+0x532>
    8f82:	4665      	mov	r5, ip
    8f84:	e7ef      	b.n	8f66 <tfp_format+0x3f2>
                putf(putp, (char)(va_arg(va, int)));
    8f86:	f858 1b04 	ldr.w	r1, [r8], #4
    8f8a:	4630      	mov	r0, r6
    8f8c:	b2c9      	uxtb	r1, r1
    8f8e:	47b8      	blx	r7
                break;
    8f90:	e609      	b.n	8ba6 <tfp_format+0x32>
                p.uc = (ch == 'X')?1:0;
    8f92:	f1a1 0158 	sub.w	r1, r1, #88	; 0x58
    8f96:	fab1 f181 	clz	r1, r1
                p.base = 16;
    8f9a:	2210      	movs	r2, #16
                p.uc = (ch == 'X')?1:0;
    8f9c:	f89d 3004 	ldrb.w	r3, [sp, #4]
    8fa0:	0949      	lsrs	r1, r1, #5
    8fa2:	f361 0382 	bfi	r3, r1, #2, #1
                if (2 == lng)
    8fa6:	2802      	cmp	r0, #2
                p.base = 16;
    8fa8:	9204      	str	r2, [sp, #16]
                p.uc = (ch == 'X')?1:0;
    8faa:	f88d 3004 	strb.w	r3, [sp, #4]
                if (2 == lng)
    8fae:	d11f      	bne.n	8ff0 <tfp_format+0x47c>
                    ulli2a(va_arg(va, unsigned long long int), &p);
    8fb0:	f108 0807 	add.w	r8, r8, #7
    8fb4:	f028 0807 	bic.w	r8, r8, #7
    8fb8:	ad01      	add	r5, sp, #4
    8fba:	462a      	mov	r2, r5
    8fbc:	e8f8 0102 	ldrd	r0, r1, [r8], #8
    8fc0:	f7ff f8ce 	bl	8160 <ulli2a>
    8fc4:	e008      	b.n	8fd8 <tfp_format+0x464>
        if (n || dgt > 0 || d == 0) {
    8fc6:	4299      	cmp	r1, r3
    8fc8:	f4bf af4d 	bcs.w	8e66 <tfp_format+0x2f2>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    8fcc:	3230      	adds	r2, #48	; 0x30
    8fce:	f800 2b01 	strb.w	r2, [r0], #1
    *bf = 0;
    8fd2:	f880 9000 	strb.w	r9, [r0]
    8fd6:	ad01      	add	r5, sp, #4
                putchw(putp, putf, &p);
    8fd8:	462a      	mov	r2, r5
    8fda:	4639      	mov	r1, r7
    8fdc:	4630      	mov	r0, r6
    8fde:	f7ff f92d 	bl	823c <putchw>
                break;
    8fe2:	e5e0      	b.n	8ba6 <tfp_format+0x32>
                ch = *(fmt++);
    8fe4:	7821      	ldrb	r1, [r4, #0]
                if (ch == 'l') {
    8fe6:	296c      	cmp	r1, #108	; 0x6c
    8fe8:	d068      	beq.n	90bc <tfp_format+0x548>
                lng = 1;
    8fea:	2001      	movs	r0, #1
                ch = *(fmt++);
    8fec:	3401      	adds	r4, #1
    8fee:	e61e      	b.n	8c2e <tfp_format+0xba>
                  if (1 == lng)
    8ff0:	2801      	cmp	r0, #1
    8ff2:	f47f af14 	bne.w	8e1e <tfp_format+0x2aa>
                    uli2a(va_arg(va, unsigned long int), &p);
    8ff6:	f858 5b04 	ldr.w	r5, [r8], #4
    unsigned long int d = 1;
    8ffa:	4602      	mov	r2, r0
    while (num / d >= p->base)
    8ffc:	2d0f      	cmp	r5, #15
    char *bf = p->bf;
    8ffe:	f8dd b014 	ldr.w	fp, [sp, #20]
    while (num / d >= p->base)
    9002:	f240 80e6 	bls.w	91d2 <tfp_format+0x65e>
        d *= p->base;
    9006:	0112      	lsls	r2, r2, #4
    while (num / d >= p->base)
    9008:	fbb5 f1f2 	udiv	r1, r5, r2
    900c:	290f      	cmp	r1, #15
    900e:	d8fa      	bhi.n	9006 <tfp_format+0x492>
    while (d != 0) {
    9010:	2a00      	cmp	r2, #0
    9012:	f000 80dc 	beq.w	91ce <tfp_format+0x65a>
    unsigned long int d = 1;
    9016:	2310      	movs	r3, #16
    int n = 0;
    9018:	f04f 0e00 	mov.w	lr, #0
    901c:	e015      	b.n	904a <tfp_format+0x4d6>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    901e:	f89d 0004 	ldrb.w	r0, [sp, #4]
    9022:	f010 0f04 	tst.w	r0, #4
    9026:	bf0c      	ite	eq
    9028:	f04f 0c57 	moveq.w	ip, #87	; 0x57
    902c:	f04f 0c37 	movne.w	ip, #55	; 0x37
    9030:	4658      	mov	r0, fp
    9032:	4461      	add	r1, ip
    while (d != 0) {
    9034:	429a      	cmp	r2, r3
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    9036:	f800 1b01 	strb.w	r1, [r0], #1
            ++n;
    903a:	f10e 0e01 	add.w	lr, lr, #1
    while (d != 0) {
    903e:	d3c8      	bcc.n	8fd2 <tfp_format+0x45e>
    int n = 0;
    9040:	4652      	mov	r2, sl
    9042:	4683      	mov	fp, r0
    9044:	fbb5 f1fa 	udiv	r1, r5, sl
    9048:	9b04      	ldr	r3, [sp, #16]
        d /= p->base;
    904a:	fbb2 faf3 	udiv	sl, r2, r3
        num %= d;
    904e:	fb02 5511 	mls	r5, r2, r1, r5
        if (n || dgt > 0 || d == 0) {
    9052:	f1be 0f00 	cmp.w	lr, #0
    9056:	d101      	bne.n	905c <tfp_format+0x4e8>
    9058:	2900      	cmp	r1, #0
    905a:	dd2b      	ble.n	90b4 <tfp_format+0x540>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    905c:	2909      	cmp	r1, #9
    905e:	dcde      	bgt.n	901e <tfp_format+0x4aa>
    9060:	f04f 0c30 	mov.w	ip, #48	; 0x30
    9064:	e7e4      	b.n	9030 <tfp_format+0x4bc>
                    lli2a(va_arg(va, long long int), &p);
    9066:	f108 0807 	add.w	r8, r8, #7
    906a:	f028 0807 	bic.w	r8, r8, #7
    906e:	e8f8 0102 	ldrd	r0, r1, [r8], #8
    if (num < 0) {
    9072:	2800      	cmp	r0, #0
    9074:	f171 0300 	sbcs.w	r3, r1, #0
    9078:	db5f      	blt.n	913a <tfp_format+0x5c6>
    ulli2a(num, p);
    907a:	ad01      	add	r5, sp, #4
    907c:	462a      	mov	r2, r5
    907e:	f7ff f86f 	bl	8160 <ulli2a>
}
    9082:	e7a9      	b.n	8fd8 <tfp_format+0x464>
        if (n || dgt > 0 || d == 0) {
    9084:	458c      	cmp	ip, r1
    9086:	f67f af26 	bls.w	8ed6 <tfp_format+0x362>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    908a:	3230      	adds	r2, #48	; 0x30
    908c:	f800 2b01 	strb.w	r2, [r0], #1
    *bf = 0;
    9090:	f880 9000 	strb.w	r9, [r0]
                putchw(putp, putf, &p);
    9094:	4639      	mov	r1, r7
    9096:	4630      	mov	r0, r6
    9098:	aa01      	add	r2, sp, #4
    909a:	f7ff f8cf 	bl	823c <putchw>
                break;
    909e:	e582      	b.n	8ba6 <tfp_format+0x32>
        if (n || dgt > 0 || d == 0) {
    90a0:	429a      	cmp	r2, r3
    90a2:	f4bf ae94 	bcs.w	8dce <tfp_format+0x25a>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    90a6:	3130      	adds	r1, #48	; 0x30
    90a8:	f800 1b01 	strb.w	r1, [r0], #1
    while (d != 0) {
    90ac:	e791      	b.n	8fd2 <tfp_format+0x45e>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    90ae:	f04f 0c30 	mov.w	ip, #48	; 0x30
    90b2:	e751      	b.n	8f58 <tfp_format+0x3e4>
        if (n || dgt > 0 || d == 0) {
    90b4:	429a      	cmp	r2, r3
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    90b6:	4658      	mov	r0, fp
        if (n || dgt > 0 || d == 0) {
    90b8:	d3f5      	bcc.n	90a6 <tfp_format+0x532>
    90ba:	e7c1      	b.n	9040 <tfp_format+0x4cc>
                  lng = 2;
    90bc:	2002      	movs	r0, #2
                  ch = *(fmt++);
    90be:	7861      	ldrb	r1, [r4, #1]
    90c0:	4404      	add	r4, r0
    90c2:	e5b4      	b.n	8c2e <tfp_format+0xba>
    while (num / d >= p->base)
    90c4:	2d09      	cmp	r5, #9
    unsigned long int d = 1;
    90c6:	4602      	mov	r2, r0
    char *bf = p->bf;
    90c8:	9905      	ldr	r1, [sp, #20]
    while (num / d >= p->base)
    90ca:	d907      	bls.n	90dc <tfp_format+0x568>
        d *= p->base;
    90cc:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    90d0:	0052      	lsls	r2, r2, #1
    while (num / d >= p->base)
    90d2:	fbb5 f3f2 	udiv	r3, r5, r2
    90d6:	2b09      	cmp	r3, #9
    90d8:	d8f8      	bhi.n	90cc <tfp_format+0x558>
    while (d != 0) {
    90da:	b352      	cbz	r2, 9132 <tfp_format+0x5be>
    unsigned long int d = 1;
    90dc:	230a      	movs	r3, #10
    int n = 0;
    90de:	f04f 0e00 	mov.w	lr, #0
    90e2:	e011      	b.n	9108 <tfp_format+0x594>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    90e4:	f89d c004 	ldrb.w	ip, [sp, #4]
    90e8:	f01c 0f04 	tst.w	ip, #4
    90ec:	bf0c      	ite	eq
    90ee:	f04f 0c57 	moveq.w	ip, #87	; 0x57
    90f2:	f04f 0c37 	movne.w	ip, #55	; 0x37
    90f6:	4460      	add	r0, ip
    while (d != 0) {
    90f8:	429a      	cmp	r2, r3
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    90fa:	f801 0b01 	strb.w	r0, [r1], #1
            ++n;
    90fe:	f10e 0e01 	add.w	lr, lr, #1
    while (d != 0) {
    9102:	d316      	bcc.n	9132 <tfp_format+0x5be>
    int n = 0;
    9104:	4652      	mov	r2, sl
    9106:	9b04      	ldr	r3, [sp, #16]
        int dgt = num / d;
    9108:	fbb5 f0f2 	udiv	r0, r5, r2
        d /= p->base;
    910c:	fbb2 faf3 	udiv	sl, r2, r3
        num %= d;
    9110:	fb02 5510 	mls	r5, r2, r0, r5
        if (n || dgt > 0 || d == 0) {
    9114:	f1be 0f00 	cmp.w	lr, #0
    9118:	d101      	bne.n	911e <tfp_format+0x5aa>
    911a:	2800      	cmp	r0, #0
    911c:	dd04      	ble.n	9128 <tfp_format+0x5b4>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    911e:	2809      	cmp	r0, #9
    9120:	dce0      	bgt.n	90e4 <tfp_format+0x570>
    9122:	f04f 0c30 	mov.w	ip, #48	; 0x30
    9126:	e7e6      	b.n	90f6 <tfp_format+0x582>
        if (n || dgt > 0 || d == 0) {
    9128:	429a      	cmp	r2, r3
    912a:	d2eb      	bcs.n	9104 <tfp_format+0x590>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    912c:	3030      	adds	r0, #48	; 0x30
    912e:	f801 0b01 	strb.w	r0, [r1], #1
    *bf = 0;
    9132:	f881 9000 	strb.w	r9, [r1]
    9136:	ad01      	add	r5, sp, #4
}
    9138:	e74e      	b.n	8fd8 <tfp_format+0x464>
        p->sign = '-';
    913a:	232d      	movs	r3, #45	; 0x2d
        num = -num;
    913c:	4240      	negs	r0, r0
    913e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
        p->sign = '-';
    9142:	f88d 300c 	strb.w	r3, [sp, #12]
    9146:	e798      	b.n	907a <tfp_format+0x506>
    9148:	462a      	mov	r2, r5
    914a:	e6b0      	b.n	8eae <tfp_format+0x33a>
    if (num < 0) {
    914c:	2900      	cmp	r1, #0
    914e:	da03      	bge.n	9158 <tfp_format+0x5e4>
        p->sign = '-';
    9150:	232d      	movs	r3, #45	; 0x2d
        num = -num;
    9152:	4249      	negs	r1, r1
        p->sign = '-';
    9154:	f88d 300c 	strb.w	r3, [sp, #12]
    while (num / d >= p->base)
    9158:	2909      	cmp	r1, #9
    uli2a(num, p);
    915a:	468c      	mov	ip, r1
    unsigned long int d = 1;
    915c:	f04f 0201 	mov.w	r2, #1
    char *bf = p->bf;
    9160:	9805      	ldr	r0, [sp, #20]
    while (num / d >= p->base)
    9162:	dd09      	ble.n	9178 <tfp_format+0x604>
        d *= p->base;
    9164:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    9168:	0052      	lsls	r2, r2, #1
    while (num / d >= p->base)
    916a:	fbb1 f3f2 	udiv	r3, r1, r2
    916e:	2b09      	cmp	r3, #9
    9170:	d8f8      	bhi.n	9164 <tfp_format+0x5f0>
    while (d != 0) {
    9172:	2a00      	cmp	r2, #0
    9174:	f43f af2d 	beq.w	8fd2 <tfp_format+0x45e>
    unsigned long int d = 1;
    9178:	230a      	movs	r3, #10
    int n = 0;
    917a:	2500      	movs	r5, #0
    917c:	e014      	b.n	91a8 <tfp_format+0x634>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    917e:	2909      	cmp	r1, #9
    9180:	d920      	bls.n	91c4 <tfp_format+0x650>
    9182:	f89d e004 	ldrb.w	lr, [sp, #4]
    9186:	f01e 0f04 	tst.w	lr, #4
    918a:	bf0c      	ite	eq
    918c:	f04f 0e57 	moveq.w	lr, #87	; 0x57
    9190:	f04f 0e37 	movne.w	lr, #55	; 0x37
    9194:	4471      	add	r1, lr
    while (d != 0) {
    9196:	429a      	cmp	r2, r3
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    9198:	f800 1b01 	strb.w	r1, [r0], #1
            ++n;
    919c:	f105 0501 	add.w	r5, r5, #1
    while (d != 0) {
    91a0:	f4ff af17 	bcc.w	8fd2 <tfp_format+0x45e>
    int n = 0;
    91a4:	4652      	mov	r2, sl
    91a6:	9b04      	ldr	r3, [sp, #16]
        int dgt = num / d;
    91a8:	fbbc f1f2 	udiv	r1, ip, r2
        if (n || dgt > 0 || d == 0) {
    91ac:	ea55 0e01 	orrs.w	lr, r5, r1
        d /= p->base;
    91b0:	fbb2 faf3 	udiv	sl, r2, r3
        num %= d;
    91b4:	fb02 cc11 	mls	ip, r2, r1, ip
        if (n || dgt > 0 || d == 0) {
    91b8:	d1e1      	bne.n	917e <tfp_format+0x60a>
    91ba:	429a      	cmp	r2, r3
    91bc:	f4ff af73 	bcc.w	90a6 <tfp_format+0x532>
    91c0:	4675      	mov	r5, lr
    91c2:	e7ef      	b.n	91a4 <tfp_format+0x630>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    91c4:	f04f 0e30 	mov.w	lr, #48	; 0x30
    91c8:	e7e4      	b.n	9194 <tfp_format+0x620>
    91ca:	462a      	mov	r2, r5
    91cc:	e636      	b.n	8e3c <tfp_format+0x2c8>
    char *bf = p->bf;
    91ce:	4658      	mov	r0, fp
    *bf = 0;
    91d0:	e6ff      	b.n	8fd2 <tfp_format+0x45e>
    91d2:	4629      	mov	r1, r5
    91d4:	e71f      	b.n	9016 <tfp_format+0x4a2>
    91d6:	bf00      	nop

000091d8 <tfp_vsnprintf>:

int tfp_vsnprintf(char *str, size_t size, const char *format, va_list ap)
{
    91d8:	b5f0      	push	{r4, r5, r6, r7, lr}
    91da:	b085      	sub	sp, #20
    91dc:	4605      	mov	r5, r0
    91de:	4616      	mov	r6, r2
  struct _vsnprintf_putcf_data data;

  if (size < 1)
    91e0:	4608      	mov	r0, r1
    91e2:	b189      	cbz	r1, 9208 <tfp_vsnprintf+0x30>
    return 0;

  data.dest = str;
  data.dest_capacity = size-1;
  data.num_chars = 0;
    91e4:	2700      	movs	r7, #0
  tfp_format(&data, _vsnprintf_putcf, format, ap);
    91e6:	461a      	mov	r2, r3
  data.dest_capacity = size-1;
    91e8:	1e4c      	subs	r4, r1, #1
  tfp_format(&data, _vsnprintf_putcf, format, ap);
    91ea:	a801      	add	r0, sp, #4
    91ec:	4631      	mov	r1, r6
  data.dest = str;
    91ee:	e9cd 4501 	strd	r4, r5, [sp, #4]
  data.num_chars = 0;
    91f2:	9703      	str	r7, [sp, #12]
  tfp_format(&data, _vsnprintf_putcf, format, ap);
    91f4:	f7ff f976 	bl	84e4 <tfp_format.constprop.0>

  if (data.num_chars < data.dest_capacity)
    91f8:	9a03      	ldr	r2, [sp, #12]
    91fa:	9b01      	ldr	r3, [sp, #4]
    91fc:	429a      	cmp	r2, r3
    data.dest[data.num_chars] = '\0';
    91fe:	bf34      	ite	cc
    9200:	9b02      	ldrcc	r3, [sp, #8]
  else
    data.dest[data.dest_capacity] = '\0';
    9202:	9a02      	ldrcs	r2, [sp, #8]
    9204:	54d7      	strb	r7, [r2, r3]

  return data.num_chars;
    9206:	9803      	ldr	r0, [sp, #12]
}
    9208:	b005      	add	sp, #20
    920a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000920c <a_putc>:
#include <ubtbr/console.h>
#include <ubtbr/system.h>

static void a_putc(void *arg, char c)
{
	console_putc(c);
    920c:	4608      	mov	r0, r1
    920e:	f7fe be6b 	b.w	7ee8 <console_putc>
    9212:	bf00      	nop

00009214 <cprintf>:
}

void cprintf(char *fmt, ...)
{
    9214:	b40f      	push	{r0, r1, r2, r3}
    9216:	b500      	push	{lr}
    9218:	b083      	sub	sp, #12
    921a:	ab04      	add	r3, sp, #16
    921c:	f853 2b04 	ldr.w	r2, [r3], #4
	va_list ap;
	void *ret;

	va_start(ap, fmt);
	tfp_format(NULL, a_putc, fmt, ap);
    9220:	2000      	movs	r0, #0
    9222:	4904      	ldr	r1, [pc, #16]	; (9234 <cprintf+0x20>)
	va_start(ap, fmt);
    9224:	9301      	str	r3, [sp, #4]
	tfp_format(NULL, a_putc, fmt, ap);
    9226:	f7ff fca5 	bl	8b74 <tfp_format>
	va_end(ap);
}
    922a:	b003      	add	sp, #12
    922c:	f85d eb04 	ldr.w	lr, [sp], #4
    9230:	b004      	add	sp, #16
    9232:	4770      	bx	lr
    9234:	0000920d 	.word	0x0000920d

00009238 <early_printf>:

void early_printf(char *fmt, ...)
{
    9238:	b40f      	push	{r0, r1, r2, r3}
    923a:	b5f0      	push	{r4, r5, r6, r7, lr}
    923c:	b093      	sub	sp, #76	; 0x4c
    923e:	ac18      	add	r4, sp, #96	; 0x60
    9240:	f854 7b04 	ldr.w	r7, [r4], #4
    9244:	f3ef 8510 	mrs	r5, PRIMASK
    9248:	b672      	cpsid	i
	uint32_t flags = irq_save_disable();
	char buf[64] = {0};
    924a:	2100      	movs	r1, #0
	int len;
	va_list ap;
	void *ret;
	
	buf[0] = BTUSB_EARLY_PRINT;
    924c:	2650      	movs	r6, #80	; 0x50
	char buf[64] = {0};
    924e:	223c      	movs	r2, #60	; 0x3c
    9250:	a803      	add	r0, sp, #12
    9252:	9102      	str	r1, [sp, #8]
    9254:	f7fa ffa2 	bl	419c <memset>
	va_start(ap, fmt);
	len = tfp_vsnprintf(buf+1, sizeof(buf)-1, fmt, ap);
    9258:	463a      	mov	r2, r7
    925a:	4623      	mov	r3, r4
    925c:	213f      	movs	r1, #63	; 0x3f
    925e:	f10d 0009 	add.w	r0, sp, #9
	va_start(ap, fmt);
    9262:	9401      	str	r4, [sp, #4]
	buf[0] = BTUSB_EARLY_PRINT;
    9264:	f88d 6008 	strb.w	r6, [sp, #8]
	len = tfp_vsnprintf(buf+1, sizeof(buf)-1, fmt, ap);
    9268:	f7ff ffb6 	bl	91d8 <tfp_vsnprintf>
	va_end(ap);
	usb_send_sync((void*)buf, 1+len);
    926c:	1c41      	adds	r1, r0, #1
    926e:	a802      	add	r0, sp, #8
    9270:	f000 f902 	bl	9478 <usb_send_sync>
	__asm__ __volatile__ (
    9274:	f385 8810 	msr	PRIMASK, r5

	irq_restore(flags);
}
    9278:	b013      	add	sp, #76	; 0x4c
    927a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    927e:	b004      	add	sp, #16
    9280:	4770      	bx	lr
    9282:	bf00      	nop

00009284 <flash_leds>:
	int i;
	for (i=msec/2;i;i--);
}

// flash LEDs a certain number of times
void flash_leds(int count, int delay) {
    9284:	b470      	push	{r4, r5, r6}
	int i;

	for (i = 0; i < count; ++i) {
    9286:	2800      	cmp	r0, #0
    9288:	dd0f      	ble.n	92aa <flash_leds+0x26>
    928a:	2100      	movs	r1, #0
		USRLED_SET;
    928c:	2602      	movs	r6, #2
		RXLED_SET;
    928e:	2510      	movs	r5, #16
		TXLED_SET;
    9290:	f44f 7480 	mov.w	r4, #256	; 0x100
		USRLED_SET;
    9294:	4a06      	ldr	r2, [pc, #24]	; (92b0 <flash_leds+0x2c>)
		active_msleep(delay);
		USRLED_CLR;
    9296:	4b07      	ldr	r3, [pc, #28]	; (92b4 <flash_leds+0x30>)
	for (i = 0; i < count; ++i) {
    9298:	3101      	adds	r1, #1
    929a:	4288      	cmp	r0, r1
		USRLED_SET;
    929c:	6016      	str	r6, [r2, #0]
		RXLED_SET;
    929e:	6015      	str	r5, [r2, #0]
		TXLED_SET;
    92a0:	6014      	str	r4, [r2, #0]
		USRLED_CLR;
    92a2:	601e      	str	r6, [r3, #0]
		RXLED_CLR;
    92a4:	601d      	str	r5, [r3, #0]
		TXLED_CLR;
    92a6:	601c      	str	r4, [r3, #0]
	for (i = 0; i < count; ++i) {
    92a8:	d1f6      	bne.n	9298 <flash_leds+0x14>
		active_msleep(delay);
	}
}
    92aa:	bc70      	pop	{r4, r5, r6}
    92ac:	4770      	bx	lr
    92ae:	bf00      	nop
    92b0:	2009c038 	.word	0x2009c038
    92b4:	2009c03c 	.word	0x2009c03c

000092b8 <usb_vendor_request_handler>:
}

VendorRequestHandler *v_req_handler;

BOOL usb_vendor_request_handler(TSetupPacket *pSetup, int *piLen, u8 **ppbData)
{
    92b8:	b570      	push	{r4, r5, r6, lr}
    92ba:	b082      	sub	sp, #8
	int rv;
	u16 params[3] = {pSetup->wValue, pSetup->wIndex, pSetup->wLength};
	rv = v_req_handler(pSetup->bRequest, params, *ppbData, piLen);
    92bc:	4c09      	ldr	r4, [pc, #36]	; (92e4 <usb_vendor_request_handler+0x2c>)
	u16 params[3] = {pSetup->wValue, pSetup->wIndex, pSetup->wLength};
    92be:	f8d0 6002 	ldr.w	r6, [r0, #2]
    92c2:	88c5      	ldrh	r5, [r0, #6]
{
    92c4:	460b      	mov	r3, r1
	rv = v_req_handler(pSetup->bRequest, params, *ppbData, piLen);
    92c6:	6812      	ldr	r2, [r2, #0]
    92c8:	4669      	mov	r1, sp
    92ca:	6824      	ldr	r4, [r4, #0]
	u16 params[3] = {pSetup->wValue, pSetup->wIndex, pSetup->wLength};
    92cc:	9600      	str	r6, [sp, #0]
    92ce:	f8ad 5004 	strh.w	r5, [sp, #4]
	rv = v_req_handler(pSetup->bRequest, params, *ppbData, piLen);
    92d2:	7840      	ldrb	r0, [r0, #1]
    92d4:	47a0      	blx	r4
	return (BOOL) (rv==1);
}
    92d6:	f1a0 0001 	sub.w	r0, r0, #1
    92da:	fab0 f080 	clz	r0, r0
    92de:	0940      	lsrs	r0, r0, #5
    92e0:	b002      	add	sp, #8
    92e2:	bd70      	pop	{r4, r5, r6, pc}
    92e4:	100025e8 	.word	0x100025e8

000092e8 <usb_bulk_out_handler>:
{
    92e8:	b570      	push	{r4, r5, r6, lr}
    92ea:	b090      	sub	sp, #64	; 0x40
	bulk_size = USBHwEPRead(BULK_OUT_EP, (u8*)data, MAX_PACKET_SIZE);
    92ec:	2240      	movs	r2, #64	; 0x40
    92ee:	4669      	mov	r1, sp
    92f0:	2005      	movs	r0, #5
    92f2:	f000 fe43 	bl	9f7c <USBHwEPRead>
	if (rx_msg == NULL)
    92f6:	4d2c      	ldr	r5, [pc, #176]	; (93a8 <usb_bulk_out_handler+0xc0>)
	bulk_size = USBHwEPRead(BULK_OUT_EP, (u8*)data, MAX_PACKET_SIZE);
    92f8:	4604      	mov	r4, r0
	if (rx_msg == NULL)
    92fa:	682b      	ldr	r3, [r5, #0]
	type = data[0];
    92fc:	f89d 1000 	ldrb.w	r1, [sp]
	if (rx_msg == NULL)
    9300:	b303      	cbz	r3, 9344 <usb_bulk_out_handler+0x5c>
		if (type != BTUSB_MSG_CONT)
    9302:	2943      	cmp	r1, #67	; 0x43
    9304:	d14a      	bne.n	939c <usb_bulk_out_handler+0xb4>
	return (int)(msg->write - msg->data);
    9306:	6898      	ldr	r0, [r3, #8]
        return msg->data_len - msg_write_len(msg);
    9308:	8859      	ldrh	r1, [r3, #2]
	return (int)(msg->write - msg->data);
    930a:	f103 020c 	add.w	r2, r3, #12
    930e:	1a82      	subs	r2, r0, r2
        return msg->data_len - msg_write_len(msg);
    9310:	1a89      	subs	r1, r1, r2
		wsize = MIN(bulk_size-1, msg_write_avail(rx_msg));
    9312:	428c      	cmp	r4, r1
    9314:	dd10      	ble.n	9338 <usb_bulk_out_handler+0x50>
		p = msg_put(rx_msg, wsize);
    9316:	460a      	mov	r2, r1
        msg->write += len;
    9318:	1881      	adds	r1, r0, r2
    931a:	6099      	str	r1, [r3, #8]
		memcpy(p, data+1, wsize);
    931c:	f10d 0101 	add.w	r1, sp, #1
    9320:	f001 f9d0 	bl	a6c4 <memcpy>
	if (msg_write_avail(rx_msg) == 0)
    9324:	6829      	ldr	r1, [r5, #0]
	return (int)(msg->write - msg->data);
    9326:	688b      	ldr	r3, [r1, #8]
        return msg->data_len - msg_write_len(msg);
    9328:	884a      	ldrh	r2, [r1, #2]
	return (int)(msg->write - msg->data);
    932a:	f101 000c 	add.w	r0, r1, #12
    932e:	1a1b      	subs	r3, r3, r0
    9330:	429a      	cmp	r2, r3
    9332:	d027      	beq.n	9384 <usb_bulk_out_handler+0x9c>
}
    9334:	b010      	add	sp, #64	; 0x40
    9336:	bd70      	pop	{r4, r5, r6, pc}
		wsize = MIN(bulk_size-1, msg_write_avail(rx_msg));
    9338:	1e62      	subs	r2, r4, #1
        if (msg_write_avail(msg) < (int) len)
    933a:	428a      	cmp	r2, r1
    933c:	ddec      	ble.n	9318 <usb_bulk_out_handler+0x30>
		DIE("msg_put: short buf\n");
    933e:	481b      	ldr	r0, [pc, #108]	; (93ac <usb_bulk_out_handler+0xc4>)
    9340:	f7fe fe68 	bl	8014 <die>
		if (type != BTUSB_MSG_START)
    9344:	2953      	cmp	r1, #83	; 0x53
    9346:	d12c      	bne.n	93a2 <usb_bulk_out_handler+0xba>
		packet_size = data[2]|(data[3]<<8);
    9348:	f89d 2003 	ldrb.w	r2, [sp, #3]
    934c:	f89d 6002 	ldrb.w	r6, [sp, #2]
    9350:	ea46 2602 	orr.w	r6, r6, r2, lsl #8
	msg_t *msg = (msg_t*)btctl_mem_alloc(sizeof(msg_t)+size);
    9354:	f106 000c 	add.w	r0, r6, #12
    9358:	f7fe fd64 	bl	7e24 <mem_pool_alloc>
    935c:	4603      	mov	r3, r0
		wsize = MIN(bulk_size-4, msg_write_avail(rx_msg));
    935e:	1ee2      	subs	r2, r4, #3
	msg->write = msg->data;
    9360:	300c      	adds	r0, #12
    9362:	42b2      	cmp	r2, r6
		rx_msg = msg_alloc(packet_size);
    9364:	4631      	mov	r1, r6
	msg->read = msg->data;
    9366:	e9c3 0001 	strd	r0, r0, [r3, #4]
	msg->data_len = size;
    936a:	805e      	strh	r6, [r3, #2]
    936c:	602b      	str	r3, [r5, #0]
		wsize = MIN(bulk_size-4, msg_write_avail(rx_msg));
    936e:	dc02      	bgt.n	9376 <usb_bulk_out_handler+0x8e>
    9370:	1f26      	subs	r6, r4, #4
        if (msg_write_avail(msg) < (int) len)
    9372:	42b1      	cmp	r1, r6
    9374:	dbe3      	blt.n	933e <usb_bulk_out_handler+0x56>
        msg->write += len;
    9376:	1982      	adds	r2, r0, r6
    9378:	609a      	str	r2, [r3, #8]
		memcpy(p, data+4, wsize);
    937a:	a901      	add	r1, sp, #4
    937c:	4632      	mov	r2, r6
    937e:	f001 f9a1 	bl	a6c4 <memcpy>
    9382:	e7cf      	b.n	9324 <usb_bulk_out_handler+0x3c>
	__asm__ __volatile__ (
    9384:	f3ef 8410 	mrs	r4, PRIMASK
    9388:	b672      	cpsid	i
	rc = msg_enqueue(q, msg);
    938a:	4809      	ldr	r0, [pc, #36]	; (93b0 <usb_bulk_out_handler+0xc8>)
    938c:	f7fe fecc 	bl	8128 <msg_enqueue>
	__asm__ __volatile__ (
    9390:	f384 8810 	msr	PRIMASK, r4
		rx_msg = NULL;
    9394:	2300      	movs	r3, #0
    9396:	602b      	str	r3, [r5, #0]
}
    9398:	b010      	add	sp, #64	; 0x40
    939a:	bd70      	pop	{r4, r5, r6, pc}
			DIE("Invalid type %d while waiting rx_msg cont\n", type);
    939c:	4805      	ldr	r0, [pc, #20]	; (93b4 <usb_bulk_out_handler+0xcc>)
    939e:	f7fe fe39 	bl	8014 <die>
			DIE("Unexpected type %c while waiting rx_msg\n", type);
    93a2:	4805      	ldr	r0, [pc, #20]	; (93b8 <usb_bulk_out_handler+0xd0>)
    93a4:	f7fe fe36 	bl	8014 <die>
    93a8:	10002224 	.word	0x10002224
    93ac:	0000da98 	.word	0x0000da98
    93b0:	100023e0 	.word	0x100023e0
    93b4:	0000e160 	.word	0x0000e160
    93b8:	0000e130 	.word	0x0000e130

000093bc <set_serial_descriptor>:


void set_serial_descriptor(u8 *descriptors) {
    93bc:	b530      	push	{r4, r5, lr}
    93be:	b087      	sub	sp, #28
    93c0:	4604      	mov	r4, r0
	u8 buf[17], *desc, nibble;
	int len, i;
	get_device_serial(buf, &len);
    93c2:	4669      	mov	r1, sp
    93c4:	a801      	add	r0, sp, #4
    93c6:	f000 fc15 	bl	9bf4 <get_device_serial>
	if(buf[0] == 0) { /* IAP success */
    93ca:	f89d 3004 	ldrb.w	r3, [sp, #4]
    93ce:	b9f3      	cbnz	r3, 940e <set_serial_descriptor+0x52>
		desc = descriptors + USB_SERIAL_OFFSET;
		for(i=0; i<16; i++) {
    93d0:	4620      	mov	r0, r4
			nibble  = (buf[i+1]>>4) & 0xF;
			desc[i * 4] = (nibble > 9) ? ('a' + nibble - 10) : ('0' + nibble);
			desc[1+ i * 4] = 0;
    93d2:	461c      	mov	r4, r3
    93d4:	f10d 0105 	add.w	r1, sp, #5
    93d8:	f10d 0515 	add.w	r5, sp, #21
			nibble  = (buf[i+1]>>4) & 0xF;
    93dc:	f811 3b01 	ldrb.w	r3, [r1], #1
			desc[1+ i * 4] = 0;
    93e0:	f880 407d 	strb.w	r4, [r0, #125]	; 0x7d
			nibble  = (buf[i+1]>>4) & 0xF;
    93e4:	091a      	lsrs	r2, r3, #4
			desc[i * 4] = (nibble > 9) ? ('a' + nibble - 10) : ('0' + nibble);
    93e6:	2b9f      	cmp	r3, #159	; 0x9f
			nibble = buf[i+1]&0xF;
    93e8:	f003 030f 	and.w	r3, r3, #15
			desc[i * 4] = (nibble > 9) ? ('a' + nibble - 10) : ('0' + nibble);
    93ec:	bf8c      	ite	hi
    93ee:	3257      	addhi	r2, #87	; 0x57
    93f0:	3230      	addls	r2, #48	; 0x30
			desc[2 + i * 4] = (nibble > 9) ? ('a' + nibble - 10) : ('0' + nibble);
    93f2:	2b09      	cmp	r3, #9
    93f4:	bf8c      	ite	hi
    93f6:	3357      	addhi	r3, #87	; 0x57
    93f8:	3330      	addls	r3, #48	; 0x30
		for(i=0; i<16; i++) {
    93fa:	42a9      	cmp	r1, r5
			desc[i * 4] = (nibble > 9) ? ('a' + nibble - 10) : ('0' + nibble);
    93fc:	f880 207c 	strb.w	r2, [r0, #124]	; 0x7c
			desc[2 + i * 4] = (nibble > 9) ? ('a' + nibble - 10) : ('0' + nibble);
    9400:	f880 307e 	strb.w	r3, [r0, #126]	; 0x7e
			desc[3 + i * 4] = 0;
    9404:	f880 407f 	strb.w	r4, [r0, #127]	; 0x7f
		for(i=0; i<16; i++) {
    9408:	f100 0004 	add.w	r0, r0, #4
    940c:	d1e6      	bne.n	93dc <set_serial_descriptor+0x20>
		}
	}
}
    940e:	b007      	add	sp, #28
    9410:	bd30      	pop	{r4, r5, pc}
    9412:	bf00      	nop

00009414 <ubertooth_usb_init>:

int ubertooth_usb_init(VendorRequestHandler *vendor_req_handler)
{
    9414:	b538      	push	{r3, r4, r5, lr}
    9416:	4604      	mov	r4, r0
	// initialise stack
	USBInit();

	set_serial_descriptor(abDescriptors);
    9418:	4d10      	ldr	r5, [pc, #64]	; (945c <ubertooth_usb_init+0x48>)
	USBInit();
    941a:	f000 fcbf 	bl	9d9c <USBInit>
	set_serial_descriptor(abDescriptors);
    941e:	4628      	mov	r0, r5
    9420:	f7ff ffcc 	bl	93bc <set_serial_descriptor>
	
	// register device descriptors
	USBRegisterDescriptors(abDescriptors);
    9424:	4628      	mov	r0, r5
    9426:	f000 fef1 	bl	a20c <USBRegisterDescriptors>

	// Request handler
	v_req_handler = vendor_req_handler;
    942a:	4b0d      	ldr	r3, [pc, #52]	; (9460 <ubertooth_usb_init+0x4c>)

	// override standard request handler
	USBRegisterRequestHandler(REQTYPE_TYPE_VENDOR, usb_vendor_request_handler, abVendorReqData);
    942c:	4a0d      	ldr	r2, [pc, #52]	; (9464 <ubertooth_usb_init+0x50>)
    942e:	2002      	movs	r0, #2
    9430:	490d      	ldr	r1, [pc, #52]	; (9468 <ubertooth_usb_init+0x54>)
	v_req_handler = vendor_req_handler;
    9432:	601c      	str	r4, [r3, #0]
	USBRegisterRequestHandler(REQTYPE_TYPE_VENDOR, usb_vendor_request_handler, abVendorReqData);
    9434:	f000 fca8 	bl	9d88 <USBRegisterRequestHandler>

	// register endpoints
	//USBHwRegisterEPIntHandler(BULK_IN_EP, usb_bulk_in_handler);
	USBHwRegisterEPIntHandler(BULK_OUT_EP, usb_bulk_out_handler);
    9438:	2005      	movs	r0, #5
    943a:	490c      	ldr	r1, [pc, #48]	; (946c <ubertooth_usb_init+0x58>)
    943c:	f000 fd1a 	bl	9e74 <USBHwRegisterEPIntHandler>

	// enable USB interrupts
	ISER0 = ISER0_ISE_USB;
    9440:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    9444:	4b0a      	ldr	r3, [pc, #40]	; (9470 <ubertooth_usb_init+0x5c>)

	// Enable WCID / driverless setup on Windows - Consumes Vendor Request 0xFF
	USBRegisterWinusbInterface(0xFF, "{8ac47a88-cc26-4aa9-887b-42ca8cf07a63}");
    9446:	490b      	ldr	r1, [pc, #44]	; (9474 <ubertooth_usb_init+0x60>)
	ISER0 = ISER0_ISE_USB;
    9448:	601a      	str	r2, [r3, #0]
	USBRegisterWinusbInterface(0xFF, "{8ac47a88-cc26-4aa9-887b-42ca8cf07a63}");
    944a:	20ff      	movs	r0, #255	; 0xff
    944c:	f000 fec8 	bl	a1e0 <USBRegisterWinusbInterface>

	// connect to bus
	USBHwConnect(TRUE);
    9450:	2001      	movs	r0, #1
    9452:	f000 fd3a 	bl	9eca <USBHwConnect>

	return 0;
}
    9456:	2000      	movs	r0, #0
    9458:	bd38      	pop	{r3, r4, r5, pc}
    945a:	bf00      	nop
    945c:	10000020 	.word	0x10000020
    9460:	100025e8 	.word	0x100025e8
    9464:	10002228 	.word	0x10002228
    9468:	000092b9 	.word	0x000092b9
    946c:	000092e9 	.word	0x000092e9
    9470:	e000e100 	.word	0xe000e100
    9474:	0000e190 	.word	0x0000e190

00009478 <usb_send_sync>:

void usb_send_sync(void *buf, int size)
{
    9478:	b538      	push	{r3, r4, r5, lr}
	u8 epstat;
	/* mask usb interrupt */
	ICER0 = ICER0_ICE_USB;
    947a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
{
    947e:	4604      	mov	r4, r0
    9480:	460d      	mov	r5, r1
	ICER0 = ICER0_ICE_USB;
    9482:	4b0b      	ldr	r3, [pc, #44]	; (94b0 <usb_send_sync+0x38>)
    9484:	601a      	str	r2, [r3, #0]
	
	/* flush usb buffers */
	do {
		epstat = USBHwEPGetStatus(BULK_IN_EP);
    9486:	2082      	movs	r0, #130	; 0x82
    9488:	f000 fd2a 	bl	9ee0 <USBHwEPGetStatus>
	} while(epstat & (EPSTAT_B1FULL|EPSTAT_B2FULL));
    948c:	f010 0f60 	tst.w	r0, #96	; 0x60
    9490:	d1f9      	bne.n	9486 <usb_send_sync+0xe>

	size = MIN(size, MAX_PACKET_SIZE);

	USBHwEPWrite(BULK_IN_EP, buf, size);
    9492:	2d40      	cmp	r5, #64	; 0x40
    9494:	462a      	mov	r2, r5
    9496:	4621      	mov	r1, r4
    9498:	bfa8      	it	ge
    949a:	2240      	movge	r2, #64	; 0x40
    949c:	2082      	movs	r0, #130	; 0x82
    949e:	f000 fd45 	bl	9f2c <USBHwEPWrite>
	
	/* polled "interrupt" */
	USBHwISR();
    94a2:	f000 fda9 	bl	9ff8 <USBHwISR>

	/* restore usb interrupt */
	ISER0 = ICER0_ICE_USB;
    94a6:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    94aa:	4b02      	ldr	r3, [pc, #8]	; (94b4 <usb_send_sync+0x3c>)
    94ac:	601a      	str	r2, [r3, #0]
}
    94ae:	bd38      	pop	{r3, r4, r5, pc}
    94b0:	e000e180 	.word	0xe000e180
    94b4:	e000e100 	.word	0xe000e100

000094b8 <usb_work>:

int usb_work(void)
{
    94b8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    94bc:	b091      	sub	sp, #68	; 0x44
	uint16_t full_len, buf_idx = 0;
	unsigned buf_avail = MAX_PACKET_SIZE;
	int work = 0;

	/* mask usb interrupt */
	ICER0 = ICER0_ICE_USB;
    94be:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    94c2:	4b49      	ldr	r3, [pc, #292]	; (95e8 <usb_work+0x130>)

	epstat = USBHwEPGetStatus(BULK_IN_EP);
    94c4:	2082      	movs	r0, #130	; 0x82
	ICER0 = ICER0_ICE_USB;
    94c6:	601a      	str	r2, [r3, #0]
	epstat = USBHwEPGetStatus(BULK_IN_EP);
    94c8:	f000 fd0a 	bl	9ee0 <USBHwEPGetStatus>
	b1full = epstat & EPSTAT_B1FULL;
	b2full = epstat & EPSTAT_B2FULL;

	/* If both buffers are full, do nothing */
	if (b1full && b2full)
    94cc:	f000 0360 	and.w	r3, r0, #96	; 0x60
    94d0:	2b60      	cmp	r3, #96	; 0x60
	epstat = USBHwEPGetStatus(BULK_IN_EP);
    94d2:	4604      	mov	r4, r0
	if (b1full && b2full)
    94d4:	d06a      	beq.n	95ac <usb_work+0xf4>
	{
		goto end;
	}
	if (!tx_msg)
    94d6:	4f45      	ldr	r7, [pc, #276]	; (95ec <usb_work+0x134>)
    94d8:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
    94dc:	2b00      	cmp	r3, #0
    94de:	d067      	beq.n	95b0 <usb_work+0xf8>
		buf[2] = full_len & 0xff;
		buf[3] = full_len >> 8;
		buf_idx = 4;
	}
	else{
		buf[0] = BTUSB_MSG_CONT;
    94e0:	2001      	movs	r0, #1
    94e2:	2243      	movs	r2, #67	; 0x43
    94e4:	4680      	mov	r8, r0
    94e6:	263f      	movs	r6, #63	; 0x3f
    94e8:	f88d 2000 	strb.w	r2, [sp]
		buf_idx = 1;
    94ec:	e9d3 1501 	ldrd	r1, r5, [r3, #4]
    94f0:	1a6d      	subs	r5, r5, r1
	return (int)(msg->write - msg->read);
    94f2:	42ae      	cmp	r6, r5
    94f4:	bfa8      	it	ge
    94f6:	462e      	movge	r6, r5
	}
	// now we should have a msg to send
	len = MIN(msg_read_avail(tx_msg), MAX_PACKET_SIZE-buf_idx);
	if (len && !b1full)
    94f8:	b1ee      	cbz	r6, 9536 <usb_work+0x7e>
    94fa:	06a2      	lsls	r2, r4, #26
    94fc:	d42f      	bmi.n	955e <usb_work+0xa6>
	{
		memcpy(buf+buf_idx, msg_pull(tx_msg, len), len);
    94fe:	46e9      	mov	r9, sp
}

static inline uint8_t *msg_pull(msg_t *msg, unsigned int len)
{
	uint8_t *read = msg->read;
	if (msg_read_avail(msg) < (int) len)
    9500:	42ae      	cmp	r6, r5
    9502:	4448      	add	r0, r9
    9504:	dc6d      	bgt.n	95e2 <usb_work+0x12a>
		DIE("msg_pull: short buf\n");
	msg->read += len;
    9506:	198a      	adds	r2, r1, r6
    9508:	605a      	str	r2, [r3, #4]
    950a:	4632      	mov	r2, r6
    950c:	f001 f8da 	bl	a6c4 <memcpy>
		USBHwEPWrite(BULK_IN_EP, buf, buf_idx+len);
    9510:	4649      	mov	r1, r9
    9512:	eb06 0208 	add.w	r2, r6, r8
    9516:	2082      	movs	r0, #130	; 0x82
    9518:	f000 fd08 	bl	9f2c <USBHwEPWrite>
		buf[0] = BTUSB_MSG_CONT;
    951c:	2243      	movs	r2, #67	; 0x43
		buf_idx = 1;
		/* length for second buffer */
		len = MIN(msg_read_avail(tx_msg),MAX_PACKET_SIZE-buf_idx);
    951e:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
		buf[0] = BTUSB_MSG_CONT;
    9522:	f88d 2000 	strb.w	r2, [sp]
	return (int)(msg->write - msg->read);
    9526:	e9d3 1501 	ldrd	r1, r5, [r3, #4]
    952a:	1a6d      	subs	r5, r5, r1
		len = MIN(msg_read_avail(tx_msg),MAX_PACKET_SIZE-buf_idx);
    952c:	2d3e      	cmp	r5, #62	; 0x3e
    952e:	dc12      	bgt.n	9556 <usb_work+0x9e>
	}
	if (len && !b2full)
    9530:	b10d      	cbz	r5, 9536 <usb_work+0x7e>
    9532:	0662      	lsls	r2, r4, #25
    9534:	d533      	bpl.n	959e <usb_work+0xe6>
	{
		memcpy(buf+buf_idx, msg_pull(tx_msg, len), len);
		USBHwEPWrite(BULK_IN_EP, buf, buf_idx+len);
	}
	/* polled "interrupt" */
	USBHwISR();
    9536:	f000 fd5f 	bl	9ff8 <USBHwISR>

	/* Free message if completed */
	if (!msg_read_avail(tx_msg))
    953a:	f8d7 0108 	ldr.w	r0, [r7, #264]	; 0x108
    953e:	e9d0 2301 	ldrd	r2, r3, [r0, #4]
    9542:	429a      	cmp	r2, r3
    9544:	d024      	beq.n	9590 <usb_work+0xd8>
	{
		/* Done with this message */
		msg_free(tx_msg);
		tx_msg = NULL;
	}
	work = 1;
    9546:	2001      	movs	r0, #1
end:
	ISER0 = ISER0_ISE_USB;
    9548:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    954c:	4b28      	ldr	r3, [pc, #160]	; (95f0 <usb_work+0x138>)
    954e:	601a      	str	r2, [r3, #0]
	return work;
}
    9550:	b011      	add	sp, #68	; 0x44
    9552:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    9556:	f04f 0801 	mov.w	r8, #1
		len = MIN(msg_read_avail(tx_msg),MAX_PACKET_SIZE-buf_idx);
    955a:	263f      	movs	r6, #63	; 0x3f
    955c:	4640      	mov	r0, r8
	if (len && !b2full)
    955e:	0664      	lsls	r4, r4, #25
    9560:	d4e9      	bmi.n	9536 <usb_work+0x7e>
		memcpy(buf+buf_idx, msg_pull(tx_msg, len), len);
    9562:	46e9      	mov	r9, sp
	if (msg_read_avail(msg) < (int) len)
    9564:	42b5      	cmp	r5, r6
    9566:	4632      	mov	r2, r6
    9568:	4448      	add	r0, r9
    956a:	db3a      	blt.n	95e2 <usb_work+0x12a>
	msg->read += len;
    956c:	188c      	adds	r4, r1, r2
    956e:	605c      	str	r4, [r3, #4]
    9570:	f001 f8a8 	bl	a6c4 <memcpy>
		USBHwEPWrite(BULK_IN_EP, buf, buf_idx+len);
    9574:	eb06 0208 	add.w	r2, r6, r8
    9578:	4649      	mov	r1, r9
    957a:	2082      	movs	r0, #130	; 0x82
    957c:	f000 fcd6 	bl	9f2c <USBHwEPWrite>
	USBHwISR();
    9580:	f000 fd3a 	bl	9ff8 <USBHwISR>
	if (!msg_read_avail(tx_msg))
    9584:	f8d7 0108 	ldr.w	r0, [r7, #264]	; 0x108
    9588:	e9d0 2301 	ldrd	r2, r3, [r0, #4]
    958c:	429a      	cmp	r2, r3
    958e:	d1da      	bne.n	9546 <usb_work+0x8e>
	btctl_mem_free(msg);
    9590:	f7fe fc6c 	bl	7e6c <mem_pool_free>
		tx_msg = NULL;
    9594:	2300      	movs	r3, #0
	work = 1;
    9596:	2001      	movs	r0, #1
		tx_msg = NULL;
    9598:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    959c:	e7d4      	b.n	9548 <usb_work+0x90>
		memcpy(buf+buf_idx, msg_pull(tx_msg, len), len);
    959e:	f04f 0801 	mov.w	r8, #1
    95a2:	462a      	mov	r2, r5
    95a4:	462e      	mov	r6, r5
    95a6:	eb0d 0008 	add.w	r0, sp, r8
    95aa:	e7df      	b.n	956c <usb_work+0xb4>
	int work = 0;
    95ac:	2000      	movs	r0, #0
    95ae:	e7cb      	b.n	9548 <usb_work+0x90>
	__asm__ __volatile__ (
    95b0:	f3ef 8510 	mrs	r5, PRIMASK
    95b4:	b672      	cpsid	i
	msg = msg_dequeue(q);
    95b6:	480f      	ldr	r0, [pc, #60]	; (95f4 <usb_work+0x13c>)
    95b8:	f7fe fda0 	bl	80fc <msg_dequeue>
    95bc:	4603      	mov	r3, r0
	__asm__ __volatile__ (
    95be:	f385 8810 	msr	PRIMASK, r5
		if(!(tx_msg = btctl_tx_dequeue()))
    95c2:	f8c7 0108 	str.w	r0, [r7, #264]	; 0x108
    95c6:	2800      	cmp	r0, #0
    95c8:	d0f0      	beq.n	95ac <usb_work+0xf4>
	return (int)(msg->write - msg->read);
    95ca:	e9d3 1501 	ldrd	r1, r5, [r3, #4]
		buf[0] = BTUSB_MSG_START;
    95ce:	2253      	movs	r2, #83	; 0x53
    95d0:	2004      	movs	r0, #4
    95d2:	1a6d      	subs	r5, r5, r1
		buf[3] = full_len >> 8;
    95d4:	4680      	mov	r8, r0
    95d6:	263c      	movs	r6, #60	; 0x3c
		buf[0] = BTUSB_MSG_START;
    95d8:	f8ad 2000 	strh.w	r2, [sp]
		buf[2] = full_len & 0xff;
    95dc:	f8ad 5002 	strh.w	r5, [sp, #2]
		buf_idx = 4;
    95e0:	e787      	b.n	94f2 <usb_work+0x3a>
		DIE("msg_pull: short buf\n");
    95e2:	4805      	ldr	r0, [pc, #20]	; (95f8 <usb_work+0x140>)
    95e4:	f7fe fd16 	bl	8014 <die>
    95e8:	e000e180 	.word	0xe000e180
    95ec:	10002224 	.word	0x10002224
    95f0:	e000e100 	.word	0xe000e100
    95f4:	10002408 	.word	0x10002408
    95f8:	0000e1b8 	.word	0x0000e1b8

000095fc <DMA_IRQHandler>:
volatile uint8_t *dma_user_tx_buf = (void*)0;
dma_tx_cb_t dma_user_tx_cb = (void*)0;
void *dma_user_tx_cb_arg = (void*)0;

void DMA_IRQHandler(void)
{
    95fc:	b508      	push	{r3, lr}
	cprintf ("DMAI %x\n", DMACIntStat);
    95fe:	4b05      	ldr	r3, [pc, #20]	; (9614 <DMA_IRQHandler+0x18>)
    9600:	4805      	ldr	r0, [pc, #20]	; (9618 <DMA_IRQHandler+0x1c>)
    9602:	6819      	ldr	r1, [r3, #0]
    9604:	f7ff fe06 	bl	9214 <cprintf>
	DMACIntTCClear = 0xFF;
    9608:	23ff      	movs	r3, #255	; 0xff
    960a:	4904      	ldr	r1, [pc, #16]	; (961c <DMA_IRQHandler+0x20>)
	DMACIntErrClr = 0xFF;
    960c:	4a04      	ldr	r2, [pc, #16]	; (9620 <DMA_IRQHandler+0x24>)
	DMACIntTCClear = 0xFF;
    960e:	600b      	str	r3, [r1, #0]
	DMACIntErrClr = 0xFF;
    9610:	6013      	str	r3, [r2, #0]
		if (DMACIntErrStat & (1 << 1)) {
			DMACIntErrClr = (1 << 1);
		}
	}
#endif
}
    9612:	bd08      	pop	{r3, pc}
    9614:	50004000 	.word	0x50004000
    9618:	0000e1d4 	.word	0x0000e1d4
    961c:	50004008 	.word	0x50004008
    9620:	50004010 	.word	0x50004010

00009624 <dma_poweron>:

void dma_poweron(void) {
    9624:	b4f0      	push	{r4, r5, r6, r7}
	PCONP |= PCONP_PCGPDMA;

	// enable DMA interrupts at lowest priority
	//IPR6 |= IPR6_IP_DMA; // hack, sets it to 31 (lowest)
	IPR6 |= 31<<19; // pri 
	ISER0 = ISER0_ISE_DMA;
    9626:	f04f 6780 	mov.w	r7, #67108864	; 0x4000000

	/* Disable DMA interrupt */
	//ICER0 = ICER0_ICE_DMA;

	// disable active channels
	DMACC0Config = 0;
    962a:	2300      	movs	r3, #0
	DMACC7Config = 0;
	DMACIntTCClear = 0xFF;
	DMACIntErrClr = 0xFF;

	/* enable DMA globally */
	DMACConfig = DMACConfig_E;
    962c:	4814      	ldr	r0, [pc, #80]	; (9680 <dma_poweron+0x5c>)
	DMACIntTCClear = 0xFF;
    962e:	24ff      	movs	r4, #255	; 0xff
	DMACConfig = DMACConfig_E;
    9630:	2601      	movs	r6, #1
	while (!(DMACConfig & DMACConfig_E));
    9632:	4602      	mov	r2, r0
	PCONP |= PCONP_PCGPDMA;
    9634:	4d13      	ldr	r5, [pc, #76]	; (9684 <dma_poweron+0x60>)
    9636:	6829      	ldr	r1, [r5, #0]
    9638:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
    963c:	6029      	str	r1, [r5, #0]
	IPR6 |= 31<<19; // pri 
    963e:	4d12      	ldr	r5, [pc, #72]	; (9688 <dma_poweron+0x64>)
    9640:	6829      	ldr	r1, [r5, #0]
    9642:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
    9646:	6029      	str	r1, [r5, #0]
	ISER0 = ISER0_ISE_DMA;
    9648:	4910      	ldr	r1, [pc, #64]	; (968c <dma_poweron+0x68>)
	DMACC0Config = 0;
    964a:	4d11      	ldr	r5, [pc, #68]	; (9690 <dma_poweron+0x6c>)
	ISER0 = ISER0_ISE_DMA;
    964c:	600f      	str	r7, [r1, #0]
	DMACC1Config = 0;
    964e:	4911      	ldr	r1, [pc, #68]	; (9694 <dma_poweron+0x70>)
	DMACC0Config = 0;
    9650:	602b      	str	r3, [r5, #0]
	DMACC1Config = 0;
    9652:	600b      	str	r3, [r1, #0]
	DMACC2Config = 0;
    9654:	642b      	str	r3, [r5, #64]	; 0x40
	DMACC3Config = 0;
    9656:	640b      	str	r3, [r1, #64]	; 0x40
	DMACC4Config = 0;
    9658:	f8c5 3080 	str.w	r3, [r5, #128]	; 0x80
	DMACC5Config = 0;
    965c:	f8c1 3080 	str.w	r3, [r1, #128]	; 0x80
	DMACC6Config = 0;
    9660:	f8c5 30c0 	str.w	r3, [r5, #192]	; 0xc0
	DMACC7Config = 0;
    9664:	f8c1 30c0 	str.w	r3, [r1, #192]	; 0xc0
	DMACIntErrClr = 0xFF;
    9668:	4b0b      	ldr	r3, [pc, #44]	; (9698 <dma_poweron+0x74>)
	DMACIntTCClear = 0xFF;
    966a:	f5a1 7194 	sub.w	r1, r1, #296	; 0x128
    966e:	600c      	str	r4, [r1, #0]
	DMACIntErrClr = 0xFF;
    9670:	601c      	str	r4, [r3, #0]
	DMACConfig = DMACConfig_E;
    9672:	6006      	str	r6, [r0, #0]
	while (!(DMACConfig & DMACConfig_E));
    9674:	6813      	ldr	r3, [r2, #0]
    9676:	07db      	lsls	r3, r3, #31
    9678:	d5fc      	bpl.n	9674 <dma_poweron+0x50>
}
    967a:	bcf0      	pop	{r4, r5, r6, r7}
    967c:	4770      	bx	lr
    967e:	bf00      	nop
    9680:	50004030 	.word	0x50004030
    9684:	400fc0c4 	.word	0x400fc0c4
    9688:	e000e418 	.word	0xe000e418
    968c:	e000e100 	.word	0xe000e100
    9690:	50004110 	.word	0x50004110
    9694:	50004130 	.word	0x50004130
    9698:	50004010 	.word	0x50004010

0000969c <dio_ssp_stop>:
	DMACIntTCClear = 1 << channel;
	DMACIntErrClr  = 1 << channel;
}

void dio_ssp_stop(void)
{
    969c:	b570      	push	{r4, r5, r6, lr}
    969e:	b082      	sub	sp, #8
	// disable CC2400's output (active low)
	DIO_SSEL_SET;
    96a0:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000

	// disable DMA on SSP; disable SSP ; disable DMA channel
	DIO_SSP_CR1 &= ~SSPCR1_SSE;
	DIO_SSP_DMACR = 0;
    96a4:	2400      	movs	r4, #0
	DMACIntTCClear = 1 << channel;
    96a6:	2202      	movs	r2, #2
    96a8:	2001      	movs	r0, #1
	DIO_SSEL_SET;
    96aa:	4b11      	ldr	r3, [pc, #68]	; (96f0 <dio_ssp_stop+0x54>)
	DIO_SSP_CR1 &= ~SSPCR1_SSE;
    96ac:	4911      	ldr	r1, [pc, #68]	; (96f4 <dio_ssp_stop+0x58>)
	DIO_SSEL_SET;
    96ae:	601d      	str	r5, [r3, #0]
	DIO_SSP_CR1 &= ~SSPCR1_SSE;
    96b0:	680b      	ldr	r3, [r1, #0]
	DIO_SSP_DMACR = 0;
    96b2:	4e11      	ldr	r6, [pc, #68]	; (96f8 <dio_ssp_stop+0x5c>)
	DIO_SSP_CR1 &= ~SSPCR1_SSE;
    96b4:	f023 0302 	bic.w	r3, r3, #2
	DMACC0Config = 0;
    96b8:	4d10      	ldr	r5, [pc, #64]	; (96fc <dio_ssp_stop+0x60>)
	DIO_SSP_CR1 &= ~SSPCR1_SSE;
    96ba:	600b      	str	r3, [r1, #0]
	DMACIntErrClr  = 1 << channel;
    96bc:	4b10      	ldr	r3, [pc, #64]	; (9700 <dio_ssp_stop+0x64>)
	DMACIntTCClear = 1 << channel;
    96be:	4911      	ldr	r1, [pc, #68]	; (9704 <dio_ssp_stop+0x68>)
	DIO_SSP_DMACR = 0;
    96c0:	6034      	str	r4, [r6, #0]
	DMACC0Config = 0;
    96c2:	602c      	str	r4, [r5, #0]

	dma_clear_interrupts(0);
	dma_clear_interrupts(1);

	// flush SSP
	while (SSP1SR & SSPSR_RNE) {
    96c4:	4c10      	ldr	r4, [pc, #64]	; (9708 <dio_ssp_stop+0x6c>)
	DMACIntTCClear = 1 << channel;
    96c6:	6008      	str	r0, [r1, #0]
	DMACIntErrClr  = 1 << channel;
    96c8:	6018      	str	r0, [r3, #0]
	DMACIntTCClear = 1 << channel;
    96ca:	600a      	str	r2, [r1, #0]
	DMACIntErrClr  = 1 << channel;
    96cc:	601a      	str	r2, [r3, #0]
	while (SSP1SR & SSPSR_RNE) {
    96ce:	6823      	ldr	r3, [r4, #0]
    96d0:	075a      	lsls	r2, r3, #29
    96d2:	d50b      	bpl.n	96ec <dio_ssp_stop+0x50>
		cprintf("ssp ne\n");
    96d4:	4e0d      	ldr	r6, [pc, #52]	; (970c <dio_ssp_stop+0x70>)
		volatile uint8_t tmp = (uint8_t)DIO_SSP_DR;
    96d6:	4d0e      	ldr	r5, [pc, #56]	; (9710 <dio_ssp_stop+0x74>)
		cprintf("ssp ne\n");
    96d8:	4630      	mov	r0, r6
    96da:	f7ff fd9b 	bl	9214 <cprintf>
		volatile uint8_t tmp = (uint8_t)DIO_SSP_DR;
    96de:	682b      	ldr	r3, [r5, #0]
    96e0:	b2db      	uxtb	r3, r3
    96e2:	f88d 3007 	strb.w	r3, [sp, #7]
	while (SSP1SR & SSPSR_RNE) {
    96e6:	6823      	ldr	r3, [r4, #0]
    96e8:	075b      	lsls	r3, r3, #29
    96ea:	d4f5      	bmi.n	96d8 <dio_ssp_stop+0x3c>
	}
}
    96ec:	b002      	add	sp, #8
    96ee:	bd70      	pop	{r4, r5, r6, pc}
    96f0:	2009c098 	.word	0x2009c098
    96f4:	40030004 	.word	0x40030004
    96f8:	40030024 	.word	0x40030024
    96fc:	50004110 	.word	0x50004110
    9700:	50004010 	.word	0x50004010
    9704:	50004008 	.word	0x50004008
    9708:	4003000c 	.word	0x4003000c
    970c:	0000e1e0 	.word	0x0000e1e0
    9710:	40030008 	.word	0x40030008

00009714 <dio_ssp_start_rx>:

void dio_ssp_start_rx(void)
{
    9714:	b430      	push	{r4, r5}
	/* make sure the (active low) slave select signal is not active */
	DIO_SSEL_SET;
	//SCLK_SET_IN;

	/* Configure RX DMA on DIO_SSP (SSP1 for Ubertooth One) */
	DIO_SSP_DMACR = SSPDMACR_RXDMAE ;
    9716:	2401      	movs	r4, #1
	DIO_SSEL_SET;
    9718:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
	/* Configuration of DMA : Slave, Slave output disable
		DIO_SSP_CR1 = SSPCR1_MS | SSPCR1_SOD;
	DIO_SSP_CR1 = SSPCR1_MS | SSPCR1_SOD;
	 */
	DIO_SSP_CR1 = SSPCR1_MS | SSPCR1_SOD;
    971c:	220c      	movs	r2, #12
    971e:	4b09      	ldr	r3, [pc, #36]	; (9744 <dio_ssp_start_rx+0x30>)
	DIO_SSEL_SET;
    9720:	4d09      	ldr	r5, [pc, #36]	; (9748 <dio_ssp_start_rx+0x34>)
	DIO_SSP_DMACR = SSPDMACR_RXDMAE ;
    9722:	480a      	ldr	r0, [pc, #40]	; (974c <dio_ssp_start_rx+0x38>)
	DIO_SSEL_SET;
    9724:	6029      	str	r1, [r5, #0]
	DIO_SSP_DMACR = SSPDMACR_RXDMAE ;
    9726:	6004      	str	r4, [r0, #0]
	DIO_SSP_CR1 = SSPCR1_MS | SSPCR1_SOD;
    9728:	601a      	str	r2, [r3, #0]

	/* Enable ssp */
	DIO_SSP_CR1 |= SSPCR1_SSE;
    972a:	681a      	ldr	r2, [r3, #0]

	// enable channel
	DMACC0Config |= 1;
    972c:	4808      	ldr	r0, [pc, #32]	; (9750 <dio_ssp_start_rx+0x3c>)
	DIO_SSP_CR1 |= SSPCR1_SSE;
    972e:	f042 0202 	orr.w	r2, r2, #2
    9732:	601a      	str	r2, [r3, #0]
	DMACC0Config |= 1;
    9734:	6803      	ldr	r3, [r0, #0]

	/* activate slave select pin */
	DIO_SSEL_CLR;
    9736:	4a07      	ldr	r2, [pc, #28]	; (9754 <dio_ssp_start_rx+0x40>)
	DMACC0Config |= 1;
    9738:	4323      	orrs	r3, r4
    973a:	6003      	str	r3, [r0, #0]
}
    973c:	bc30      	pop	{r4, r5}
	DIO_SSEL_CLR;
    973e:	6011      	str	r1, [r2, #0]
}
    9740:	4770      	bx	lr
    9742:	bf00      	nop
    9744:	40030004 	.word	0x40030004
    9748:	2009c098 	.word	0x2009c098
    974c:	40030024 	.word	0x40030024
    9750:	50004110 	.word	0x50004110
    9754:	2009c09c 	.word	0x2009c09c

00009758 <dma_init_rx_single>:

void dma_init_rx_single(volatile void *buf, unsigned buf_size)
{
    9758:	b470      	push	{r4, r5, r6}
	dma_user_rx_buf = buf;

	/* configure DMA channel 0: Rx single slot */
	DMACC0SrcAddr	= (uint32_t)&(DIO_SSP_DR);
	DMACC0DestAddr	= (uint32_t)buf;
	DMACC0LLI	= 0;
    975a:	2500      	movs	r5, #0
			(0 << 18) |        /* source width 8 bits */
			(0 << 21) |        /* destination width 8 bits */
			DMACCxControl_DI  /* destination increment */
			;

	DMACC0Config	= DIO_SSP_SRC	/* Src periph (3 for Ubertooth One) */
    975c:	f241 0206 	movw	r2, #4102	; 0x1006
	dma_user_rx_buf = buf;
    9760:	4b08      	ldr	r3, [pc, #32]	; (9784 <dma_init_rx_single+0x2c>)
	DMACC0SrcAddr	= (uint32_t)&(DIO_SSP_DR);
    9762:	4c09      	ldr	r4, [pc, #36]	; (9788 <dma_init_rx_single+0x30>)
	dma_user_rx_buf = buf;
    9764:	6018      	str	r0, [r3, #0]
	DMACC0SrcAddr	= (uint32_t)&(DIO_SSP_DR);
    9766:	4e09      	ldr	r6, [pc, #36]	; (978c <dma_init_rx_single+0x34>)
	DMACC0DestAddr	= (uint32_t)buf;
    9768:	4b09      	ldr	r3, [pc, #36]	; (9790 <dma_init_rx_single+0x38>)
	DMACC0SrcAddr	= (uint32_t)&(DIO_SSP_DR);
    976a:	6026      	str	r6, [r4, #0]
			(0 << 21) |        /* destination width 8 bits */
    976c:	f041 6100 	orr.w	r1, r1, #134217728	; 0x8000000
	DMACC0DestAddr	= (uint32_t)buf;
    9770:	6018      	str	r0, [r3, #0]
	DMACC0Control	= buf_size |
    9772:	4808      	ldr	r0, [pc, #32]	; (9794 <dma_init_rx_single+0x3c>)
			(0 << 21) |        /* destination width 8 bits */
    9774:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
	DMACC0LLI	= 0;
    9778:	60a5      	str	r5, [r4, #8]
	DMACC0Control	= buf_size |
    977a:	6001      	str	r1, [r0, #0]
			| (0x2 << 11)	/* peripheral to memory */
			;
}
    977c:	bc70      	pop	{r4, r5, r6}
	DMACC0Config	= DIO_SSP_SRC	/* Src periph (3 for Ubertooth One) */
    977e:	60da      	str	r2, [r3, #12]
}
    9780:	4770      	bx	lr
    9782:	bf00      	nop
    9784:	10002330 	.word	0x10002330
    9788:	50004100 	.word	0x50004100
    978c:	40030008 	.word	0x40030008
    9790:	50004104 	.word	0x50004104
    9794:	5000410c 	.word	0x5000410c

00009798 <dma_get_rx_offset>:

unsigned long dma_get_rx_offset(void)
{
	return (unsigned long)DMACC0DestAddr - (unsigned long)dma_user_rx_buf;
    9798:	4a02      	ldr	r2, [pc, #8]	; (97a4 <dma_get_rx_offset+0xc>)
    979a:	4b03      	ldr	r3, [pc, #12]	; (97a8 <dma_get_rx_offset+0x10>)
    979c:	6810      	ldr	r0, [r2, #0]
    979e:	681b      	ldr	r3, [r3, #0]
}
    97a0:	1ac0      	subs	r0, r0, r3
    97a2:	4770      	bx	lr
    97a4:	50004104 	.word	0x50004104
    97a8:	10002330 	.word	0x10002330

000097ac <USB_IRQHandler>:
	return fifo_get(&rxfifo, &c) ? c : EOF;
}

void USB_IRQHandler()
{
	USBHwISR();
    97ac:	f000 bc24 	b.w	9ff8 <USBHwISR>

000097b0 <Reset_Handler>:
extern void __libc_init_array(void);
extern int main(void);

/* Reset Handler */
void Reset_Handler(void)
{
    97b0:	b508      	push	{r3, lr}
	unsigned long *src, *dest;

	// Copy the data segment initializers from flash to SRAM
	src = &_etext;
	for(dest = &_data; dest < &_edata; )
    97b2:	4b0d      	ldr	r3, [pc, #52]	; (97e8 <Reset_Handler+0x38>)
	src = &_etext;
    97b4:	4a0d      	ldr	r2, [pc, #52]	; (97ec <Reset_Handler+0x3c>)
	for(dest = &_data; dest < &_edata; )
    97b6:	490e      	ldr	r1, [pc, #56]	; (97f0 <Reset_Handler+0x40>)
    97b8:	428b      	cmp	r3, r1
    97ba:	d30c      	bcc.n	97d6 <Reset_Handler+0x26>

	// Initialize the .bss segment of memory to zeros
	src = &_bss;
	while (src < &_ebss)
	{
		*src++ = 0;
    97bc:	2100      	movs	r1, #0
	src = &_bss;
    97be:	4b0d      	ldr	r3, [pc, #52]	; (97f4 <Reset_Handler+0x44>)
	while (src < &_ebss)
    97c0:	4a0d      	ldr	r2, [pc, #52]	; (97f8 <Reset_Handler+0x48>)
    97c2:	4293      	cmp	r3, r2
    97c4:	d30c      	bcc.n	97e0 <Reset_Handler+0x30>
	}

	__libc_init_array();
    97c6:	f7fa fcc5 	bl	4154 <__libc_init_array>

	// Set the vector table location.
	SCB_VTOR = (uint32_t)&_interrupt_vector_table;
    97ca:	4a0c      	ldr	r2, [pc, #48]	; (97fc <Reset_Handler+0x4c>)
    97cc:	4b0c      	ldr	r3, [pc, #48]	; (9800 <Reset_Handler+0x50>)
    97ce:	601a      	str	r2, [r3, #0]

	main();
    97d0:	f7fb fd22 	bl	5218 <main>

	// In case main() fails, have something to breakpoint
	while (1) {;}
    97d4:	e7fe      	b.n	97d4 <Reset_Handler+0x24>
		*dest++ = *src++;
    97d6:	f852 0b04 	ldr.w	r0, [r2], #4
    97da:	f843 0b04 	str.w	r0, [r3], #4
    97de:	e7eb      	b.n	97b8 <Reset_Handler+0x8>
		*src++ = 0;
    97e0:	f843 1b04 	str.w	r1, [r3], #4
    97e4:	e7ed      	b.n	97c2 <Reset_Handler+0x12>
    97e6:	bf00      	nop
    97e8:	10000020 	.word	0x10000020
    97ec:	0000e238 	.word	0x0000e238
    97f0:	10000181 	.word	0x10000181
    97f4:	10000188 	.word	0x10000188
    97f8:	100025ec 	.word	0x100025ec
    97fc:	00004000 	.word	0x00004000
    9800:	e000ed08 	.word	0xe000ed08

00009804 <ADC_IRQHandler>:
extern unsigned long _StackTop;

extern void Reset_Handler(void);

/* Default interrupt handler */
static void Default_Handler(void) { while(1) {;} }
    9804:	e7fe      	b.n	9804 <ADC_IRQHandler>
    9806:	0000      	movs	r0, r0

00009808 <wait_us>:
	/* This is binary multiply by ~0.3999, i.e, multiply by
	   0.011011011b. The loop also contains 6 instructions at -Os, so
	   why this factor works is not at all related to the comment
	   above ;-) */
	wait_us_counter =
		(us>>2) + (us>>3) + (us>>6) + (us>>7) + (us>>10) + (us>>11);
    9808:	08c3      	lsrs	r3, r0, #3
    980a:	eb03 0390 	add.w	r3, r3, r0, lsr #2
    980e:	eb03 1390 	add.w	r3, r3, r0, lsr #6
    9812:	eb03 13d0 	add.w	r3, r3, r0, lsr #7
    9816:	eb03 2390 	add.w	r3, r3, r0, lsr #10
    981a:	eb03 20d0 	add.w	r0, r3, r0, lsr #11
	wait_us_counter =
    981e:	4b04      	ldr	r3, [pc, #16]	; (9830 <wait_us+0x28>)
    9820:	6058      	str	r0, [r3, #4]
	while(--wait_us_counter);
    9822:	685a      	ldr	r2, [r3, #4]
    9824:	3a01      	subs	r2, #1
    9826:	605a      	str	r2, [r3, #4]
    9828:	2a00      	cmp	r2, #0
    982a:	d1fa      	bne.n	9822 <wait_us+0x1a>
}
    982c:	4770      	bx	lr
    982e:	bf00      	nop
    9830:	10002340 	.word	0x10002340

00009834 <all_pins_off>:
}

void all_pins_off(void)
{
	/* configure all pins for GPIO */
	PINSEL0 = 0;
    9834:	2300      	movs	r3, #0
    9836:	4a10      	ldr	r2, [pc, #64]	; (9878 <all_pins_off+0x44>)
    9838:	6013      	str	r3, [r2, #0]
	PINSEL1 = 0;
    983a:	6053      	str	r3, [r2, #4]
	PINSEL2 = 0;
    983c:	6093      	str	r3, [r2, #8]
	PINSEL3 = 0;
    983e:	60d3      	str	r3, [r2, #12]
	PINSEL4 = 0;
    9840:	6113      	str	r3, [r2, #16]
	PINSEL7 = 0;
    9842:	61d3      	str	r3, [r2, #28]
	PINSEL9 = 0;
    9844:	6253      	str	r3, [r2, #36]	; 0x24
	PINSEL10 = 0;
    9846:	6293      	str	r3, [r2, #40]	; 0x28

	/* configure all pins as inputs */
	FIO0DIR = 0;
    9848:	4a0c      	ldr	r2, [pc, #48]	; (987c <all_pins_off+0x48>)
    984a:	6013      	str	r3, [r2, #0]
	FIO1DIR = 0;
    984c:	6213      	str	r3, [r2, #32]
	FIO2DIR = 0;
    984e:	6413      	str	r3, [r2, #64]	; 0x40
	FIO3DIR = 0;
    9850:	6613      	str	r3, [r2, #96]	; 0x60
	FIO4DIR = 0;
    9852:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80

	/* pull-up on every pin */
	PINMODE0 = 0;
    9856:	4a0a      	ldr	r2, [pc, #40]	; (9880 <all_pins_off+0x4c>)
    9858:	6013      	str	r3, [r2, #0]
	PINMODE1 = 0;
    985a:	6053      	str	r3, [r2, #4]
	PINMODE2 = 0;
    985c:	6093      	str	r3, [r2, #8]
	PINMODE3 = 0;
    985e:	60d3      	str	r3, [r2, #12]
	PINMODE4 = 0;
    9860:	6113      	str	r3, [r2, #16]
	PINMODE7 = 0;
    9862:	61d3      	str	r3, [r2, #28]
	PINMODE9 = 0;
    9864:	6253      	str	r3, [r2, #36]	; 0x24

	/* set all outputs low */
	FIO0PIN = 0;
    9866:	4a07      	ldr	r2, [pc, #28]	; (9884 <all_pins_off+0x50>)
    9868:	6013      	str	r3, [r2, #0]
	FIO1PIN = 0;
    986a:	6213      	str	r3, [r2, #32]
	FIO2PIN = 0;
    986c:	6413      	str	r3, [r2, #64]	; 0x40
	FIO3PIN = 0;
    986e:	6613      	str	r3, [r2, #96]	; 0x60
	FIO4PIN = 0;
    9870:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
}
    9874:	4770      	bx	lr
    9876:	bf00      	nop
    9878:	4002c000 	.word	0x4002c000
    987c:	2009c000 	.word	0x2009c000
    9880:	4002c040 	.word	0x4002c040
    9884:	2009c014 	.word	0x2009c014

00009888 <gpio_init>:
{
    9888:	b508      	push	{r3, lr}
	all_pins_off();
    988a:	f7ff ffd3 	bl	9834 <all_pins_off>
	FIO0DIR = 0;
    988e:	2300      	movs	r3, #0
	FIO1DIR = (PIN_USRLED | PIN_RXLED | PIN_TXLED | PIN_CC3V3 |
    9890:	f24c 7112 	movw	r1, #50962	; 0xc712
	FIO0DIR = 0;
    9894:	4a08      	ldr	r2, [pc, #32]	; (98b8 <gpio_init+0x30>)
    9896:	6013      	str	r3, [r2, #0]
	FIO1DIR = (PIN_USRLED | PIN_RXLED | PIN_TXLED | PIN_CC3V3 |
    9898:	6211      	str	r1, [r2, #32]
	FIO2DIR = (PIN_CSN | PIN_SCLK | PIN_MOSI | PIN_PAEN | PIN_HGM);
    989a:	f240 11b1 	movw	r1, #433	; 0x1b1
    989e:	6411      	str	r1, [r2, #64]	; 0x40
	FIO4DIR = (PIN_TX | PIN_SSEL1);
    98a0:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
	FIO3DIR = 0;
    98a4:	6613      	str	r3, [r2, #96]	; 0x60
	FIO4DIR = (PIN_TX | PIN_SSEL1);
    98a6:	f8c2 1080 	str.w	r1, [r2, #128]	; 0x80
	FIO0PIN = 0;
    98aa:	6153      	str	r3, [r2, #20]
	FIO1PIN = 0;
    98ac:	6353      	str	r3, [r2, #52]	; 0x34
	FIO2PIN = 0;
    98ae:	6553      	str	r3, [r2, #84]	; 0x54
	FIO3PIN = 0;
    98b0:	6753      	str	r3, [r2, #116]	; 0x74
	FIO4PIN = 0;
    98b2:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
}
    98b6:	bd08      	pop	{r3, pc}
    98b8:	2009c000 	.word	0x2009c000

000098bc <dio_ssp_init>:
	/* set P1.18 as MOSI0 */
	PINSEL1 = (PINSEL1 & ~(3 << 4)) | (2 << 4);
#endif
#if defined UBERTOOTH_ONE || defined TC13BADGE
	/* set P0.7 as SCK1 */
	PINSEL0 = (PINSEL0 & ~(3 << 14)) | (2 << 14);
    98bc:	4b11      	ldr	r3, [pc, #68]	; (9904 <dio_ssp_init+0x48>)
    98be:	681a      	ldr	r2, [r3, #0]
    98c0:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
    98c4:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
    98c8:	601a      	str	r2, [r3, #0]

	/* set P0.6 as SSEL1 */
	PINSEL0 = (PINSEL0 & ~(3 << 12)) | (2 << 12);
    98ca:	681a      	ldr	r2, [r3, #0]
    98cc:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
    98d0:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
    98d4:	601a      	str	r2, [r3, #0]

	/* set P0.8 as MISO1 */
	PINSEL0 = (PINSEL0 & ~(3 << 16)) | (2 << 16);
    98d6:	681a      	ldr	r2, [r3, #0]
    98d8:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
    98dc:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
    98e0:	601a      	str	r2, [r3, #0]

	/* set P0.9 as MOSI1 */
	PINSEL0 = (PINSEL0 & ~(3 << 18)) | (2 << 18);
    98e2:	681a      	ldr	r2, [r3, #0]
    98e4:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
    98e8:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
    98ec:	601a      	str	r2, [r3, #0]
	 * interface.  Since the CC2400 doesn't have a slave select output, we
	 * control it with this.  DIO_SSEL should already be configured by
	 * gpio_init().  We set it high by default because it is an active low
	 * signal.
	 */
	DIO_SSEL_SET;
    98ee:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    98f2:	4b05      	ldr	r3, [pc, #20]	; (9908 <dio_ssp_init+0x4c>)
    98f4:	601a      	str	r2, [r3, #0]

	/* configure DIO_SSP */
	DIO_SSP_CR0 = (0x7 /* 8 bit transfer */ | SSPCR0_CPOL | SSPCR0_CPHA);
    98f6:	22c7      	movs	r2, #199	; 0xc7
    98f8:	4b04      	ldr	r3, [pc, #16]	; (990c <dio_ssp_init+0x50>)
    98fa:	601a      	str	r2, [r3, #0]
	DIO_SSP_CR1 = (SSPCR1_MS | SSPCR1_SOD);
    98fc:	220c      	movs	r2, #12
    98fe:	605a      	str	r2, [r3, #4]
}
    9900:	4770      	bx	lr
    9902:	bf00      	nop
    9904:	4002c000 	.word	0x4002c000
    9908:	2009c098 	.word	0x2009c098
    990c:	40030000 	.word	0x40030000

00009910 <atest_init>:
	 * ADC can optionally be configured for ATEST1 and ATEST2, but for now we
	 * set them as floating inputs.
	 */

	/* P0.25 is ATEST1, P0.26 is ATEST2 */
	PINSEL1 &= ~((0x3 << 20) | (0x3 << 18)); // set as GPIO
    9910:	4a09      	ldr	r2, [pc, #36]	; (9938 <atest_init+0x28>)
    9912:	6813      	ldr	r3, [r2, #0]
    9914:	f423 1370 	bic.w	r3, r3, #3932160	; 0x3c0000
    9918:	6013      	str	r3, [r2, #0]
	FIO0DIR &= ~(0x3 << 25); // set as input
    991a:	4a08      	ldr	r2, [pc, #32]	; (993c <atest_init+0x2c>)
    991c:	6813      	ldr	r3, [r2, #0]
    991e:	f023 63c0 	bic.w	r3, r3, #100663296	; 0x6000000
    9922:	6013      	str	r3, [r2, #0]
	PINMODE1 |= (0x5 << 19); // no pull-up/pull-down
    9924:	4b06      	ldr	r3, [pc, #24]	; (9940 <atest_init+0x30>)
    9926:	681a      	ldr	r2, [r3, #0]
    9928:	f442 1220 	orr.w	r2, r2, #2621440	; 0x280000
    992c:	601a      	str	r2, [r3, #0]
	PINMODE1 &= ~(0x5 << 18); // no pull-up/pull-down
    992e:	681a      	ldr	r2, [r3, #0]
    9930:	f422 12a0 	bic.w	r2, r2, #1310720	; 0x140000
    9934:	601a      	str	r2, [r3, #0]
}
    9936:	4770      	bx	lr
    9938:	4002c004 	.word	0x4002c004
    993c:	2009c000 	.word	0x2009c000
    9940:	4002c044 	.word	0x4002c044

00009944 <cc2400_spi>:
 * 2. We're saving the second SPI peripheral for an expansion port.
 * 3. The CC2400 needs CSN held low for the entire transaction which the
 *    LPC17xx SPI peripheral won't do without some workaround anyway.
 */
u32 cc2400_spi(u8 len, u32 data)
{
    9944:	b5f0      	push	{r4, r5, r6, r7, lr}
	u32 msb = 1 << (len - 1);
    9946:	1e45      	subs	r5, r0, #1
{
    9948:	4603      	mov	r3, r0

	/* start transaction by dropping CSN */
	CSN_CLR;
    994a:	2020      	movs	r0, #32
	u32 msb = 1 << (len - 1);
    994c:	2401      	movs	r4, #1
			MOSI_SET;
		else
			MOSI_CLR;
		data <<= 1;

		SCLK_SET;
    994e:	2710      	movs	r7, #16
	CSN_CLR;
    9950:	4a0d      	ldr	r2, [pc, #52]	; (9988 <cc2400_spi+0x44>)
		/* Save a few cycles by avoiding the compare/branch */
		data |= !!MISO;
    9952:	f8df c03c 	ldr.w	ip, [pc, #60]	; 9990 <cc2400_spi+0x4c>
	CSN_CLR;
    9956:	6010      	str	r0, [r2, #0]
	while (len--) {
    9958:	4608      	mov	r0, r1
    995a:	490c      	ldr	r1, [pc, #48]	; (998c <cc2400_spi+0x48>)
	u32 msb = 1 << (len - 1);
    995c:	fa04 f505 	lsl.w	r5, r4, r5
	while (len--) {
    9960:	3b01      	subs	r3, #1
    9962:	b2db      	uxtb	r3, r3
    9964:	2bff      	cmp	r3, #255	; 0xff
    9966:	d102      	bne.n	996e <cc2400_spi+0x2a>
		SCLK_CLR;
	}

	/* end transaction by raising CSN */
	CSN_SET;
    9968:	2320      	movs	r3, #32
    996a:	600b      	str	r3, [r1, #0]

	return data;
}
    996c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (data & msb)
    996e:	4228      	tst	r0, r5
			MOSI_SET;
    9970:	bf14      	ite	ne
    9972:	600c      	strne	r4, [r1, #0]
			MOSI_CLR;
    9974:	6014      	streq	r4, [r2, #0]
		SCLK_SET;
    9976:	600f      	str	r7, [r1, #0]
		data |= !!MISO;
    9978:	f8dc 6000 	ldr.w	r6, [ip]
		SCLK_CLR;
    997c:	6017      	str	r7, [r2, #0]
		data |= !!MISO;
    997e:	f3c6 0640 	ubfx	r6, r6, #1, #1
    9982:	ea46 0040 	orr.w	r0, r6, r0, lsl #1
		SCLK_CLR;
    9986:	e7eb      	b.n	9960 <cc2400_spi+0x1c>
    9988:	2009c05c 	.word	0x2009c05c
    998c:	2009c058 	.word	0x2009c058
    9990:	2009c054 	.word	0x2009c054

00009994 <cc2400_init>:
{
    9994:	b508      	push	{r3, lr}
	atest_init();
    9996:	f7ff ffbb 	bl	9910 <atest_init>
	CC1V8_SET;
    999a:	f44f 7300 	mov.w	r3, #512	; 0x200
    999e:	4908      	ldr	r1, [pc, #32]	; (99c0 <cc2400_init+0x2c>)
	wait_us(50);
    99a0:	2032      	movs	r0, #50	; 0x32
	CC1V8_SET;
    99a2:	600b      	str	r3, [r1, #0]
	wait_us(50);
    99a4:	f7ff ff30 	bl	9808 <wait_us>
	CSN_SET;
    99a8:	2220      	movs	r2, #32
    99aa:	4b06      	ldr	r3, [pc, #24]	; (99c4 <cc2400_init+0x30>)

/* write 16 bit value to a register */
void cc2400_set(u8 reg, u16 val)
{
	u32 out = (reg << 16) | val;
	cc2400_spi(24, out);
    99ac:	2018      	movs	r0, #24
	CSN_SET;
    99ae:	601a      	str	r2, [r3, #0]
	CC3V3_SET;
    99b0:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    99b4:	600b      	str	r3, [r1, #0]
	cc2400_spi(24, out);
    99b6:	4904      	ldr	r1, [pc, #16]	; (99c8 <cc2400_init+0x34>)
}
    99b8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	cc2400_spi(24, out);
    99bc:	f7ff bfc2 	b.w	9944 <cc2400_spi>
    99c0:	2009c038 	.word	0x2009c038
    99c4:	2009c058 	.word	0x2009c058
    99c8:	000d7fff 	.word	0x000d7fff

000099cc <cc2400_get>:
{
    99cc:	b508      	push	{r3, lr}
	u32 out = (reg | 0x80) << 16;
    99ce:	f040 0180 	orr.w	r1, r0, #128	; 0x80
	in = cc2400_spi(24, out);
    99d2:	0409      	lsls	r1, r1, #16
    99d4:	2018      	movs	r0, #24
    99d6:	f7ff ffb5 	bl	9944 <cc2400_spi>
}
    99da:	b280      	uxth	r0, r0
    99dc:	bd08      	pop	{r3, pc}

000099de <cc2400_set>:
	cc2400_spi(24, out);
    99de:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
    99e2:	2018      	movs	r0, #24
    99e4:	f7ff bfae 	b.w	9944 <cc2400_spi>

000099e8 <cc2400_status>:
	CSN_SET;
}

/* get the status */
u8 cc2400_status()
{
    99e8:	b508      	push	{r3, lr}
	return cc2400_spi(8, 0);
    99ea:	2100      	movs	r1, #0
    99ec:	2008      	movs	r0, #8
    99ee:	f7ff ffa9 	bl	9944 <cc2400_spi>
}
    99f2:	b2c0      	uxtb	r0, r0
    99f4:	bd08      	pop	{r3, pc}

000099f6 <cc2400_strobe>:

/* strobe register, return status */
u8 cc2400_strobe(u8 reg)
{
    99f6:	b508      	push	{r3, lr}
    99f8:	4601      	mov	r1, r0
	return cc2400_spi(8, reg);
    99fa:	2008      	movs	r0, #8
    99fc:	f7ff ffa2 	bl	9944 <cc2400_spi>
}
    9a00:	b2c0      	uxtb	r0, r0
    9a02:	bd08      	pop	{r3, pc}

00009a04 <cc2400_reset>:
/*
 * Warning: This should only be called when running on the internal oscillator.
 * Otherwise use clock_start().
 */
void cc2400_reset()
{
    9a04:	b508      	push	{r3, lr}
	cc2400_spi(24, out);
    9a06:	2100      	movs	r1, #0
    9a08:	2018      	movs	r0, #24
    9a0a:	f7ff ff9b 	bl	9944 <cc2400_spi>
	cc2400_set(MAIN, 0x0000);
	while (cc2400_get(MAIN) != 0x0000);
    9a0e:	2000      	movs	r0, #0
    9a10:	f7ff ffdc 	bl	99cc <cc2400_get>
    9a14:	2800      	cmp	r0, #0
    9a16:	d1fa      	bne.n	9a0e <cc2400_reset+0xa>
	cc2400_spi(24, out);
    9a18:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    9a1c:	2018      	movs	r0, #24
    9a1e:	f7ff ff91 	bl	9944 <cc2400_spi>
	cc2400_set(MAIN, 0x8000);
	while (cc2400_get(MAIN) != 0x8000);
    9a22:	2000      	movs	r0, #0
    9a24:	f7ff ffd2 	bl	99cc <cc2400_get>
    9a28:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
    9a2c:	d1f9      	bne.n	9a22 <cc2400_reset+0x1e>
}
    9a2e:	bd08      	pop	{r3, pc}

00009a30 <clock_start>:

/* activate the CC2400's 16 MHz oscillator and sync LPC175x to it */
void clock_start()
{
    9a30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	/* configure flash accelerator for higher clock rate */
	FLASHCFG = (0x03A | (FLASHTIM << 12));
    9a34:	f244 023a 	movw	r2, #16442	; 0x403a
    9a38:	4b40      	ldr	r3, [pc, #256]	; (9b3c <clock_start+0x10c>)

	/* switch to the internal oscillator if necessary */
	CLKSRCSEL = 0;
    9a3a:	4e41      	ldr	r6, [pc, #260]	; (9b40 <clock_start+0x110>)
	FLASHCFG = (0x03A | (FLASHTIM << 12));
    9a3c:	601a      	str	r2, [r3, #0]
	CLKSRCSEL = 0;
    9a3e:	2300      	movs	r3, #0

	/* disconnect PLL0 */
	PLL0CON &= ~PLL0CON_PLLC0;
    9a40:	4d40      	ldr	r5, [pc, #256]	; (9b44 <clock_start+0x114>)
	CLKSRCSEL = 0;
    9a42:	6033      	str	r3, [r6, #0]
	PLL0CON &= ~PLL0CON_PLLC0;
    9a44:	682b      	ldr	r3, [r5, #0]
	PLL0FEED_SEQUENCE;
    9a46:	4c40      	ldr	r4, [pc, #256]	; (9b48 <clock_start+0x118>)
	PLL0CON &= ~PLL0CON_PLLC0;
    9a48:	f023 0302 	bic.w	r3, r3, #2
    9a4c:	602b      	str	r3, [r5, #0]
	PLL0FEED_SEQUENCE;
    9a4e:	23aa      	movs	r3, #170	; 0xaa
    9a50:	6023      	str	r3, [r4, #0]
    9a52:	2355      	movs	r3, #85	; 0x55
    9a54:	6023      	str	r3, [r4, #0]
	while (PLL0STAT & PLL0STAT_PLLC0_STAT);
    9a56:	4b3d      	ldr	r3, [pc, #244]	; (9b4c <clock_start+0x11c>)
    9a58:	461f      	mov	r7, r3
    9a5a:	681a      	ldr	r2, [r3, #0]
    9a5c:	0190      	lsls	r0, r2, #6
    9a5e:	d4fc      	bmi.n	9a5a <clock_start+0x2a>

	/* turn off PLL0 */
	PLL0CON &= ~PLL0CON_PLLE0;
    9a60:	682b      	ldr	r3, [r5, #0]
    9a62:	f023 0301 	bic.w	r3, r3, #1
    9a66:	602b      	str	r3, [r5, #0]
	PLL0FEED_SEQUENCE;
    9a68:	23aa      	movs	r3, #170	; 0xaa
    9a6a:	6023      	str	r3, [r4, #0]
    9a6c:	2355      	movs	r3, #85	; 0x55
    9a6e:	6023      	str	r3, [r4, #0]
	while (PLL0STAT & PLL0STAT_PLLE0_STAT);
    9a70:	683b      	ldr	r3, [r7, #0]
    9a72:	f013 7380 	ands.w	r3, r3, #16777216	; 0x1000000
    9a76:	d1fb      	bne.n	9a70 <clock_start+0x40>

	/* temporarily set CPU clock divider to 1 */
	CCLKCFG = 0;
    9a78:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 9b70 <clock_start+0x140>
    9a7c:	f8c8 3000 	str.w	r3, [r8]

	/* configure CC2400 oscillator, output carrier sense on GIO6 */
	cc2400_reset();
    9a80:	f7ff ffc0 	bl	9a04 <cc2400_reset>
	cc2400_spi(24, out);
    9a84:	2018      	movs	r0, #24
    9a86:	4932      	ldr	r1, [pc, #200]	; (9b50 <clock_start+0x120>)
    9a88:	f7ff ff5c 	bl	9944 <cc2400_spi>
	cc2400_set(IOCFG, (GIO_CARRIER_SENSE_N << 9) | (GIO_CLK_16M << 3));
	cc2400_strobe(SXOSCON);
    9a8c:	2060      	movs	r0, #96	; 0x60
    9a8e:	f7ff ffb2 	bl	99f6 <cc2400_strobe>
	while (!(cc2400_status() & XOSC16M_STABLE));
    9a92:	f7ff ffa9 	bl	99e8 <cc2400_status>
    9a96:	0641      	lsls	r1, r0, #25
    9a98:	d5fb      	bpl.n	9a92 <clock_start+0x62>

	/* activate main oscillator */
	SCS = SCS_OSCEN;
    9a9a:	2220      	movs	r2, #32
    9a9c:	4b2d      	ldr	r3, [pc, #180]	; (9b54 <clock_start+0x124>)
    9a9e:	601a      	str	r2, [r3, #0]
	while (!(SCS & SCS_OSCSTAT));
    9aa0:	681a      	ldr	r2, [r3, #0]
    9aa2:	0652      	lsls	r2, r2, #25
    9aa4:	d5fc      	bpl.n	9aa0 <clock_start+0x70>
#ifdef TC13BADGE
	PCLKSEL0  = (1 << 2); /* TIMER0 at cclk (30 MHz) */
	PCLKSEL1  = 0;
#else
        // XXX here
	PCLKSEL0  = (2 << 2) | (2 << 4); /* TIMER0 and TIMER1 at cclk/2 (50 MHz) */
    9aa6:	2228      	movs	r2, #40	; 0x28
    9aa8:	4b2b      	ldr	r3, [pc, #172]	; (9b58 <clock_start+0x128>)
	/* switch to main oscillator */
	CLKSRCSEL = 1;

	/* configure PLL0 */
	PLL0CFG = (MSEL0 << 0) | (NSEL0 << 16);
	PLL0FEED_SEQUENCE;
    9aaa:	21aa      	movs	r1, #170	; 0xaa
	PCLKSEL0  = (2 << 2) | (2 << 4); /* TIMER0 and TIMER1 at cclk/2 (50 MHz) */
    9aac:	601a      	str	r2, [r3, #0]
	PCLKSEL1  = (2 << 12); /* TIMER2 at cclk/2 (50 MHz) */
    9aae:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    9ab2:	605a      	str	r2, [r3, #4]
	CLKSRCSEL = 1;
    9ab4:	2301      	movs	r3, #1
	PLL0CFG = (MSEL0 << 0) | (NSEL0 << 16);
    9ab6:	4a29      	ldr	r2, [pc, #164]	; (9b5c <clock_start+0x12c>)
	CLKSRCSEL = 1;
    9ab8:	6033      	str	r3, [r6, #0]
	PLL0CFG = (MSEL0 << 0) | (NSEL0 << 16);
    9aba:	4b29      	ldr	r3, [pc, #164]	; (9b60 <clock_start+0x130>)
    9abc:	601a      	str	r2, [r3, #0]
	PLL0FEED_SEQUENCE;
    9abe:	2255      	movs	r2, #85	; 0x55
    9ac0:	6021      	str	r1, [r4, #0]
    9ac2:	6022      	str	r2, [r4, #0]

	/* turn on PLL0 */
	PLL0CON |= PLL0CON_PLLE0;
    9ac4:	682b      	ldr	r3, [r5, #0]
    9ac6:	f043 0301 	orr.w	r3, r3, #1
    9aca:	602b      	str	r3, [r5, #0]
	PLL0FEED_SEQUENCE;
    9acc:	6021      	str	r1, [r4, #0]
    9ace:	6022      	str	r2, [r4, #0]
	while (!(PLL0STAT & PLL0STAT_PLLE0_STAT));
    9ad0:	683b      	ldr	r3, [r7, #0]
    9ad2:	01de      	lsls	r6, r3, #7
    9ad4:	d5fc      	bpl.n	9ad0 <clock_start+0xa0>

	/* set CPU clock divider */
	CCLKCFG = CCLKSEL;
    9ad6:	2303      	movs	r3, #3
    9ad8:	f8c8 3000 	str.w	r3, [r8]

	/* connect PLL0 */
	PLL0CON |= PLL0CON_PLLC0;
    9adc:	682b      	ldr	r3, [r5, #0]
    9ade:	f043 0302 	orr.w	r3, r3, #2
    9ae2:	602b      	str	r3, [r5, #0]
	PLL0FEED_SEQUENCE;
    9ae4:	23aa      	movs	r3, #170	; 0xaa
    9ae6:	6023      	str	r3, [r4, #0]
    9ae8:	2355      	movs	r3, #85	; 0x55
    9aea:	6023      	str	r3, [r4, #0]
	while (!(PLL0STAT & PLL0STAT_PLLC0_STAT));
    9aec:	683b      	ldr	r3, [r7, #0]
    9aee:	019d      	lsls	r5, r3, #6
    9af0:	d5fc      	bpl.n	9aec <clock_start+0xbc>

	/* configure PLL1 */
	PLL1CFG = (MSEL1 << 0) | (PSEL1 << 5);
    9af2:	2222      	movs	r2, #34	; 0x22
	PLL1FEED_SEQUENCE;
    9af4:	2055      	movs	r0, #85	; 0x55
    9af6:	24aa      	movs	r4, #170	; 0xaa
	PLL1CFG = (MSEL1 << 0) | (PSEL1 << 5);
    9af8:	4b1a      	ldr	r3, [pc, #104]	; (9b64 <clock_start+0x134>)
    9afa:	601a      	str	r2, [r3, #0]

	/* turn on PLL1 */
	PLL1CON |= PLL1CON_PLLE1;
    9afc:	4a1a      	ldr	r2, [pc, #104]	; (9b68 <clock_start+0x138>)
	PLL1FEED_SEQUENCE;
    9afe:	609c      	str	r4, [r3, #8]
    9b00:	6098      	str	r0, [r3, #8]
	PLL1CON |= PLL1CON_PLLE1;
    9b02:	6811      	ldr	r1, [r2, #0]
	PLL1FEED_SEQUENCE;
    9b04:	3308      	adds	r3, #8
	PLL1CON |= PLL1CON_PLLE1;
    9b06:	f041 0101 	orr.w	r1, r1, #1
    9b0a:	6011      	str	r1, [r2, #0]
	PLL1FEED_SEQUENCE;
	while (!(PLL1STAT & PLL1STAT_PLLE1_STAT));
    9b0c:	4917      	ldr	r1, [pc, #92]	; (9b6c <clock_start+0x13c>)
	PLL1FEED_SEQUENCE;
    9b0e:	601c      	str	r4, [r3, #0]
    9b10:	6018      	str	r0, [r3, #0]
	while (!(PLL1STAT & PLL1STAT_PLLE1_STAT));
    9b12:	4608      	mov	r0, r1
    9b14:	680c      	ldr	r4, [r1, #0]
    9b16:	05e4      	lsls	r4, r4, #23
    9b18:	d5fc      	bpl.n	9b14 <clock_start+0xe4>
	while (!(PLL1STAT & PLL1STAT_PLOCK1));
    9b1a:	6801      	ldr	r1, [r0, #0]
    9b1c:	0549      	lsls	r1, r1, #21
    9b1e:	d5fc      	bpl.n	9b1a <clock_start+0xea>

	/* connect PLL1 */
	PLL1CON |= PLL1CON_PLLC1;
    9b20:	6811      	ldr	r1, [r2, #0]
    9b22:	f041 0102 	orr.w	r1, r1, #2
    9b26:	6011      	str	r1, [r2, #0]
	PLL1FEED_SEQUENCE;
    9b28:	22aa      	movs	r2, #170	; 0xaa
    9b2a:	601a      	str	r2, [r3, #0]
    9b2c:	2255      	movs	r2, #85	; 0x55
    9b2e:	601a      	str	r2, [r3, #0]
	while (!(PLL1STAT & PLL1STAT_PLLC1_STAT));
    9b30:	6803      	ldr	r3, [r0, #0]
    9b32:	059b      	lsls	r3, r3, #22
    9b34:	d5fc      	bpl.n	9b30 <clock_start+0x100>
}
    9b36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9b3a:	bf00      	nop
    9b3c:	400fc000 	.word	0x400fc000
    9b40:	400fc10c 	.word	0x400fc10c
    9b44:	400fc080 	.word	0x400fc080
    9b48:	400fc08c 	.word	0x400fc08c
    9b4c:	400fc088 	.word	0x400fc088
    9b50:	00081570 	.word	0x00081570
    9b54:	400fc1a0 	.word	0x400fc1a0
    9b58:	400fc1a8 	.word	0x400fc1a8
    9b5c:	00010018 	.word	0x00010018
    9b60:	400fc084 	.word	0x400fc084
    9b64:	400fc0a4 	.word	0x400fc0a4
    9b68:	400fc0a0 	.word	0x400fc0a0
    9b6c:	400fc0a8 	.word	0x400fc0a8
    9b70:	400fc104 	.word	0x400fc104

00009b74 <ubertooth_init>:
{
    9b74:	b508      	push	{r3, lr}
	gpio_init();
    9b76:	f7ff fe87 	bl	9888 <gpio_init>
	cc2400_init();
    9b7a:	f7ff ff0b 	bl	9994 <cc2400_init>
}
    9b7e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	clock_start();
    9b82:	f7ff bf55 	b.w	9a30 <clock_start>
    9b86:	0000      	movs	r0, r0

00009b88 <reset>:

/* reset the LPC17xx, the cc2400 will be handled by the boot code */
void reset()
{
    9b88:	b508      	push	{r3, lr}
	all_pins_off();
    9b8a:	f7ff fe53 	bl	9834 <all_pins_off>

	/* Enable the watchdog with reset enabled */
	USRLED_CLR;
    9b8e:	2202      	movs	r2, #2
    9b90:	4b08      	ldr	r3, [pc, #32]	; (9bb4 <reset+0x2c>)
	wait_us(seconds * 1000000);
    9b92:	4809      	ldr	r0, [pc, #36]	; (9bb8 <reset+0x30>)
	USRLED_CLR;
    9b94:	601a      	str	r2, [r3, #0]
	WDMOD |= WDMOD_WDEN | WDMOD_WDRESET;
    9b96:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    9b9a:	6813      	ldr	r3, [r2, #0]
    9b9c:	f043 0303 	orr.w	r3, r3, #3
    9ba0:	6013      	str	r3, [r2, #0]
	WDFEED_SEQUENCE;
    9ba2:	22aa      	movs	r2, #170	; 0xaa
    9ba4:	4b05      	ldr	r3, [pc, #20]	; (9bbc <reset+0x34>)
    9ba6:	601a      	str	r2, [r3, #0]
    9ba8:	2255      	movs	r2, #85	; 0x55
    9baa:	601a      	str	r2, [r3, #0]
	
	/* Set watchdog timeout to 256us (minimum) */
	
	/* sleep for 1s (minimum) */
	wait(1);
}
    9bac:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	wait_us(seconds * 1000000);
    9bb0:	f7ff be2a 	b.w	9808 <wait_us>
    9bb4:	2009c03c 	.word	0x2009c03c
    9bb8:	000f4240 	.word	0x000f4240
    9bbc:	40000008 	.word	0x40000008

00009bc0 <get_part_num>:
	while (!(cc2400_status() & FS_LOCK));
	cc2400_strobe(SRX);
}

void get_part_num(uint8_t *buffer, int *len)
{
    9bc0:	b530      	push	{r4, r5, lr}
    9bc2:	b08b      	sub	sp, #44	; 0x2c
	u32 command[5];
	u32 result[5];
	command[0] = 54; /* read part number */
    9bc4:	2336      	movs	r3, #54	; 0x36
{
    9bc6:	4604      	mov	r4, r0
    9bc8:	460d      	mov	r5, r1
	command[0] = 54; /* read part number */
    9bca:	9300      	str	r3, [sp, #0]
	iap_entry(command, result);
    9bcc:	4668      	mov	r0, sp
    9bce:	4b08      	ldr	r3, [pc, #32]	; (9bf0 <get_part_num+0x30>)
    9bd0:	a905      	add	r1, sp, #20
    9bd2:	4798      	blx	r3
	buffer[0] = result[0] & 0xFF; /* status */
    9bd4:	9b05      	ldr	r3, [sp, #20]
    9bd6:	7023      	strb	r3, [r4, #0]
	buffer[1] = result[1] & 0xFF;
    9bd8:	9b06      	ldr	r3, [sp, #24]
	buffer[2] = (result[1] >> 8) & 0xFF;
    9bda:	0a1a      	lsrs	r2, r3, #8
	buffer[1] = result[1] & 0xFF;
    9bdc:	7063      	strb	r3, [r4, #1]
	buffer[2] = (result[1] >> 8) & 0xFF;
    9bde:	70a2      	strb	r2, [r4, #2]
	buffer[3] = (result[1] >> 16) & 0xFF;
    9be0:	0c1a      	lsrs	r2, r3, #16
	buffer[4] = (result[1] >> 24) & 0xFF;
    9be2:	0e1b      	lsrs	r3, r3, #24
    9be4:	7123      	strb	r3, [r4, #4]
	*len = 5;
    9be6:	2305      	movs	r3, #5
	buffer[3] = (result[1] >> 16) & 0xFF;
    9be8:	70e2      	strb	r2, [r4, #3]
	*len = 5;
    9bea:	602b      	str	r3, [r5, #0]
	
}
    9bec:	b00b      	add	sp, #44	; 0x2c
    9bee:	bd30      	pop	{r4, r5, pc}
    9bf0:	1fff1ff1 	.word	0x1fff1ff1

00009bf4 <get_device_serial>:

void get_device_serial(uint8_t *buffer, int *len)
{
    9bf4:	b530      	push	{r4, r5, lr}
    9bf6:	b08b      	sub	sp, #44	; 0x2c
	u32 command[5];
	u32 result[5];
	command[0] = 58; /* read device serial number */
    9bf8:	233a      	movs	r3, #58	; 0x3a
{
    9bfa:	4604      	mov	r4, r0
    9bfc:	460d      	mov	r5, r1
	command[0] = 58; /* read device serial number */
    9bfe:	9300      	str	r3, [sp, #0]
	iap_entry(command, result);
    9c00:	4668      	mov	r0, sp
    9c02:	4b14      	ldr	r3, [pc, #80]	; (9c54 <get_device_serial+0x60>)
    9c04:	a905      	add	r1, sp, #20
    9c06:	4798      	blx	r3
	buffer[0] = result[0] & 0xFF; /* status */
    9c08:	9b05      	ldr	r3, [sp, #20]
    9c0a:	7023      	strb	r3, [r4, #0]
	buffer[1] = result[1] & 0xFF;
    9c0c:	9b06      	ldr	r3, [sp, #24]
	buffer[2] = (result[1] >> 8) & 0xFF;
    9c0e:	0a1a      	lsrs	r2, r3, #8
	buffer[1] = result[1] & 0xFF;
    9c10:	7063      	strb	r3, [r4, #1]
	buffer[2] = (result[1] >> 8) & 0xFF;
    9c12:	70a2      	strb	r2, [r4, #2]
	buffer[3] = (result[1] >> 16) & 0xFF;
    9c14:	0c1a      	lsrs	r2, r3, #16
	buffer[4] = (result[1] >> 24) & 0xFF;
    9c16:	0e1b      	lsrs	r3, r3, #24
    9c18:	7123      	strb	r3, [r4, #4]
	buffer[5] = result[2] & 0xFF;
    9c1a:	9b07      	ldr	r3, [sp, #28]
	buffer[3] = (result[1] >> 16) & 0xFF;
    9c1c:	70e2      	strb	r2, [r4, #3]
	buffer[6] = (result[2] >> 8) & 0xFF;
    9c1e:	0a1a      	lsrs	r2, r3, #8
	buffer[5] = result[2] & 0xFF;
    9c20:	7163      	strb	r3, [r4, #5]
	buffer[6] = (result[2] >> 8) & 0xFF;
    9c22:	71a2      	strb	r2, [r4, #6]
	buffer[7] = (result[2] >> 16) & 0xFF;
    9c24:	0c1a      	lsrs	r2, r3, #16
	buffer[8] = (result[2] >> 24) & 0xFF;
    9c26:	0e1b      	lsrs	r3, r3, #24
    9c28:	7223      	strb	r3, [r4, #8]
	buffer[9] = result[3] & 0xFF;
    9c2a:	9b08      	ldr	r3, [sp, #32]
	buffer[7] = (result[2] >> 16) & 0xFF;
    9c2c:	71e2      	strb	r2, [r4, #7]
	buffer[10] = (result[3] >> 8) & 0xFF;
    9c2e:	0a1a      	lsrs	r2, r3, #8
	buffer[9] = result[3] & 0xFF;
    9c30:	7263      	strb	r3, [r4, #9]
	buffer[10] = (result[3] >> 8) & 0xFF;
    9c32:	72a2      	strb	r2, [r4, #10]
	buffer[11] = (result[3] >> 16) & 0xFF;
    9c34:	0c1a      	lsrs	r2, r3, #16
	buffer[12] = (result[3] >> 24) & 0xFF;
    9c36:	0e1b      	lsrs	r3, r3, #24
    9c38:	7323      	strb	r3, [r4, #12]
	buffer[13] = result[4] & 0xFF;
    9c3a:	9b09      	ldr	r3, [sp, #36]	; 0x24
	buffer[11] = (result[3] >> 16) & 0xFF;
    9c3c:	72e2      	strb	r2, [r4, #11]
	buffer[14] = (result[4] >> 8) & 0xFF;
    9c3e:	0a1a      	lsrs	r2, r3, #8
	buffer[13] = result[4] & 0xFF;
    9c40:	7363      	strb	r3, [r4, #13]
	buffer[14] = (result[4] >> 8) & 0xFF;
    9c42:	73a2      	strb	r2, [r4, #14]
	buffer[15] = (result[4] >> 16) & 0xFF;
    9c44:	0c1a      	lsrs	r2, r3, #16
	buffer[16] = (result[4] >> 24) & 0xFF;
    9c46:	0e1b      	lsrs	r3, r3, #24
    9c48:	7423      	strb	r3, [r4, #16]
	*len = 17;
    9c4a:	2311      	movs	r3, #17
	buffer[15] = (result[4] >> 16) & 0xFF;
    9c4c:	73e2      	strb	r2, [r4, #15]
	*len = 17;
    9c4e:	602b      	str	r3, [r5, #0]
}
    9c50:	b00b      	add	sp, #44	; 0x2c
    9c52:	bd30      	pop	{r4, r5, pc}
    9c54:	1fff1ff1 	.word	0x1fff1ff1

00009c58 <set_isp>:

void set_isp(void)
{
    9c58:	b500      	push	{lr}
    9c5a:	b08b      	sub	sp, #44	; 0x2c
	u32 command[5];
	u32 result[5];
	command[0] = 57;
    9c5c:	2339      	movs	r3, #57	; 0x39
	iap_entry(command, result);
    9c5e:	4668      	mov	r0, sp
	command[0] = 57;
    9c60:	9300      	str	r3, [sp, #0]
	iap_entry(command, result);
    9c62:	a905      	add	r1, sp, #20
    9c64:	4b02      	ldr	r3, [pc, #8]	; (9c70 <set_isp+0x18>)
    9c66:	4798      	blx	r3
}
    9c68:	b00b      	add	sp, #44	; 0x2c
    9c6a:	f85d fb04 	ldr.w	pc, [sp], #4
    9c6e:	bf00      	nop
    9c70:	1fff1ff1 	.word	0x1fff1ff1

00009c74 <DataIn>:

/**
	Sends next chunk of data (possibly 0 bytes) to host
 */
static void DataIn(void)
{
    9c74:	b538      	push	{r3, r4, r5, lr}
	int iChunk;

	iChunk = MIN(MAX_PACKET_SIZE0, iResidue);
    9c76:	4c08      	ldr	r4, [pc, #32]	; (9c98 <DataIn+0x24>)
	USBHwEPWrite(0x80, pbData, iChunk);
    9c78:	2080      	movs	r0, #128	; 0x80
	iChunk = MIN(MAX_PACKET_SIZE0, iResidue);
    9c7a:	6825      	ldr	r5, [r4, #0]
	USBHwEPWrite(0x80, pbData, iChunk);
    9c7c:	6861      	ldr	r1, [r4, #4]
	iChunk = MIN(MAX_PACKET_SIZE0, iResidue);
    9c7e:	2d40      	cmp	r5, #64	; 0x40
    9c80:	bfa8      	it	ge
    9c82:	2540      	movge	r5, #64	; 0x40
	USBHwEPWrite(0x80, pbData, iChunk);
    9c84:	462a      	mov	r2, r5
    9c86:	f000 f951 	bl	9f2c <USBHwEPWrite>
	pbData += iChunk;
    9c8a:	6863      	ldr	r3, [r4, #4]
	iResidue -= iChunk;
    9c8c:	6822      	ldr	r2, [r4, #0]
	pbData += iChunk;
    9c8e:	442b      	add	r3, r5
	iResidue -= iChunk;
    9c90:	1b52      	subs	r2, r2, r5
	pbData += iChunk;
    9c92:	6063      	str	r3, [r4, #4]
	iResidue -= iChunk;
    9c94:	6022      	str	r2, [r4, #0]
}
    9c96:	bd38      	pop	{r3, r4, r5, pc}
    9c98:	10002348 	.word	0x10002348

00009c9c <_HandleRequest.constprop.0>:
static BOOL _HandleRequest(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
    9c9c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	iType = REQTYPE_GET_TYPE(pSetup->bmRequestType);
    9c9e:	4810      	ldr	r0, [pc, #64]	; (9ce0 <_HandleRequest.constprop.0+0x44>)
    9ca0:	7a04      	ldrb	r4, [r0, #8]
    9ca2:	4605      	mov	r5, r0
    9ca4:	f3c4 1441 	ubfx	r4, r4, #5, #2
	if(iType == REQTYPE_TYPE_VENDOR) {
    9ca8:	2c02      	cmp	r4, #2
    9caa:	d10c      	bne.n	9cc6 <_HandleRequest.constprop.0+0x2a>
		BOOL fFilterStatus = FALSE;
    9cac:	2300      	movs	r3, #0
		if(USBFilterOsVendorMessage(pSetup, &fFilterStatus, piLen, ppbData)) {
    9cae:	f100 0210 	add.w	r2, r0, #16
		BOOL fFilterStatus = FALSE;
    9cb2:	9301      	str	r3, [sp, #4]
		if(USBFilterOsVendorMessage(pSetup, &fFilterStatus, piLen, ppbData)) {
    9cb4:	a901      	add	r1, sp, #4
    9cb6:	1d03      	adds	r3, r0, #4
    9cb8:	3008      	adds	r0, #8
    9cba:	f000 fa5d 	bl	a178 <USBFilterOsVendorMessage>
    9cbe:	b110      	cbz	r0, 9cc6 <_HandleRequest.constprop.0+0x2a>
			return fFilterStatus;
    9cc0:	9801      	ldr	r0, [sp, #4]
}
    9cc2:	b003      	add	sp, #12
    9cc4:	bd30      	pop	{r4, r5, pc}
	pfnHandler = apfnReqHandlers[iType];
    9cc6:	eb05 0484 	add.w	r4, r5, r4, lsl #2
    9cca:	6963      	ldr	r3, [r4, #20]
	if (pfnHandler == NULL) {
    9ccc:	b12b      	cbz	r3, 9cda <_HandleRequest.constprop.0+0x3e>
	return pfnHandler(pSetup, piLen, ppbData);
    9cce:	4a05      	ldr	r2, [pc, #20]	; (9ce4 <_HandleRequest.constprop.0+0x48>)
    9cd0:	f102 010c 	add.w	r1, r2, #12
    9cd4:	1d10      	adds	r0, r2, #4
    9cd6:	4798      	blx	r3
    9cd8:	e7f3      	b.n	9cc2 <_HandleRequest.constprop.0+0x26>
		return FALSE;
    9cda:	4618      	mov	r0, r3
    9cdc:	e7f1      	b.n	9cc2 <_HandleRequest.constprop.0+0x26>
    9cde:	bf00      	nop
    9ce0:	10002348 	.word	0x10002348
    9ce4:	1000234c 	.word	0x1000234c

00009ce8 <USBHandleControlTransfer>:
 *
 *	@param [in]	bEP		Endpoint address
 *	@param [in]	bEPStat	Endpoint status
 */
void USBHandleControlTransfer(U8 bEP, U8 bEPStat)
{
    9ce8:	b510      	push	{r4, lr}
	int iChunk, iType;

	if (bEP == 0x00) {
    9cea:	2800      	cmp	r0, #0
    9cec:	d147      	bne.n	9d7e <USBHandleControlTransfer+0x96>
		// OUT transfer
		if (bEPStat & EP_STATUS_SETUP) {
    9cee:	f011 0104 	ands.w	r1, r1, #4
    9cf2:	4c24      	ldr	r4, [pc, #144]	; (9d84 <USBHandleControlTransfer+0x9c>)
    9cf4:	d023      	beq.n	9d3e <USBHandleControlTransfer+0x56>
			// setup packet, reset request message state machine
			USBHwEPRead(0x00, (U8 *)&Setup, sizeof(Setup));
    9cf6:	2208      	movs	r2, #8
    9cf8:	18a1      	adds	r1, r4, r2
    9cfa:	f000 f93f 	bl	9f7c <USBHwEPRead>
			DBG("S%x", Setup.bRequest);

			// defaults for data pointer and residue
			iType = REQTYPE_GET_TYPE(Setup.bmRequestType);
    9cfe:	7a22      	ldrb	r2, [r4, #8]
    9d00:	f3c2 1341 	ubfx	r3, r2, #5, #2
			pbData = apbDataStore[iType];
    9d04:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    9d08:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    9d0a:	6063      	str	r3, [r4, #4]
			iResidue = Setup.wLength;
    9d0c:	89e3      	ldrh	r3, [r4, #14]
    9d0e:	6023      	str	r3, [r4, #0]
			iLen = Setup.wLength;
    9d10:	6123      	str	r3, [r4, #16]

			if ((Setup.wLength == 0) ||
    9d12:	b10b      	cbz	r3, 9d18 <USBHandleControlTransfer+0x30>
    9d14:	09d3      	lsrs	r3, r2, #7
    9d16:	d034      	beq.n	9d82 <USBHandleControlTransfer+0x9a>
				(REQTYPE_GET_DIR(Setup.bmRequestType) == REQTYPE_DIR_TO_HOST)) {
				// ask installed handler to process request
				if (!_HandleRequest(&Setup, &iLen, &pbData)) {
    9d18:	f7ff ffc0 	bl	9c9c <_HandleRequest.constprop.0>
    9d1c:	b928      	cbnz	r0, 9d2a <USBHandleControlTransfer+0x42>
		DataIn();
	}
	else {
		ASSERT(FALSE);
	}
}
    9d1e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USBHwEPStall(0x80, TRUE);
    9d22:	2101      	movs	r1, #1
    9d24:	2080      	movs	r0, #128	; 0x80
    9d26:	f000 b8f5 	b.w	9f14 <USBHwEPStall>
				iResidue = MIN(iLen, Setup.wLength);
    9d2a:	89e2      	ldrh	r2, [r4, #14]
    9d2c:	6923      	ldr	r3, [r4, #16]
    9d2e:	429a      	cmp	r2, r3
    9d30:	bfd4      	ite	le
    9d32:	6022      	strle	r2, [r4, #0]
    9d34:	6023      	strgt	r3, [r4, #0]
}
    9d36:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
					DataIn();
    9d3a:	f7ff bf9b 	b.w	9c74 <DataIn>
			if (iResidue > 0) {
    9d3e:	6822      	ldr	r2, [r4, #0]
    9d40:	2a00      	cmp	r2, #0
    9d42:	dd17      	ble.n	9d74 <USBHandleControlTransfer+0x8c>
				iChunk = USBHwEPRead(0x00, pbData, iResidue);
    9d44:	6861      	ldr	r1, [r4, #4]
    9d46:	f000 f919 	bl	9f7c <USBHwEPRead>
				if (iChunk < 0) {
    9d4a:	2800      	cmp	r0, #0
    9d4c:	dbe7      	blt.n	9d1e <USBHandleControlTransfer+0x36>
				pbData += iChunk;
    9d4e:	6863      	ldr	r3, [r4, #4]
    9d50:	4403      	add	r3, r0
    9d52:	6063      	str	r3, [r4, #4]
				iResidue -= iChunk;
    9d54:	6823      	ldr	r3, [r4, #0]
    9d56:	1a18      	subs	r0, r3, r0
    9d58:	6020      	str	r0, [r4, #0]
				if (iResidue == 0) {
    9d5a:	b990      	cbnz	r0, 9d82 <USBHandleControlTransfer+0x9a>
					iType = REQTYPE_GET_TYPE(Setup.bmRequestType);
    9d5c:	7a23      	ldrb	r3, [r4, #8]
    9d5e:	f3c3 1341 	ubfx	r3, r3, #5, #2
					pbData = apbDataStore[iType];
    9d62:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    9d66:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    9d68:	6063      	str	r3, [r4, #4]
					if (!_HandleRequest(&Setup, &iLen, &pbData)) {
    9d6a:	f7ff ff97 	bl	9c9c <_HandleRequest.constprop.0>
    9d6e:	2800      	cmp	r0, #0
    9d70:	d1e1      	bne.n	9d36 <USBHandleControlTransfer+0x4e>
    9d72:	e7d4      	b.n	9d1e <USBHandleControlTransfer+0x36>
				iChunk = USBHwEPRead(0x00, NULL, 0);
    9d74:	460a      	mov	r2, r1
}
    9d76:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				iChunk = USBHwEPRead(0x00, NULL, 0);
    9d7a:	f000 b8ff 	b.w	9f7c <USBHwEPRead>
	else if (bEP == 0x80) {
    9d7e:	2880      	cmp	r0, #128	; 0x80
    9d80:	d0d9      	beq.n	9d36 <USBHandleControlTransfer+0x4e>
}
    9d82:	bd10      	pop	{r4, pc}
    9d84:	10002348 	.word	0x10002348

00009d88 <USBRegisterRequestHandler>:
 */
void USBRegisterRequestHandler(int iType, TFnHandleRequest *pfnHandler, U8 *pbDataStore)
{
	ASSERT(iType >= 0);
	ASSERT(iType < 4);
	apfnReqHandlers[iType] = pfnHandler;
    9d88:	4b02      	ldr	r3, [pc, #8]	; (9d94 <USBRegisterRequestHandler+0xc>)
    9d8a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    9d8e:	6141      	str	r1, [r0, #20]
	apbDataStore[iType] = pbDataStore;
    9d90:	6242      	str	r2, [r0, #36]	; 0x24
}
    9d92:	4770      	bx	lr
    9d94:	10002348 	.word	0x10002348

00009d98 <HandleUsbReset>:
static void HandleUsbReset(U8 bDevStatus)
{
	if (bDevStatus & DEV_STATUS_RESET) {
		DBG("\n!");
	}
}
    9d98:	4770      	bx	lr
    9d9a:	0000      	movs	r0, r0

00009d9c <USBInit>:
	installing default callbacks.
	
	@return TRUE if initialisation was successful
 */
BOOL USBInit(void)
{
    9d9c:	b510      	push	{r4, lr}
	
	// register bus reset handler
	USBHwRegisterDevIntHandler(HandleUsbReset);
	
	// register control transfer handler on EP0
	USBHwRegisterEPIntHandler(0x00, USBHandleControlTransfer);
    9d9e:	4c0e      	ldr	r4, [pc, #56]	; (9dd8 <USBInit+0x3c>)
	USBHwInit();
    9da0:	f000 f990 	bl	a0c4 <USBHwInit>
	USBHwRegisterDevIntHandler(HandleUsbReset);
    9da4:	480d      	ldr	r0, [pc, #52]	; (9ddc <USBInit+0x40>)
    9da6:	f000 f87f 	bl	9ea8 <USBHwRegisterDevIntHandler>
	USBHwRegisterEPIntHandler(0x00, USBHandleControlTransfer);
    9daa:	4621      	mov	r1, r4
    9dac:	2000      	movs	r0, #0
    9dae:	f000 f861 	bl	9e74 <USBHwRegisterEPIntHandler>
	USBHwRegisterEPIntHandler(0x80, USBHandleControlTransfer);
    9db2:	4621      	mov	r1, r4
    9db4:	2080      	movs	r0, #128	; 0x80
    9db6:	f000 f85d 	bl	9e74 <USBHwRegisterEPIntHandler>
	
	// setup control endpoints
	USBHwEPConfig(0x00, MAX_PACKET_SIZE0);
    9dba:	2140      	movs	r1, #64	; 0x40
    9dbc:	2000      	movs	r0, #0
    9dbe:	f000 f83b 	bl	9e38 <USBHwEPConfig>
	USBHwEPConfig(0x80, MAX_PACKET_SIZE0);
    9dc2:	2140      	movs	r1, #64	; 0x40
    9dc4:	2080      	movs	r0, #128	; 0x80
    9dc6:	f000 f837 	bl	9e38 <USBHwEPConfig>
	
	// register standard request handler
	USBRegisterRequestHandler(REQTYPE_TYPE_STANDARD, USBHandleStandardRequest, abStdReqData);
    9dca:	2000      	movs	r0, #0
    9dcc:	4a04      	ldr	r2, [pc, #16]	; (9de0 <USBInit+0x44>)
    9dce:	4905      	ldr	r1, [pc, #20]	; (9de4 <USBInit+0x48>)
    9dd0:	f7ff ffda 	bl	9d88 <USBRegisterRequestHandler>

	return TRUE;
}
    9dd4:	2001      	movs	r0, #1
    9dd6:	bd10      	pop	{r4, pc}
    9dd8:	00009ce9 	.word	0x00009ce9
    9ddc:	00009d99 	.word	0x00009d99
    9de0:	1000237c 	.word	0x1000237c
    9de4:	0000a26d 	.word	0x0000a26d

00009de8 <Wait4DevInt>:
    @param [in] dwIntr      Bitmask of interrupts to wait for   
 */
static void Wait4DevInt(U32 dwIntr)
{
    // wait for specific interrupt
    while ((USBDevIntSt & dwIntr) != dwIntr);
    9de8:	4a03      	ldr	r2, [pc, #12]	; (9df8 <Wait4DevInt+0x10>)
    9dea:	6813      	ldr	r3, [r2, #0]
    9dec:	ea30 0303 	bics.w	r3, r0, r3
    9df0:	d1fb      	bne.n	9dea <Wait4DevInt+0x2>
    // clear the interrupt bits
    USBDevIntClr = dwIntr;
    9df2:	4b02      	ldr	r3, [pc, #8]	; (9dfc <Wait4DevInt+0x14>)
    9df4:	6018      	str	r0, [r3, #0]
}
    9df6:	4770      	bx	lr
    9df8:	5000c200 	.word	0x5000c200
    9dfc:	5000c208 	.word	0x5000c208

00009e00 <USBHwCmd>:
    @param [in] bCmd        Command to send
 */
static void USBHwCmd(U8 bCmd)
{
    // clear CDFULL/CCEMTY
    USBDevIntClr = CDFULL | CCEMTY;
    9e00:	2230      	movs	r2, #48	; 0x30
    9e02:	4b04      	ldr	r3, [pc, #16]	; (9e14 <USBHwCmd+0x14>)
    // write command code
    USBCmdCode = 0x00000500 | (bCmd << 16);
    9e04:	0400      	lsls	r0, r0, #16
    9e06:	f440 60a0 	orr.w	r0, r0, #1280	; 0x500
    USBDevIntClr = CDFULL | CCEMTY;
    9e0a:	601a      	str	r2, [r3, #0]
    USBCmdCode = 0x00000500 | (bCmd << 16);
    9e0c:	6098      	str	r0, [r3, #8]
    Wait4DevInt(CCEMTY);
    9e0e:	2010      	movs	r0, #16
    9e10:	f7ff bfea 	b.w	9de8 <Wait4DevInt>
    9e14:	5000c208 	.word	0x5000c208

00009e18 <USBHwCmdWrite>:
        
    @param [in] bCmd        Command to send
    @param [in] bData       Data to send
 */
static void USBHwCmdWrite(U8 bCmd, U16 bData)
{
    9e18:	b508      	push	{r3, lr}
    // write command code
    USBHwCmd(bCmd);
    9e1a:	f7ff fff1 	bl	9e00 <USBHwCmd>

    // write command data
    USBCmdCode = 0x00000100 | (bData << 16);
    9e1e:	4b05      	ldr	r3, [pc, #20]	; (9e34 <USBHwCmdWrite+0x1c>)
    9e20:	0409      	lsls	r1, r1, #16
    9e22:	f441 7180 	orr.w	r1, r1, #256	; 0x100
    9e26:	6019      	str	r1, [r3, #0]
    Wait4DevInt(CCEMTY);
    9e28:	2010      	movs	r0, #16
}
    9e2a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Wait4DevInt(CCEMTY);
    9e2e:	f7ff bfdb 	b.w	9de8 <Wait4DevInt>
    9e32:	bf00      	nop
    9e34:	5000c210 	.word	0x5000c210

00009e38 <USBHwEPConfig>:
        
    @param [in] bEP             Endpoint number
    @param [in] wMaxPacketSize  Maximum packet size for this EP
 */
void USBHwEPConfig(U8 bEP, U16 wMaxPacketSize)
{
    9e38:	b510      	push	{r4, lr}
    USBReEp |= (1 << idx);
    9e3a:	2301      	movs	r3, #1
    9e3c:	4a0b      	ldr	r2, [pc, #44]	; (9e6c <USBHwEPConfig+0x34>)
    int idx;
    
    idx = EP2IDX(bEP);
    9e3e:	0044      	lsls	r4, r0, #1
    9e40:	f004 041e 	and.w	r4, r4, #30
    9e44:	ea44 14d0 	orr.w	r4, r4, r0, lsr #7
    USBReEp |= (1 << idx);
    9e48:	6810      	ldr	r0, [r2, #0]
    9e4a:	40a3      	lsls	r3, r4
    9e4c:	4303      	orrs	r3, r0
    9e4e:	6013      	str	r3, [r2, #0]
    USBEpIn = idx;
    9e50:	4b07      	ldr	r3, [pc, #28]	; (9e70 <USBHwEPConfig+0x38>)
    Wait4DevInt(EP_RLZED);
    9e52:	f44f 7080 	mov.w	r0, #256	; 0x100
    USBEpIn = idx;
    9e56:	601c      	str	r4, [r3, #0]
    USBMaxPSize = wMaxPSize;
    9e58:	6059      	str	r1, [r3, #4]
    Wait4DevInt(EP_RLZED);
    9e5a:	f7ff ffc5 	bl	9de8 <Wait4DevInt>
    USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fEnable ? 0 : EP_DA);
    9e5e:	f044 0040 	orr.w	r0, r4, #64	; 0x40
    9e62:	2100      	movs	r1, #0
    // realise EP
    USBHwEPRealize(idx, wMaxPacketSize);

    // enable EP
    USBHwEPEnable(idx, TRUE);
}
    9e64:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fEnable ? 0 : EP_DA);
    9e68:	f7ff bfd6 	b.w	9e18 <USBHwCmdWrite>
    9e6c:	5000c244 	.word	0x5000c244
    9e70:	5000c248 	.word	0x5000c248

00009e74 <USBHwRegisterEPIntHandler>:
    idx = EP2IDX(bEP);

    ASSERT(idx<32);

    /* add handler to list of EP handlers */
    _apfnEPIntHandlers[idx / 2] = pfnHandler;
    9e74:	4a0a      	ldr	r2, [pc, #40]	; (9ea0 <USBHwRegisterEPIntHandler+0x2c>)
    idx = EP2IDX(bEP);
    9e76:	0043      	lsls	r3, r0, #1
    9e78:	f003 031e 	and.w	r3, r3, #30
    _apfnEPIntHandlers[idx / 2] = pfnHandler;
    9e7c:	f842 1013 	str.w	r1, [r2, r3, lsl #1]
    idx = EP2IDX(bEP);
    9e80:	ea43 10d0 	orr.w	r0, r3, r0, lsr #7
    
    /* enable EP interrupt */
    USBEpIntEn |= (1 << idx);
    9e84:	2301      	movs	r3, #1
    9e86:	4a07      	ldr	r2, [pc, #28]	; (9ea4 <USBHwRegisterEPIntHandler+0x30>)
    9e88:	fa03 f000 	lsl.w	r0, r3, r0
    9e8c:	6811      	ldr	r1, [r2, #0]
    9e8e:	4308      	orrs	r0, r1
    9e90:	6010      	str	r0, [r2, #0]
    USBDevIntEn |= EP_SLOW;
    9e92:	f852 3c30 	ldr.w	r3, [r2, #-48]
    9e96:	f043 0304 	orr.w	r3, r3, #4
    9e9a:	f842 3c30 	str.w	r3, [r2, #-48]
    
    DBG("Registered handler for EP 0x%x\n", bEP);
}
    9e9e:	4770      	bx	lr
    9ea0:	10002384 	.word	0x10002384
    9ea4:	5000c234 	.word	0x5000c234

00009ea8 <USBHwRegisterDevIntHandler>:
        
    @param [in] pfnHandler  Callback function
 */
void USBHwRegisterDevIntHandler(TFnDevIntHandler *pfnHandler)
{
    _pfnDevIntHandler = pfnHandler;
    9ea8:	4b03      	ldr	r3, [pc, #12]	; (9eb8 <USBHwRegisterDevIntHandler+0x10>)
    
    // enable device interrupt
    USBDevIntEn |= DEV_STAT;
    9eaa:	4a04      	ldr	r2, [pc, #16]	; (9ebc <USBHwRegisterDevIntHandler+0x14>)
    _pfnDevIntHandler = pfnHandler;
    9eac:	6418      	str	r0, [r3, #64]	; 0x40
    USBDevIntEn |= DEV_STAT;
    9eae:	6813      	ldr	r3, [r2, #0]
    9eb0:	f043 0308 	orr.w	r3, r3, #8
    9eb4:	6013      	str	r3, [r2, #0]

    DBG("Registered handler for device status\n");
}
    9eb6:	4770      	bx	lr
    9eb8:	10002384 	.word	0x10002384
    9ebc:	5000c204 	.word	0x5000c204

00009ec0 <USBHwSetAddress>:
        
    @param [in] bAddr       Device address to set
 */
void USBHwSetAddress(U8 bAddr)
{
    USBHwCmdWrite(CMD_DEV_SET_ADDRESS, DEV_EN | bAddr);
    9ec0:	f040 0180 	orr.w	r1, r0, #128	; 0x80
    9ec4:	20d0      	movs	r0, #208	; 0xd0
    9ec6:	f7ff bfa7 	b.w	9e18 <USBHwCmdWrite>

00009eca <USBHwConnect>:
    FIO0CLR = (1<<14);
  else
    FIO0SET = (1<<14);
#endif
#endif
    USBHwCmdWrite(CMD_DEV_STATUS, fConnect ? CON : 0);
    9eca:	1e01      	subs	r1, r0, #0
    9ecc:	bf18      	it	ne
    9ece:	2101      	movne	r1, #1
    9ed0:	20fe      	movs	r0, #254	; 0xfe
    9ed2:	f7ff bfa1 	b.w	9e18 <USBHwCmdWrite>

00009ed6 <USBHwNakIntEnable>:
    from NAK interrupt by checking the bits in their bEPStatus argument.
    
    @param [in] bIntBits    Bitmap indicating which NAK interrupts to enable
 */
void USBHwNakIntEnable(U8 bIntBits)
{
    9ed6:	4601      	mov	r1, r0
    USBHwCmdWrite(CMD_DEV_SET_MODE, bIntBits);
    9ed8:	20f3      	movs	r0, #243	; 0xf3
    9eda:	f7ff bf9d 	b.w	9e18 <USBHwCmdWrite>
    9ede:	0000      	movs	r0, r0

00009ee0 <USBHwEPGetStatus>:
        
    @param [in] bEP     Endpoint number
    @return Endpoint status byte (containing EP_STATUS_xxx bits)
 */
U8  USBHwEPGetStatus(U8 bEP)
{
    9ee0:	b508      	push	{r3, lr}
    int idx = EP2IDX(bEP);
    9ee2:	0043      	lsls	r3, r0, #1
    9ee4:	f003 031e 	and.w	r3, r3, #30
    9ee8:	ea43 11d0 	orr.w	r1, r3, r0, lsr #7
    USBHwCmd(bCmd);
    9eec:	4608      	mov	r0, r1
    9eee:	f7ff ff87 	bl	9e00 <USBHwCmd>
    USBCmdCode = 0x00000200 | (bCmd << 16);
    9ef2:	4b06      	ldr	r3, [pc, #24]	; (9f0c <USBHwEPGetStatus+0x2c>)
    9ef4:	0409      	lsls	r1, r1, #16
    9ef6:	f441 7100 	orr.w	r1, r1, #512	; 0x200
    9efa:	6019      	str	r1, [r3, #0]
    Wait4DevInt(CDFULL);
    9efc:	2020      	movs	r0, #32
    9efe:	f7ff ff73 	bl	9de8 <Wait4DevInt>
    return USBCmdData;
    9f02:	4b03      	ldr	r3, [pc, #12]	; (9f10 <USBHwEPGetStatus+0x30>)
    9f04:	6818      	ldr	r0, [r3, #0]

    return USBHwCmdRead(CMD_EP_SELECT | idx);
}
    9f06:	b2c0      	uxtb	r0, r0
    9f08:	bd08      	pop	{r3, pc}
    9f0a:	bf00      	nop
    9f0c:	5000c210 	.word	0x5000c210
    9f10:	5000c214 	.word	0x5000c214

00009f14 <USBHwEPStall>:
    @param [in] bEP     Endpoint number
    @param [in] fStall  TRUE to stall, FALSE to unstall
 */
void USBHwEPStall(U8 bEP, BOOL fStall)
{
    int idx = EP2IDX(bEP);
    9f14:	0043      	lsls	r3, r0, #1
    9f16:	f003 031e 	and.w	r3, r3, #30
    9f1a:	ea43 10d0 	orr.w	r0, r3, r0, lsr #7

    USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fStall ? EP_ST : 0);
    9f1e:	3900      	subs	r1, #0
    9f20:	bf18      	it	ne
    9f22:	2101      	movne	r1, #1
    9f24:	f040 0040 	orr.w	r0, r0, #64	; 0x40
    9f28:	f7ff bf76 	b.w	9e18 <USBHwCmdWrite>

00009f2c <USBHwEPWrite>:
    @param [in] iLen    Number of bytes to write
            
    @return number of bytes written into the endpoint buffer
*/
int USBHwEPWrite(U8 bEP, U8 *pbBuf, U32 iLen)
{
    9f2c:	b538      	push	{r3, r4, r5, lr}
    9f2e:	4603      	mov	r3, r0
    9f30:	4615      	mov	r5, r2
    U32 idx;
    
    idx = EP2IDX(bEP);
    9f32:	0040      	lsls	r0, r0, #1
    9f34:	f000 001e 	and.w	r0, r0, #30
    9f38:	ea40 10d3 	orr.w	r0, r0, r3, lsr #7
    
    // set write enable for specific endpoint
    USBCtrl = WR_EN | ((bEP & 0xF) << 2);
    9f3c:	009b      	lsls	r3, r3, #2
    9f3e:	4c0d      	ldr	r4, [pc, #52]	; (9f74 <USBHwEPWrite+0x48>)
    9f40:	f003 033c 	and.w	r3, r3, #60	; 0x3c
    9f44:	f043 0302 	orr.w	r3, r3, #2
    9f48:	6023      	str	r3, [r4, #0]
    
    // set packet length
    USBTxPLen = iLen;
    9f4a:	4b0b      	ldr	r3, [pc, #44]	; (9f78 <USBHwEPWrite+0x4c>)
    9f4c:	601a      	str	r2, [r3, #0]
    
    // write data
    while (USBCtrl & WR_EN) {
    9f4e:	4623      	mov	r3, r4
        USBTxData = (pbBuf[3] << 24) | (pbBuf[2] << 16) | (pbBuf[1] << 8) | pbBuf[0];
    9f50:	3c0c      	subs	r4, #12
    while (USBCtrl & WR_EN) {
    9f52:	681a      	ldr	r2, [r3, #0]
    9f54:	f012 0202 	ands.w	r2, r2, #2
    9f58:	d107      	bne.n	9f6a <USBHwEPWrite+0x3e>
        pbBuf += 4;
    }

    USBCtrl = 0;
    9f5a:	601a      	str	r2, [r3, #0]

    // select endpoint and validate buffer
    USBHwCmd(CMD_EP_SELECT | idx);
    9f5c:	f7ff ff50 	bl	9e00 <USBHwCmd>
    USBHwCmd(CMD_EP_VALIDATE_BUFFER);
    9f60:	20fa      	movs	r0, #250	; 0xfa
    9f62:	f7ff ff4d 	bl	9e00 <USBHwCmd>
    
    return iLen;
}
    9f66:	4628      	mov	r0, r5
    9f68:	bd38      	pop	{r3, r4, r5, pc}
        USBTxData = (pbBuf[3] << 24) | (pbBuf[2] << 16) | (pbBuf[1] << 8) | pbBuf[0];
    9f6a:	f851 2b04 	ldr.w	r2, [r1], #4
    9f6e:	6022      	str	r2, [r4, #0]
        pbBuf += 4;
    9f70:	e7ef      	b.n	9f52 <USBHwEPWrite+0x26>
    9f72:	bf00      	nop
    9f74:	5000c228 	.word	0x5000c228
    9f78:	5000c224 	.word	0x5000c224

00009f7c <USBHwEPRead>:
            
    @return the number of bytes available in the EP (possibly more than iMaxLen),
    or <0 in case of error.
 */
int USBHwEPRead(U8 bEP, U8 *pbBuf, U32 iMaxLen)
{
    9f7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9f7e:	4603      	mov	r3, r0
    U32 i, idx;
    U32 dwData, dwLen;
    
    idx = EP2IDX(bEP);
    9f80:	0040      	lsls	r0, r0, #1
    9f82:	f000 001e 	and.w	r0, r0, #30
    9f86:	ea40 10d3 	orr.w	r0, r0, r3, lsr #7
    
    // set read enable bit for specific endpoint
    USBCtrl = RD_EN | ((bEP & 0xF) << 2);
    9f8a:	009b      	lsls	r3, r3, #2
    9f8c:	4e14      	ldr	r6, [pc, #80]	; (9fe0 <USBHwEPRead+0x64>)
    9f8e:	f003 033c 	and.w	r3, r3, #60	; 0x3c
    9f92:	f043 0301 	orr.w	r3, r3, #1
    
    // wait for PKT_RDY
    do {
        dwLen = USBRxPLen;
    9f96:	4c13      	ldr	r4, [pc, #76]	; (9fe4 <USBHwEPRead+0x68>)
    USBCtrl = RD_EN | ((bEP & 0xF) << 2);
    9f98:	6033      	str	r3, [r6, #0]
        dwLen = USBRxPLen;
    9f9a:	6823      	ldr	r3, [r4, #0]
    } while ((dwLen & PKT_RDY) == 0);
    9f9c:	051d      	lsls	r5, r3, #20
    9f9e:	d5fc      	bpl.n	9f9a <USBHwEPRead+0x1e>
    
    // packet valid?
    if ((dwLen & DV) == 0) {
    9fa0:	055c      	lsls	r4, r3, #21
    9fa2:	d51a      	bpl.n	9fda <USBHwEPRead+0x5e>
    
    // get length
    dwLen &= PKT_LNGTH_MASK;
    
    // get data
    dwData = 0;
    9fa4:	2500      	movs	r5, #0
    for (i = 0; i < dwLen; i++) {
    9fa6:	462c      	mov	r4, r5
        if ((i % 4) == 0) {
            dwData = USBRxData;
    9fa8:	4f0f      	ldr	r7, [pc, #60]	; (9fe8 <USBHwEPRead+0x6c>)
    dwLen &= PKT_LNGTH_MASK;
    9faa:	f3c3 0309 	ubfx	r3, r3, #0, #10
    for (i = 0; i < dwLen; i++) {
    9fae:	429c      	cmp	r4, r3
    9fb0:	d108      	bne.n	9fc4 <USBHwEPRead+0x48>
        }
        dwData >>= 8;
    }

    // make sure RD_EN is clear
    USBCtrl = 0;
    9fb2:	2300      	movs	r3, #0
    9fb4:	6033      	str	r3, [r6, #0]

    // select endpoint and clear buffer
    USBHwCmd(CMD_EP_SELECT | idx);
    9fb6:	f7ff ff23 	bl	9e00 <USBHwCmd>
    USBHwCmd(CMD_EP_CLEAR_BUFFER);
    9fba:	20f2      	movs	r0, #242	; 0xf2
    9fbc:	f7ff ff20 	bl	9e00 <USBHwCmd>
    
    return dwLen;
    9fc0:	4620      	mov	r0, r4
}
    9fc2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if ((i % 4) == 0) {
    9fc4:	f014 0f03 	tst.w	r4, #3
            dwData = USBRxData;
    9fc8:	bf08      	it	eq
    9fca:	683d      	ldreq	r5, [r7, #0]
        if ((pbBuf != NULL) && (i < iMaxLen)) {
    9fcc:	b111      	cbz	r1, 9fd4 <USBHwEPRead+0x58>
    9fce:	4294      	cmp	r4, r2
            pbBuf[i] = dwData & 0xFF;
    9fd0:	bf38      	it	cc
    9fd2:	550d      	strbcc	r5, [r1, r4]
        dwData >>= 8;
    9fd4:	0a2d      	lsrs	r5, r5, #8
    for (i = 0; i < dwLen; i++) {
    9fd6:	3401      	adds	r4, #1
    9fd8:	e7e9      	b.n	9fae <USBHwEPRead+0x32>
        return -1;
    9fda:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    9fde:	e7f0      	b.n	9fc2 <USBHwEPRead+0x46>
    9fe0:	5000c228 	.word	0x5000c228
    9fe4:	5000c220 	.word	0x5000c220
    9fe8:	5000c218 	.word	0x5000c218

00009fec <USBHwConfigDevice>:
    @param [in] fConfigured If TRUE, configure device, else unconfigure
 */
void USBHwConfigDevice(BOOL fConfigured)
{
    // set configured bit
    USBHwCmdWrite(CMD_DEV_CONFIG, fConfigured ? CONF_DEVICE : 0);
    9fec:	1e01      	subs	r1, r0, #0
    9fee:	bf18      	it	ne
    9ff0:	2101      	movne	r1, #1
    9ff2:	20d8      	movs	r0, #216	; 0xd8
    9ff4:	f7ff bf10 	b.w	9e18 <USBHwCmdWrite>

00009ff8 <USBHwISR>:
    @todo Get all 11 bits of frame number instead of just 8

    Endpoint interrupts are mapped to the slow interrupt
 */
void USBHwISR(void)
{
    9ff8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

// LED9 monitors total time in interrupt routine
DEBUG_LED_ON(9);

    // handle device interrupts
    dwStatus = USBDevIntSt;
    9ffa:	4b29      	ldr	r3, [pc, #164]	; (a0a0 <USBHwISR+0xa8>)
    9ffc:	681c      	ldr	r4, [r3, #0]
    
    // frame interrupt
    if (dwStatus & FRAME) {
    9ffe:	07e1      	lsls	r1, r4, #31
    a000:	d511      	bpl.n	a026 <USBHwISR+0x2e>
        // clear int
        USBDevIntClr = FRAME;
    a002:	2201      	movs	r2, #1
    a004:	609a      	str	r2, [r3, #8]
        // call handler
        if (_pfnFrameHandler != NULL) {
    a006:	4b27      	ldr	r3, [pc, #156]	; (a0a4 <USBHwISR+0xac>)
    a008:	6c59      	ldr	r1, [r3, #68]	; 0x44
    a00a:	b161      	cbz	r1, a026 <USBHwISR+0x2e>
    USBHwCmd(bCmd);
    a00c:	20f5      	movs	r0, #245	; 0xf5
    a00e:	f7ff fef7 	bl	9e00 <USBHwCmd>
    USBCmdCode = 0x00000200 | (bCmd << 16);
    a012:	4b25      	ldr	r3, [pc, #148]	; (a0a8 <USBHwISR+0xb0>)
    a014:	4a25      	ldr	r2, [pc, #148]	; (a0ac <USBHwISR+0xb4>)
    Wait4DevInt(CDFULL);
    a016:	2020      	movs	r0, #32
    USBCmdCode = 0x00000200 | (bCmd << 16);
    a018:	601a      	str	r2, [r3, #0]
    Wait4DevInt(CDFULL);
    a01a:	f7ff fee5 	bl	9de8 <Wait4DevInt>
    return USBCmdData;
    a01e:	4b24      	ldr	r3, [pc, #144]	; (a0b0 <USBHwISR+0xb8>)
    a020:	6818      	ldr	r0, [r3, #0]
            wFrame = USBHwCmdRead(CMD_DEV_READ_CUR_FRAME_NR);
            _pfnFrameHandler(wFrame);
    a022:	b2c0      	uxtb	r0, r0
    a024:	4788      	blx	r1
        }
    }
    
    // device status interrupt
    if (dwStatus & DEV_STAT) {
    a026:	0722      	lsls	r2, r4, #28
    a028:	d517      	bpl.n	a05a <USBHwISR+0x62>
        /*  Clear DEV_STAT interrupt before reading DEV_STAT register.
            This prevents corrupted device status reads, see
            LPC2148 User manual revision 2, 25 july 2006.
        */
        USBDevIntClr = DEV_STAT;
    a02a:	2208      	movs	r2, #8
    a02c:	4b21      	ldr	r3, [pc, #132]	; (a0b4 <USBHwISR+0xbc>)
    USBHwCmd(bCmd);
    a02e:	20fe      	movs	r0, #254	; 0xfe
        USBDevIntClr = DEV_STAT;
    a030:	601a      	str	r2, [r3, #0]
    USBHwCmd(bCmd);
    a032:	f7ff fee5 	bl	9e00 <USBHwCmd>
    USBCmdCode = 0x00000200 | (bCmd << 16);
    a036:	4b1c      	ldr	r3, [pc, #112]	; (a0a8 <USBHwISR+0xb0>)
    a038:	4a1f      	ldr	r2, [pc, #124]	; (a0b8 <USBHwISR+0xc0>)
    Wait4DevInt(CDFULL);
    a03a:	2020      	movs	r0, #32
    USBCmdCode = 0x00000200 | (bCmd << 16);
    a03c:	601a      	str	r2, [r3, #0]
    Wait4DevInt(CDFULL);
    a03e:	f7ff fed3 	bl	9de8 <Wait4DevInt>
    return USBCmdData;
    a042:	4b1b      	ldr	r3, [pc, #108]	; (a0b0 <USBHwISR+0xb8>)
    a044:	681b      	ldr	r3, [r3, #0]
        bDevStat = USBHwCmdRead(CMD_DEV_STATUS);
        if (bDevStat & (CON_CH | SUS_CH | RST)) {
    a046:	f013 0f1a 	tst.w	r3, #26
    return USBCmdData;
    a04a:	b2d8      	uxtb	r0, r3
        if (bDevStat & (CON_CH | SUS_CH | RST)) {
    a04c:	d005      	beq.n	a05a <USBHwISR+0x62>
            // convert device status into something HW independent
            bStat = ((bDevStat & CON) ? DEV_STATUS_CONNECT : 0) |
                    ((bDevStat & SUS) ? DEV_STATUS_SUSPEND : 0) |
                    ((bDevStat & RST) ? DEV_STATUS_RESET : 0);
            // call handler
            if (_pfnDevIntHandler != NULL) {
    a04e:	4b15      	ldr	r3, [pc, #84]	; (a0a4 <USBHwISR+0xac>)
    a050:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    a052:	b113      	cbz	r3, a05a <USBHwISR+0x62>
DEBUG_LED_ON(8);        
                _pfnDevIntHandler(bStat);
    a054:	f000 0015 	and.w	r0, r0, #21
    a058:	4798      	blx	r3
            }
        }
    }
    
    // endpoint interrupt
    if (dwStatus & EP_SLOW) {
    a05a:	0763      	lsls	r3, r4, #29
    a05c:	d51e      	bpl.n	a09c <USBHwISR+0xa4>
        // clear EP_SLOW
        USBDevIntClr = EP_SLOW;
    a05e:	2204      	movs	r2, #4
        // check all endpoints
        for (i = 0; i < 32; i++) {
    a060:	2400      	movs	r4, #0
        USBDevIntClr = EP_SLOW;
    a062:	4b14      	ldr	r3, [pc, #80]	; (a0b4 <USBHwISR+0xbc>)
            dwIntBit = (1 << i);
            if (USBEpIntSt & dwIntBit) {
    a064:	4d15      	ldr	r5, [pc, #84]	; (a0bc <USBHwISR+0xc4>)
                // clear int (and retrieve status)
                USBEpIntClr = dwIntBit;
    a066:	4e16      	ldr	r6, [pc, #88]	; (a0c0 <USBHwISR+0xc8>)
                Wait4DevInt(CDFULL);
                bEPStat = USBCmdData;
    a068:	4f11      	ldr	r7, [pc, #68]	; (a0b0 <USBHwISR+0xb8>)
        USBDevIntClr = EP_SLOW;
    a06a:	601a      	str	r2, [r3, #0]
            dwIntBit = (1 << i);
    a06c:	2301      	movs	r3, #1
            if (USBEpIntSt & dwIntBit) {
    a06e:	682a      	ldr	r2, [r5, #0]
            dwIntBit = (1 << i);
    a070:	40a3      	lsls	r3, r4
            if (USBEpIntSt & dwIntBit) {
    a072:	421a      	tst	r2, r3
    a074:	d00f      	beq.n	a096 <USBHwISR+0x9e>
                Wait4DevInt(CDFULL);
    a076:	2020      	movs	r0, #32
                USBEpIntClr = dwIntBit;
    a078:	6033      	str	r3, [r6, #0]
                Wait4DevInt(CDFULL);
    a07a:	f7ff feb5 	bl	9de8 <Wait4DevInt>
                        ((bEPStat & EPSTAT_ST) ? EP_STATUS_STALLED : 0) |
                        ((bEPStat & EPSTAT_STP) ? EP_STATUS_SETUP : 0) |
                        ((bEPStat & EPSTAT_EPN) ? EP_STATUS_NACKED : 0) |
                        ((bEPStat & EPSTAT_PO) ? EP_STATUS_ERROR : 0);
                // call handler
                if (_apfnEPIntHandlers[i / 2] != NULL) {
    a07e:	4b09      	ldr	r3, [pc, #36]	; (a0a4 <USBHwISR+0xac>)
    a080:	1060      	asrs	r0, r4, #1
    a082:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
                bEPStat = USBCmdData;
    a086:	6839      	ldr	r1, [r7, #0]
                if (_apfnEPIntHandlers[i / 2] != NULL) {
    a088:	b12b      	cbz	r3, a096 <USBHwISR+0x9e>
DEBUG_LED_ON(10);       
                    _apfnEPIntHandlers[i / 2](IDX2EP(i), bStat);
    a08a:	ea40 10c4 	orr.w	r0, r0, r4, lsl #7
    a08e:	f001 011f 	and.w	r1, r1, #31
    a092:	b2c0      	uxtb	r0, r0
    a094:	4798      	blx	r3
        for (i = 0; i < 32; i++) {
    a096:	3401      	adds	r4, #1
    a098:	2c20      	cmp	r4, #32
    a09a:	d1e7      	bne.n	a06c <USBHwISR+0x74>
            }
        }
    }
    
DEBUG_LED_OFF(9);       
}
    a09c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a09e:	bf00      	nop
    a0a0:	5000c200 	.word	0x5000c200
    a0a4:	10002384 	.word	0x10002384
    a0a8:	5000c210 	.word	0x5000c210
    a0ac:	00f50200 	.word	0x00f50200
    a0b0:	5000c214 	.word	0x5000c214
    a0b4:	5000c208 	.word	0x5000c208
    a0b8:	00fe0200 	.word	0x00fe0200
    a0bc:	5000c230 	.word	0x5000c230
    a0c0:	5000c238 	.word	0x5000c238

0000a0c4 <USBHwInit>:
    acts as a pull-up and so prevents detection of USB disconnect.
        
    @return TRUE if the hardware was successfully initialised
 */
BOOL USBHwInit(void)
{
    a0c4:	b508      	push	{r3, lr}
#ifdef LPC17xx
	// P2.9 is USB_CONNECT
    PINSEL4 = (PINSEL4 & ~(3 << 18)) | (1 << 18);
    a0c6:	4a26      	ldr	r2, [pc, #152]	; (a160 <USBHwInit+0x9c>)
    a0c8:	6813      	ldr	r3, [r2, #0]
    a0ca:	f423 2340 	bic.w	r3, r3, #786432	; 0xc0000
    a0ce:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    a0d2:	6013      	str	r3, [r2, #0]

	// P1.18 is USB_UP_LED
    PINSEL3 = (PINSEL3 & ~(3 << 4)) | (1 << 4);
    a0d4:	f852 3c04 	ldr.w	r3, [r2, #-4]
    a0d8:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    a0dc:	f043 0310 	orr.w	r3, r3, #16
    a0e0:	f842 3c04 	str.w	r3, [r2, #-4]

	// P1.30 is VBUS
    PINSEL3 = (PINSEL3 & ~(3 << 28)) | (2 << 28);
    a0e4:	f852 3c04 	ldr.w	r3, [r2, #-4]
    a0e8:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
    a0ec:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    a0f0:	f842 3c04 	str.w	r3, [r2, #-4]

	// P0.29 is USB_D+
    PINSEL1 = (PINSEL1 & ~(3 << 26)) | (1 << 26);
    a0f4:	f852 3c0c 	ldr.w	r3, [r2, #-12]
    a0f8:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
    a0fc:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
    a100:	f842 3c0c 	str.w	r3, [r2, #-12]

	// P0.30 is USB_D-
    PINSEL1 = (PINSEL1 & ~(3 << 28)) | (1 << 28);
    a104:	f852 3c0c 	ldr.w	r3, [r2, #-12]
    a108:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
    a10c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    a110:	f842 3c0c 	str.w	r3, [r2, #-12]

	// enable PUSB
	PCONP |= PCONP_PCUSB;
    a114:	f502 2250 	add.w	r2, r2, #851968	; 0xd0000
    a118:	f8d2 30b4 	ldr.w	r3, [r2, #180]	; 0xb4
    a11c:	32b4      	adds	r2, #180	; 0xb4
    a11e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    a122:	6013      	str	r3, [r2, #0]

	/* enable the USB controller clocks */
    USBClkCtrl |= (USBClkCtrl_DEV_CLK_EN | USBClkCtrl_AHB_CLK_EN);
    a124:	4a0f      	ldr	r2, [pc, #60]	; (a164 <USBHwInit+0xa0>)
    a126:	6813      	ldr	r3, [r2, #0]
    a128:	f043 0312 	orr.w	r3, r3, #18
    a12c:	6013      	str	r3, [r2, #0]
    while (!(USBClkSt & USBClkSt_DEV_CLK_ON));
    a12e:	4b0e      	ldr	r3, [pc, #56]	; (a168 <USBHwInit+0xa4>)
    a130:	461a      	mov	r2, r3
    a132:	6819      	ldr	r1, [r3, #0]
    a134:	0789      	lsls	r1, r1, #30
    a136:	d5fc      	bpl.n	a132 <USBHwInit+0x6e>
    while (!(USBClkSt & USBClkSt_AHB_CLK_ON));
    a138:	6813      	ldr	r3, [r2, #0]
    a13a:	06db      	lsls	r3, r3, #27
    a13c:	d5fc      	bpl.n	a138 <USBHwInit+0x74>
#endif

#endif
    
    // disable/clear all interrupts for now
    USBDevIntEn = 0;
    a13e:	2000      	movs	r0, #0
    a140:	4b0a      	ldr	r3, [pc, #40]	; (a16c <USBHwInit+0xa8>)
    USBDevIntClr = 0xFFFFFFFF;
    a142:	4a0b      	ldr	r2, [pc, #44]	; (a170 <USBHwInit+0xac>)
    USBDevIntEn = 0;
    a144:	6018      	str	r0, [r3, #0]
    USBDevIntClr = 0xFFFFFFFF;
    a146:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    a14a:	6013      	str	r3, [r2, #0]
    USBDevIntPri = 0;
    a14c:	6250      	str	r0, [r2, #36]	; 0x24

    USBEpIntEn = 0;
    a14e:	62d0      	str	r0, [r2, #44]	; 0x2c
    USBEpIntClr = 0xFFFFFFFF;
    a150:	6313      	str	r3, [r2, #48]	; 0x30
    USBEpIntPri = 0;
    a152:	4b08      	ldr	r3, [pc, #32]	; (a174 <USBHwInit+0xb0>)
    a154:	6018      	str	r0, [r3, #0]

    // by default, only ACKs generate interrupts
    USBHwNakIntEnable(0);
    a156:	f7ff febe 	bl	9ed6 <USBHwNakIntEnable>
    DEBUG_LED_INIT(8);
    DEBUG_LED_INIT(9);
    DEBUG_LED_INIT(10);

    return TRUE;
}
    a15a:	2001      	movs	r0, #1
    a15c:	bd08      	pop	{r3, pc}
    a15e:	bf00      	nop
    a160:	4002c010 	.word	0x4002c010
    a164:	5000cff4 	.word	0x5000cff4
    a168:	5000cff8 	.word	0x5000cff8
    a16c:	5000c204 	.word	0x5000c204
    a170:	5000c208 	.word	0x5000c208
    a174:	5000c240 	.word	0x5000c240

0000a178 <USBFilterOsVendorMessage>:
	@param [out]	*ppbData	Descriptor data
	
	@return TRUE if the request was handled by this filter, FALSE otherwise
 */
BOOL USBFilterOsVendorMessage(TSetupPacket *pSetup, BOOL *pfSuccess, int *piLen, U8 **ppbData)
{
    a178:	b570      	push	{r4, r5, r6, lr}
    a17a:	4604      	mov	r4, r0
	if(bMsVendorIndex == 0)	{
    a17c:	4815      	ldr	r0, [pc, #84]	; (a1d4 <USBFilterOsVendorMessage+0x5c>)
    a17e:	7805      	ldrb	r5, [r0, #0]
    a180:	2000      	movs	r0, #0
    a182:	b32d      	cbz	r5, a1d0 <USBFilterOsVendorMessage+0x58>
		// Feature is disabled.
		return FALSE;
	}
	
	if(pSetup->bRequest == bMsVendorIndex) {
    a184:	7866      	ldrb	r6, [r4, #1]
    a186:	42ae      	cmp	r6, r5
    a188:	d11d      	bne.n	a1c6 <USBFilterOsVendorMessage+0x4e>
		// Fail unless we make it to the end.
		*pfSuccess = FALSE;
	
		int iRequestLength = pSetup->wLength;
    a18a:	88e6      	ldrh	r6, [r4, #6]
		*pfSuccess = FALSE;
    a18c:	6008      	str	r0, [r1, #0]
		U8 bInterfaceNumber = GET_OS_DESC_INTERFACE(pSetup->wValue);
    a18e:	8860      	ldrh	r0, [r4, #2]
		U8 bPageNumber = GET_OS_DESC_PAGE(pSetup->wValue);
	
		switch (pSetup->wIndex) {
    a190:	88a4      	ldrh	r4, [r4, #4]
    a192:	2c04      	cmp	r4, #4
    a194:	d003      	beq.n	a19e <USBFilterOsVendorMessage+0x26>
    a196:	2c05      	cmp	r4, #5
    a198:	d016      	beq.n	a1c8 <USBFilterOsVendorMessage+0x50>
		
		// Decide what portion of the descriptor to return.
		int iPageOffset = bPageNumber*0x10000; // This will probably always be zero...
		if (*piLen < iPageOffset) {
			// Not enough data for the requested offset.
			return TRUE;
    a19a:	2001      	movs	r0, #1
    a19c:	e013      	b.n	a1c6 <USBFilterOsVendorMessage+0x4e>
			*ppbData = (U8*)abExtendedOsFeatureDescriptor;
    a19e:	4c0e      	ldr	r4, [pc, #56]	; (a1d8 <USBFilterOsVendorMessage+0x60>)
    a1a0:	601c      	str	r4, [r3, #0]
			*piLen = sizeof(abExtendedOsFeatureDescriptor);
    a1a2:	2428      	movs	r4, #40	; 0x28
			*piLen = sizeof(abExtendedPropertiesFeatureDescriptor);			
    a1a4:	6014      	str	r4, [r2, #0]
		int iPageOffset = bPageNumber*0x10000; // This will probably always be zero...
    a1a6:	0a04      	lsrs	r4, r0, #8
		if (*piLen < iPageOffset) {
    a1a8:	6810      	ldr	r0, [r2, #0]
		int iPageOffset = bPageNumber*0x10000; // This will probably always be zero...
    a1aa:	0425      	lsls	r5, r4, #16
		if (*piLen < iPageOffset) {
    a1ac:	ebb0 4f04 	cmp.w	r0, r4, lsl #16
    a1b0:	dbf3      	blt.n	a19a <USBFilterOsVendorMessage+0x22>
		}
		*ppbData += iPageOffset;
    a1b2:	681c      	ldr	r4, [r3, #0]
		*piLen -= iPageOffset;
    a1b4:	1b40      	subs	r0, r0, r5
		*ppbData += iPageOffset;
    a1b6:	442c      	add	r4, r5
    a1b8:	601c      	str	r4, [r3, #0]
		
		if (*piLen > iRequestLength) {
    a1ba:	42b0      	cmp	r0, r6
    a1bc:	bfd4      	ite	le
    a1be:	6010      	strle	r0, [r2, #0]
    a1c0:	6016      	strgt	r6, [r2, #0]
			// Clip data longer than the requested length
			*piLen = iRequestLength;
		}
	
		*pfSuccess = TRUE;
    a1c2:	2001      	movs	r0, #1
    a1c4:	6008      	str	r0, [r1, #0]
		return TRUE;
	}
	
	// These are not the requests you are looking for
	return FALSE;
}
    a1c6:	bd70      	pop	{r4, r5, r6, pc}
			*ppbData = abExtendedPropertiesFeatureDescriptor;
    a1c8:	4c04      	ldr	r4, [pc, #16]	; (a1dc <USBFilterOsVendorMessage+0x64>)
    a1ca:	601c      	str	r4, [r3, #0]
			*piLen = sizeof(abExtendedPropertiesFeatureDescriptor);			
    a1cc:	2492      	movs	r4, #146	; 0x92
    a1ce:	e7e9      	b.n	a1a4 <USBFilterOsVendorMessage+0x2c>
		return FALSE;
    a1d0:	4628      	mov	r0, r5
    a1d2:	e7f8      	b.n	a1c6 <USBFilterOsVendorMessage+0x4e>
    a1d4:	100023cc 	.word	0x100023cc
    a1d8:	0000e1e8 	.word	0x0000e1e8
    a1dc:	100000dd 	.word	0x100000dd

0000a1e0 <USBRegisterWinusbInterface>:
												Windows will use this as a 
												Device Interface GUID
 */
void USBRegisterWinusbInterface(U8 bVendorRequestIndex, const char* pcInterfaceGuid)
{
	bMsVendorIndex = bVendorRequestIndex;
    a1e0:	4b08      	ldr	r3, [pc, #32]	; (a204 <USBRegisterWinusbInterface+0x24>)
    a1e2:	7018      	strb	r0, [r3, #0]
	
	if(!pcInterfaceGuid) {
    a1e4:	b161      	cbz	r1, a200 <USBRegisterWinusbInterface+0x20>
		return; // Trust that caller is actually specifying this with nonzero RequestIndex.
	}
	
	// Copy GUID into Extended Properties feature descriptor.
	// Trust that the caller did the right thing, but ensure double null termination if string terminates early.
	U8* pbWriteCursor = abExtendedPropertiesFeatureDescriptor + EXTENDEDPROPERTIESFEATURE_GUIDSTRINGOFFSET;
    a1e6:	4b08      	ldr	r3, [pc, #32]	; (a208 <USBRegisterWinusbInterface+0x28>)
    a1e8:	1e4a      	subs	r2, r1, #1
    a1ea:	3125      	adds	r1, #37	; 0x25
	const int ciMaxLength = 38;
	
	for(int i = 0; i < ciMaxLength; i++) {
		if(!pcInterfaceGuid[i]) break;
    a1ec:	f812 0f01 	ldrb.w	r0, [r2, #1]!
    a1f0:	b118      	cbz	r0, a1fa <USBRegisterWinusbInterface+0x1a>
	for(int i = 0; i < ciMaxLength; i++) {
    a1f2:	428a      	cmp	r2, r1
		pbWriteCursor[0] = (U8) pcInterfaceGuid[i];
    a1f4:	f803 0b02 	strb.w	r0, [r3], #2
	for(int i = 0; i < ciMaxLength; i++) {
    a1f8:	d1f8      	bne.n	a1ec <USBRegisterWinusbInterface+0xc>
		pbWriteCursor += 2;
	}
	// Double terminate
	pbWriteCursor[0] = 0;
    a1fa:	2200      	movs	r2, #0
    a1fc:	701a      	strb	r2, [r3, #0]
	pbWriteCursor[2] = 0;
    a1fe:	709a      	strb	r2, [r3, #2]
	
}
    a200:	4770      	bx	lr
    a202:	bf00      	nop
    a204:	100023cc 	.word	0x100023cc
    a208:	1000011f 	.word	0x1000011f

0000a20c <USBRegisterDescriptors>:

	@param [in]	pabDescriptors	The descriptor byte array
 */
void USBRegisterDescriptors(U8 *pabDescriptors)
{
	pabDescrip = pabDescriptors;
    a20c:	4b01      	ldr	r3, [pc, #4]	; (a214 <USBRegisterDescriptors+0x8>)
    a20e:	6058      	str	r0, [r3, #4]
}
    a210:	4770      	bx	lr
    a212:	bf00      	nop
    a214:	100023cc 	.word	0x100023cc

0000a218 <USBGetDescriptor>:
	@param [out]	*ppbData	Descriptor data
	
	@return TRUE if the descriptor was found, FALSE otherwise
 */
BOOL USBGetDescriptor(U16 wTypeIndex, U16 wLangID, int *piLen, U8 **ppbData)
{
    a218:	b5f0      	push	{r4, r5, r6, r7, lr}
	U8	*pab;
	int iCurIndex;
	
	ASSERT(pabDescrip != NULL);

	bType = GET_DESC_TYPE(wTypeIndex);
    a21a:	0a04      	lsrs	r4, r0, #8
	bIndex = GET_DESC_INDEX(wTypeIndex);
	
    if (bType == DESC_STRING &&
    a21c:	2c03      	cmp	r4, #3
	bIndex = GET_DESC_INDEX(wTypeIndex);
    a21e:	b2c1      	uxtb	r1, r0
	bType = GET_DESC_TYPE(wTypeIndex);
    a220:	4626      	mov	r6, r4
    if (bType == DESC_STRING &&
    a222:	4810      	ldr	r0, [pc, #64]	; (a264 <USBGetDescriptor+0x4c>)
    a224:	d10a      	bne.n	a23c <USBGetDescriptor+0x24>
    a226:	29ee      	cmp	r1, #238	; 0xee
    a228:	d108      	bne.n	a23c <USBGetDescriptor+0x24>
	abOsStringDescriptor[sizeof(abOsStringDescriptor)-2] = bMsVendorIndex;
    a22a:	490f      	ldr	r1, [pc, #60]	; (a268 <USBGetDescriptor+0x50>)
    a22c:	7800      	ldrb	r0, [r0, #0]
	*ppbData = abOsStringDescriptor;
    a22e:	3192      	adds	r1, #146	; 0x92
	abOsStringDescriptor[sizeof(abOsStringDescriptor)-2] = bMsVendorIndex;
    a230:	7408      	strb	r0, [r1, #16]
	*ppbData = abOsStringDescriptor;
    a232:	6019      	str	r1, [r3, #0]
	*piLen = sizeof(abOsStringDescriptor);
    a234:	2312      	movs	r3, #18
				}
				else {
					// normally length is at offset 0
					*piLen = pab[DESC_bLength];
				}
				return TRUE;
    a236:	2001      	movs	r0, #1
					*piLen = pab[DESC_bLength];
    a238:	6013      	str	r3, [r2, #0]
		pab += pab[DESC_bLength];
	}
	// nothing found
	DBG("Desc %x not found!\n", wTypeIndex);
	return FALSE;
}
    a23a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	iCurIndex = 0;
    a23c:	2500      	movs	r5, #0
	pab = (U8 *)pabDescrip;
    a23e:	6844      	ldr	r4, [r0, #4]
	while (pab[DESC_bLength] != 0) {
    a240:	7820      	ldrb	r0, [r4, #0]
    a242:	2800      	cmp	r0, #0
    a244:	d0f9      	beq.n	a23a <USBGetDescriptor+0x22>
		if (pab[DESC_bDescriptorType] == bType) {
    a246:	7867      	ldrb	r7, [r4, #1]
    a248:	42b7      	cmp	r7, r6
    a24a:	d108      	bne.n	a25e <USBGetDescriptor+0x46>
			if (iCurIndex == bIndex) {
    a24c:	42a9      	cmp	r1, r5
    a24e:	d105      	bne.n	a25c <USBGetDescriptor+0x44>
				*ppbData = pab;
    a250:	601c      	str	r4, [r3, #0]
				if (bType == DESC_CONFIGURATION) {
    a252:	2e02      	cmp	r6, #2
					*piLen =	(pab[CONF_DESC_wTotalLength]) |
    a254:	bf0c      	ite	eq
    a256:	8863      	ldrheq	r3, [r4, #2]
					*piLen = pab[DESC_bLength];
    a258:	7823      	ldrbne	r3, [r4, #0]
    a25a:	e7ec      	b.n	a236 <USBGetDescriptor+0x1e>
			iCurIndex++;
    a25c:	3501      	adds	r5, #1
		pab += pab[DESC_bLength];
    a25e:	4404      	add	r4, r0
    a260:	e7ee      	b.n	a240 <USBGetDescriptor+0x28>
    a262:	bf00      	nop
    a264:	100023cc 	.word	0x100023cc
    a268:	100000dd 	.word	0x100000dd

0000a26c <USBHandleStandardRequest>:
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
BOOL USBHandleStandardRequest(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
    a26c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	// try the custom request handler first
	if ((pfnHandleCustomReq != NULL) && pfnHandleCustomReq(pSetup, piLen, ppbData)) {
    a270:	4c55      	ldr	r4, [pc, #340]	; (a3c8 <USBHandleStandardRequest+0x15c>)
{
    a272:	4605      	mov	r5, r0
	if ((pfnHandleCustomReq != NULL) && pfnHandleCustomReq(pSetup, piLen, ppbData)) {
    a274:	68a3      	ldr	r3, [r4, #8]
{
    a276:	460f      	mov	r7, r1
    a278:	4690      	mov	r8, r2
    a27a:	46a1      	mov	r9, r4
	if ((pfnHandleCustomReq != NULL) && pfnHandleCustomReq(pSetup, piLen, ppbData)) {
    a27c:	b94b      	cbnz	r3, a292 <USBHandleStandardRequest+0x26>
		return TRUE;
	}
	
	switch (REQTYPE_GET_RECIP(pSetup->bmRequestType)) {
    a27e:	7828      	ldrb	r0, [r5, #0]
    a280:	f000 061f 	and.w	r6, r0, #31
    a284:	2e01      	cmp	r6, #1
    a286:	d069      	beq.n	a35c <USBHandleStandardRequest+0xf0>
    a288:	2e02      	cmp	r6, #2
    a28a:	d07b      	beq.n	a384 <USBHandleStandardRequest+0x118>
    a28c:	b136      	cbz	r6, a29c <USBHandleStandardRequest+0x30>
			return FALSE;
    a28e:	2000      	movs	r0, #0
    a290:	e037      	b.n	a302 <USBHandleStandardRequest+0x96>
	if ((pfnHandleCustomReq != NULL) && pfnHandleCustomReq(pSetup, piLen, ppbData)) {
    a292:	4798      	blx	r3
    a294:	2800      	cmp	r0, #0
    a296:	d0f2      	beq.n	a27e <USBHandleStandardRequest+0x12>
		return TRUE;
    a298:	2001      	movs	r0, #1
    a29a:	e032      	b.n	a302 <USBHandleStandardRequest+0x96>
	U8	*pbData = *ppbData;
    a29c:	786a      	ldrb	r2, [r5, #1]
    a29e:	f8d8 3000 	ldr.w	r3, [r8]
	switch (pSetup->bRequest) {
    a2a2:	2a09      	cmp	r2, #9
    a2a4:	d8f3      	bhi.n	a28e <USBHandleStandardRequest+0x22>
    a2a6:	a101      	add	r1, pc, #4	; (adr r1, a2ac <USBHandleStandardRequest+0x40>)
    a2a8:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
    a2ac:	0000a2d5 	.word	0x0000a2d5
    a2b0:	0000a28f 	.word	0x0000a28f
    a2b4:	0000a28f 	.word	0x0000a28f
    a2b8:	0000a28f 	.word	0x0000a28f
    a2bc:	0000a28f 	.word	0x0000a28f
    a2c0:	0000a2e1 	.word	0x0000a2e1
    a2c4:	0000a2e9 	.word	0x0000a2e9
    a2c8:	0000a28f 	.word	0x0000a28f
    a2cc:	0000a2f9 	.word	0x0000a2f9
    a2d0:	0000a307 	.word	0x0000a307
		pbData[0] = 0;
    a2d4:	2200      	movs	r2, #0
    a2d6:	701a      	strb	r2, [r3, #0]
		pbData[1] = 0;
    a2d8:	705a      	strb	r2, [r3, #1]
		*piLen = 2;
    a2da:	2302      	movs	r3, #2
		*piLen = 0;
    a2dc:	603b      	str	r3, [r7, #0]
		break;
    a2de:	e7db      	b.n	a298 <USBHandleStandardRequest+0x2c>
		USBHwSetAddress(pSetup->wValue);
    a2e0:	78a8      	ldrb	r0, [r5, #2]
    a2e2:	f7ff fded 	bl	9ec0 <USBHwSetAddress>
		break;
    a2e6:	e7d7      	b.n	a298 <USBHandleStandardRequest+0x2c>
		return USBGetDescriptor(pSetup->wValue, pSetup->wIndex, piLen, ppbData);
    a2e8:	4643      	mov	r3, r8
    a2ea:	463a      	mov	r2, r7
    a2ec:	88a9      	ldrh	r1, [r5, #4]
    a2ee:	8868      	ldrh	r0, [r5, #2]
	case REQTYPE_RECIP_DEVICE:		return HandleStdDeviceReq(pSetup, piLen, ppbData);
	case REQTYPE_RECIP_INTERFACE:	return HandleStdInterfaceReq(pSetup, piLen, ppbData);
	case REQTYPE_RECIP_ENDPOINT: 	return HandleStdEndPointReq(pSetup, piLen, ppbData);
	default: 						return FALSE;
	}
}
    a2f0:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		return USBGetDescriptor(pSetup->wValue, pSetup->wIndex, piLen, ppbData);
    a2f4:	f7ff bf90 	b.w	a218 <USBGetDescriptor>
		*piLen = 1;
    a2f8:	2001      	movs	r0, #1
		pbData[0] = bConfiguration;
    a2fa:	f899 200c 	ldrb.w	r2, [r9, #12]
    a2fe:	701a      	strb	r2, [r3, #0]
		*piLen = 1;
    a300:	6038      	str	r0, [r7, #0]
}
    a302:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if (!USBSetConfiguration(pSetup->wValue & 0xFF, 0)) {
    a306:	78ae      	ldrb	r6, [r5, #2]
	if (bConfigIndex == 0) {
    a308:	b936      	cbnz	r6, a318 <USBHandleStandardRequest+0xac>
		USBHwConfigDevice(FALSE);
    a30a:	4630      	mov	r0, r6
		USBHwConfigDevice(TRUE);
    a30c:	f7ff fe6e 	bl	9fec <USBHwConfigDevice>
		bConfiguration = pSetup->wValue & 0xFF;	
    a310:	886b      	ldrh	r3, [r5, #2]
    a312:	f889 300c 	strb.w	r3, [r9, #12]
		break;
    a316:	e7bf      	b.n	a298 <USBHandleStandardRequest+0x2c>
		bCurAltSetting = 0xFF;
    a318:	27ff      	movs	r7, #255	; 0xff
		bCurConfig = 0xFF;
    a31a:	46b8      	mov	r8, r7
		pab = (U8 *)pabDescrip;
    a31c:	f8d9 4004 	ldr.w	r4, [r9, #4]
		while (pab[DESC_bLength] != 0) {
    a320:	7823      	ldrb	r3, [r4, #0]
    a322:	b90b      	cbnz	r3, a328 <USBHandleStandardRequest+0xbc>
		USBHwConfigDevice(TRUE);
    a324:	2001      	movs	r0, #1
    a326:	e7f1      	b.n	a30c <USBHandleStandardRequest+0xa0>
			switch (pab[DESC_bDescriptorType]) {
    a328:	7863      	ldrb	r3, [r4, #1]
    a32a:	2b04      	cmp	r3, #4
    a32c:	d008      	beq.n	a340 <USBHandleStandardRequest+0xd4>
    a32e:	2b05      	cmp	r3, #5
    a330:	d008      	beq.n	a344 <USBHandleStandardRequest+0xd8>
    a332:	2b02      	cmp	r3, #2
    a334:	d101      	bne.n	a33a <USBHandleStandardRequest+0xce>
				bCurConfig = pab[CONF_DESC_bConfigurationValue];
    a336:	f894 8005 	ldrb.w	r8, [r4, #5]
			pab += pab[DESC_bLength];
    a33a:	7823      	ldrb	r3, [r4, #0]
    a33c:	441c      	add	r4, r3
    a33e:	e7ef      	b.n	a320 <USBHandleStandardRequest+0xb4>
				bCurAltSetting = pab[INTF_DESC_bAlternateSetting];
    a340:	78e7      	ldrb	r7, [r4, #3]
				break;
    a342:	e7fa      	b.n	a33a <USBHandleStandardRequest+0xce>
				if ((bCurConfig == bConfigIndex) &&
    a344:	4546      	cmp	r6, r8
    a346:	d1f8      	bne.n	a33a <USBHandleStandardRequest+0xce>
    a348:	2f00      	cmp	r7, #0
    a34a:	d1f6      	bne.n	a33a <USBHandleStandardRequest+0xce>
									(pab[ENDP_DESC_wMaxPacketSize + 1] << 8);
    a34c:	7961      	ldrb	r1, [r4, #5]
					wMaxPktSize = 	(pab[ENDP_DESC_wMaxPacketSize]) |
    a34e:	7923      	ldrb	r3, [r4, #4]
					USBHwEPConfig(bEP, wMaxPktSize);
    a350:	78a0      	ldrb	r0, [r4, #2]
    a352:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
    a356:	f7ff fd6f 	bl	9e38 <USBHwEPConfig>
    a35a:	e7ee      	b.n	a33a <USBHandleStandardRequest+0xce>
	switch (pSetup->bRequest) {
    a35c:	786b      	ldrb	r3, [r5, #1]
	case REQTYPE_RECIP_INTERFACE:	return HandleStdInterfaceReq(pSetup, piLen, ppbData);
    a35e:	f8d8 2000 	ldr.w	r2, [r8]
	switch (pSetup->bRequest) {
    a362:	2b0a      	cmp	r3, #10
    a364:	d006      	beq.n	a374 <USBHandleStandardRequest+0x108>
    a366:	2b0b      	cmp	r3, #11
    a368:	d008      	beq.n	a37c <USBHandleStandardRequest+0x110>
    a36a:	2b00      	cmp	r3, #0
    a36c:	d18f      	bne.n	a28e <USBHandleStandardRequest+0x22>
		pbData[0] = 0;
    a36e:	7013      	strb	r3, [r2, #0]
		pbData[1] = 0;
    a370:	7053      	strb	r3, [r2, #1]
    a372:	e7b2      	b.n	a2da <USBHandleStandardRequest+0x6e>
		pbData[0] = 0;
    a374:	2300      	movs	r3, #0
    a376:	7013      	strb	r3, [r2, #0]
		*piLen = 2;
    a378:	603e      	str	r6, [r7, #0]
		break;
    a37a:	e78d      	b.n	a298 <USBHandleStandardRequest+0x2c>
		if (pSetup->wValue != 0) {
    a37c:	886b      	ldrh	r3, [r5, #2]
    a37e:	2b00      	cmp	r3, #0
    a380:	d0ac      	beq.n	a2dc <USBHandleStandardRequest+0x70>
    a382:	e784      	b.n	a28e <USBHandleStandardRequest+0x22>
	switch (pSetup->bRequest) {
    a384:	786c      	ldrb	r4, [r5, #1]
    a386:	2c01      	cmp	r4, #1
    a388:	d010      	beq.n	a3ac <USBHandleStandardRequest+0x140>
    a38a:	2c03      	cmp	r4, #3
    a38c:	d016      	beq.n	a3bc <USBHandleStandardRequest+0x150>
    a38e:	2c00      	cmp	r4, #0
    a390:	f47f af7d 	bne.w	a28e <USBHandleStandardRequest+0x22>
		pbData[0] = (USBHwEPGetStatus(pSetup->wIndex) & EP_STATUS_STALLED) ? 1 : 0;
    a394:	7928      	ldrb	r0, [r5, #4]
	case REQTYPE_RECIP_ENDPOINT: 	return HandleStdEndPointReq(pSetup, piLen, ppbData);
    a396:	f8d8 8000 	ldr.w	r8, [r8]
		pbData[0] = (USBHwEPGetStatus(pSetup->wIndex) & EP_STATUS_STALLED) ? 1 : 0;
    a39a:	f7ff fda1 	bl	9ee0 <USBHwEPGetStatus>
    a39e:	f3c0 0040 	ubfx	r0, r0, #1, #1
    a3a2:	f888 0000 	strb.w	r0, [r8]
		pbData[1] = 0;
    a3a6:	f888 4001 	strb.w	r4, [r8, #1]
    a3aa:	e7e5      	b.n	a378 <USBHandleStandardRequest+0x10c>
		if (pSetup->wValue == FEA_ENDPOINT_HALT) {
    a3ac:	8869      	ldrh	r1, [r5, #2]
    a3ae:	2900      	cmp	r1, #0
    a3b0:	f47f af6d 	bne.w	a28e <USBHandleStandardRequest+0x22>
			USBHwEPStall(pSetup->wIndex, TRUE);
    a3b4:	7928      	ldrb	r0, [r5, #4]
    a3b6:	f7ff fdad 	bl	9f14 <USBHwEPStall>
			break;
    a3ba:	e76d      	b.n	a298 <USBHandleStandardRequest+0x2c>
		if (pSetup->wValue == FEA_ENDPOINT_HALT) {
    a3bc:	886b      	ldrh	r3, [r5, #2]
    a3be:	2b00      	cmp	r3, #0
    a3c0:	f47f af65 	bne.w	a28e <USBHandleStandardRequest+0x22>
			USBHwEPStall(pSetup->wIndex, TRUE);
    a3c4:	2101      	movs	r1, #1
    a3c6:	e7f5      	b.n	a3b4 <USBHandleStandardRequest+0x148>
    a3c8:	100023cc 	.word	0x100023cc

0000a3cc <__aeabi_uldivmod>:
    a3cc:	b953      	cbnz	r3, a3e4 <__aeabi_uldivmod+0x18>
    a3ce:	b94a      	cbnz	r2, a3e4 <__aeabi_uldivmod+0x18>
    a3d0:	2900      	cmp	r1, #0
    a3d2:	bf08      	it	eq
    a3d4:	2800      	cmpeq	r0, #0
    a3d6:	bf1c      	itt	ne
    a3d8:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
    a3dc:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
    a3e0:	f000 b96e 	b.w	a6c0 <__aeabi_idiv0>
    a3e4:	f1ad 0c08 	sub.w	ip, sp, #8
    a3e8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    a3ec:	f000 f806 	bl	a3fc <__udivmoddi4>
    a3f0:	f8dd e004 	ldr.w	lr, [sp, #4]
    a3f4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    a3f8:	b004      	add	sp, #16
    a3fa:	4770      	bx	lr

0000a3fc <__udivmoddi4>:
    a3fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    a400:	9e08      	ldr	r6, [sp, #32]
    a402:	460d      	mov	r5, r1
    a404:	4604      	mov	r4, r0
    a406:	468e      	mov	lr, r1
    a408:	2b00      	cmp	r3, #0
    a40a:	f040 8083 	bne.w	a514 <__udivmoddi4+0x118>
    a40e:	428a      	cmp	r2, r1
    a410:	4617      	mov	r7, r2
    a412:	d947      	bls.n	a4a4 <__udivmoddi4+0xa8>
    a414:	fab2 f382 	clz	r3, r2
    a418:	b14b      	cbz	r3, a42e <__udivmoddi4+0x32>
    a41a:	f1c3 0120 	rsb	r1, r3, #32
    a41e:	fa05 fe03 	lsl.w	lr, r5, r3
    a422:	fa20 f101 	lsr.w	r1, r0, r1
    a426:	409f      	lsls	r7, r3
    a428:	ea41 0e0e 	orr.w	lr, r1, lr
    a42c:	409c      	lsls	r4, r3
    a42e:	ea4f 4817 	mov.w	r8, r7, lsr #16
    a432:	fbbe fcf8 	udiv	ip, lr, r8
    a436:	fa1f f987 	uxth.w	r9, r7
    a43a:	fb08 e21c 	mls	r2, r8, ip, lr
    a43e:	fb0c f009 	mul.w	r0, ip, r9
    a442:	0c21      	lsrs	r1, r4, #16
    a444:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
    a448:	4290      	cmp	r0, r2
    a44a:	d90a      	bls.n	a462 <__udivmoddi4+0x66>
    a44c:	18ba      	adds	r2, r7, r2
    a44e:	f10c 31ff 	add.w	r1, ip, #4294967295	; 0xffffffff
    a452:	f080 8118 	bcs.w	a686 <__udivmoddi4+0x28a>
    a456:	4290      	cmp	r0, r2
    a458:	f240 8115 	bls.w	a686 <__udivmoddi4+0x28a>
    a45c:	f1ac 0c02 	sub.w	ip, ip, #2
    a460:	443a      	add	r2, r7
    a462:	1a12      	subs	r2, r2, r0
    a464:	fbb2 f0f8 	udiv	r0, r2, r8
    a468:	fb08 2210 	mls	r2, r8, r0, r2
    a46c:	fb00 f109 	mul.w	r1, r0, r9
    a470:	b2a4      	uxth	r4, r4
    a472:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
    a476:	42a1      	cmp	r1, r4
    a478:	d909      	bls.n	a48e <__udivmoddi4+0x92>
    a47a:	193c      	adds	r4, r7, r4
    a47c:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
    a480:	f080 8103 	bcs.w	a68a <__udivmoddi4+0x28e>
    a484:	42a1      	cmp	r1, r4
    a486:	f240 8100 	bls.w	a68a <__udivmoddi4+0x28e>
    a48a:	3802      	subs	r0, #2
    a48c:	443c      	add	r4, r7
    a48e:	1a64      	subs	r4, r4, r1
    a490:	2100      	movs	r1, #0
    a492:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
    a496:	b11e      	cbz	r6, a4a0 <__udivmoddi4+0xa4>
    a498:	2200      	movs	r2, #0
    a49a:	40dc      	lsrs	r4, r3
    a49c:	e9c6 4200 	strd	r4, r2, [r6]
    a4a0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a4a4:	b902      	cbnz	r2, a4a8 <__udivmoddi4+0xac>
    a4a6:	deff      	udf	#255	; 0xff
    a4a8:	fab2 f382 	clz	r3, r2
    a4ac:	2b00      	cmp	r3, #0
    a4ae:	d14f      	bne.n	a550 <__udivmoddi4+0x154>
    a4b0:	1a8d      	subs	r5, r1, r2
    a4b2:	2101      	movs	r1, #1
    a4b4:	ea4f 4e12 	mov.w	lr, r2, lsr #16
    a4b8:	fa1f f882 	uxth.w	r8, r2
    a4bc:	fbb5 fcfe 	udiv	ip, r5, lr
    a4c0:	fb0e 551c 	mls	r5, lr, ip, r5
    a4c4:	fb08 f00c 	mul.w	r0, r8, ip
    a4c8:	0c22      	lsrs	r2, r4, #16
    a4ca:	ea42 4505 	orr.w	r5, r2, r5, lsl #16
    a4ce:	42a8      	cmp	r0, r5
    a4d0:	d907      	bls.n	a4e2 <__udivmoddi4+0xe6>
    a4d2:	197d      	adds	r5, r7, r5
    a4d4:	f10c 32ff 	add.w	r2, ip, #4294967295	; 0xffffffff
    a4d8:	d202      	bcs.n	a4e0 <__udivmoddi4+0xe4>
    a4da:	42a8      	cmp	r0, r5
    a4dc:	f200 80e9 	bhi.w	a6b2 <__udivmoddi4+0x2b6>
    a4e0:	4694      	mov	ip, r2
    a4e2:	1a2d      	subs	r5, r5, r0
    a4e4:	fbb5 f0fe 	udiv	r0, r5, lr
    a4e8:	fb0e 5510 	mls	r5, lr, r0, r5
    a4ec:	fb08 f800 	mul.w	r8, r8, r0
    a4f0:	b2a4      	uxth	r4, r4
    a4f2:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
    a4f6:	45a0      	cmp	r8, r4
    a4f8:	d907      	bls.n	a50a <__udivmoddi4+0x10e>
    a4fa:	193c      	adds	r4, r7, r4
    a4fc:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
    a500:	d202      	bcs.n	a508 <__udivmoddi4+0x10c>
    a502:	45a0      	cmp	r8, r4
    a504:	f200 80d9 	bhi.w	a6ba <__udivmoddi4+0x2be>
    a508:	4610      	mov	r0, r2
    a50a:	eba4 0408 	sub.w	r4, r4, r8
    a50e:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
    a512:	e7c0      	b.n	a496 <__udivmoddi4+0x9a>
    a514:	428b      	cmp	r3, r1
    a516:	d908      	bls.n	a52a <__udivmoddi4+0x12e>
    a518:	2e00      	cmp	r6, #0
    a51a:	f000 80b1 	beq.w	a680 <__udivmoddi4+0x284>
    a51e:	2100      	movs	r1, #0
    a520:	e9c6 0500 	strd	r0, r5, [r6]
    a524:	4608      	mov	r0, r1
    a526:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a52a:	fab3 f183 	clz	r1, r3
    a52e:	2900      	cmp	r1, #0
    a530:	d14b      	bne.n	a5ca <__udivmoddi4+0x1ce>
    a532:	42ab      	cmp	r3, r5
    a534:	d302      	bcc.n	a53c <__udivmoddi4+0x140>
    a536:	4282      	cmp	r2, r0
    a538:	f200 80b9 	bhi.w	a6ae <__udivmoddi4+0x2b2>
    a53c:	1a84      	subs	r4, r0, r2
    a53e:	eb65 0303 	sbc.w	r3, r5, r3
    a542:	2001      	movs	r0, #1
    a544:	469e      	mov	lr, r3
    a546:	2e00      	cmp	r6, #0
    a548:	d0aa      	beq.n	a4a0 <__udivmoddi4+0xa4>
    a54a:	e9c6 4e00 	strd	r4, lr, [r6]
    a54e:	e7a7      	b.n	a4a0 <__udivmoddi4+0xa4>
    a550:	409f      	lsls	r7, r3
    a552:	f1c3 0220 	rsb	r2, r3, #32
    a556:	40d1      	lsrs	r1, r2
    a558:	ea4f 4e17 	mov.w	lr, r7, lsr #16
    a55c:	fbb1 f0fe 	udiv	r0, r1, lr
    a560:	fa1f f887 	uxth.w	r8, r7
    a564:	fb0e 1110 	mls	r1, lr, r0, r1
    a568:	fa24 f202 	lsr.w	r2, r4, r2
    a56c:	409d      	lsls	r5, r3
    a56e:	fb00 fc08 	mul.w	ip, r0, r8
    a572:	432a      	orrs	r2, r5
    a574:	0c15      	lsrs	r5, r2, #16
    a576:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
    a57a:	45ac      	cmp	ip, r5
    a57c:	fa04 f403 	lsl.w	r4, r4, r3
    a580:	d909      	bls.n	a596 <__udivmoddi4+0x19a>
    a582:	197d      	adds	r5, r7, r5
    a584:	f100 31ff 	add.w	r1, r0, #4294967295	; 0xffffffff
    a588:	f080 808f 	bcs.w	a6aa <__udivmoddi4+0x2ae>
    a58c:	45ac      	cmp	ip, r5
    a58e:	f240 808c 	bls.w	a6aa <__udivmoddi4+0x2ae>
    a592:	3802      	subs	r0, #2
    a594:	443d      	add	r5, r7
    a596:	eba5 050c 	sub.w	r5, r5, ip
    a59a:	fbb5 f1fe 	udiv	r1, r5, lr
    a59e:	fb0e 5c11 	mls	ip, lr, r1, r5
    a5a2:	fb01 f908 	mul.w	r9, r1, r8
    a5a6:	b295      	uxth	r5, r2
    a5a8:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
    a5ac:	45a9      	cmp	r9, r5
    a5ae:	d907      	bls.n	a5c0 <__udivmoddi4+0x1c4>
    a5b0:	197d      	adds	r5, r7, r5
    a5b2:	f101 32ff 	add.w	r2, r1, #4294967295	; 0xffffffff
    a5b6:	d274      	bcs.n	a6a2 <__udivmoddi4+0x2a6>
    a5b8:	45a9      	cmp	r9, r5
    a5ba:	d972      	bls.n	a6a2 <__udivmoddi4+0x2a6>
    a5bc:	3902      	subs	r1, #2
    a5be:	443d      	add	r5, r7
    a5c0:	eba5 0509 	sub.w	r5, r5, r9
    a5c4:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
    a5c8:	e778      	b.n	a4bc <__udivmoddi4+0xc0>
    a5ca:	f1c1 0720 	rsb	r7, r1, #32
    a5ce:	408b      	lsls	r3, r1
    a5d0:	fa22 fc07 	lsr.w	ip, r2, r7
    a5d4:	ea4c 0c03 	orr.w	ip, ip, r3
    a5d8:	fa25 f407 	lsr.w	r4, r5, r7
    a5dc:	ea4f 4e1c 	mov.w	lr, ip, lsr #16
    a5e0:	fbb4 f9fe 	udiv	r9, r4, lr
    a5e4:	fa1f f88c 	uxth.w	r8, ip
    a5e8:	fb0e 4419 	mls	r4, lr, r9, r4
    a5ec:	fa20 f307 	lsr.w	r3, r0, r7
    a5f0:	fb09 fa08 	mul.w	sl, r9, r8
    a5f4:	408d      	lsls	r5, r1
    a5f6:	431d      	orrs	r5, r3
    a5f8:	0c2b      	lsrs	r3, r5, #16
    a5fa:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
    a5fe:	45a2      	cmp	sl, r4
    a600:	fa02 f201 	lsl.w	r2, r2, r1
    a604:	fa00 f301 	lsl.w	r3, r0, r1
    a608:	d909      	bls.n	a61e <__udivmoddi4+0x222>
    a60a:	eb1c 0404 	adds.w	r4, ip, r4
    a60e:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
    a612:	d248      	bcs.n	a6a6 <__udivmoddi4+0x2aa>
    a614:	45a2      	cmp	sl, r4
    a616:	d946      	bls.n	a6a6 <__udivmoddi4+0x2aa>
    a618:	f1a9 0902 	sub.w	r9, r9, #2
    a61c:	4464      	add	r4, ip
    a61e:	eba4 040a 	sub.w	r4, r4, sl
    a622:	fbb4 f0fe 	udiv	r0, r4, lr
    a626:	fb0e 4410 	mls	r4, lr, r0, r4
    a62a:	fb00 fa08 	mul.w	sl, r0, r8
    a62e:	b2ad      	uxth	r5, r5
    a630:	ea45 4404 	orr.w	r4, r5, r4, lsl #16
    a634:	45a2      	cmp	sl, r4
    a636:	d908      	bls.n	a64a <__udivmoddi4+0x24e>
    a638:	eb1c 0404 	adds.w	r4, ip, r4
    a63c:	f100 35ff 	add.w	r5, r0, #4294967295	; 0xffffffff
    a640:	d22d      	bcs.n	a69e <__udivmoddi4+0x2a2>
    a642:	45a2      	cmp	sl, r4
    a644:	d92b      	bls.n	a69e <__udivmoddi4+0x2a2>
    a646:	3802      	subs	r0, #2
    a648:	4464      	add	r4, ip
    a64a:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
    a64e:	fba0 8902 	umull	r8, r9, r0, r2
    a652:	eba4 040a 	sub.w	r4, r4, sl
    a656:	454c      	cmp	r4, r9
    a658:	46c6      	mov	lr, r8
    a65a:	464d      	mov	r5, r9
    a65c:	d319      	bcc.n	a692 <__udivmoddi4+0x296>
    a65e:	d016      	beq.n	a68e <__udivmoddi4+0x292>
    a660:	b15e      	cbz	r6, a67a <__udivmoddi4+0x27e>
    a662:	ebb3 020e 	subs.w	r2, r3, lr
    a666:	eb64 0405 	sbc.w	r4, r4, r5
    a66a:	fa04 f707 	lsl.w	r7, r4, r7
    a66e:	fa22 f301 	lsr.w	r3, r2, r1
    a672:	431f      	orrs	r7, r3
    a674:	40cc      	lsrs	r4, r1
    a676:	e9c6 7400 	strd	r7, r4, [r6]
    a67a:	2100      	movs	r1, #0
    a67c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a680:	4631      	mov	r1, r6
    a682:	4630      	mov	r0, r6
    a684:	e70c      	b.n	a4a0 <__udivmoddi4+0xa4>
    a686:	468c      	mov	ip, r1
    a688:	e6eb      	b.n	a462 <__udivmoddi4+0x66>
    a68a:	4610      	mov	r0, r2
    a68c:	e6ff      	b.n	a48e <__udivmoddi4+0x92>
    a68e:	4543      	cmp	r3, r8
    a690:	d2e6      	bcs.n	a660 <__udivmoddi4+0x264>
    a692:	ebb8 0e02 	subs.w	lr, r8, r2
    a696:	eb69 050c 	sbc.w	r5, r9, ip
    a69a:	3801      	subs	r0, #1
    a69c:	e7e0      	b.n	a660 <__udivmoddi4+0x264>
    a69e:	4628      	mov	r0, r5
    a6a0:	e7d3      	b.n	a64a <__udivmoddi4+0x24e>
    a6a2:	4611      	mov	r1, r2
    a6a4:	e78c      	b.n	a5c0 <__udivmoddi4+0x1c4>
    a6a6:	4681      	mov	r9, r0
    a6a8:	e7b9      	b.n	a61e <__udivmoddi4+0x222>
    a6aa:	4608      	mov	r0, r1
    a6ac:	e773      	b.n	a596 <__udivmoddi4+0x19a>
    a6ae:	4608      	mov	r0, r1
    a6b0:	e749      	b.n	a546 <__udivmoddi4+0x14a>
    a6b2:	f1ac 0c02 	sub.w	ip, ip, #2
    a6b6:	443d      	add	r5, r7
    a6b8:	e713      	b.n	a4e2 <__udivmoddi4+0xe6>
    a6ba:	3802      	subs	r0, #2
    a6bc:	443c      	add	r4, r7
    a6be:	e724      	b.n	a50a <__udivmoddi4+0x10e>

0000a6c0 <__aeabi_idiv0>:
    a6c0:	4770      	bx	lr
    a6c2:	bf00      	nop

0000a6c4 <memcpy>:
    a6c4:	4684      	mov	ip, r0
    a6c6:	ea41 0300 	orr.w	r3, r1, r0
    a6ca:	f013 0303 	ands.w	r3, r3, #3
    a6ce:	d149      	bne.n	a764 <memcpy+0xa0>
    a6d0:	3a40      	subs	r2, #64	; 0x40
    a6d2:	d323      	bcc.n	a71c <memcpy+0x58>
    a6d4:	680b      	ldr	r3, [r1, #0]
    a6d6:	6003      	str	r3, [r0, #0]
    a6d8:	684b      	ldr	r3, [r1, #4]
    a6da:	6043      	str	r3, [r0, #4]
    a6dc:	688b      	ldr	r3, [r1, #8]
    a6de:	6083      	str	r3, [r0, #8]
    a6e0:	68cb      	ldr	r3, [r1, #12]
    a6e2:	60c3      	str	r3, [r0, #12]
    a6e4:	690b      	ldr	r3, [r1, #16]
    a6e6:	6103      	str	r3, [r0, #16]
    a6e8:	694b      	ldr	r3, [r1, #20]
    a6ea:	6143      	str	r3, [r0, #20]
    a6ec:	698b      	ldr	r3, [r1, #24]
    a6ee:	6183      	str	r3, [r0, #24]
    a6f0:	69cb      	ldr	r3, [r1, #28]
    a6f2:	61c3      	str	r3, [r0, #28]
    a6f4:	6a0b      	ldr	r3, [r1, #32]
    a6f6:	6203      	str	r3, [r0, #32]
    a6f8:	6a4b      	ldr	r3, [r1, #36]	; 0x24
    a6fa:	6243      	str	r3, [r0, #36]	; 0x24
    a6fc:	6a8b      	ldr	r3, [r1, #40]	; 0x28
    a6fe:	6283      	str	r3, [r0, #40]	; 0x28
    a700:	6acb      	ldr	r3, [r1, #44]	; 0x2c
    a702:	62c3      	str	r3, [r0, #44]	; 0x2c
    a704:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    a706:	6303      	str	r3, [r0, #48]	; 0x30
    a708:	6b4b      	ldr	r3, [r1, #52]	; 0x34
    a70a:	6343      	str	r3, [r0, #52]	; 0x34
    a70c:	6b8b      	ldr	r3, [r1, #56]	; 0x38
    a70e:	6383      	str	r3, [r0, #56]	; 0x38
    a710:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
    a712:	63c3      	str	r3, [r0, #60]	; 0x3c
    a714:	3040      	adds	r0, #64	; 0x40
    a716:	3140      	adds	r1, #64	; 0x40
    a718:	3a40      	subs	r2, #64	; 0x40
    a71a:	d2db      	bcs.n	a6d4 <memcpy+0x10>
    a71c:	3230      	adds	r2, #48	; 0x30
    a71e:	d30b      	bcc.n	a738 <memcpy+0x74>
    a720:	680b      	ldr	r3, [r1, #0]
    a722:	6003      	str	r3, [r0, #0]
    a724:	684b      	ldr	r3, [r1, #4]
    a726:	6043      	str	r3, [r0, #4]
    a728:	688b      	ldr	r3, [r1, #8]
    a72a:	6083      	str	r3, [r0, #8]
    a72c:	68cb      	ldr	r3, [r1, #12]
    a72e:	60c3      	str	r3, [r0, #12]
    a730:	3010      	adds	r0, #16
    a732:	3110      	adds	r1, #16
    a734:	3a10      	subs	r2, #16
    a736:	d2f3      	bcs.n	a720 <memcpy+0x5c>
    a738:	320c      	adds	r2, #12
    a73a:	d305      	bcc.n	a748 <memcpy+0x84>
    a73c:	f851 3b04 	ldr.w	r3, [r1], #4
    a740:	f840 3b04 	str.w	r3, [r0], #4
    a744:	3a04      	subs	r2, #4
    a746:	d2f9      	bcs.n	a73c <memcpy+0x78>
    a748:	3204      	adds	r2, #4
    a74a:	d008      	beq.n	a75e <memcpy+0x9a>
    a74c:	07d2      	lsls	r2, r2, #31
    a74e:	bf1c      	itt	ne
    a750:	f811 3b01 	ldrbne.w	r3, [r1], #1
    a754:	f800 3b01 	strbne.w	r3, [r0], #1
    a758:	d301      	bcc.n	a75e <memcpy+0x9a>
    a75a:	880b      	ldrh	r3, [r1, #0]
    a75c:	8003      	strh	r3, [r0, #0]
    a75e:	4660      	mov	r0, ip
    a760:	4770      	bx	lr
    a762:	bf00      	nop
    a764:	2a08      	cmp	r2, #8
    a766:	d313      	bcc.n	a790 <memcpy+0xcc>
    a768:	078b      	lsls	r3, r1, #30
    a76a:	d0b1      	beq.n	a6d0 <memcpy+0xc>
    a76c:	f010 0303 	ands.w	r3, r0, #3
    a770:	d0ae      	beq.n	a6d0 <memcpy+0xc>
    a772:	f1c3 0304 	rsb	r3, r3, #4
    a776:	1ad2      	subs	r2, r2, r3
    a778:	07db      	lsls	r3, r3, #31
    a77a:	bf1c      	itt	ne
    a77c:	f811 3b01 	ldrbne.w	r3, [r1], #1
    a780:	f800 3b01 	strbne.w	r3, [r0], #1
    a784:	d3a4      	bcc.n	a6d0 <memcpy+0xc>
    a786:	f831 3b02 	ldrh.w	r3, [r1], #2
    a78a:	f820 3b02 	strh.w	r3, [r0], #2
    a78e:	e79f      	b.n	a6d0 <memcpy+0xc>
    a790:	3a04      	subs	r2, #4
    a792:	d3d9      	bcc.n	a748 <memcpy+0x84>
    a794:	3a01      	subs	r2, #1
    a796:	f811 3b01 	ldrb.w	r3, [r1], #1
    a79a:	f800 3b01 	strb.w	r3, [r0], #1
    a79e:	d2f9      	bcs.n	a794 <memcpy+0xd0>
    a7a0:	780b      	ldrb	r3, [r1, #0]
    a7a2:	7003      	strb	r3, [r0, #0]
    a7a4:	784b      	ldrb	r3, [r1, #1]
    a7a6:	7043      	strb	r3, [r0, #1]
    a7a8:	788b      	ldrb	r3, [r1, #2]
    a7aa:	7083      	strb	r3, [r0, #2]
    a7ac:	4660      	mov	r0, ip
    a7ae:	4770      	bx	lr

0000a7b0 <strlen>:
    a7b0:	f020 0103 	bic.w	r1, r0, #3
    a7b4:	f010 0003 	ands.w	r0, r0, #3
    a7b8:	f1c0 0000 	rsb	r0, r0, #0
    a7bc:	f851 3b04 	ldr.w	r3, [r1], #4
    a7c0:	f100 0c04 	add.w	ip, r0, #4
    a7c4:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
    a7c8:	f06f 0200 	mvn.w	r2, #0
    a7cc:	bf1c      	itt	ne
    a7ce:	fa22 f20c 	lsrne.w	r2, r2, ip
    a7d2:	4313      	orrne	r3, r2
    a7d4:	f04f 0c01 	mov.w	ip, #1
    a7d8:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
    a7dc:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
    a7e0:	eba3 020c 	sub.w	r2, r3, ip
    a7e4:	ea22 0203 	bic.w	r2, r2, r3
    a7e8:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
    a7ec:	bf04      	itt	eq
    a7ee:	f851 3b04 	ldreq.w	r3, [r1], #4
    a7f2:	3004      	addeq	r0, #4
    a7f4:	d0f4      	beq.n	a7e0 <strlen+0x30>
    a7f6:	f1c2 0100 	rsb	r1, r2, #0
    a7fa:	ea02 0201 	and.w	r2, r2, r1
    a7fe:	fab2 f282 	clz	r2, r2
    a802:	f1c2 021f 	rsb	r2, r2, #31
    a806:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
    a80a:	4770      	bx	lr

0000a80c <perm5_lut>:
    a80c:	0100 0302 0504 0706 0908 0b0a 0d0c 0f0e     ................
    a81c:	1110 1312 1514 1716 1918 1b1a 1d1c 1f1e     ................
    a82c:	0100 0302 0504 0706 1110 1312 1514 1716     ................
    a83c:	0908 0b0a 0d0c 0f0e 1918 1b1a 1d1c 1f1e     ................
    a84c:	0100 1110 0504 1514 0908 1918 0d0c 1d1c     ................
    a85c:	0302 1312 0706 1716 0b0a 1b1a 0f0e 1f1e     ................
    a86c:	0100 0908 0504 0d0c 1110 1918 1514 1d1c     ................
    a87c:	0302 0b0a 0706 0f0e 1312 1b1a 1716 1f1e     ................
    a88c:	0800 0a02 0c04 0e06 0901 0b03 0d05 0f07     ................
    a89c:	1810 1a12 1c14 1e16 1911 1b13 1d15 1f17     ................
    a8ac:	1000 1202 1404 1606 1101 1303 1505 1707     ................
    a8bc:	1808 1a0a 1c0c 1e0e 1909 1b0b 1d0d 1f0f     ................
    a8cc:	0800 1810 0c04 1c14 0901 1911 0d05 1d15     ................
    a8dc:	0a02 1a12 0e06 1e16 0b03 1b13 0f07 1f17     ................
    a8ec:	1000 1808 1404 1c0c 1101 1909 1505 1d0d     ................
    a8fc:	1202 1a0a 1606 1e0e 1303 1b0b 1707 1f0f     ................
    a90c:	0100 0302 1110 1312 0908 0b0a 1918 1b1a     ................
    a91c:	0504 0706 1514 1716 0d0c 0f0e 1d1c 1f1e     ................
    a92c:	0100 0302 0908 0b0a 1110 1312 1918 1b1a     ................
    a93c:	0504 0706 0d0c 0f0e 1514 1716 1d1c 1f1e     ................
    a94c:	0100 1110 0302 1312 0908 1918 0b0a 1b1a     ................
    a95c:	0504 1514 0706 1716 0d0c 1d1c 0f0e 1f1e     ................
    a96c:	0100 0908 0302 0b0a 1110 1918 1312 1b1a     ................
    a97c:	0504 0d0c 0706 0f0e 1514 1d1c 1716 1f1e     ................
    a98c:	0800 0a02 1810 1a12 0901 0b03 1911 1b13     ................
    a99c:	0c04 0e06 1c14 1e16 0d05 0f07 1d15 1f17     ................
    a9ac:	1000 1202 1808 1a0a 1101 1303 1909 1b0b     ................
    a9bc:	1404 1606 1c0c 1e0e 1505 1707 1d0d 1f0f     ................
    a9cc:	0800 1810 0a02 1a12 0901 1911 0b03 1b13     ................
    a9dc:	0c04 1c14 0e06 1e16 0d05 1d15 0f07 1f17     ................
    a9ec:	1000 1808 1202 1a0a 1101 1909 1303 1b0b     ................
    a9fc:	1404 1c0c 1606 1e0e 1505 1d0d 1707 1f0f     ................
    aa0c:	0100 0908 0504 0d0c 0302 0b0a 0706 0f0e     ................
    aa1c:	1110 1918 1514 1d1c 1312 1b1a 1716 1f1e     ................
    aa2c:	0100 1110 0504 1514 0302 1312 0706 1716     ................
    aa3c:	0908 1918 0d0c 1d1c 0b0a 1b1a 0f0e 1f1e     ................
    aa4c:	0100 0908 0504 0d0c 1110 1918 1514 1d1c     ................
    aa5c:	0302 0b0a 0706 0f0e 1312 1b1a 1716 1f1e     ................
    aa6c:	0100 1110 0504 1514 0908 1918 0d0c 1d1c     ................
    aa7c:	0302 1312 0706 1716 0b0a 1b1a 0f0e 1f1e     ................
    aa8c:	0800 0901 0c04 0d05 0a02 0b03 0e06 0f07     ................
    aa9c:	1810 1911 1c14 1d15 1a12 1b13 1e16 1f17     ................
    aaac:	1000 1101 1404 1505 1202 1303 1606 1707     ................
    aabc:	1808 1909 1c0c 1d0d 1a0a 1b0b 1e0e 1f0f     ................
    aacc:	0800 0901 0c04 0d05 1810 1911 1c14 1d15     ................
    aadc:	0a02 0b03 0e06 0f07 1a12 1b13 1e16 1f17     ................
    aaec:	1000 1101 1404 1505 1808 1909 1c0c 1d0d     ................
    aafc:	1202 1303 1606 1707 1a0a 1b0b 1e0e 1f0f     ................
    ab0c:	0100 0908 1110 1918 0302 0b0a 1312 1b1a     ................
    ab1c:	0504 0d0c 1514 1d1c 0706 0f0e 1716 1f1e     ................
    ab2c:	0100 1110 0908 1918 0302 1312 0b0a 1b1a     ................
    ab3c:	0504 1514 0d0c 1d1c 0706 1716 0f0e 1f1e     ................
    ab4c:	0100 0908 0302 0b0a 1110 1918 1312 1b1a     ................
    ab5c:	0504 0d0c 0706 0f0e 1514 1d1c 1716 1f1e     ................
    ab6c:	0100 1110 0302 1312 0908 1918 0b0a 1b1a     ................
    ab7c:	0504 1514 0706 1716 0d0c 1d1c 0f0e 1f1e     ................
    ab8c:	0800 0901 1810 1911 0a02 0b03 1a12 1b13     ................
    ab9c:	0c04 0d05 1c14 1d15 0e06 0f07 1e16 1f17     ................
    abac:	1000 1101 1808 1909 1202 1303 1a0a 1b0b     ................
    abbc:	1404 1505 1c0c 1d0d 1606 1707 1e0e 1f0f     ................
    abcc:	0800 0901 0a02 0b03 1810 1911 1a12 1b13     ................
    abdc:	0c04 0d05 0e06 0f07 1c14 1d15 1e16 1f17     ................
    abec:	1000 1101 1202 1303 1808 1909 1a0a 1b0b     ................
    abfc:	1404 1505 1606 1707 1c0c 1d0d 1e0e 1f0f     ................
    ac0c:	0800 0a02 0c04 0e06 0901 0b03 0d05 0f07     ................
    ac1c:	1810 1a12 1c14 1e16 1911 1b13 1d15 1f17     ................
    ac2c:	1000 1202 1404 1606 1101 1303 1505 1707     ................
    ac3c:	1808 1a0a 1c0c 1e0e 1909 1b0b 1d0d 1f0f     ................
    ac4c:	0800 1810 0c04 1c14 0901 1911 0d05 1d15     ................
    ac5c:	0a02 1a12 0e06 1e16 0b03 1b13 0f07 1f17     ................
    ac6c:	1000 1808 1404 1c0c 1101 1909 1505 1d0d     ................
    ac7c:	1202 1a0a 1606 1e0e 1303 1b0b 1707 1f0f     ................
    ac8c:	0100 0302 0504 0706 0908 0b0a 0d0c 0f0e     ................
    ac9c:	1110 1312 1514 1716 1918 1b1a 1d1c 1f1e     ................
    acac:	0100 0302 0504 0706 1110 1312 1514 1716     ................
    acbc:	0908 0b0a 0d0c 0f0e 1918 1b1a 1d1c 1f1e     ................
    accc:	0100 1110 0504 1514 0908 1918 0d0c 1d1c     ................
    acdc:	0302 1312 0706 1716 0b0a 1b1a 0f0e 1f1e     ................
    acec:	0100 0908 0504 0d0c 1110 1918 1514 1d1c     ................
    acfc:	0302 0b0a 0706 0f0e 1312 1b1a 1716 1f1e     ................
    ad0c:	0800 0a02 1810 1a12 0901 0b03 1911 1b13     ................
    ad1c:	0c04 0e06 1c14 1e16 0d05 0f07 1d15 1f17     ................
    ad2c:	1000 1202 1808 1a0a 1101 1303 1909 1b0b     ................
    ad3c:	1404 1606 1c0c 1e0e 1505 1707 1d0d 1f0f     ................
    ad4c:	0800 1810 0a02 1a12 0901 1911 0b03 1b13     ................
    ad5c:	0c04 1c14 0e06 1e16 0d05 1d15 0f07 1f17     ................
    ad6c:	1000 1808 1202 1a0a 1101 1909 1303 1b0b     ................
    ad7c:	1404 1c0c 1606 1e0e 1505 1d0d 1707 1f0f     ................
    ad8c:	0100 0302 1110 1312 0908 0b0a 1918 1b1a     ................
    ad9c:	0504 0706 1514 1716 0d0c 0f0e 1d1c 1f1e     ................
    adac:	0100 0302 0908 0b0a 1110 1312 1918 1b1a     ................
    adbc:	0504 0706 0d0c 0f0e 1514 1716 1d1c 1f1e     ................
    adcc:	0100 1110 0302 1312 0908 1918 0b0a 1b1a     ................
    addc:	0504 1514 0706 1716 0d0c 1d1c 0f0e 1f1e     ................
    adec:	0100 0908 0302 0b0a 1110 1918 1312 1b1a     ................
    adfc:	0504 0d0c 0706 0f0e 1514 1d1c 1716 1f1e     ................
    ae0c:	0200 0a08 0604 0e0c 0301 0b09 0705 0f0d     ................
    ae1c:	1210 1a18 1614 1e1c 1311 1b19 1715 1f1d     ................
    ae2c:	0200 1210 0604 1614 0301 1311 0705 1715     ................
    ae3c:	0a08 1a18 0e0c 1e1c 0b09 1b19 0f0d 1f1d     ................
    ae4c:	1000 1808 1404 1c0c 1101 1909 1505 1d0d     ................
    ae5c:	1202 1a0a 1606 1e0e 1303 1b0b 1707 1f0f     ................
    ae6c:	0800 1810 0c04 1c14 0901 1911 0d05 1d15     ................
    ae7c:	0a02 1a12 0e06 1e16 0b03 1b13 0f07 1f17     ................
    ae8c:	0200 0301 0604 0705 0a08 0b09 0e0c 0f0d     ................
    ae9c:	1210 1311 1614 1715 1a18 1b19 1e1c 1f1d     ................
    aeac:	0200 0301 0604 0705 1210 1311 1614 1715     ................
    aebc:	0a08 0b09 0e0c 0f0d 1a18 1b19 1e1c 1f1d     ................
    aecc:	1000 1101 1404 1505 1808 1909 1c0c 1d0d     ................
    aedc:	1202 1303 1606 1707 1a0a 1b0b 1e0e 1f0f     ................
    aeec:	0800 0901 0c04 0d05 1810 1911 1c14 1d15     ................
    aefc:	0a02 0b03 0e06 0f07 1a12 1b13 1e16 1f17     ................
    af0c:	0200 0a08 1210 1a18 0301 0b09 1311 1b19     ................
    af1c:	0604 0e0c 1614 1e1c 0705 0f0d 1715 1f1d     ................
    af2c:	0200 1210 0a08 1a18 0301 1311 0b09 1b19     ................
    af3c:	0604 1614 0e0c 1e1c 0705 1715 0f0d 1f1d     ................
    af4c:	1000 1808 1202 1a0a 1101 1909 1303 1b0b     ................
    af5c:	1404 1c0c 1606 1e0e 1505 1d0d 1707 1f0f     ................
    af6c:	0800 1810 0a02 1a12 0901 1911 0b03 1b13     ................
    af7c:	0c04 1c14 0e06 1e16 0d05 1d15 0f07 1f17     ................
    af8c:	0200 0301 1210 1311 0a08 0b09 1a18 1b19     ................
    af9c:	0604 0705 1614 1715 0e0c 0f0d 1e1c 1f1d     ................
    afac:	0200 0301 0a08 0b09 1210 1311 1a18 1b19     ................
    afbc:	0604 0705 0e0c 0f0d 1614 1715 1e1c 1f1d     ................
    afcc:	1000 1101 1202 1303 1808 1909 1a0a 1b0b     ................
    afdc:	1404 1505 1606 1707 1c0c 1d0d 1e0e 1f0f     ................
    afec:	0800 0901 0a02 0b03 1810 1911 1a12 1b13     ................
    affc:	0c04 0d05 0e06 0f07 1c14 1d15 1e16 1f17     ................
    b00c:	0100 0504 0302 0706 0908 0d0c 0b0a 0f0e     ................
    b01c:	1110 1514 1312 1716 1918 1d1c 1b1a 1f1e     ................
    b02c:	0100 0504 0302 0706 1110 1514 1312 1716     ................
    b03c:	0908 0d0c 0b0a 0f0e 1918 1d1c 1b1a 1f1e     ................
    b04c:	0100 0504 1110 1514 0908 0d0c 1918 1d1c     ................
    b05c:	0302 0706 1312 1716 0b0a 0f0e 1b1a 1f1e     ................
    b06c:	0100 0504 0908 0d0c 1110 1514 1918 1d1c     ................
    b07c:	0302 0706 0b0a 0f0e 1312 1716 1b1a 1f1e     ................
    b08c:	0800 0c04 0a02 0e06 0901 0d05 0b03 0f07     ................
    b09c:	1810 1c14 1a12 1e16 1911 1d15 1b13 1f17     ................
    b0ac:	1000 1404 1202 1606 1101 1505 1303 1707     ................
    b0bc:	1808 1c0c 1a0a 1e0e 1909 1d0d 1b0b 1f0f     ................
    b0cc:	0800 0c04 1810 1c14 0901 0d05 1911 1d15     ................
    b0dc:	0a02 0e06 1a12 1e16 0b03 0f07 1b13 1f17     ................
    b0ec:	1000 1404 1808 1c0c 1101 1505 1909 1d0d     ................
    b0fc:	1202 1606 1a0a 1e0e 1303 1707 1b0b 1f0f     ................
    b10c:	0100 1110 0302 1312 0908 1918 0b0a 1b1a     ................
    b11c:	0504 1514 0706 1716 0d0c 1d1c 0f0e 1f1e     ................
    b12c:	0100 0908 0302 0b0a 1110 1918 1312 1b1a     ................
    b13c:	0504 0d0c 0706 0f0e 1514 1d1c 1716 1f1e     ................
    b14c:	0100 0302 1110 1312 0908 0b0a 1918 1b1a     ................
    b15c:	0504 0706 1514 1716 0d0c 0f0e 1d1c 1f1e     ................
    b16c:	0100 0302 0908 0b0a 1110 1312 1918 1b1a     ................
    b17c:	0504 0706 0d0c 0f0e 1514 1716 1d1c 1f1e     ................
    b18c:	0800 1810 0a02 1a12 0901 1911 0b03 1b13     ................
    b19c:	0c04 1c14 0e06 1e16 0d05 1d15 0f07 1f17     ................
    b1ac:	1000 1808 1202 1a0a 1101 1909 1303 1b0b     ................
    b1bc:	1404 1c0c 1606 1e0e 1505 1d0d 1707 1f0f     ................
    b1cc:	0800 0a02 1810 1a12 0901 0b03 1911 1b13     ................
    b1dc:	0c04 0e06 1c14 1e16 0d05 0f07 1d15 1f17     ................
    b1ec:	1000 1202 1808 1a0a 1101 1303 1909 1b0b     ................
    b1fc:	1404 1606 1c0c 1e0e 1505 1707 1d0d 1f0f     ................
    b20c:	0100 0504 0908 0d0c 0302 0706 0b0a 0f0e     ................
    b21c:	1110 1514 1918 1d1c 1312 1716 1b1a 1f1e     ................
    b22c:	0100 0504 1110 1514 0302 0706 1312 1716     ................
    b23c:	0908 0d0c 1918 1d1c 0b0a 0f0e 1b1a 1f1e     ................
    b24c:	0100 0504 0908 0d0c 1110 1514 1918 1d1c     ................
    b25c:	0302 0706 0b0a 0f0e 1312 1716 1b1a 1f1e     ................
    b26c:	0100 0504 1110 1514 0908 0d0c 1918 1d1c     ................
    b27c:	0302 0706 1312 1716 0b0a 0f0e 1b1a 1f1e     ................
    b28c:	0800 0c04 0901 0d05 0a02 0e06 0b03 0f07     ................
    b29c:	1810 1c14 1911 1d15 1a12 1e16 1b13 1f17     ................
    b2ac:	1000 1404 1101 1505 1202 1606 1303 1707     ................
    b2bc:	1808 1c0c 1909 1d0d 1a0a 1e0e 1b0b 1f0f     ................
    b2cc:	0800 0c04 0901 0d05 1810 1c14 1911 1d15     ................
    b2dc:	0a02 0e06 0b03 0f07 1a12 1e16 1b13 1f17     ................
    b2ec:	1000 1404 1101 1505 1808 1c0c 1909 1d0d     ................
    b2fc:	1202 1606 1303 1707 1a0a 1e0e 1b0b 1f0f     ................
    b30c:	0100 1110 0908 1918 0302 1312 0b0a 1b1a     ................
    b31c:	0504 1514 0d0c 1d1c 0706 1716 0f0e 1f1e     ................
    b32c:	0100 0908 1110 1918 0302 0b0a 1312 1b1a     ................
    b33c:	0504 0d0c 1514 1d1c 0706 0f0e 1716 1f1e     ................
    b34c:	0100 0302 0908 0b0a 1110 1312 1918 1b1a     ................
    b35c:	0504 0706 0d0c 0f0e 1514 1716 1d1c 1f1e     ................
    b36c:	0100 0302 1110 1312 0908 0b0a 1918 1b1a     ................
    b37c:	0504 0706 1514 1716 0d0c 0f0e 1d1c 1f1e     ................
    b38c:	0800 1810 0901 1911 0a02 1a12 0b03 1b13     ................
    b39c:	0c04 1c14 0d05 1d15 0e06 1e16 0f07 1f17     ................
    b3ac:	1000 1808 1101 1909 1202 1a0a 1303 1b0b     ................
    b3bc:	1404 1c0c 1505 1d0d 1606 1e0e 1707 1f0f     ................
    b3cc:	0800 0a02 0901 0b03 1810 1a12 1911 1b13     ................
    b3dc:	0c04 0e06 0d05 0f07 1c14 1e16 1d15 1f17     ................
    b3ec:	1000 1202 1101 1303 1808 1a0a 1909 1b0b     ................
    b3fc:	1404 1606 1505 1707 1c0c 1e0e 1d0d 1f0f     ................
    b40c:	0800 0c04 0a02 0e06 0901 0d05 0b03 0f07     ................
    b41c:	1810 1c14 1a12 1e16 1911 1d15 1b13 1f17     ................
    b42c:	1000 1404 1202 1606 1101 1505 1303 1707     ................
    b43c:	1808 1c0c 1a0a 1e0e 1909 1d0d 1b0b 1f0f     ................
    b44c:	0800 0c04 1810 1c14 0901 0d05 1911 1d15     ................
    b45c:	0a02 0e06 1a12 1e16 0b03 0f07 1b13 1f17     ................
    b46c:	1000 1404 1808 1c0c 1101 1505 1909 1d0d     ................
    b47c:	1202 1606 1a0a 1e0e 1303 1707 1b0b 1f0f     ................
    b48c:	0100 0504 0302 0706 0908 0d0c 0b0a 0f0e     ................
    b49c:	1110 1514 1312 1716 1918 1d1c 1b1a 1f1e     ................
    b4ac:	0100 0504 0302 0706 1110 1514 1312 1716     ................
    b4bc:	0908 0d0c 0b0a 0f0e 1918 1d1c 1b1a 1f1e     ................
    b4cc:	0100 0504 1110 1514 0908 0d0c 1918 1d1c     ................
    b4dc:	0302 0706 1312 1716 0b0a 0f0e 1b1a 1f1e     ................
    b4ec:	0100 0504 0908 0d0c 1110 1514 1918 1d1c     ................
    b4fc:	0302 0706 0b0a 0f0e 1312 1716 1b1a 1f1e     ................
    b50c:	0800 1810 0a02 1a12 0901 1911 0b03 1b13     ................
    b51c:	0c04 1c14 0e06 1e16 0d05 1d15 0f07 1f17     ................
    b52c:	1000 1808 1202 1a0a 1101 1909 1303 1b0b     ................
    b53c:	1404 1c0c 1606 1e0e 1505 1d0d 1707 1f0f     ................
    b54c:	0800 0a02 1810 1a12 0901 0b03 1911 1b13     ................
    b55c:	0c04 0e06 1c14 1e16 0d05 0f07 1d15 1f17     ................
    b56c:	1000 1202 1808 1a0a 1101 1303 1909 1b0b     ................
    b57c:	1404 1606 1c0c 1e0e 1505 1707 1d0d 1f0f     ................
    b58c:	0100 1110 0302 1312 0908 1918 0b0a 1b1a     ................
    b59c:	0504 1514 0706 1716 0d0c 1d1c 0f0e 1f1e     ................
    b5ac:	0100 0908 0302 0b0a 1110 1918 1312 1b1a     ................
    b5bc:	0504 0d0c 0706 0f0e 1514 1d1c 1716 1f1e     ................
    b5cc:	0100 0302 1110 1312 0908 0b0a 1918 1b1a     ................
    b5dc:	0504 0706 1514 1716 0d0c 0f0e 1d1c 1f1e     ................
    b5ec:	0100 0302 0908 0b0a 1110 1312 1918 1b1a     ................
    b5fc:	0504 0706 0d0c 0f0e 1514 1716 1d1c 1f1e     ................
    b60c:	0200 0604 0a08 0e0c 0301 0705 0b09 0f0d     ................
    b61c:	1210 1614 1a18 1e1c 1311 1715 1b19 1f1d     ................
    b62c:	0200 0604 1210 1614 0301 0705 1311 1715     ................
    b63c:	0a08 0e0c 1a18 1e1c 0b09 0f0d 1b19 1f1d     ................
    b64c:	1000 1404 1808 1c0c 1101 1505 1909 1d0d     ................
    b65c:	1202 1606 1a0a 1e0e 1303 1707 1b0b 1f0f     ................
    b66c:	0800 0c04 1810 1c14 0901 0d05 1911 1d15     ................
    b67c:	0a02 0e06 1a12 1e16 0b03 0f07 1b13 1f17     ................
    b68c:	0200 0604 0301 0705 0a08 0e0c 0b09 0f0d     ................
    b69c:	1210 1614 1311 1715 1a18 1e1c 1b19 1f1d     ................
    b6ac:	0200 0604 0301 0705 1210 1614 1311 1715     ................
    b6bc:	0a08 0e0c 0b09 0f0d 1a18 1e1c 1b19 1f1d     ................
    b6cc:	1000 1404 1101 1505 1808 1c0c 1909 1d0d     ................
    b6dc:	1202 1606 1303 1707 1a0a 1e0e 1b0b 1f0f     ................
    b6ec:	0800 0c04 0901 0d05 1810 1c14 1911 1d15     ................
    b6fc:	0a02 0e06 0b03 0f07 1a12 1e16 1b13 1f17     ................
    b70c:	0200 1210 0a08 1a18 0301 1311 0b09 1b19     ................
    b71c:	0604 1614 0e0c 1e1c 0705 1715 0f0d 1f1d     ................
    b72c:	0200 0a08 1210 1a18 0301 0b09 1311 1b19     ................
    b73c:	0604 0e0c 1614 1e1c 0705 0f0d 1715 1f1d     ................
    b74c:	1000 1202 1808 1a0a 1101 1303 1909 1b0b     ................
    b75c:	1404 1606 1c0c 1e0e 1505 1707 1d0d 1f0f     ................
    b76c:	0800 0a02 1810 1a12 0901 0b03 1911 1b13     ................
    b77c:	0c04 0e06 1c14 1e16 0d05 0f07 1d15 1f17     ................
    b78c:	0200 1210 0301 1311 0a08 1a18 0b09 1b19     ................
    b79c:	0604 1614 0705 1715 0e0c 1e1c 0f0d 1f1d     ................
    b7ac:	0200 0a08 0301 0b09 1210 1a18 1311 1b19     ................
    b7bc:	0604 0e0c 0705 0f0d 1614 1e1c 1715 1f1d     ................
    b7cc:	1000 1202 1101 1303 1808 1a0a 1909 1b0b     ................
    b7dc:	1404 1606 1505 1707 1c0c 1e0e 1d0d 1f0f     ................
    b7ec:	0800 0a02 0901 0b03 1810 1a12 1911 1b13     ................
    b7fc:	0c04 0e06 0d05 0f07 1c14 1e16 1d15 1f17     ................
    b80c:	0100 0302 0504 0706 0908 0b0a 0d0c 0f0e     ................
    b81c:	1110 1312 1514 1716 1918 1b1a 1d1c 1f1e     ................
    b82c:	0200 0301 0604 0705 0a08 0b09 0e0c 0f0d     ................
    b83c:	1210 1311 1614 1715 1a18 1b19 1e1c 1f1d     ................
    b84c:	0100 0302 0908 0b0a 0504 0706 0d0c 0f0e     ................
    b85c:	1110 1312 1918 1b1a 1514 1716 1d1c 1f1e     ................
    b86c:	0200 0301 0a08 0b09 0604 0705 0e0c 0f0d     ................
    b87c:	1210 1311 1a18 1b19 1614 1715 1e1c 1f1d     ................
    b88c:	0100 0504 0302 0706 0908 0d0c 0b0a 0f0e     ................
    b89c:	1110 1514 1312 1716 1918 1d1c 1b1a 1f1e     ................
    b8ac:	0200 0604 0301 0705 0a08 0e0c 0b09 0f0d     ................
    b8bc:	1210 1614 1311 1715 1a18 1e1c 1b19 1f1d     ................
    b8cc:	0100 0908 0302 0b0a 0504 0d0c 0706 0f0e     ................
    b8dc:	1110 1918 1312 1b1a 1514 1d1c 1716 1f1e     ................
    b8ec:	0200 0a08 0301 0b09 0604 0e0c 0705 0f0d     ................
    b8fc:	1210 1a18 1311 1b19 1614 1e1c 1715 1f1d     ................
    b90c:	0100 0302 0504 0706 1110 1312 1514 1716     ................
    b91c:	0908 0b0a 0d0c 0f0e 1918 1b1a 1d1c 1f1e     ................
    b92c:	0200 0301 0604 0705 1210 1311 1614 1715     ................
    b93c:	0a08 0b09 0e0c 0f0d 1a18 1b19 1e1c 1f1d     ................
    b94c:	0100 0302 0908 0b0a 1110 1312 1918 1b1a     ................
    b95c:	0504 0706 0d0c 0f0e 1514 1716 1d1c 1f1e     ................
    b96c:	0200 0301 0a08 0b09 1210 1311 1a18 1b19     ................
    b97c:	0604 0705 0e0c 0f0d 1614 1715 1e1c 1f1d     ................
    b98c:	0100 0504 0302 0706 1110 1514 1312 1716     ................
    b99c:	0908 0d0c 0b0a 0f0e 1918 1d1c 1b1a 1f1e     ................
    b9ac:	0200 0604 0301 0705 1210 1614 1311 1715     ................
    b9bc:	0a08 0e0c 0b09 0f0d 1a18 1e1c 1b19 1f1d     ................
    b9cc:	0100 0908 0302 0b0a 1110 1918 1312 1b1a     ................
    b9dc:	0504 0d0c 0706 0f0e 1514 1d1c 1716 1f1e     ................
    b9ec:	0200 0a08 0301 0b09 1210 1a18 1311 1b19     ................
    b9fc:	0604 0e0c 0705 0f0d 1614 1e1c 1715 1f1d     ................
    ba0c:	1000 1202 1404 1606 1808 1a0a 1c0c 1e0e     ................
    ba1c:	1101 1303 1505 1707 1909 1b0b 1d0d 1f0f     ................
    ba2c:	1000 1101 1404 1505 1808 1909 1c0c 1d0d     ................
    ba3c:	1202 1303 1606 1707 1a0a 1b0b 1e0e 1f0f     ................
    ba4c:	1000 1202 1808 1a0a 1404 1606 1c0c 1e0e     ................
    ba5c:	1101 1303 1909 1b0b 1505 1707 1d0d 1f0f     ................
    ba6c:	1000 1101 1808 1909 1404 1505 1c0c 1d0d     ................
    ba7c:	1202 1303 1a0a 1b0b 1606 1707 1e0e 1f0f     ................
    ba8c:	1000 1404 1202 1606 1808 1c0c 1a0a 1e0e     ................
    ba9c:	1101 1505 1303 1707 1909 1d0d 1b0b 1f0f     ................
    baac:	1000 1404 1101 1505 1808 1c0c 1909 1d0d     ................
    babc:	1202 1606 1303 1707 1a0a 1e0e 1b0b 1f0f     ................
    bacc:	1000 1808 1202 1a0a 1404 1c0c 1606 1e0e     ................
    badc:	1101 1909 1303 1b0b 1505 1d0d 1707 1f0f     ................
    baec:	1000 1808 1101 1909 1404 1c0c 1505 1d0d     ................
    bafc:	1202 1a0a 1303 1b0b 1606 1e0e 1707 1f0f     ................
    bb0c:	0800 0a02 0c04 0e06 1810 1a12 1c14 1e16     ................
    bb1c:	0901 0b03 0d05 0f07 1911 1b13 1d15 1f17     ................
    bb2c:	0800 0901 0c04 0d05 1810 1911 1c14 1d15     ................
    bb3c:	0a02 0b03 0e06 0f07 1a12 1b13 1e16 1f17     ................
    bb4c:	0400 0602 0c08 0e0a 1410 1612 1c18 1e1a     ................
    bb5c:	0501 0703 0d09 0f0b 1511 1713 1d19 1f1b     ................
    bb6c:	0400 0501 0c08 0d09 1410 1511 1c18 1d19     ................
    bb7c:	0602 0703 0e0a 0f0b 1612 1713 1e1a 1f1b     ................
    bb8c:	0800 0c04 0a02 0e06 1810 1c14 1a12 1e16     ................
    bb9c:	0901 0d05 0b03 0f07 1911 1d15 1b13 1f17     ................
    bbac:	0800 0c04 0901 0d05 1810 1c14 1911 1d15     ................
    bbbc:	0a02 0e06 0b03 0f07 1a12 1e16 1b13 1f17     ................
    bbcc:	0400 0c08 0602 0e0a 1410 1c18 1612 1e1a     ................
    bbdc:	0501 0d09 0703 0f0b 1511 1d19 1713 1f1b     ................
    bbec:	0400 0c08 0501 0d09 1410 1c18 1511 1d19     ................
    bbfc:	0602 0e0a 0703 0f0b 1612 1e1a 1713 1f1b     ................
    bc0c:	0100 0908 0504 0d0c 0302 0b0a 0706 0f0e     ................
    bc1c:	1110 1918 1514 1d1c 1312 1b1a 1716 1f1e     ................
    bc2c:	0200 0a08 0604 0e0c 0301 0b09 0705 0f0d     ................
    bc3c:	1210 1a18 1614 1e1c 1311 1b19 1715 1f1d     ................
    bc4c:	0100 0504 0908 0d0c 0302 0706 0b0a 0f0e     ................
    bc5c:	1110 1514 1918 1d1c 1312 1716 1b1a 1f1e     ................
    bc6c:	0200 0604 0a08 0e0c 0301 0705 0b09 0f0d     ................
    bc7c:	1210 1614 1a18 1e1c 1311 1715 1b19 1f1d     ................
    bc8c:	0100 0908 0302 0b0a 0504 0d0c 0706 0f0e     ................
    bc9c:	1110 1918 1312 1b1a 1514 1d1c 1716 1f1e     ................
    bcac:	0200 0a08 0301 0b09 0604 0e0c 0705 0f0d     ................
    bcbc:	1210 1a18 1311 1b19 1614 1e1c 1715 1f1d     ................
    bccc:	0100 0504 0302 0706 0908 0d0c 0b0a 0f0e     ................
    bcdc:	1110 1514 1312 1716 1918 1d1c 1b1a 1f1e     ................
    bcec:	0200 0604 0301 0705 0a08 0e0c 0b09 0f0d     ................
    bcfc:	1210 1614 1311 1715 1a18 1e1c 1b19 1f1d     ................
    bd0c:	0100 1110 0504 1514 0302 1312 0706 1716     ................
    bd1c:	0908 1918 0d0c 1d1c 0b0a 1b1a 0f0e 1f1e     ................
    bd2c:	0200 1210 0604 1614 0301 1311 0705 1715     ................
    bd3c:	0a08 1a18 0e0c 1e1c 0b09 1b19 0f0d 1f1d     ................
    bd4c:	0100 1110 0908 1918 0302 1312 0b0a 1b1a     ................
    bd5c:	0504 1514 0d0c 1d1c 0706 1716 0f0e 1f1e     ................
    bd6c:	0200 1210 0a08 1a18 0301 1311 0b09 1b19     ................
    bd7c:	0604 1614 0e0c 1e1c 0705 1715 0f0d 1f1d     ................
    bd8c:	0100 1110 0302 1312 0504 1514 0706 1716     ................
    bd9c:	0908 1918 0b0a 1b1a 0d0c 1d1c 0f0e 1f1e     ................
    bdac:	0200 1210 0301 1311 0604 1614 0705 1715     ................
    bdbc:	0a08 1a18 0b09 1b19 0e0c 1e1c 0f0d 1f1d     ................
    bdcc:	0100 1110 0302 1312 0908 1918 0b0a 1b1a     ................
    bddc:	0504 1514 0706 1716 0d0c 1d1c 0f0e 1f1e     ................
    bdec:	0200 1210 0301 1311 0a08 1a18 0b09 1b19     ................
    bdfc:	0604 1614 0705 1715 0e0c 1e1c 0f0d 1f1d     ................
    be0c:	1000 1808 1404 1c0c 1202 1a0a 1606 1e0e     ................
    be1c:	1101 1909 1505 1d0d 1303 1b0b 1707 1f0f     ................
    be2c:	1000 1808 1404 1c0c 1101 1909 1505 1d0d     ................
    be3c:	1202 1a0a 1606 1e0e 1303 1b0b 1707 1f0f     ................
    be4c:	1000 1404 1808 1c0c 1202 1606 1a0a 1e0e     ................
    be5c:	1101 1505 1909 1d0d 1303 1707 1b0b 1f0f     ................
    be6c:	1000 1404 1808 1c0c 1101 1505 1909 1d0d     ................
    be7c:	1202 1606 1a0a 1e0e 1303 1707 1b0b 1f0f     ................
    be8c:	1000 1808 1202 1a0a 1404 1c0c 1606 1e0e     ................
    be9c:	1101 1909 1303 1b0b 1505 1d0d 1707 1f0f     ................
    beac:	1000 1808 1101 1909 1404 1c0c 1505 1d0d     ................
    bebc:	1202 1a0a 1303 1b0b 1606 1e0e 1707 1f0f     ................
    becc:	1000 1404 1202 1606 1808 1c0c 1a0a 1e0e     ................
    bedc:	1101 1505 1303 1707 1909 1d0d 1b0b 1f0f     ................
    beec:	1000 1404 1101 1505 1808 1c0c 1909 1d0d     ................
    befc:	1202 1606 1303 1707 1a0a 1e0e 1b0b 1f0f     ................
    bf0c:	0800 1810 0c04 1c14 0a02 1a12 0e06 1e16     ................
    bf1c:	0901 1911 0d05 1d15 0b03 1b13 0f07 1f17     ................
    bf2c:	0800 1810 0c04 1c14 0901 1911 0d05 1d15     ................
    bf3c:	0a02 1a12 0e06 1e16 0b03 1b13 0f07 1f17     ................
    bf4c:	0400 1410 0c08 1c18 0602 1612 0e0a 1e1a     ................
    bf5c:	0501 1511 0d09 1d19 0703 1713 0f0b 1f1b     ................
    bf6c:	0400 1410 0c08 1c18 0501 1511 0d09 1d19     ................
    bf7c:	0602 1612 0e0a 1e1a 0703 1713 0f0b 1f1b     ................
    bf8c:	0800 1810 0a02 1a12 0c04 1c14 0e06 1e16     ................
    bf9c:	0901 1911 0b03 1b13 0d05 1d15 0f07 1f17     ................
    bfac:	0800 1810 0901 1911 0c04 1c14 0d05 1d15     ................
    bfbc:	0a02 1a12 0b03 1b13 0e06 1e16 0f07 1f17     ................
    bfcc:	0400 1410 0602 1612 0c08 1c18 0e0a 1e1a     ................
    bfdc:	0501 1511 0703 1713 0d09 1d19 0f0b 1f1b     ................
    bfec:	0400 1410 0501 1511 0c08 1c18 0d09 1d19     ................
    bffc:	0602 1612 0703 1713 0e0a 1e1a 0f0b 1f1b     ................
    c00c:	0400 0602 0501 0703 0c08 0e0a 0d09 0f0b     ................
    c01c:	1410 1612 1511 1713 1c18 1e1a 1d19 1f1b     ................
    c02c:	0400 0501 0602 0703 0c08 0d09 0e0a 0f0b     ................
    c03c:	1410 1511 1612 1713 1c18 1d19 1e1a 1f1b     ................
    c04c:	0800 0a02 0901 0b03 0c04 0e06 0d05 0f07     ................
    c05c:	1810 1a12 1911 1b13 1c14 1e16 1d15 1f17     ................
    c06c:	0800 0901 0a02 0b03 0c04 0d05 0e06 0f07     ................
    c07c:	1810 1911 1a12 1b13 1c14 1d15 1e16 1f17     ................
    c08c:	0200 0604 0301 0705 0a08 0e0c 0b09 0f0d     ................
    c09c:	1210 1614 1311 1715 1a18 1e1c 1b19 1f1d     ................
    c0ac:	0100 0504 0302 0706 0908 0d0c 0b0a 0f0e     ................
    c0bc:	1110 1514 1312 1716 1918 1d1c 1b1a 1f1e     ................
    c0cc:	0200 0a08 0301 0b09 0604 0e0c 0705 0f0d     ................
    c0dc:	1210 1a18 1311 1b19 1614 1e1c 1715 1f1d     ................
    c0ec:	0100 0908 0302 0b0a 0504 0d0c 0706 0f0e     ................
    c0fc:	1110 1918 1312 1b1a 1514 1d1c 1716 1f1e     ................
    c10c:	0400 0602 0501 0703 1410 1612 1511 1713     ................
    c11c:	0c08 0e0a 0d09 0f0b 1c18 1e1a 1d19 1f1b     ................
    c12c:	0400 0501 0602 0703 1410 1511 1612 1713     ................
    c13c:	0c08 0d09 0e0a 0f0b 1c18 1d19 1e1a 1f1b     ................
    c14c:	0800 0a02 0901 0b03 1810 1a12 1911 1b13     ................
    c15c:	0c04 0e06 0d05 0f07 1c14 1e16 1d15 1f17     ................
    c16c:	0800 0901 0a02 0b03 1810 1911 1a12 1b13     ................
    c17c:	0c04 0d05 0e06 0f07 1c14 1d15 1e16 1f17     ................
    c18c:	0200 0604 0301 0705 1210 1614 1311 1715     ................
    c19c:	0a08 0e0c 0b09 0f0d 1a18 1e1c 1b19 1f1d     ................
    c1ac:	0100 0504 0302 0706 1110 1514 1312 1716     ................
    c1bc:	0908 0d0c 0b0a 0f0e 1918 1d1c 1b1a 1f1e     ................
    c1cc:	0200 0a08 0301 0b09 1210 1a18 1311 1b19     ................
    c1dc:	0604 0e0c 0705 0f0d 1614 1e1c 1715 1f1d     ................
    c1ec:	0100 0908 0302 0b0a 1110 1918 1312 1b1a     ................
    c1fc:	0504 0d0c 0706 0f0e 1514 1d1c 1716 1f1e     ................
    c20c:	0400 0602 1410 1612 0c08 0e0a 1c18 1e1a     ................
    c21c:	0501 0703 1511 1713 0d09 0f0b 1d19 1f1b     ................
    c22c:	0400 0501 1410 1511 0c08 0d09 1c18 1d19     ................
    c23c:	0602 0703 1612 1713 0e0a 0f0b 1e1a 1f1b     ................
    c24c:	0800 0a02 1810 1a12 0c04 0e06 1c14 1e16     ................
    c25c:	0901 0b03 1911 1b13 0d05 0f07 1d15 1f17     ................
    c26c:	0800 0901 1810 1911 0c04 0d05 1c14 1d15     ................
    c27c:	0a02 0b03 1a12 1b13 0e06 0f07 1e16 1f17     ................
    c28c:	0200 0604 1210 1614 0a08 0e0c 1a18 1e1c     ................
    c29c:	0301 0705 1311 1715 0b09 0f0d 1b19 1f1d     ................
    c2ac:	0100 0504 1110 1514 0908 0d0c 1918 1d1c     ................
    c2bc:	0302 0706 1312 1716 0b0a 0f0e 1b1a 1f1e     ................
    c2cc:	0200 0a08 1210 1a18 0604 0e0c 1614 1e1c     ................
    c2dc:	0301 0b09 1311 1b19 0705 0f0d 1715 1f1d     ................
    c2ec:	0100 0908 1110 1918 0504 0d0c 1514 1d1c     ................
    c2fc:	0302 0b0a 1312 1b1a 0706 0f0e 1716 1f1e     ................
    c30c:	0400 0602 0c08 0e0a 1410 1612 1c18 1e1a     ................
    c31c:	0501 0703 0d09 0f0b 1511 1713 1d19 1f1b     ................
    c32c:	0400 0501 0c08 0d09 1410 1511 1c18 1d19     ................
    c33c:	0602 0703 0e0a 0f0b 1612 1713 1e1a 1f1b     ................
    c34c:	0800 0a02 0c04 0e06 1810 1a12 1c14 1e16     ................
    c35c:	0901 0b03 0d05 0f07 1911 1b13 1d15 1f17     ................
    c36c:	0800 0901 0c04 0d05 1810 1911 1c14 1d15     ................
    c37c:	0a02 0b03 0e06 0f07 1a12 1b13 1e16 1f17     ................
    c38c:	0200 0604 0a08 0e0c 1210 1614 1a18 1e1c     ................
    c39c:	0301 0705 0b09 0f0d 1311 1715 1b19 1f1d     ................
    c3ac:	0100 0504 0908 0d0c 1110 1514 1918 1d1c     ................
    c3bc:	0302 0706 0b0a 0f0e 1312 1716 1b1a 1f1e     ................
    c3cc:	0200 0a08 0604 0e0c 1210 1a18 1614 1e1c     ................
    c3dc:	0301 0b09 0705 0f0d 1311 1b19 1715 1f1d     ................
    c3ec:	0100 0908 0504 0d0c 1110 1918 1514 1d1c     ................
    c3fc:	0302 0b0a 0706 0f0e 1312 1b1a 1716 1f1e     ................
    c40c:	0400 0c08 0501 0d09 0602 0e0a 0703 0f0b     ................
    c41c:	1410 1c18 1511 1d19 1612 1e1a 1713 1f1b     ................
    c42c:	0400 0c08 0602 0e0a 0501 0d09 0703 0f0b     ................
    c43c:	1410 1c18 1612 1e1a 1511 1d19 1713 1f1b     ................
    c44c:	0800 0c04 0901 0d05 0a02 0e06 0b03 0f07     ................
    c45c:	1810 1c14 1911 1d15 1a12 1e16 1b13 1f17     ................
    c46c:	0800 0c04 0a02 0e06 0901 0d05 0b03 0f07     ................
    c47c:	1810 1c14 1a12 1e16 1911 1d15 1b13 1f17     ................
    c48c:	0200 0a08 0301 0b09 0604 0e0c 0705 0f0d     ................
    c49c:	1210 1a18 1311 1b19 1614 1e1c 1715 1f1d     ................
    c4ac:	0100 0908 0302 0b0a 0504 0d0c 0706 0f0e     ................
    c4bc:	1110 1918 1312 1b1a 1514 1d1c 1716 1f1e     ................
    c4cc:	0200 0604 0301 0705 0a08 0e0c 0b09 0f0d     ................
    c4dc:	1210 1614 1311 1715 1a18 1e1c 1b19 1f1d     ................
    c4ec:	0100 0504 0302 0706 0908 0d0c 0b0a 0f0e     ................
    c4fc:	1110 1514 1312 1716 1918 1d1c 1b1a 1f1e     ................
    c50c:	0400 1410 0501 1511 0602 1612 0703 1713     ................
    c51c:	0c08 1c18 0d09 1d19 0e0a 1e1a 0f0b 1f1b     ................
    c52c:	0400 1410 0602 1612 0501 1511 0703 1713     ................
    c53c:	0c08 1c18 0e0a 1e1a 0d09 1d19 0f0b 1f1b     ................
    c54c:	0800 1810 0901 1911 0a02 1a12 0b03 1b13     ................
    c55c:	0c04 1c14 0d05 1d15 0e06 1e16 0f07 1f17     ................
    c56c:	0800 1810 0a02 1a12 0901 1911 0b03 1b13     ................
    c57c:	0c04 1c14 0e06 1e16 0d05 1d15 0f07 1f17     ................
    c58c:	0200 1210 0301 1311 0604 1614 0705 1715     ................
    c59c:	0a08 1a18 0b09 1b19 0e0c 1e1c 0f0d 1f1d     ................
    c5ac:	0100 1110 0302 1312 0504 1514 0706 1716     ................
    c5bc:	0908 1918 0b0a 1b1a 0d0c 1d1c 0f0e 1f1e     ................
    c5cc:	0200 1210 0301 1311 0a08 1a18 0b09 1b19     ................
    c5dc:	0604 1614 0705 1715 0e0c 1e1c 0f0d 1f1d     ................
    c5ec:	0100 1110 0302 1312 0908 1918 0b0a 1b1a     ................
    c5fc:	0504 1514 0706 1716 0d0c 1d1c 0f0e 1f1e     ................
    c60c:	0400 0c08 1410 1c18 0602 0e0a 1612 1e1a     ................
    c61c:	0501 0d09 1511 1d19 0703 0f0b 1713 1f1b     ................
    c62c:	0400 0c08 1410 1c18 0501 0d09 1511 1d19     ................
    c63c:	0602 0e0a 1612 1e1a 0703 0f0b 1713 1f1b     ................
    c64c:	0800 0c04 1810 1c14 0a02 0e06 1a12 1e16     ................
    c65c:	0901 0d05 1911 1d15 0b03 0f07 1b13 1f17     ................
    c66c:	0800 0c04 1810 1c14 0901 0d05 1911 1d15     ................
    c67c:	0a02 0e06 1a12 1e16 0b03 0f07 1b13 1f17     ................
    c68c:	0200 0a08 1210 1a18 0604 0e0c 1614 1e1c     ................
    c69c:	0301 0b09 1311 1b19 0705 0f0d 1715 1f1d     ................
    c6ac:	0100 0908 1110 1918 0504 0d0c 1514 1d1c     ................
    c6bc:	0302 0b0a 1312 1b1a 0706 0f0e 1716 1f1e     ................
    c6cc:	0200 0604 1210 1614 0a08 0e0c 1a18 1e1c     ................
    c6dc:	0301 0705 1311 1715 0b09 0f0d 1b19 1f1d     ................
    c6ec:	0100 0504 1110 1514 0908 0d0c 1918 1d1c     ................
    c6fc:	0302 0706 1312 1716 0b0a 0f0e 1b1a 1f1e     ................
    c70c:	0400 1410 0c08 1c18 0602 1612 0e0a 1e1a     ................
    c71c:	0501 1511 0d09 1d19 0703 1713 0f0b 1f1b     ................
    c72c:	0400 1410 0c08 1c18 0501 1511 0d09 1d19     ................
    c73c:	0602 1612 0e0a 1e1a 0703 1713 0f0b 1f1b     ................
    c74c:	0800 1810 0c04 1c14 0a02 1a12 0e06 1e16     ................
    c75c:	0901 1911 0d05 1d15 0b03 1b13 0f07 1f17     ................
    c76c:	0800 1810 0c04 1c14 0901 1911 0d05 1d15     ................
    c77c:	0a02 1a12 0e06 1e16 0b03 1b13 0f07 1f17     ................
    c78c:	0200 1210 0a08 1a18 0604 1614 0e0c 1e1c     ................
    c79c:	0301 1311 0b09 1b19 0705 1715 0f0d 1f1d     ................
    c7ac:	0100 1110 0908 1918 0504 1514 0d0c 1d1c     ................
    c7bc:	0302 1312 0b0a 1b1a 0706 1716 0f0e 1f1e     ................
    c7cc:	0200 1210 0604 1614 0a08 1a18 0e0c 1e1c     ................
    c7dc:	0301 1311 0705 1715 0b09 1b19 0f0d 1f1d     ................
    c7ec:	0100 1110 0504 1514 0908 1918 0d0c 1d1c     ................
    c7fc:	0302 1312 0706 1716 0b0a 1b1a 0f0e 1f1e     ................
    c80c:	0000 0000                                   ....

0000c810 <sw_matrix>:
    c810:	c014 a0d1 0002 fe00 201f f0b9 0003 0100     ......... ......
    c820:	0edb 3ae4 0003 0080 99b9 5fca 0003 0040     ...:......._..@.
    c830:	d208 6d5d 0003 0020 e904 b6ae 0001 0010     ..]m.. .........
    c840:	7482 db57 0000 0008 ba41 6dab 0000 0004     .tW.....A..m....
    c850:	43f4 f46d 0002 0002 a1fa 7a36 0001 0001     .Cm.......6z....
    c860:	50fd bd1b 8000 0000 36aa 9c35 4002 0000     .P.......65..@..
    c870:	9b55 4e1a 2001 0000 d37e 65b5 1002 0000     U..N. ..~..e....
    c880:	e9bf 32da 0801 0000 ea0b 5bd5 0402 0000     ...2.......[....
    c890:	6bd1 ef52 0203 0000 ab3c 3511 0103 0000     .kR.....<..5....
    c8a0:	d59e 9a88 0081 0000 6acf cd44 0040 0000     .........jD.@...
    c8b0:	abb3 a41a 0022 0000 cb0d 90b5 0013 0000     ...."...........
    c8c0:	7b52 0ae2 000b 0000 3da9 8571 0005 0000     R{.......=q.....
    c8d0:	4e28 6979 7020 746c 2520 2964 0000 0000     (Nyi plt %d)....
    c8e0:	4944 7c45 6f4e 7020 7961 6f6c 6461 6620     DIE|No payload f
    c8f0:	726f 7420 7079 2065 7025 0a0a 0000 0000     or type %p......
    c900:	4944 7c45 6564 5f63 636e 203a 6e75 206b     DIE|dec_nc: unk 
    c910:	6c70 6c20 6e65 0a0a 0000 0000 4944 7c45     pl len......DIE|
    c920:	6564 5f63 636e 203a 7265 6f72 2072 7661     dec_nc: error av
    c930:	2520 2064 666f 2520 0a64 000a 4944 7c45      %d of %d...DIE|
    c940:	6b50 2074 6f6e 2074 6564 6f63 6564 3f64     Pkt not decoded?
    c950:	2520 3a64 6425 0a0a 0000 0000                %d:%d......

0000c95c <bbcodec_acl_types>:
    c95c:	0001 0000 0000 0001 0000 0000 0001 0012     ................
    c96c:	0101 0101 0011 0101 0101 001b 0100 0000     ................
    c97c:	0000 0000 0000 0000 0000 0000 0000 0000     ................
    c98c:	0000 0000 0000 0000 0000 0000 0203 0079     ..............y.
    c99c:	0101 0203 00b7 0100 0000 0000 0000 0000     ................
    c9ac:	0000 0000 0205 00e0 0101 0205 0153 0100     ............S...
    c9bc:	4944 7c45 796e 2069 6e75 6c61 6769 656e     DIE|nyi unaligne
    c9cc:	2064 6e69 2520 0a64 000a 0000 4944 7c45     d in %d.....DIE|
    c9dc:	796e 2069 6e75 6c61 6769 656e 2064 756f     nyi unaligned ou
    c9ec:	2074 6425 0a0a 0000                         t %d....

0000c9f4 <whiten_word_tbl>:
    c9f4:	4000 6020 d090 f0b0 0848 2868 98d8 b8f8     .@ `....H.h(....
    ca04:	6424 4404 f4b4 d494 2c6c 0c4c bcfc 9cdc     $d.D....l,L.....
    ca14:	d292 f2b2 4202 6222 9ada bafa 0a4a 2a6a     .....B"b....J.j*
    ca24:	f6b6 d696 6626 4606 befe 9ede 2e6e 0e4e     ....&f.F....n.N.
    ca34:	89c9 a9e9 1959 3979 c181 e1a1 5111 7131     ....Y.y9.....Q1q
    ca44:	aded 8dcd 3d7d 1d5d e5a5 c585 7535 5515     ....}=].....5u.U
    ca54:	1b5b 3b7b 8bcb abeb 5313 7333 c383 e3a3     [.{;.....S3s....
    ca64:	3f7f 1f5f afef 8fcf 7737 5717 e7a7 c787     .?_.....7w.W....

0000ca74 <whiten_state_tbl>:
    ca74:	0200 0604 0a08 0e0c 1210 1614 1a18 1e1c     ................
    ca84:	2220 2624 2a28 2e2c 3230 3634 3a38 3e3c      "$&(*,.02468:<>
    ca94:	4240 4644 4a48 4e4c 5250 5654 5a58 5e5c     @BDFHJLNPRTVXZ\^
    caa4:	6260 6664 6a68 6e6c 7270 7674 7a78 7e7c     `bdfhjlnprtvxz|~
    cab4:	1311 1715 1b19 1f1d 0301 0705 0b09 0f0d     ................
    cac4:	3331 3735 3b39 3f3d 2321 2725 2b29 2f2d     13579;=?!#%')+-/
    cad4:	5351 5755 5b59 5f5d 4341 4745 4b49 4f4d     QSUWY[]_ACEGIKMO
    cae4:	7371 7775 7b79 7f7d 6361 6765 6b69 6f6d     qsuwy{}.acegikmo
    caf4:	0400 0c08 1410 1c18 2420 2c28 3430 3c38     ........ $(,048<
    cb04:	4440 4c48 5450 5c58 6460 6c68 7470 7c78     @DHLPTX\`dhlptx|
    cb14:	1511 1d19 0501 0d09 3531 3d39 2521 2d29     ........159=!%)-
    cb24:	5551 5d59 4541 4d49 7571 7d79 6561 6d69     QUY]AEIMquy}aeim
    cb34:	2622 2e2a 3632 3e3a 0602 0e0a 1612 1e1a     "&*.26:>........
    cb44:	6662 6e6a 7672 7e7a 4642 4e4a 5652 5e5a     bfjnrvz~BFJNRVZ^
    cb54:	3733 3f3b 2723 2f2b 1713 1f1b 0703 0f0b     37;?#'+/........
    cb64:	7773 7f7b 6763 6f6b 5753 5f5b 4743 4f4b     sw{.cgkoSW[_CGKO
    cb74:	0800 1810 2820 3830 4840 5850 6860 7870     .... (08@HPX`hpx
    cb84:	1911 0901 3931 2921 5951 4941 7971 6961     ....19!)QYAIqyai
    cb94:	2a22 3a32 0a02 1a12 6a62 7a72 4a42 5a52     "*2:....bjrzBJRZ
    cba4:	3b33 2b23 1b13 0b03 7b73 6b63 5b53 4b43     3;#+....s{ckS[CK
    cbb4:	4c44 5c54 6c64 7c74 0c04 1c14 2c24 3c34     DLT\dlt|....$,4<
    cbc4:	5d55 4d45 7d75 6d65 1d15 0d05 3d35 2d25     U]EMu}em....5=%-
    cbd4:	6e66 7e76 4e46 5e56 2e26 3e36 0e06 1e16     fnv~FNV^&.6>....
    cbe4:	7f77 6f67 5f57 4f47 3f37 2f27 1f17 0f07     w.goW_GO7?'/....
    cbf4:	1000 3020 5040 7060 0111 2131 4151 6171     .. 0@P`p..1!QAqa
    cc04:	3222 1202 7262 5242 2333 0313 6373 4353     "2..brBR3#..scSC
    cc14:	5444 7464 1404 3424 4555 6575 0515 2535     DTdt..$4UEue..5%
    cc24:	7666 5646 3626 1606 6777 4757 2737 0717     fvFV&6..wgWG7'..
    cc34:	0919 2939 4959 6979 1808 3828 5848 7868     ..9)YIyi..(8HXhx
    cc44:	2b3b 0b1b 6b7b 4b5b 3a2a 1a0a 7a6a 5a4a     ;+..{k[K*:..jzJZ
    cc54:	4d5d 6d7d 0d1d 2d3d 5c4c 7c6c 1c0c 3c2c     ]M}m..=-L\l|..,<
    cc64:	6f7f 4f5f 2f3f 0f1f 7e6e 5e4e 3e2e 1e0e     .o_O?/..n~N^.>..
    cc74:	2000 6040 3111 7151 0222 4262 1333 5373     . @`.1Qq".bB3.sS
    cc84:	6444 2404 7555 3515 4666 0626 5777 1737     Dd.$Uu.5fF&.wW7.
    cc94:	3919 7959 2808 6848 1b3b 5b7b 0a2a 4a6a     .9Yy.(Hh;.{[*.jJ
    cca4:	7d5d 3d1d 6c4c 2c0c 5f7f 1f3f 4e6e 0e2e     ]}.=Ll.,._?.nN..
    ccb4:	1232 5272 0323 4363 3010 7050 2101 6141     2.rR#.cC.0Pp.!Aa
    ccc4:	5676 1636 4767 0727 7454 3414 6545 2505     vV6.gG'.Tt.4Ee.%
    ccd4:	0b2b 4b6b 1a3a 5a7a 2909 6949 3818 7858     +.kK:.zZ.)Ii.8Xx
    cce4:	4f6f 0f2f 5e7e 1e3e 6d4d 2d0d 7c5c 3c1c     oO/.~^>.Mm.-\|.<
    ccf4:	4000 5111 6222 7333 0444 1555 2666 3777     .@.Q"b3sD.U.f&w7
    cd04:	5919 4808 7b3b 6a2a 1d5d 0c4c 3f7f 2e6e     .Y.H;{*j].L..?n.
    cd14:	7232 6323 5010 4101 3676 2767 1454 0545     2r#c.P.Av6g'T.E.
    cd24:	6b2b 7a3a 4909 5818 2f6f 3e7e 0d4d 1c5c     +k:z.I.Xo/~>M.\.
    cd34:	2464 3575 0646 1757 6020 7131 4202 5313     d$u5F.W. `1q.B.S
    cd44:	3d7d 2c6c 1f5f 0e4e 7939 6828 5b1b 4a0a     }=l,_.N.9y(h.[.J
    cd54:	1656 0747 3474 2565 5212 4303 7030 6121     V.G.t4e%.R.C0p!a
    cd64:	0f4f 1e5e 2d6d 3c7c 4b0b 5a1a 6929 7838     O.^.m-|<.K.Z)i8x
    cd74:	1100 3322 5544 7766 0819 2a3b 4c5d 6e7f     .."3DUfw..;*]L.n
    cd84:	2332 0110 6776 4554 3a2b 1809 7e6f 5c4d     2#..vgTE+:..o~M\
    cd94:	7564 5746 3120 1302 6c7d 4e5f 2839 0a1b     duFW 1..}l_N9(..
    cda4:	4756 6574 0312 2130 5e4f 7c6d 1a0b 3829     VGte..0!O^m|..)8
    cdb4:	4859 6a7b 0c1d 2e3f 5140 7362 1504 3726     YH{j..?.@Qbs..&7
    cdc4:	7a6b 5849 3e2f 1c0d 6372 4150 2736 0514     kzIX/>..rcPA6'..
    cdd4:	2c3d 0e1f 6879 4a5b 3524 1706 7160 5342     =,..yh[J$5..`qBS
    cde4:	1e0f 3c2d 5a4b 7869 0716 2534 4352 6170     ..-<KZix..4%RCpa
    cdf4:	2200 6644 3b19 7f5d 1032 5476 092b 4d6f     ."Df.;].2.vT+.oM
    ce04:	4664 0220 5f7d 1b39 7456 3012 6d4f 290b     dF .}_9.Vt.0Om.)
    ce14:	7b59 3f1d 6240 2604 496b 0d2f 5072 1436     Y{.?@b.&kI/.rP6.
    ce24:	1f3d 5b79 0624 4260 2d0f 694b 3416 7052     =.y[$.`B.-Ki.4Rp
    ce34:	0123 4567 183a 5c7e 3311 7755 2a08 6e4c     #.gE:.~\.3Uw.*Ln
    ce44:	6547 2103 7c5e 381a 5775 1331 4e6c 0a28     Ge.!^|.8uW1.lN(.
    ce54:	587a 1c3e 4163 0527 6a48 2e0c 7351 3715     zX>.cA'.Hj..Qs.7
    ce64:	3c1e 785a 2507 6143 0e2c 4a68 1735 5371     .<Zx.%Ca,.hJ5.qS

0000ce74 <fec23_tbl>:
    ce74:	0b00 1d16 0c07 1a11 050e 1318 0209 141f     ................
    ce84:	171c 010a 101b 060d 1912 0f04 1e15 0803     ................
    ce94:	1813 0e05 1f14 0902 161d 000b 111a 070c     ................
    cea4:	040f 1219 0308 151e 0a01 1c17 0d06 1b10     ................
    ceb4:	060d 101b 010a 171c 0803 1e15 0f04 1912     ................
    cec4:	1a11 0c07 1d16 0b00 141f 0209 1318 050e     ................
    ced4:	151e 0308 1219 040f 1b10 0d06 1c17 0a01     ................
    cee4:	0902 1f14 0e05 1813 070c 111a 000b 161d     ................
    cef4:	111a 070c 161d 000b 1f14 0902 1813 0e05     ................
    cf04:	0d06 1b10 0a01 1c17 0308 151e 040f 1219     ................
    cf14:	0209 141f 050e 1318 0c07 1a11 0b00 1d16     ................
    cf24:	1e15 0803 1912 0f04 101b 060d 171c 010a     ................
    cf34:	1c17 0a01 1b10 0d06 1219 040f 151e 0308     ................
    cf44:	000b 161d 070c 111a 0e05 1813 0902 1f14     ................
    cf54:	0f04 1912 0803 1e15 010a 171c 060d 101b     ................
    cf64:	1318 050e 141f 0209 1d16 0b00 1a11 0c07     ................
    cf74:	141f 0209 1318 050e 1a11 0c07 1d16 0b00     ................
    cf84:	0803 1e15 0f04 1912 060d 101b 010a 171c     ................
    cf94:	070c 111a 000b 161d 0902 1f14 0e05 1813     ................
    cfa4:	1b10 0d06 1c17 0a01 151e 0308 1219 040f     ................
    cfb4:	1912 0f04 1e15 0803 171c 010a 101b 060d     ................
    cfc4:	050e 1318 0209 141f 0b00 1d16 0c07 1a11     ................
    cfd4:	0a01 1c17 0d06 1b10 040f 1219 0308 151e     ................
    cfe4:	161d 000b 111a 070c 1813 0e05 1f14 0902     ................
    cff4:	0e05 1813 0902 1f14 000b 161d 070c 111a     ................
    d004:	1219 040f 151e 0308 1c17 0a01 1b10 0d06     ................
    d014:	1d16 0b00 1a11 0c07 1318 050e 141f 0209     ................
    d024:	010a 171c 060d 101b 0f04 1912 0803 1e15     ................
    d034:	0308 151e 040f 1219 0d06 1b10 0a01 1c17     ................
    d044:	1f14 0902 1813 0e05 111a 070c 161d 000b     ................
    d054:	101b 060d 171c 010a 1e15 0803 1912 0f04     ................
    d064:	0c07 1a11 0b00 1d16 0209 141f 050e 1318     ................
    d074:	1e15 0803 1912 0f04 101b 060d 171c 010a     ................
    d084:	0209 141f 050e 1318 0c07 1a11 0b00 1d16     ................
    d094:	0d06 1b10 0a01 1c17 0308 151e 040f 1219     ................
    d0a4:	111a 070c 161d 000b 1f14 0902 1813 0e05     ................
    d0b4:	1318 050e 141f 0209 1d16 0b00 1a11 0c07     ................
    d0c4:	0f04 1912 0803 1e15 010a 171c 060d 101b     ................
    d0d4:	000b 161d 070c 111a 0e05 1813 0902 1f14     ................
    d0e4:	1c17 0a01 1b10 0d06 1219 040f 151e 0308     ................
    d0f4:	040f 1219 0308 151e 0a01 1c17 0d06 1b10     ................
    d104:	1813 0e05 1f14 0902 161d 000b 111a 070c     ................
    d114:	171c 010a 101b 060d 1912 0f04 1e15 0803     ................
    d124:	0b00 1d16 0c07 1a11 050e 1318 0209 141f     ................
    d134:	0902 1f14 0e05 1813 070c 111a 000b 161d     ................
    d144:	151e 0308 1219 040f 1b10 0d06 1c17 0a01     ................
    d154:	1a11 0c07 1d16 0b00 141f 0209 1318 050e     ................
    d164:	060d 101b 010a 171c 0803 1e15 0f04 1912     ................
    d174:	010a 171c 060d 101b 0f04 1912 0803 1e15     ................
    d184:	1d16 0b00 1a11 0c07 1318 050e 141f 0209     ................
    d194:	1219 040f 151e 0308 1c17 0a01 1b10 0d06     ................
    d1a4:	0e05 1813 0902 1f14 000b 161d 070c 111a     ................
    d1b4:	0c07 1a11 0b00 1d16 0209 141f 050e 1318     ................
    d1c4:	101b 060d 171c 010a 1e15 0803 1912 0f04     ................
    d1d4:	1f14 0902 1813 0e05 111a 070c 161d 000b     ................
    d1e4:	0308 151e 040f 1219 0d06 1b10 0a01 1c17     ................
    d1f4:	1b10 0d06 1c17 0a01 151e 0308 1219 040f     ................
    d204:	070c 111a 000b 161d 0902 1f14 0e05 1813     ................
    d214:	0803 1e15 0f04 1912 060d 101b 010a 171c     ................
    d224:	141f 0209 1318 050e 1a11 0c07 1d16 0b00     ................
    d234:	161d 000b 111a 070c 1813 0e05 1f14 0902     ................
    d244:	0a01 1c17 0d06 1b10 040f 1219 0308 151e     ................
    d254:	050e 1318 0209 141f 0b00 1d16 0c07 1a11     ................
    d264:	1912 0f04 1e15 0803 171c 010a 101b 060d     ................

0000d274 <fec23_cor>:
    d274:	0000 0000 0000 0000 0000 0000 0000 0004     ................
    d284:	0000 0000 0000 0001 0000 0040 0008 0000     ..........@.....
    d294:	0000 0000 0000 0020 0000 0200 0002 0000     ...... .........
    d2a4:	0000 0000 0080 0000 0010 0000 0000 0100     ................

0000d2b4 <fec13_tbl>:
    d2b4:	0000 0000 0007 0000 0038 0000 003f 0000     ........8...?...
    d2c4:	01c0 0000 01c7 0000 01f8 0000 01ff 0000     ................
    d2d4:	0e00 0000 0e07 0000 0e38 0000 0e3f 0000     ........8...?...
    d2e4:	0fc0 0000 0fc7 0000 0ff8 0000 0fff 0000     ................
    d2f4:	7000 0000 7007 0000 7038 0000 703f 0000     .p...p..8p..?p..
    d304:	71c0 0000 71c7 0000 71f8 0000 71ff 0000     .q...q...q...q..
    d314:	7e00 0000 7e07 0000 7e38 0000 7e3f 0000     .~...~..8~..?~..
    d324:	7fc0 0000 7fc7 0000 7ff8 0000 7fff 0000     ................
    d334:	8000 0003 8007 0003 8038 0003 803f 0003     ........8...?...
    d344:	81c0 0003 81c7 0003 81f8 0003 81ff 0003     ................
    d354:	8e00 0003 8e07 0003 8e38 0003 8e3f 0003     ........8...?...
    d364:	8fc0 0003 8fc7 0003 8ff8 0003 8fff 0003     ................
    d374:	f000 0003 f007 0003 f038 0003 f03f 0003     ........8...?...
    d384:	f1c0 0003 f1c7 0003 f1f8 0003 f1ff 0003     ................
    d394:	fe00 0003 fe07 0003 fe38 0003 fe3f 0003     ........8...?...
    d3a4:	ffc0 0003 ffc7 0003 fff8 0003 ffff 0003     ................
    d3b4:	0000 001c 0007 001c 0038 001c 003f 001c     ........8...?...
    d3c4:	01c0 001c 01c7 001c 01f8 001c 01ff 001c     ................
    d3d4:	0e00 001c 0e07 001c 0e38 001c 0e3f 001c     ........8...?...
    d3e4:	0fc0 001c 0fc7 001c 0ff8 001c 0fff 001c     ................
    d3f4:	7000 001c 7007 001c 7038 001c 703f 001c     .p...p..8p..?p..
    d404:	71c0 001c 71c7 001c 71f8 001c 71ff 001c     .q...q...q...q..
    d414:	7e00 001c 7e07 001c 7e38 001c 7e3f 001c     .~...~..8~..?~..
    d424:	7fc0 001c 7fc7 001c 7ff8 001c 7fff 001c     ................
    d434:	8000 001f 8007 001f 8038 001f 803f 001f     ........8...?...
    d444:	81c0 001f 81c7 001f 81f8 001f 81ff 001f     ................
    d454:	8e00 001f 8e07 001f 8e38 001f 8e3f 001f     ........8...?...
    d464:	8fc0 001f 8fc7 001f 8ff8 001f 8fff 001f     ................
    d474:	f000 001f f007 001f f038 001f f03f 001f     ........8...?...
    d484:	f1c0 001f f1c7 001f f1f8 001f f1ff 001f     ................
    d494:	fe00 001f fe07 001f fe38 001f fe3f 001f     ........8...?...
    d4a4:	ffc0 001f ffc7 001f fff8 001f ffff 001f     ................
    d4b4:	0000 00e0 0007 00e0 0038 00e0 003f 00e0     ........8...?...
    d4c4:	01c0 00e0 01c7 00e0 01f8 00e0 01ff 00e0     ................
    d4d4:	0e00 00e0 0e07 00e0 0e38 00e0 0e3f 00e0     ........8...?...
    d4e4:	0fc0 00e0 0fc7 00e0 0ff8 00e0 0fff 00e0     ................
    d4f4:	7000 00e0 7007 00e0 7038 00e0 703f 00e0     .p...p..8p..?p..
    d504:	71c0 00e0 71c7 00e0 71f8 00e0 71ff 00e0     .q...q...q...q..
    d514:	7e00 00e0 7e07 00e0 7e38 00e0 7e3f 00e0     .~...~..8~..?~..
    d524:	7fc0 00e0 7fc7 00e0 7ff8 00e0 7fff 00e0     ................
    d534:	8000 00e3 8007 00e3 8038 00e3 803f 00e3     ........8...?...
    d544:	81c0 00e3 81c7 00e3 81f8 00e3 81ff 00e3     ................
    d554:	8e00 00e3 8e07 00e3 8e38 00e3 8e3f 00e3     ........8...?...
    d564:	8fc0 00e3 8fc7 00e3 8ff8 00e3 8fff 00e3     ................
    d574:	f000 00e3 f007 00e3 f038 00e3 f03f 00e3     ........8...?...
    d584:	f1c0 00e3 f1c7 00e3 f1f8 00e3 f1ff 00e3     ................
    d594:	fe00 00e3 fe07 00e3 fe38 00e3 fe3f 00e3     ........8...?...
    d5a4:	ffc0 00e3 ffc7 00e3 fff8 00e3 ffff 00e3     ................
    d5b4:	0000 00fc 0007 00fc 0038 00fc 003f 00fc     ........8...?...
    d5c4:	01c0 00fc 01c7 00fc 01f8 00fc 01ff 00fc     ................
    d5d4:	0e00 00fc 0e07 00fc 0e38 00fc 0e3f 00fc     ........8...?...
    d5e4:	0fc0 00fc 0fc7 00fc 0ff8 00fc 0fff 00fc     ................
    d5f4:	7000 00fc 7007 00fc 7038 00fc 703f 00fc     .p...p..8p..?p..
    d604:	71c0 00fc 71c7 00fc 71f8 00fc 71ff 00fc     .q...q...q...q..
    d614:	7e00 00fc 7e07 00fc 7e38 00fc 7e3f 00fc     .~...~..8~..?~..
    d624:	7fc0 00fc 7fc7 00fc 7ff8 00fc 7fff 00fc     ................
    d634:	8000 00ff 8007 00ff 8038 00ff 803f 00ff     ........8...?...
    d644:	81c0 00ff 81c7 00ff 81f8 00ff 81ff 00ff     ................
    d654:	8e00 00ff 8e07 00ff 8e38 00ff 8e3f 00ff     ........8...?...
    d664:	8fc0 00ff 8fc7 00ff 8ff8 00ff 8fff 00ff     ................
    d674:	f000 00ff f007 00ff f038 00ff f03f 00ff     ........8...?...
    d684:	f1c0 00ff f1c7 00ff f1f8 00ff f1ff 00ff     ................
    d694:	fe00 00ff fe07 00ff fe38 00ff fe3f 00ff     ........8...?...
    d6a4:	ffc0 00ff ffc7 00ff fff8 00ff ffff 00ff     ................

0000d6b4 <unfec13_tbl>:
    d6b4:	0000 4000 4000 4001 4000 4001 4001 0001     ...@.@.@.@.@.@..
    d6c4:	4000 8000 8000 8001 8000 8001 8001 4001     .@.............@
    d6d4:	4000 8000 8000 8001 8000 8001 8001 4001     .@.............@
    d6e4:	4002 8002 8002 8003 8002 8003 8003 4003     .@.............@
    d6f4:	4000 8000 8000 8001 8000 8001 8001 4001     .@.............@
    d704:	4002 8002 8002 8003 8002 8003 8003 4003     .@.............@
    d714:	4002 8002 8002 8003 8002 8003 8003 4003     .@.............@
    d724:	0002 4002 4002 4003 4002 4003 4003 0003     ...@.@.@.@.@.@..

0000d734 <hec_tbl>:
    d734:	ce00 9957 60ae 37f9 5997 0ec0 f739 a06e     ..W..`.7.Y..9.n.
    d744:	2be5 7cb2 854b d21c bc72 eb25 12dc 458b     .+.|K...r.%....E

0000d754 <crc_tbl>:
    d754:	0000 1189 2312 329b 4624 57ad 6536 74bf     .....#.2$F.W6e.t
    d764:	8c48 9dc1 af5a bed3 ca6c dbe5 e97e f8f7     H...Z...l...~...
    d774:	1081 0108 3393 221a 56a5 472c 75b7 643e     .....3.".V,G.u>d
    d784:	9cc9 8d40 bfdb ae52 daed cb64 f9ff e876     ..@...R...d...v.
    d794:	2102 308b 0210 1399 6726 76af 4434 55bd     .!.0....&g.v4D.U
    d7a4:	ad4a bcc3 8e58 9fd1 eb6e fae7 c87c d9f5     J...X...n...|...
    d7b4:	3183 200a 1291 0318 77a7 662e 54b5 453c     .1. .....w.f.T<E
    d7c4:	bdcb ac42 9ed9 8f50 fbef ea66 d8fd c974     ..B...P...f...t.
    d7d4:	4204 538d 6116 709f 0420 15a9 2732 36bb     .B.S.a.p ...2'.6
    d7e4:	ce4c dfc5 ed5e fcd7 8868 99e1 ab7a baf3     L...^...h...z...
    d7f4:	5285 430c 7197 601e 14a1 0528 37b3 263a     .R.C.q.`..(..7:&
    d804:	decd cf44 fddf ec56 98e9 8960 bbfb aa72     ..D...V...`...r.
    d814:	6306 728f 4014 519d 2522 34ab 0630 17b9     .c.r.@.Q"%.40...
    d824:	ef4e fec7 cc5c ddd5 a96a b8e3 8a78 9bf1     N...\...j...x...
    d834:	7387 620e 5095 411c 35a3 242a 16b1 0738     .s.b.P.A.5*$..8.
    d844:	ffcf ee46 dcdd cd54 b9eb a862 9af9 8b70     ..F...T...b...p.
    d854:	8408 9581 a71a b693 c22c d3a5 e13e f0b7     ........,...>...
    d864:	0840 19c9 2b52 3adb 4e64 5fed 6d76 7cff     @...R+.:dN._vm.|
    d874:	9489 8500 b79b a612 d2ad c324 f1bf e036     ..........$...6.
    d884:	18c1 0948 3bd3 2a5a 5ee5 4f6c 7df7 6c7e     ..H..;Z*.^lO.}~l
    d894:	a50a b483 8618 9791 e32e f2a7 c03c d1b5     ............<...
    d8a4:	2942 38cb 0a50 1bd9 6f66 7eef 4c74 5dfd     B).8P...fo.~tL.]
    d8b4:	b58b a402 9699 8710 f3af e226 d0bd c134     ..........&...4.
    d8c4:	39c3 284a 1ad1 0b58 7fe7 6e6e 5cf5 4d7c     .9J(..X...nn.\|M
    d8d4:	c60c d785 e51e f497 8028 91a1 a33a b2b3     ........(...:...
    d8e4:	4a44 5bcd 6956 78df 0c60 1de9 2f72 3efb     DJ.[Vi.x`...r/.>
    d8f4:	d68d c704 f59f e416 90a9 8120 b3bb a232     .......... ...2.
    d904:	5ac5 4b4c 79d7 685e 1ce1 0d68 3ff3 2e7a     .ZLK.y^h..h..?z.
    d914:	e70e f687 c41c d595 a12a b0a3 8238 93b1     ........*...8...
    d924:	6b46 7acf 4854 59dd 2d62 3ceb 0e70 1ff9     Fk.zTH.Yb-.<p...
    d934:	f78f e606 d49d c514 b1ab a022 92b9 8330     .........."...0.
    d944:	7bc7 6a4e 58d5 495c 3de3 2c6a 1ef1 0f78     .{Nj.X\I.=j,..x.

0000d954 <rev8_map>:
    d954:	8000 c040 a020 e060 9010 d050 b030 f070     ..@. .`...P.0.p.
    d964:	8808 c848 a828 e868 9818 d858 b838 f878     ..H.(.h...X.8.x.
    d974:	8404 c444 a424 e464 9414 d454 b434 f474     ..D.$.d...T.4.t.
    d984:	8c0c cc4c ac2c ec6c 9c1c dc5c bc3c fc7c     ..L.,.l...\.<.|.
    d994:	8202 c242 a222 e262 9212 d252 b232 f272     ..B.".b...R.2.r.
    d9a4:	8a0a ca4a aa2a ea6a 9a1a da5a ba3a fa7a     ..J.*.j...Z.:.z.
    d9b4:	8606 c646 a626 e666 9616 d656 b636 f676     ..F.&.f...V.6.v.
    d9c4:	8e0e ce4e ae2e ee6e 9e1e de5e be3e fe7e     ..N...n...^.>.~.
    d9d4:	8101 c141 a121 e161 9111 d151 b131 f171     ..A.!.a...Q.1.q.
    d9e4:	8909 c949 a929 e969 9919 d959 b939 f979     ..I.).i...Y.9.y.
    d9f4:	8505 c545 a525 e565 9515 d555 b535 f575     ..E.%.e...U.5.u.
    da04:	8d0d cd4d ad2d ed6d 9d1d dd5d bd3d fd7d     ..M.-.m...].=.}.
    da14:	8303 c343 a323 e363 9313 d353 b333 f373     ..C.#.c...S.3.s.
    da24:	8b0b cb4b ab2b eb6b 9b1b db5b bb3b fb7b     ..K.+.k...[.;.{.
    da34:	8707 c747 a727 e767 9717 d757 b737 f777     ..G.'.g...W.7.w.
    da44:	8f0f cf4f af2f ef6f 9f1f df5f bf3f ff7f     ..O./.o..._.?...
    da54:	3032 3032 312d 2d32 3152 0000 6e49 6176     2020-12-R1..Inva
    da64:	696c 0064 4f54 4f44 0000 0000 6564 7562     lid.TODO....debu
    da74:	2067 6572 3a71 2520 0a73 0000 5453 4e41     g req: %s...STAN
    da84:	4244 0059 7453 7461 2065 7325 2d20 203e     DBY.State %s -> 
    da94:	7325 000a 4944 7c45 736d 5f67 7570 3a74     %s..DIE|msg_put:
    daa4:	7320 6f68 7472 6220 6675 0a0a 0000 0000      short buf......
    dab4:	6143 6e6e 746f 6320 6168 676e 2065 6965     Cannot change ei
    dac4:	5f72 736d 2067 6f6e 0a77 0000 4945 2052     r_msg now...EIR 
    dad4:	7075 6164 6574 0a64 0000 0000 6e49 6176     updated.....Inva
    dae4:	696c 2064 656d 7373 6761 2065 7974 6570     lid message type
    daf4:	2520 0a64 0000 0000 4944 7c45 6e49 6176      %d.....DIE|Inva
    db04:	696c 2064 7473 7461 2065 7274 6e61 6973     lid state transi
    db14:	6974 6e6f 2520 2073 3e2d 2520 0a73 000a     tion %s -> %s...
    db24:	4e49 5551 5249 0059 4150 4547 0000 0000     INQUIRY.PAGE....
    db34:	4f43 4e4e 4345 4554 0044 0000 4e49 5551     CONNECTED...INQU
    db44:	5249 5f59 4353 4e41 0000 0000 4150 4547     IRY_SCAN....PAGE
    db54:	535f 4143 004e 0000                         _SCAN...

0000db5c <btctl_state_name_tbl.5216>:
    db5c:	da80 0000 db24 0000 db2c 0000 db34 0000     ....$...,...4...
    db6c:	db40 0000 db50 0000 4944 7c45 7872 3a20     @...P...DIE|rx :
    db7c:	6520 7078 6365 2074 7872 7020 746b 000a      expect rx pkt..
    db8c:	534c 5420 206f 6328 6e6f 6620 726f 2520     LS To (con for %
    db9c:	2064 6573 2c63 2520 2064 6b70 2074 7872     d sec, %d pkt rx
    dbac:	0a29 0000 4944 7c45 7874 2071 7566 6c6c     )...DIE|txq full
    dbbc:	6920 206e 616d 7473 7265 0a0a 0000 0000      in master......
    dbcc:	4944 7c45 5442 5443 5f4c 5854 415f 4c43     DIE|BTCTL_TX_ACL
    dbdc:	525f 5145 6520 7078 6365 6574 0a64 000a     _REQ expected...
    dbec:	4944 7c45 6f74 206f 616d 796e 7420 6d69     DIE|too many tim
    dbfc:	7265 0a73 0000 0000 4944 7c45 6974 656d     ers.....DIE|time
    dc0c:	7372 6f20 6576 6672 6f6c 0a77 0000 0000     rs overflow.....
    dc1c:	5828 0029 6d28 7369 6573 2064 6974 656d     (X).(missed time
    dc2c:	2972 0000 4944 7c45 6e49 6176 696c 2064     r)..DIE|Invalid 
    dc3c:	7872 6d20 646f 2065 6425 0a0a 0000 0000     rx mode %d......
    dc4c:	6553 2074 6462 6461 7264 2520 6c6c 2078     Set bdaddr %llx 
    dc5c:	3e2d 7320 2077 6c25 786c 000a 6474 616d     -> sw %llx..tdma
    dc6c:	735f 6863 6465 6c75 2065 7562 6b63 7465     _schedule bucket
    dc7c:	6f20 6576 6672 6f6c 0a77 0000 280a 3225      overflow....(%2
    dc8c:	2975 0000 7525 003a 4944 7c45 7872 646e     u)..%u:.DIE|rxnd
    dc9c:	203a 6f6e 7220 5f78 6b70 0a74 0000 0000     : no rx_pkt.....
    dcac:	4944 7c45 7872 646e 203a 6f6e 7020 746b     DIE|rxnd: no pkt
    dcbc:	635f 0a62 0000 0000 7872 656e 203a 4652     _cb.....rxne: RF
    dccc:	6e20 746f 7220 7964 000a 0000 4944 7c45      not rdy....DIE|
    dcdc:	6564 2063 6468 2072 6425 203a 6372 253d     dec hdr %d: rc=%
    dcec:	0a64 000a 4944 7c45 7872 735f 6863 6465     d...DIE|rx_sched
    dcfc:	6c75 3a65 7220 5f78 736d 2167 303d 000a     ule: rx_msg!=0..

0000dd0c <rx_sched_set>:
    dd0c:	6121 0000 0000 0000 0000 0000 0000 0000     !a..............
    dd1c:	0000 0000 0000 0000 6331 0000 0000 0000     ........1c......
    dd2c:	fffd 0000 0000 0000 0000 0000 0000 0000     ................
    dd3c:	5e01 0000 0000 0000 0000 0000 6e69 7571     .^..........inqu
    dd4c:	7269 2079 6974 656d 756f 0a74 0000 0000     iry timeout.....
    dd5c:	4944 7c45 6170 6967 676e 3a20 6520 7078     DIE|paging : exp
    dd6c:	6365 2074 6361 206c 7872 000a 4944 7c45     ect acl rx..DIE|
    dd7c:	7874 2071 7566 6c6c 6920 206e 6e69 7571     txq full in inqu
    dd8c:	7269 0a79 000a 0000 6170 6967 676e 7420     iry.....paging t
    dd9c:	6d69 6f65 7475 000a 4449 3328 0a29 0000     imeout..ID(3)...
    ddac:	6f6e 4920 2844 2933 000a 0000 616d 7473     no ID(3)....mast
    ddbc:	7265 7320 6174 7472 6465 000a 6c73 7661     er started..slav
    ddcc:	2065 7473 7261 6574 0a64 0000 4944 7c45     e started...DIE|
    dddc:	6f4e 7020 6920 206e 7874 665f 6669 5f6f     No p in tx_fifo_
    ddec:	6263 2820 6973 657a 2520 2964 0a0a 0000     cb (size %d)....
    ddfc:	5854 203a 4652 6e20 746f 4620 5f53 4e4f     TX: RF not FS_ON
    de0c:	000a 0000 4944 7c45 7874 3a65 7720 6f72     ....DIE|txe: wro
    de1c:	676e 6320 6b6c 206e 7825 000a 4944 7c45     ng clkn %x..DIE|
    de2c:	7874 3a73 6120 726c 6165 7964 6720 746f     txs: already got
    de3c:	7020 746b 000a 0000                          pkt....

0000de44 <tx_sched_set>:
    de44:	6cad 0000 0000 0000 0000 0000 0000 0000     .l..............
    de54:	0000 0000 0000 0000 6e35 0000 0000 0000     ........5n......
    de64:	fffd 0000 0000 0000 0000 0000 0000 0000     ................
    de74:	5e01 0000 0000 0000 0000 0000 4944 7c45     .^..........DIE|
    de84:	6f6e 6320 2062 6e69 7320 6163 206e 6174     no cb in scan ta
    de94:	6b73 0a0a 0000 0000 6e69 7571 7269 2079     sk......inquiry 
    dea4:	6373 6e61 7420 6d69 6f65 7475 000a 0000     scan timeout....
    deb4:	6e69 2071 6373 6e61 6320 6e61 6563 656c     inq scan cancele
    dec4:	0a64 0000 6866 3a73 6220 3d61 6c25 786c     d...fhs: ba=%llx
    ded4:	6320 6b6c 3732 325f 253d 2078 746c 3d61      clk27_2=%x lta=
    dee4:	6425 000a 6f6d 696e 6f74 3172 6320 6e61     %d..monitor1 can
    def4:	6563 656c 0a64 0000 6228 6461 7420 7079     celed...(bad typ
    df04:	2065 6425 0029 0000 6f6d 696e 6f74 3172     e %d)...monitor1
    df14:	7420 6d69 6f65 7475 000a 0000 2b28 6661      timeout....(+af
    df24:	2968 0000 2d28 6661 2968 0000 4944 7c45     h)..(-afh)..DIE|
    df34:	6e49 6176 696c 2064 6f68 2070 6f6d 6564     Invalid hop mode
    df44:	2520 0a64 000a 0000 4944 7c45 7872 3a20      %d.....DIE|rx :
    df54:	6520 7078 6365 2074 6361 206c 7872 000a      expect acl rx..
    df64:	2528 2c63 7825 252c 2978 0000 4944 7c45     (%c,%x,%x)..DIE|
    df74:	6f6d 326e 203a 7874 2071 7566 6c6c 000a     mon2: txq full..
    df84:	504e 0046 6f6d 696e 6f74 3272 7320 6174     NPF.monitor2 sta
    df94:	7472 6465 000a 0000 6170 6567 7320 6163     rted....page sca
    dfa4:	206e 6163 636e 6c65 6465 000a 6170 6567     n canceled..page
    dfb4:	7320 6163 206e 6974 656d 756f 0a74 0000      scan timeout...
    dfc4:	4944 7c45 6f4e 7020 7968 6920 746e 6820     DIE|No phy int h
    dfd4:	6e61 6c64 7265 000a 7266 7165 6f20 6666     andler..freq off
    dfe4:	7220 6765 203a 6425 000a 0000 616d 2078      reg: %d....max 
    dff4:	6361 6520 7272 726f 3a73 2520 0a64 0000     ac errors: %d...
    e004:	4944 7c45 6f70 6c6f 6e20 2079 6e69 7469     DIE|pool ny init
    e014:	6c61 7a69 6465 0a0a 0000 0000 4944 7c45     alized......DIE|
    e024:	6143 6e6e 746f 6120 6c6c 636f 2520 0a64     Cannot alloc %d.
    e034:	000a 0000 4944 7c45 6f4e 6d20 726f 2065     ....DIE|No more 
    e044:	7562 6666 7265 0a73 000a 0000 4944 7c45     buffers.....DIE|
    e054:	7874 2071 7566 6c6c 6920 206e 6f63 736e     txq full in cons
    e064:	6c6f 0a65 000a 0000 4643 5253 253d 3830     ole.....CFSR=%08
    e074:	0a78 0000 4648 5253 253d 3830 0a78 0000     x...HFSR=%08x...
    e084:	4d4d 5253 253d 3830 0a78 0000 4642 5253     MMSR=%08x...BFSR
    e094:	253d 3830 0a78 0000 4655 5253 253d 3830     =%08x...UFSR=%08
    e0a4:	0a78 0000 4642 5241 253d 3830 0a78 0000     x...BFAR=%08x...
    e0b4:	530a 6174 6b63 6420 6d75 2070 7e28 7025     .Stack dump (~%p
    e0c4:	3a29 000a 7025 203a 3025 7838 2520 3830     ):..%p: %08x %08
    e0d4:	2078 3025 7838 2520 3830 0a78 0000 0000     x %08x %08x.....
    e0e4:	6148 6472 6146 6c75 2074 7461 3020 2578     HardFault at 0x%
    e0f4:	0a78 0000 4d4d 6146 6c75 2074 7461 3020     x...MMFault at 0
    e104:	2578 0a78 0000 0000 7542 4673 7561 746c     x%x.....BusFault
    e114:	6120 2074 7825 000a 7355 6761 4665 7561      at %x..UsageFau
    e124:	746c 6120 2074 7825 000a 0000 4944 7c45     lt at %x....DIE|
    e134:	6e55 7865 6570 7463 6465 7420 7079 2065     Unexpected type 
    e144:	6325 7720 6968 656c 7720 6961 6974 676e     %c while waiting
    e154:	7220 5f78 736d 0a67 000a 0000 4944 7c45      rx_msg.....DIE|
    e164:	6e49 6176 696c 2064 7974 6570 2520 2064     Invalid type %d 
    e174:	6877 6c69 2065 6177 7469 6e69 2067 7872     while waiting rx
    e184:	6d5f 6773 6320 6e6f 0a74 000a 387b 6361     _msg cont...{8ac
    e194:	3734 3861 2d38 6363 3632 342d 6161 2d39     47a88-cc26-4aa9-
    e1a4:	3838 6237 342d 6332 3861 6663 3730 3661     887b-42ca8cf07a6
    e1b4:	7d33 0000 4944 7c45 736d 5f67 7570 6c6c     3}..DIE|msg_pull
    e1c4:	203a 6873 726f 2074 7562 0a66 000a 0000     : short buf.....
    e1d4:	4d44 4941 2520 0a78 0000 0000 7373 2070     DMAI %x.....ssp 
    e1e4:	656e 000a                                   ne..

0000e1e8 <abExtendedOsFeatureDescriptor>:
    e1e8:	0028 0000 0100 0004 0001 0000 0000 0000     (...............
    e1f8:	0100 4957 554e 4253 0000 0000 0000 0000     ..WINUSB........
    e208:	0000 0000 0000 0000                         ........

0000e210 <_init>:
    e210:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e212:	bf00      	nop
    e214:	bcf8      	pop	{r3, r4, r5, r6, r7}
    e216:	bc08      	pop	{r3}
    e218:	469e      	mov	lr, r3
    e21a:	4770      	bx	lr

0000e21c <__frame_dummy_init_array_entry>:
    e21c:	4135 0000                                   5A..

0000e220 <_fini>:
    e220:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e222:	bf00      	nop
    e224:	bcf8      	pop	{r3, r4, r5, r6, r7}
    e226:	bc08      	pop	{r3}
    e228:	469e      	mov	lr, r3
    e22a:	4770      	bx	lr

0000e22c <__do_global_dtors_aux_fini_array_entry>:
    e22c:	410d 0000                                   .A..
