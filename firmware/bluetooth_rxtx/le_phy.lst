ARM GAS  /tmp/ccXJY3ni.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"le_phy.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.le_dma_init,"ax",%progbits
  16              		.align	1
  17              		.arch armv7-m
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	le_dma_init:
  24              	.LFB17:
  25              		.file 1 "le_phy.c"
   1:le_phy.c      **** /*
   2:le_phy.c      ****  * Copyright 2017 Mike Ryan
   3:le_phy.c      ****  *
   4:le_phy.c      ****  * This file is part of Project Ubertooth and is released under the
   5:le_phy.c      ****  * terms of the GPL. Refer to COPYING for more information.
   6:le_phy.c      ****  */
   7:le_phy.c      **** 
   8:le_phy.c      **** #include <stdlib.h>
   9:le_phy.c      **** #include <string.h>
  10:le_phy.c      **** 
  11:le_phy.c      **** #include "ubertooth.h"
  12:le_phy.c      **** #include "ubertooth_clock.h"
  13:le_phy.c      **** #include "ubertooth_dma.h"
  14:le_phy.c      **** #include "ubertooth_usb.h"
  15:le_phy.c      **** #include "bluetooth_le.h"
  16:le_phy.c      **** // #include "usb_serial.h"
  17:le_phy.c      **** #include "queue.h"
  18:le_phy.c      **** #include "fsm.c"
  19:le_phy.c      **** 
  20:le_phy.c      **** // current time, from timer1
  21:le_phy.c      **** #define NOW T1TC
  22:le_phy.c      **** #define USEC(X) ((X)*10)
  23:le_phy.c      **** #define MSEC(X) ((X)*10000)
  24:le_phy.c      **** #define  SEC(X) ((X)*10000000)
  25:le_phy.c      **** #define PACKET_DURATION(X) (USEC(40 + (X)->size * 8))
  26:le_phy.c      **** 
  27:le_phy.c      **** #define ADVERTISING_AA (0x8e89bed6)
  28:le_phy.c      **** 
  29:le_phy.c      **** ///////////////////////
  30:le_phy.c      **** // time constants
  31:le_phy.c      **** 
  32:le_phy.c      **** // time for the radio to warmup + some timing slack
  33:le_phy.c      **** #define RX_WARMUP_TIME USEC(300)
ARM GAS  /tmp/ccXJY3ni.s 			page 2


  34:le_phy.c      **** 
  35:le_phy.c      **** // max inter-frame space between packets in a connection event
  36:le_phy.c      **** #define IFS_TIMEOUT USEC(300)
  37:le_phy.c      **** 
  38:le_phy.c      **** // observed connection anchor must be within ANCHOR_EPSILON of
  39:le_phy.c      **** // calculated anchor
  40:le_phy.c      **** #define ANCHOR_EPSILON USEC(3)
  41:le_phy.c      **** 
  42:le_phy.c      **** 
  43:le_phy.c      **** //////////////////////
  44:le_phy.c      **** // global state
  45:le_phy.c      **** 
  46:le_phy.c      **** extern le_state_t le; // FIXME - refactor this struct
  47:le_phy.c      **** volatile uint16_t rf_channel;
  48:le_phy.c      **** uint8_t le_dma_dest[2];
  49:le_phy.c      **** 
  50:le_phy.c      **** extern volatile uint8_t mode;
  51:le_phy.c      **** extern volatile uint8_t requested_mode;
  52:le_phy.c      **** extern volatile uint16_t le_adv_channel;
  53:le_phy.c      **** extern volatile int cancel_follow;
  54:le_phy.c      **** 
  55:le_phy.c      **** ////////////////////
  56:le_phy.c      **** // buffers
  57:le_phy.c      **** 
  58:le_phy.c      **** // packet buffers live in a pool. a minimum of one buffer is always
  59:le_phy.c      **** // being used, either waiting to receive or actively receiving a packet
  60:le_phy.c      **** // (current_rxbuf). once a packet is received, it is placed into the
  61:le_phy.c      **** // packet queue. the main loop pulls packets from this queue and
  62:le_phy.c      **** // processes them, and then returns the buffers back to the pool by
  63:le_phy.c      **** // calling buffer_release()
  64:le_phy.c      **** 
  65:le_phy.c      **** #define LE_BUFFER_POOL_SIZE 4
  66:le_phy.c      **** typedef struct _le_rx_t {
  67:le_phy.c      **** 	uint8_t data[2 + 255 + 3];  // header + PDU + CRC
  68:le_phy.c      **** 	unsigned size;              // total data length (known after header rx)
  69:le_phy.c      **** 	unsigned pos;               // current input byte offset
  70:le_phy.c      **** 	uint32_t timestamp;         // timestamp taken after first byte rx
  71:le_phy.c      **** 	unsigned channel;           // physical channel
  72:le_phy.c      **** 	uint32_t access_address;    // access address
  73:le_phy.c      **** 	int available;              // 1 if available, 0 in use
  74:le_phy.c      **** 	int8_t rssi_min, rssi_max;  // min and max RSSI observed values
  75:le_phy.c      **** 	int rssi_sum;               // running sum of all RSSI values
  76:le_phy.c      **** } le_rx_t;
  77:le_phy.c      **** 
  78:le_phy.c      **** // pool of all buffers
  79:le_phy.c      **** static le_rx_t le_buffer_pool[LE_BUFFER_POOL_SIZE];
  80:le_phy.c      **** 
  81:le_phy.c      **** // buffer waiting for or actively receiving packet
  82:le_phy.c      **** static le_rx_t *current_rxbuf = NULL;
  83:le_phy.c      **** 
  84:le_phy.c      **** // received packets, waiting to be processed
  85:le_phy.c      **** queue_t packet_queue;
  86:le_phy.c      **** 
  87:le_phy.c      **** 
  88:le_phy.c      **** /////////////////////
  89:le_phy.c      **** // connections
  90:le_phy.c      **** 
ARM GAS  /tmp/ccXJY3ni.s 			page 3


  91:le_phy.c      **** // this system is architected so that following multiple connections may
  92:le_phy.c      **** // be possible in the future. all connection state lives in an le_conn_t
  93:le_phy.c      **** // struct. at present only one such structure exists. refer to
  94:le_phy.c      **** // connection event below for how anchors are handled.
  95:le_phy.c      **** 
  96:le_phy.c      **** typedef struct _le_conn_t {
  97:le_phy.c      **** 	uint32_t access_address;
  98:le_phy.c      **** 	uint32_t crc_init;
  99:le_phy.c      **** 	uint32_t crc_init_reversed;
 100:le_phy.c      **** 
 101:le_phy.c      **** 	uint8_t  channel_idx;
 102:le_phy.c      **** 	uint8_t  hop_increment;
 103:le_phy.c      **** 	uint32_t conn_interval; // in units of 100 ns
 104:le_phy.c      **** 	uint32_t supervision_timeout; // in units of 100 ns
 105:le_phy.c      **** 
 106:le_phy.c      **** 	uint8_t  win_size;
 107:le_phy.c      **** 	uint32_t win_offset; // in units of 100 ns
 108:le_phy.c      **** 
 109:le_phy.c      **** 	le_channel_remapping_t remapping;
 110:le_phy.c      **** 
 111:le_phy.c      **** 	uint32_t last_anchor;
 112:le_phy.c      **** 	int      anchor_set;
 113:le_phy.c      **** 	uint32_t last_packet_ts; // used to check supervision timeout
 114:le_phy.c      **** 
 115:le_phy.c      **** 	uint16_t conn_event_counter;
 116:le_phy.c      **** 
 117:le_phy.c      **** 	int      conn_update_pending;
 118:le_phy.c      **** 	uint32_t conn_update_pending_interval;
 119:le_phy.c      **** 	uint32_t conn_update_pending_supervision_timeout;
 120:le_phy.c      **** 	uint16_t conn_update_instant;
 121:le_phy.c      **** 
 122:le_phy.c      **** 	int      channel_map_update_pending;
 123:le_phy.c      **** 	uint16_t channel_map_update_instant;
 124:le_phy.c      **** 	le_channel_remapping_t pending_remapping;
 125:le_phy.c      **** } le_conn_t;
 126:le_phy.c      **** le_conn_t conn = { 0, };
 127:le_phy.c      **** 
 128:le_phy.c      **** // every connection event is tracked using this global le_conn_event_t
 129:le_phy.c      **** // structure named conn_event. when a packet is observed, anchor is set.
 130:le_phy.c      **** // the event may close due to receiving two packets, or if a timeout
 131:le_phy.c      **** // occurs. in both cases, finish_conn_event() is called, which updates
 132:le_phy.c      **** // the active connection's anchor. opened is set to 1 once the radio is
 133:le_phy.c      **** // tuned to the data channel for the connection event.
 134:le_phy.c      **** typedef struct _le_conn_event_t {
 135:le_phy.c      **** 	uint32_t anchor;
 136:le_phy.c      **** 	unsigned num_packets;
 137:le_phy.c      **** 	int opened;
 138:le_phy.c      **** } le_conn_event_t;
 139:le_phy.c      **** le_conn_event_t conn_event;
 140:le_phy.c      **** 
 141:le_phy.c      **** static void reset_conn(void) {
 142:le_phy.c      **** 	memset(&conn, 0, sizeof(conn));
 143:le_phy.c      **** 	conn.access_address = ADVERTISING_AA;
 144:le_phy.c      **** }
 145:le_phy.c      **** 
 146:le_phy.c      **** 
 147:le_phy.c      **** //////////////////////
ARM GAS  /tmp/ccXJY3ni.s 			page 4


 148:le_phy.c      **** // code
 149:le_phy.c      **** 
 150:le_phy.c      **** // pre-declarations for utility stuff
 151:le_phy.c      **** static void timer1_start(void);
 152:le_phy.c      **** static void timer1_stop(void);
 153:le_phy.c      **** static void timer1_set_match(uint32_t match);
 154:le_phy.c      **** static void timer1_clear_match(void);
 155:le_phy.c      **** static void timer1_wait_fs_lock(void);
 156:le_phy.c      **** static void timer1_cancel_fs_lock(void);
 157:le_phy.c      **** static void timer1_wait_buffer(void);
 158:le_phy.c      **** static void timer1_cancel_buffer(void);
 159:le_phy.c      **** static void blink(int tx, int rx, int usr);
 160:le_phy.c      **** static void le_dma_init(void);
 161:le_phy.c      **** static void le_cc2400_strobe_rx(void);
 162:le_phy.c      **** static void change_channel(void);
 163:le_phy.c      **** static uint8_t dewhiten_length(unsigned channel, uint8_t data);
 164:le_phy.c      **** 
 165:le_phy.c      **** // resets the state of all available buffers
 166:le_phy.c      **** static void buffers_init(void) {
 167:le_phy.c      **** 	int i;
 168:le_phy.c      **** 
 169:le_phy.c      **** 	for (i = 0; i < LE_BUFFER_POOL_SIZE; ++i)
 170:le_phy.c      **** 		le_buffer_pool[i].available = 1;
 171:le_phy.c      **** }
 172:le_phy.c      **** 
 173:le_phy.c      **** // clear a buffer for new data
 174:le_phy.c      **** static void buffer_clear(le_rx_t *buf) {
 175:le_phy.c      **** 	buf->pos = 0;
 176:le_phy.c      **** 	buf->size = 0;
 177:le_phy.c      **** 	memset(buf->data, 0, sizeof(buf->data));
 178:le_phy.c      **** 	buf->rssi_min = INT8_MAX;
 179:le_phy.c      **** 	buf->rssi_max = INT8_MIN;
 180:le_phy.c      **** 	buf->rssi_sum = 0;
 181:le_phy.c      **** }
 182:le_phy.c      **** 
 183:le_phy.c      **** // get a packet buffer
 184:le_phy.c      **** // returns a pointer to a buffer if available
 185:le_phy.c      **** // returns NULL otherwise
 186:le_phy.c      **** static le_rx_t *buffer_get(void) {
 187:le_phy.c      **** 	int i;
 188:le_phy.c      **** 
 189:le_phy.c      **** 	for (i = 0; i < LE_BUFFER_POOL_SIZE; ++i) {
 190:le_phy.c      **** 		if (le_buffer_pool[i].available) {
 191:le_phy.c      **** 			le_buffer_pool[i].available = 0;
 192:le_phy.c      **** 			buffer_clear(&le_buffer_pool[i]);
 193:le_phy.c      **** 			return &le_buffer_pool[i];
 194:le_phy.c      **** 		}
 195:le_phy.c      **** 	}
 196:le_phy.c      **** 
 197:le_phy.c      **** 	return NULL;
 198:le_phy.c      **** }
 199:le_phy.c      **** 
 200:le_phy.c      **** // release a buffer back to the pool
 201:le_phy.c      **** static void buffer_release(le_rx_t *buffer) {
 202:le_phy.c      **** 	buffer->available = 1;
 203:le_phy.c      **** }
 204:le_phy.c      **** 
ARM GAS  /tmp/ccXJY3ni.s 			page 5


 205:le_phy.c      **** // clear a connection event
 206:le_phy.c      **** static void reset_conn_event(void) {
 207:le_phy.c      **** 	conn_event.num_packets = 0;
 208:le_phy.c      **** 	conn_event.opened = 0;
 209:le_phy.c      **** }
 210:le_phy.c      **** 
 211:le_phy.c      **** // finish a connection event
 212:le_phy.c      **** //
 213:le_phy.c      **** // 1) update the anchor point (see details below)
 214:le_phy.c      **** // 2) increment connection event counter
 215:le_phy.c      **** // 3) check if supervision timeout is exceeded
 216:le_phy.c      **** // 4) setup radio for next packet (data or adv if timeout exceeded)
 217:le_phy.c      **** //
 218:le_phy.c      **** // anchor update logic can be summarized thusly:
 219:le_phy.c      **** // 1) if we received two packets, set the connection anchor to the
 220:le_phy.c      **** //    observed value
 221:le_phy.c      **** // 2) if we received one packet, see if it's within ANCHOR_EPISLON
 222:le_phy.c      **** //    microseconds if the expected anchor time. if so, it's the master
 223:le_phy.c      **** //    and we can update the anchor
 224:le_phy.c      **** // 3) if the single packet is a slave or we received zero packets,
 225:le_phy.c      **** //    update the anchor to the estimated value
 226:le_phy.c      **** //
 227:le_phy.c      **** // FIXME this code does not properly handle the case where the initial
 228:le_phy.c      **** // connection transmit window has no received packets
 229:le_phy.c      **** static void finish_conn_event(void) {
 230:le_phy.c      **** 	uint32_t last_anchor = 0;
 231:le_phy.c      **** 	int last_anchor_set = 0;
 232:le_phy.c      **** 
 233:le_phy.c      **** 	// two packets -- update anchor
 234:le_phy.c      **** 	if (conn_event.num_packets == 2) {
 235:le_phy.c      **** 		last_anchor = conn_event.anchor;
 236:le_phy.c      **** 		last_anchor_set = 1;
 237:le_phy.c      **** 	}
 238:le_phy.c      **** 
 239:le_phy.c      **** 	// if there's one packet, we need to find out if it was the master
 240:le_phy.c      **** 	else if (conn_event.num_packets == 1 && conn.anchor_set) {
 241:le_phy.c      **** 		// calculate the difference between the estimated and observed anchor
 242:le_phy.c      **** 		uint32_t estimated_anchor = conn.last_anchor + conn.conn_interval;
 243:le_phy.c      **** 		uint32_t delta = estimated_anchor - conn_event.anchor;
 244:le_phy.c      **** 		// see whether the observed anchor is within 3 us of the estimate
 245:le_phy.c      **** 		delta += ANCHOR_EPSILON;
 246:le_phy.c      **** 		if (delta < 2 * ANCHOR_EPSILON) {
 247:le_phy.c      **** 			last_anchor = conn_event.anchor;
 248:le_phy.c      **** 			last_anchor_set = 1;
 249:le_phy.c      **** 		}
 250:le_phy.c      **** 	}
 251:le_phy.c      **** 
 252:le_phy.c      **** 	// if we observed a new anchor, set it
 253:le_phy.c      **** 	if (last_anchor_set) {
 254:le_phy.c      **** 		conn.last_anchor = last_anchor;
 255:le_phy.c      **** 		conn.anchor_set = 1;
 256:le_phy.c      **** 	}
 257:le_phy.c      **** 
 258:le_phy.c      **** 	// without a new anchor, estimate the next anchor
 259:le_phy.c      **** 	else if (conn.anchor_set) {
 260:le_phy.c      **** 		conn.last_anchor += conn.conn_interval;
 261:le_phy.c      **** 	}
ARM GAS  /tmp/ccXJY3ni.s 			page 6


 262:le_phy.c      **** 
 263:le_phy.c      **** 	else {
 264:le_phy.c      **** 		// FIXME this is totally broken if we receive the slave's packet first
 265:le_phy.c      **** 		conn.last_anchor = conn_event.anchor;
 266:le_phy.c      **** 		conn.last_packet_ts = NOW; // FIXME gross hack
 267:le_phy.c      **** 	}
 268:le_phy.c      **** 
 269:le_phy.c      **** 	// update last packet for supervision timeout
 270:le_phy.c      **** 	if (conn_event.num_packets > 0) {
 271:le_phy.c      **** 		conn.last_packet_ts = NOW;
 272:le_phy.c      **** 	}
 273:le_phy.c      **** 
 274:le_phy.c      **** 	reset_conn_event();
 275:le_phy.c      **** 
 276:le_phy.c      **** 	// increment connection event counter
 277:le_phy.c      **** 	++conn.conn_event_counter;
 278:le_phy.c      **** 
 279:le_phy.c      **** 	// supervision timeout reached - switch back to advertising
 280:le_phy.c      **** 	if (NOW - conn.last_packet_ts > conn.supervision_timeout) {
 281:le_phy.c      **** 		reset_conn();
 282:le_phy.c      **** 		change_channel();
 283:le_phy.c      **** 	}
 284:le_phy.c      **** 
 285:le_phy.c      **** 	// FIXME - hack to cancel following a connection
 286:le_phy.c      **** 	else if (cancel_follow) {
 287:le_phy.c      **** 		cancel_follow = 0;
 288:le_phy.c      **** 		reset_conn();
 289:le_phy.c      **** 		change_channel();
 290:le_phy.c      **** 	}
 291:le_phy.c      **** 
 292:le_phy.c      **** 	// supervision timeout not reached - hop to next channel
 293:le_phy.c      **** 	else {
 294:le_phy.c      **** 		timer1_set_match(conn.last_anchor + conn.conn_interval - RX_WARMUP_TIME);
 295:le_phy.c      **** 	}
 296:le_phy.c      **** }
 297:le_phy.c      **** 
 298:le_phy.c      **** // DMA handler
 299:le_phy.c      **** // called once per byte. handles all incoming data, but only minimally
 300:le_phy.c      **** // processes received data. at the end of a packet, it enqueues the
 301:le_phy.c      **** // received packet, fetches a new buffer, and restarts RX.
 302:le_phy.c      **** void le_DMA_IRQHandler(void) {
 303:le_phy.c      **** 	unsigned pos;
 304:le_phy.c      **** 	int8_t rssi;
 305:le_phy.c      **** 	uint32_t timestamp = NOW; // sampled early for most accurate measurement
 306:le_phy.c      **** 
 307:le_phy.c      **** 	// channel 0
 308:le_phy.c      **** 	if (DMACIntStat & (1 << 0)) {
 309:le_phy.c      **** 		// terminal count - byte received
 310:le_phy.c      **** 		if (DMACIntTCStat & (1 << 0)) {
 311:le_phy.c      **** 			DMACIntTCClear = (1 << 0);
 312:le_phy.c      **** 
 313:le_phy.c      **** 			// poll RSSI
 314:le_phy.c      **** 			rssi = (int8_t)(cc2400_get(RSSI) >> 8);
 315:le_phy.c      **** 			current_rxbuf->rssi_sum += rssi;
 316:le_phy.c      **** 			if (rssi < current_rxbuf->rssi_min) current_rxbuf->rssi_min = rssi;
 317:le_phy.c      **** 			if (rssi > current_rxbuf->rssi_max) current_rxbuf->rssi_max = rssi;
 318:le_phy.c      **** 
ARM GAS  /tmp/ccXJY3ni.s 			page 7


 319:le_phy.c      **** 			// grab byte from DMA buffer
 320:le_phy.c      **** 			pos = current_rxbuf->pos;
 321:le_phy.c      **** 			current_rxbuf->data[pos] = le_dma_dest[pos & 1]; // dirty hack
 322:le_phy.c      **** 			pos += 1;
 323:le_phy.c      **** 			current_rxbuf->pos = pos;
 324:le_phy.c      **** 
 325:le_phy.c      **** 			if (pos == 1) {
 326:le_phy.c      **** 				current_rxbuf->timestamp = timestamp - USEC(8 + 32); // packet starts at preamble
 327:le_phy.c      **** 				current_rxbuf->channel = rf_channel;
 328:le_phy.c      **** 				current_rxbuf->access_address = conn.access_address;
 329:le_phy.c      **** 
 330:le_phy.c      **** 				// data packet received: cancel timeout
 331:le_phy.c      **** 				// new timeout or hop timer will be set at end of packet RX
 332:le_phy.c      **** 				if (btle_channel_index(rf_channel) < 37) {
 333:le_phy.c      **** 					timer1_clear_match();
 334:le_phy.c      **** 				}
 335:le_phy.c      **** 			}
 336:le_phy.c      **** 
 337:le_phy.c      **** 			// get length from header
 338:le_phy.c      **** 			if (pos == 2) {
 339:le_phy.c      **** 				uint8_t length = dewhiten_length(current_rxbuf->channel, current_rxbuf->data[1]);
 340:le_phy.c      **** 				current_rxbuf->size = length + 2 + 3; // two bytes for header and three for CRC
 341:le_phy.c      **** 			}
 342:le_phy.c      **** 
 343:le_phy.c      **** 			// finished packet - state transition
 344:le_phy.c      **** 			if (pos > 2 && pos >= current_rxbuf->size) {
 345:le_phy.c      **** 				// stop the CC2400 before flushing SSP
 346:le_phy.c      **** 				cc2400_strobe(SFSON);
 347:le_phy.c      **** 
 348:le_phy.c      **** 				// stop DMA on this channel and flush SSP
 349:le_phy.c      **** 				DMACC0Config = 0;
 350:le_phy.c      **** 				DMACIntTCClear = (1 << 0); // if we don't clear a second time, data is corrupt
 351:le_phy.c      **** 
 352:le_phy.c      **** 				DIO_SSP_DMACR &= ~SSPDMACR_RXDMAE;
 353:le_phy.c      **** 				while (SSP1SR & SSPSR_RNE) {
 354:le_phy.c      **** 					uint8_t tmp = (uint8_t)DIO_SSP_DR;
 355:le_phy.c      **** 				}
 356:le_phy.c      **** 
 357:le_phy.c      **** 				// XXX disable DMA interrupt as a workaround
 358:le_phy.c      **** 				ICER0 = ICER0_ICE_DMA;
 359:le_phy.c      **** 
 360:le_phy.c      **** 				// TODO error transition on queue_insert
 361:le_phy.c      **** 				queue_insert(&packet_queue, current_rxbuf);
 362:le_phy.c      **** 
 363:le_phy.c      **** 				// track connection events
 364:le_phy.c      **** 				if (btle_channel_index(rf_channel) < 37) {
 365:le_phy.c      **** 					++conn_event.num_packets;
 366:le_phy.c      **** 
 367:le_phy.c      **** 					// first packet: set connection anchor
 368:le_phy.c      **** 					if (conn_event.num_packets == 1) {
 369:le_phy.c      **** 						conn_event.anchor = current_rxbuf->timestamp;
 370:le_phy.c      **** 						timer1_set_match(NOW + IFS_TIMEOUT); // set a timeout for next packet
 371:le_phy.c      **** 					}
 372:le_phy.c      **** 
 373:le_phy.c      **** 					// second packet: close connection event, and set hop timer
 374:le_phy.c      **** 					else if (conn_event.num_packets == 2) {
 375:le_phy.c      **** 						cc2400_strobe(SRFOFF);
ARM GAS  /tmp/ccXJY3ni.s 			page 8


 376:le_phy.c      **** 						current_rxbuf = buffer_get();
 377:le_phy.c      **** 						// TODO handle NULL
 378:le_phy.c      **** 						finish_conn_event();
 379:le_phy.c      **** 						return;
 380:le_phy.c      **** 					}
 381:le_phy.c      **** 				}
 382:le_phy.c      **** 
 383:le_phy.c      **** 				// get a new packet
 384:le_phy.c      **** 				// TODO handle error transition
 385:le_phy.c      **** 				current_rxbuf = buffer_get();
 386:le_phy.c      **** 				if (current_rxbuf == NULL) {
 387:le_phy.c      **** 					// if all buffers are in use, wait for one to free up in background
 388:le_phy.c      **** 					timer1_wait_buffer();
 389:le_phy.c      **** 				} else {
 390:le_phy.c      **** 					// wait for FS_LOCK in background
 391:le_phy.c      **** 					timer1_wait_fs_lock();
 392:le_phy.c      **** 				}
 393:le_phy.c      **** 			}
 394:le_phy.c      **** 		}
 395:le_phy.c      **** 
 396:le_phy.c      **** 		// error - transition to error state
 397:le_phy.c      **** 		if (DMACIntErrStat & (1 << 0)) {
 398:le_phy.c      **** 			// TODO error state transition
 399:le_phy.c      **** 			DMACIntErrClr = (1 << 0);
 400:le_phy.c      **** 		}
 401:le_phy.c      **** 	}
 402:le_phy.c      **** }
 403:le_phy.c      **** 
 404:le_phy.c      **** static void le_dma_init(void) {
  26              		.loc 1 404 31 view -0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30 0000 30B5     		push	{r4, r5, lr}
  31              		.cfi_def_cfa_offset 12
  32              		.cfi_offset 4, -12
  33              		.cfi_offset 5, -8
  34              		.cfi_offset 14, -4
 405:le_phy.c      **** 	int i;
  35              		.loc 1 405 2 view .LVU1
 406:le_phy.c      **** 
 407:le_phy.c      **** 	// DMA linked list items
 408:le_phy.c      **** 	typedef struct {
  36              		.loc 1 408 2 view .LVU2
 409:le_phy.c      **** 		uint32_t src;
 410:le_phy.c      **** 		uint32_t dest;
 411:le_phy.c      **** 		uint32_t next_lli;
 412:le_phy.c      **** 		uint32_t control;
 413:le_phy.c      **** 	} dma_lli;
 414:le_phy.c      **** 	static dma_lli le_dma_lli[2];
  37              		.loc 1 414 2 view .LVU3
 415:le_phy.c      **** 
 416:le_phy.c      **** 	for (i = 0; i < 2; ++i) {
  38              		.loc 1 416 2 view .LVU4
  39              	.LVL0:
  40              		.loc 1 416 14 view .LVU5
 417:le_phy.c      **** 		le_dma_lli[i].src = (uint32_t)&(DIO_SSP_DR);
ARM GAS  /tmp/ccXJY3ni.s 			page 9


  41              		.loc 1 417 3 view .LVU6
  42              		.loc 1 417 21 is_stmt 0 view .LVU7
  43 0002 0C4B     		ldr	r3, .L2
 418:le_phy.c      **** 		le_dma_lli[i].dest = (uint32_t)&le_dma_dest[i];
  44              		.loc 1 418 22 view .LVU8
  45 0004 0C49     		ldr	r1, .L2+4
 419:le_phy.c      **** 		le_dma_lli[i].next_lli = (uint32_t)&le_dma_lli[1-i]; // two elements pointing back at each other
 420:le_phy.c      **** 		le_dma_lli[i].control = 1 |
  46              		.loc 1 420 25 view .LVU9
  47 0006 0D4A     		ldr	r2, .L2+8
 417:le_phy.c      **** 		le_dma_lli[i].dest = (uint32_t)&le_dma_dest[i];
  48              		.loc 1 417 21 view .LVU10
  49 0008 0D48     		ldr	r0, .L2+12
 419:le_phy.c      **** 		le_dma_lli[i].next_lli = (uint32_t)&le_dma_lli[1-i]; // two elements pointing back at each other
  50              		.loc 1 419 28 view .LVU11
  51 000a 03F11004 		add	r4, r3, #16
 418:le_phy.c      **** 		le_dma_lli[i].dest = (uint32_t)&le_dma_dest[i];
  52              		.loc 1 418 22 view .LVU12
  53 000e 4D1C     		adds	r5, r1, #1
 417:le_phy.c      **** 		le_dma_lli[i].dest = (uint32_t)&le_dma_dest[i];
  54              		.loc 1 417 21 view .LVU13
  55 0010 C3E90320 		strd	r2, r0, [r3, #12]
  56 0014 1860     		str	r0, [r3]
 418:le_phy.c      **** 		le_dma_lli[i].dest = (uint32_t)&le_dma_dest[i];
  57              		.loc 1 418 3 is_stmt 1 view .LVU14
 418:le_phy.c      **** 		le_dma_lli[i].dest = (uint32_t)&le_dma_dest[i];
  58              		.loc 1 418 22 is_stmt 0 view .LVU15
  59 0016 5960     		str	r1, [r3, #4]
 419:le_phy.c      **** 		le_dma_lli[i].next_lli = (uint32_t)&le_dma_lli[1-i]; // two elements pointing back at each other
  60              		.loc 1 419 3 is_stmt 1 view .LVU16
 419:le_phy.c      **** 		le_dma_lli[i].next_lli = (uint32_t)&le_dma_lli[1-i]; // two elements pointing back at each other
  61              		.loc 1 419 26 is_stmt 0 view .LVU17
  62 0018 9C60     		str	r4, [r3, #8]
  63              		.loc 1 420 3 is_stmt 1 view .LVU18
 418:le_phy.c      **** 		le_dma_lli[i].dest = (uint32_t)&le_dma_dest[i];
  64              		.loc 1 418 3 view .LVU19
  65              		.loc 1 420 25 is_stmt 0 view .LVU20
  66 001a DA61     		str	r2, [r3, #28]
 419:le_phy.c      **** 		le_dma_lli[i].next_lli = (uint32_t)&le_dma_lli[1-i]; // two elements pointing back at each other
  67              		.loc 1 419 26 view .LVU21
  68 001c C3E90553 		strd	r5, r3, [r3, #20]
  69              		.loc 1 420 3 is_stmt 1 view .LVU22
 416:le_phy.c      **** 		le_dma_lli[i].src = (uint32_t)&(DIO_SSP_DR);
  70              		.loc 1 416 21 view .LVU23
  71              	.LVL1:
 416:le_phy.c      **** 		le_dma_lli[i].src = (uint32_t)&(DIO_SSP_DR);
  72              		.loc 1 416 14 view .LVU24
 421:le_phy.c      **** 				(0 << 12) |        // source burst size = 1
 422:le_phy.c      **** 				(0 << 15) |        // destination burst size = 1
 423:le_phy.c      **** 				(0 << 18) |        // source width 8 bits
 424:le_phy.c      **** 				(0 << 21) |        // destination width 8 bits
 425:le_phy.c      **** 				DMACCxControl_I;   // terminal count interrupt enable
 426:le_phy.c      **** 	}
 427:le_phy.c      **** 
 428:le_phy.c      **** 	// configure DMA channel 0
 429:le_phy.c      **** 	DMACC0SrcAddr = le_dma_lli[0].src;
  73              		.loc 1 429 2 view .LVU25
ARM GAS  /tmp/ccXJY3ni.s 			page 10


  74              		.loc 1 429 16 is_stmt 0 view .LVU26
  75 0020 084B     		ldr	r3, .L2+16
  76 0022 1860     		str	r0, [r3]
 430:le_phy.c      **** 	DMACC0DestAddr = le_dma_lli[0].dest;
  77              		.loc 1 430 2 is_stmt 1 view .LVU27
  78              		.loc 1 430 17 is_stmt 0 view .LVU28
  79 0024 5960     		str	r1, [r3, #4]
 431:le_phy.c      **** 	DMACC0LLI = le_dma_lli[0].next_lli;
  80              		.loc 1 431 2 is_stmt 1 view .LVU29
  81              		.loc 1 431 12 is_stmt 0 view .LVU30
  82 0026 9C60     		str	r4, [r3, #8]
 432:le_phy.c      **** 	DMACC0Control = le_dma_lli[0].control;
  83              		.loc 1 432 2 is_stmt 1 view .LVU31
  84              		.loc 1 432 16 is_stmt 0 view .LVU32
  85 0028 DA60     		str	r2, [r3, #12]
 433:le_phy.c      **** 	DMACC0Config =
  86              		.loc 1 433 2 is_stmt 1 view .LVU33
  87              		.loc 1 433 15 is_stmt 0 view .LVU34
  88 002a 4DF20602 		movw	r2, #53254
  89 002e 1A61     		str	r2, [r3, #16]
 434:le_phy.c      **** 			DIO_SSP_SRC |
 435:le_phy.c      **** 			(0x2 << 11) |     // peripheral to memory
 436:le_phy.c      **** 			DMACCxConfig_IE | // allow error interrupts
 437:le_phy.c      **** 			DMACCxConfig_ITC; // allow terminal count interrupts
 438:le_phy.c      **** }
  90              		.loc 1 438 1 view .LVU35
  91 0030 30BD     		pop	{r4, r5, pc}
  92              	.L3:
  93 0032 00BF     		.align	2
  94              	.L2:
  95 0034 00000000 		.word	.LANCHOR0
  96 0038 00000000 		.word	le_dma_dest
  97 003c 01000080 		.word	-2147483647
  98 0040 08000340 		.word	1073938440
  99 0044 00410050 		.word	1342193920
 100              		.cfi_endproc
 101              	.LFE17:
 103              		.section	.text.timer1_set_match,"ax",%progbits
 104              		.align	1
 105              		.syntax unified
 106              		.thumb
 107              		.thumb_func
 108              		.fpu softvfp
 110              	timer1_set_match:
 111              	.LVL2:
 112              	.LFB24:
 439:le_phy.c      **** 
 440:le_phy.c      **** // initalize USB, SSP, and DMA
 441:le_phy.c      **** static void le_sys_init(void) {
 442:le_phy.c      **** 	usb_queue_init(); // USB FIFO FIXME replace with safer queue
 443:le_phy.c      **** 	dio_ssp_init();   // init SSP and raise !CS (self-routed GPIO)
 444:le_phy.c      **** 	le_dma_init();    // prepare DMA + interrupts
 445:le_phy.c      **** 	dio_ssp_start();  // enable SSP + DMA
 446:le_phy.c      **** }
 447:le_phy.c      **** 
 448:le_phy.c      **** // initialize RF and strobe FSON
 449:le_phy.c      **** static void le_cc2400_init_rf(void) {
ARM GAS  /tmp/ccXJY3ni.s 			page 11


 450:le_phy.c      **** 	u16 grmdm, mdmctrl;
 451:le_phy.c      **** 	uint32_t sync = rbit(conn.access_address);
 452:le_phy.c      **** 
 453:le_phy.c      **** 	mdmctrl = 0x0040; // 250 kHz frequency deviation
 454:le_phy.c      **** 	grmdm = 0x44E1; // un-buffered mode, packet w/ sync word detection
 455:le_phy.c      **** 	// 0 10 00 1 001 11 0 00 0 1
 456:le_phy.c      **** 	//   |  |  | |   |  +--------> CRC off
 457:le_phy.c      **** 	//   |  |  | |   +-----------> sync word: 32 MSB bits of SYNC_WORD
 458:le_phy.c      **** 	//   |  |  | +---------------> 1 preamble byte of 01010101
 459:le_phy.c      **** 	//   |  |  +-----------------> packet mode
 460:le_phy.c      **** 	//   |  +--------------------> un-buffered mode
 461:le_phy.c      **** 	//   +-----------------------> sync error bits: 2
 462:le_phy.c      **** 
 463:le_phy.c      **** 	cc2400_set(MANAND,  0x7ffe);
 464:le_phy.c      **** 	cc2400_set(LMTST,   0x2b22);
 465:le_phy.c      **** 
 466:le_phy.c      **** 	cc2400_set(MDMTST0, 0x124b);
 467:le_phy.c      **** 	// 1      2      4b
 468:le_phy.c      **** 	// 00 0 1 0 0 10 01001011
 469:le_phy.c      **** 	//    | | | | |  +---------> AFC_DELTA = ??
 470:le_phy.c      **** 	//    | | | | +------------> AFC settling = 4 pairs (8 bit preamble)
 471:le_phy.c      **** 	//    | | | +--------------> no AFC adjust on packet
 472:le_phy.c      **** 	//    | | +----------------> do not invert data
 473:le_phy.c      **** 	//    | +------------------> TX IF freq 1 0Hz
 474:le_phy.c      **** 	//    +--------------------> PRNG off
 475:le_phy.c      **** 	//
 476:le_phy.c      **** 	// ref: CC2400 datasheet page 67
 477:le_phy.c      **** 	// AFC settling explained page 41/42
 478:le_phy.c      **** 
 479:le_phy.c      **** 	cc2400_set(GRMDM,   grmdm);
 480:le_phy.c      **** 
 481:le_phy.c      **** 	cc2400_set(SYNCL,   sync & 0xffff);
 482:le_phy.c      **** 	cc2400_set(SYNCH,   (sync >> 16) & 0xffff);
 483:le_phy.c      **** 
 484:le_phy.c      **** 	cc2400_set(FSDIV,   rf_channel - 1); // 1 MHz IF
 485:le_phy.c      **** 	cc2400_set(MDMCTRL, mdmctrl);
 486:le_phy.c      **** 
 487:le_phy.c      **** 	// XOSC16M should always be stable, but leave this test anyway
 488:le_phy.c      **** 	while (!(cc2400_status() & XOSC16M_STABLE));
 489:le_phy.c      **** 
 490:le_phy.c      **** 	// wait for FS_LOCK in background
 491:le_phy.c      **** 	cc2400_strobe(SFSON);
 492:le_phy.c      **** 	timer1_wait_fs_lock();
 493:le_phy.c      **** }
 494:le_phy.c      **** 
 495:le_phy.c      **** // strobe RX and enable PA
 496:le_phy.c      **** static void le_cc2400_strobe_rx(void) {
 497:le_phy.c      **** 	cc2400_strobe(SRX);
 498:le_phy.c      **** #ifdef UBERTOOTH_ONE
 499:le_phy.c      **** 	PAEN_SET;
 500:le_phy.c      **** 	HGM_SET;
 501:le_phy.c      **** #endif
 502:le_phy.c      **** }
 503:le_phy.c      **** 
 504:le_phy.c      **** // change channel and init rx
 505:le_phy.c      **** static void change_channel(void) {
 506:le_phy.c      **** 	uint8_t channel_idx = 0;
ARM GAS  /tmp/ccXJY3ni.s 			page 12


 507:le_phy.c      **** 
 508:le_phy.c      **** 	cc2400_strobe(SRFOFF);
 509:le_phy.c      **** 
 510:le_phy.c      **** 	// stop DMA and flush SSP
 511:le_phy.c      **** 	DIO_SSP_DMACR &= ~SSPDMACR_RXDMAE;
 512:le_phy.c      **** 	while (SSP1SR & SSPSR_RNE) {
 513:le_phy.c      **** 		uint8_t tmp = (uint8_t)DIO_SSP_DR;
 514:le_phy.c      **** 	}
 515:le_phy.c      **** 
 516:le_phy.c      **** 	buffer_clear(current_rxbuf);
 517:le_phy.c      **** 	le_dma_init();
 518:le_phy.c      **** 	dio_ssp_start();
 519:le_phy.c      **** 
 520:le_phy.c      **** 	if (conn.access_address == ADVERTISING_AA) {
 521:le_phy.c      **** 		// FIXME
 522:le_phy.c      **** 		switch (le_adv_channel) {
 523:le_phy.c      **** 			case 2402: channel_idx = 37; break;
 524:le_phy.c      **** 			case 2426: channel_idx = 38; break;
 525:le_phy.c      **** 			case 2480: channel_idx = 39; break;
 526:le_phy.c      **** 			default:   channel_idx = 37; break;
 527:le_phy.c      **** 		}
 528:le_phy.c      **** 	} else {
 529:le_phy.c      **** 		conn.channel_idx = (conn.channel_idx + conn.hop_increment) % 37;
 530:le_phy.c      **** 		channel_idx = le_map_channel(conn.channel_idx, &conn.remapping);
 531:le_phy.c      **** 	}
 532:le_phy.c      **** 
 533:le_phy.c      **** 	rf_channel = btle_channel_index_to_phys(channel_idx);
 534:le_phy.c      **** 	le_cc2400_init_rf();
 535:le_phy.c      **** }
 536:le_phy.c      **** 
 537:le_phy.c      **** ///////
 538:le_phy.c      **** // timer stuff
 539:le_phy.c      **** 
 540:le_phy.c      **** static void timer1_start(void) {
 541:le_phy.c      **** 	T1TCR = TCR_Counter_Reset;
 542:le_phy.c      **** 	T1PR = 4; // 100 ns
 543:le_phy.c      **** 	T1TCR = TCR_Counter_Enable;
 544:le_phy.c      **** 
 545:le_phy.c      **** 	// set up interrupt handler
 546:le_phy.c      **** 	ISER0 = ISER0_ISE_TIMER1;
 547:le_phy.c      **** }
 548:le_phy.c      **** 
 549:le_phy.c      **** static void timer1_stop(void) {
 550:le_phy.c      **** 	T1TCR = TCR_Counter_Reset;
 551:le_phy.c      **** 
 552:le_phy.c      **** 	// clear interrupt handler
 553:le_phy.c      **** 	ICER0 = ICER0_ICE_TIMER1;
 554:le_phy.c      **** }
 555:le_phy.c      **** 
 556:le_phy.c      **** static void timer1_set_match(uint32_t match) {
 113              		.loc 1 556 46 is_stmt 1 view -0
 114              		.cfi_startproc
 115              		@ args = 0, pretend = 0, frame = 0
 116              		@ frame_needed = 0, uses_anonymous_args = 0
 117              		@ link register save eliminated.
 118              		.loc 1 556 46 is_stmt 0 view .LVU37
 557:le_phy.c      **** 	T1MR0 = match;
ARM GAS  /tmp/ccXJY3ni.s 			page 13


 119              		.loc 1 557 2 is_stmt 1 view .LVU38
 120              		.loc 1 557 8 is_stmt 0 view .LVU39
 121 0000 034B     		ldr	r3, .L5
 558:le_phy.c      **** 	T1MCR |= TMCR_MR0I;
 122              		.loc 1 558 8 view .LVU40
 123 0002 044A     		ldr	r2, .L5+4
 557:le_phy.c      **** 	T1MR0 = match;
 124              		.loc 1 557 8 view .LVU41
 125 0004 1860     		str	r0, [r3]
 126              		.loc 1 558 2 is_stmt 1 view .LVU42
 127              		.loc 1 558 8 is_stmt 0 view .LVU43
 128 0006 1368     		ldr	r3, [r2]
 129 0008 43F00103 		orr	r3, r3, #1
 130 000c 1360     		str	r3, [r2]
 559:le_phy.c      **** }
 131              		.loc 1 559 1 view .LVU44
 132 000e 7047     		bx	lr
 133              	.L6:
 134              		.align	2
 135              	.L5:
 136 0010 18800040 		.word	1073774616
 137 0014 14800040 		.word	1073774612
 138              		.cfi_endproc
 139              	.LFE24:
 141              		.section	.text.timer1_wait_fs_lock,"ax",%progbits
 142              		.align	1
 143              		.syntax unified
 144              		.thumb
 145              		.thumb_func
 146              		.fpu softvfp
 148              	timer1_wait_fs_lock:
 149              	.LFB26:
 560:le_phy.c      **** 
 561:le_phy.c      **** static void timer1_clear_match(void) {
 562:le_phy.c      **** 	T1MCR &= ~TMCR_MR0I;
 563:le_phy.c      **** }
 564:le_phy.c      **** 
 565:le_phy.c      **** static void timer1_wait_fs_lock(void) {
 150              		.loc 1 565 39 is_stmt 1 view -0
 151              		.cfi_startproc
 152              		@ args = 0, pretend = 0, frame = 0
 153              		@ frame_needed = 0, uses_anonymous_args = 0
 154              		@ link register save eliminated.
 566:le_phy.c      **** 	T1MR2 = NOW + USEC(3);
 155              		.loc 1 566 2 view .LVU46
 156              		.loc 1 566 10 is_stmt 0 view .LVU47
 157 0000 054B     		ldr	r3, .L8
 158              		.loc 1 566 8 view .LVU48
 159 0002 064A     		ldr	r2, .L8+4
 160              		.loc 1 566 10 view .LVU49
 161 0004 1B68     		ldr	r3, [r3]
 162              		.loc 1 566 14 view .LVU50
 163 0006 1E33     		adds	r3, r3, #30
 164              		.loc 1 566 8 view .LVU51
 165 0008 1360     		str	r3, [r2]
 567:le_phy.c      **** 	T1MCR |= TMCR_MR2I;
 166              		.loc 1 567 2 is_stmt 1 view .LVU52
ARM GAS  /tmp/ccXJY3ni.s 			page 14


 167              		.loc 1 567 8 is_stmt 0 view .LVU53
 168 000a 52F80C3C 		ldr	r3, [r2, #-12]
 169 000e 43F04003 		orr	r3, r3, #64
 170 0012 42F80C3C 		str	r3, [r2, #-12]
 568:le_phy.c      **** }
 171              		.loc 1 568 1 view .LVU54
 172 0016 7047     		bx	lr
 173              	.L9:
 174              		.align	2
 175              	.L8:
 176 0018 08800040 		.word	1073774600
 177 001c 20800040 		.word	1073774624
 178              		.cfi_endproc
 179              	.LFE26:
 181              		.section	.text.timer1_wait_buffer,"ax",%progbits
 182              		.align	1
 183              		.syntax unified
 184              		.thumb
 185              		.thumb_func
 186              		.fpu softvfp
 188              	timer1_wait_buffer:
 189              	.LFB28:
 569:le_phy.c      **** 
 570:le_phy.c      **** static void timer1_cancel_fs_lock(void) {
 571:le_phy.c      **** 	T1MCR &= ~TMCR_MR2I;
 572:le_phy.c      **** }
 573:le_phy.c      **** 
 574:le_phy.c      **** static void timer1_wait_buffer(void) {
 190              		.loc 1 574 38 is_stmt 1 view -0
 191              		.cfi_startproc
 192              		@ args = 0, pretend = 0, frame = 0
 193              		@ frame_needed = 0, uses_anonymous_args = 0
 194              		@ link register save eliminated.
 575:le_phy.c      **** 	T1MR3 = NOW + USEC(100);
 195              		.loc 1 575 2 view .LVU56
 196              		.loc 1 575 10 is_stmt 0 view .LVU57
 197 0000 064B     		ldr	r3, .L11
 198              		.loc 1 575 8 view .LVU58
 199 0002 074A     		ldr	r2, .L11+4
 200              		.loc 1 575 10 view .LVU59
 201 0004 1B68     		ldr	r3, [r3]
 202              		.loc 1 575 14 view .LVU60
 203 0006 03F57A73 		add	r3, r3, #1000
 204              		.loc 1 575 8 view .LVU61
 205 000a 1360     		str	r3, [r2]
 576:le_phy.c      **** 	T1MCR |= TMCR_MR3I;
 206              		.loc 1 576 2 is_stmt 1 view .LVU62
 207              		.loc 1 576 8 is_stmt 0 view .LVU63
 208 000c 52F8103C 		ldr	r3, [r2, #-16]
 209 0010 43F40073 		orr	r3, r3, #512
 210 0014 42F8103C 		str	r3, [r2, #-16]
 577:le_phy.c      **** }
 211              		.loc 1 577 1 view .LVU64
 212 0018 7047     		bx	lr
 213              	.L12:
 214 001a 00BF     		.align	2
 215              	.L11:
ARM GAS  /tmp/ccXJY3ni.s 			page 15


 216 001c 08800040 		.word	1073774600
 217 0020 24800040 		.word	1073774628
 218              		.cfi_endproc
 219              	.LFE28:
 221              		.section	.text.extract_field,"ax",%progbits
 222              		.align	1
 223              		.syntax unified
 224              		.thumb
 225              		.thumb_func
 226              		.fpu softvfp
 228              	extract_field:
 229              	.LVL3:
 230              	.LFB34:
 578:le_phy.c      **** 
 579:le_phy.c      **** static void timer1_cancel_wait_buffer(void) {
 580:le_phy.c      **** 	T1MCR &= ~TMCR_MR3I;
 581:le_phy.c      **** }
 582:le_phy.c      **** 
 583:le_phy.c      **** void TIMER1_IRQHandler(void) {
 584:le_phy.c      **** 	// MR0: connection events
 585:le_phy.c      **** 	if (T1IR & TIR_MR0_Interrupt) {
 586:le_phy.c      **** 		// ack the interrupt
 587:le_phy.c      **** 		T1IR = TIR_MR0_Interrupt;
 588:le_phy.c      **** 
 589:le_phy.c      **** 		// connection update procedure
 590:le_phy.c      **** 		if (conn.conn_update_pending &&
 591:le_phy.c      **** 				conn.conn_event_counter == conn.conn_update_instant) {
 592:le_phy.c      **** 
 593:le_phy.c      **** 			// on the first past through, handle the transmit window
 594:le_phy.c      **** 			// offset. if there's no offset, skip down to else block
 595:le_phy.c      **** 			if (!conn_event.opened && conn.win_offset > 0) {
 596:le_phy.c      **** 				timer1_set_match(conn.last_anchor + conn.conn_interval +
 597:le_phy.c      **** 						conn.win_offset - RX_WARMUP_TIME);
 598:le_phy.c      **** 				conn_event.opened = 1;
 599:le_phy.c      **** 			}
 600:le_phy.c      **** 
 601:le_phy.c      **** 			// after the transmit window offset, or if there is no
 602:le_phy.c      **** 			// transmit window, set a packet timeout and change the
 603:le_phy.c      **** 			// channel
 604:le_phy.c      **** 			else { // conn_event.opened || conn.win_offset == 0
 605:le_phy.c      **** 				conn_event.opened = 1;
 606:le_phy.c      **** 
 607:le_phy.c      **** 				// this is like a new connection, so set all values
 608:le_phy.c      **** 				// accordingly
 609:le_phy.c      **** 				conn.anchor_set = 0;
 610:le_phy.c      **** 				conn.conn_interval = conn.conn_update_pending_interval;
 611:le_phy.c      **** 				conn.supervision_timeout = conn.conn_update_pending_supervision_timeout;
 612:le_phy.c      **** 				conn.conn_update_pending = 0;
 613:le_phy.c      **** 
 614:le_phy.c      **** 				// timeout after conn window + max packet length
 615:le_phy.c      **** 				timer1_set_match(conn.last_anchor + conn.conn_interval +
 616:le_phy.c      **** 						conn.win_offset + conn.win_size + USEC(2120));
 617:le_phy.c      **** 				change_channel();
 618:le_phy.c      **** 			}
 619:le_phy.c      **** 			return;
 620:le_phy.c      **** 		}
 621:le_phy.c      **** 
ARM GAS  /tmp/ccXJY3ni.s 			page 16


 622:le_phy.c      **** 		// channel map update
 623:le_phy.c      **** 		if (conn.channel_map_update_pending &&
 624:le_phy.c      **** 				conn.conn_event_counter == conn.channel_map_update_instant) {
 625:le_phy.c      **** 			conn.remapping = conn.pending_remapping;
 626:le_phy.c      **** 			conn.channel_map_update_pending = 0;
 627:le_phy.c      **** 		}
 628:le_phy.c      **** 
 629:le_phy.c      **** 		// new connection event: set timeout and change channel
 630:le_phy.c      **** 		if (!conn_event.opened) {
 631:le_phy.c      **** 			conn_event.opened = 1;
 632:le_phy.c      **** 			// timeout is max packet length + warmup time (slack)
 633:le_phy.c      **** 			timer1_set_match(NOW + USEC(2120) + RX_WARMUP_TIME);
 634:le_phy.c      **** 			change_channel();
 635:le_phy.c      **** 		}
 636:le_phy.c      **** 
 637:le_phy.c      **** 		// regular connection event, plus timeout from connection updates
 638:le_phy.c      **** 		// FIXME connection update timeouts and initial connection
 639:le_phy.c      **** 		// timeouts need to be handled differently: they should have a
 640:le_phy.c      **** 		// full window until the packets from the new connection are
 641:le_phy.c      **** 		// captured and a new anchor is set.
 642:le_phy.c      **** 		else {
 643:le_phy.c      **** 			// new connection event: set timeout and change channel
 644:le_phy.c      **** 			if (!conn_event.opened) {
 645:le_phy.c      **** 				conn_event.opened = 1;
 646:le_phy.c      **** 
 647:le_phy.c      **** 				// timeout is max packet length + warmup time (slack)
 648:le_phy.c      **** 				timer1_set_match(NOW + USEC(2120) + RX_WARMUP_TIME);
 649:le_phy.c      **** 				change_channel();
 650:le_phy.c      **** 			}
 651:le_phy.c      **** 
 652:le_phy.c      **** 			// timeout: close connection event and set timer for next hop
 653:le_phy.c      **** 			else {
 654:le_phy.c      **** 				finish_conn_event();
 655:le_phy.c      **** 			}
 656:le_phy.c      **** 		}
 657:le_phy.c      **** 	}
 658:le_phy.c      **** 
 659:le_phy.c      **** 	// LEDs
 660:le_phy.c      **** 	if (T1IR & TIR_MR1_Interrupt) {
 661:le_phy.c      **** 		T1IR = TIR_MR1_Interrupt;
 662:le_phy.c      **** 		T1MCR &= ~TMCR_MR1I;
 663:le_phy.c      **** 
 664:le_phy.c      **** 		TXLED_CLR;
 665:le_phy.c      **** 		RXLED_CLR;
 666:le_phy.c      **** 		USRLED_CLR;
 667:le_phy.c      **** 	}
 668:le_phy.c      **** 
 669:le_phy.c      **** 	// check FS_LOCK
 670:le_phy.c      **** 	if (T1IR & TIR_MR2_Interrupt) {
 671:le_phy.c      **** 		T1IR = TIR_MR2_Interrupt;
 672:le_phy.c      **** 
 673:le_phy.c      **** 		// if FS is locked, strobe RX and clear interrupt
 674:le_phy.c      **** 		if (cc2400_status() & FS_LOCK) {
 675:le_phy.c      **** 			// restart DMA and SSP
 676:le_phy.c      **** 			le_dma_init();
 677:le_phy.c      **** 			dio_ssp_start();
 678:le_phy.c      **** 			ISER0 = ISER0_ISE_DMA;
ARM GAS  /tmp/ccXJY3ni.s 			page 17


 679:le_phy.c      **** 
 680:le_phy.c      **** 			le_cc2400_strobe_rx();
 681:le_phy.c      **** 			T1MCR &= ~TMCR_MR2I;
 682:le_phy.c      **** 		}
 683:le_phy.c      **** 
 684:le_phy.c      **** 		// if FS is not locked, check again in 3 us
 685:le_phy.c      **** 		else {
 686:le_phy.c      **** 			timer1_wait_fs_lock();
 687:le_phy.c      **** 		}
 688:le_phy.c      **** 	}
 689:le_phy.c      **** 
 690:le_phy.c      **** 	// check if an rxbuf is available and transition to FS_LOCK/RX
 691:le_phy.c      **** 	if (T1IR & TIR_MR3_Interrupt) {
 692:le_phy.c      **** 		T1IR = TIR_MR3_Interrupt;
 693:le_phy.c      **** 
 694:le_phy.c      **** 		current_rxbuf = buffer_get();
 695:le_phy.c      **** 		if (current_rxbuf == NULL) {
 696:le_phy.c      **** 			timer1_wait_buffer();
 697:le_phy.c      **** 		} else {
 698:le_phy.c      **** 			if (cc2400_status() & FS_LOCK) {
 699:le_phy.c      **** 				// restart DMA and SSP
 700:le_phy.c      **** 				le_dma_init();
 701:le_phy.c      **** 				dio_ssp_start();
 702:le_phy.c      **** 				ISER0 = ISER0_ISE_DMA;
 703:le_phy.c      **** 
 704:le_phy.c      **** 				le_cc2400_strobe_rx();
 705:le_phy.c      **** 			} else {
 706:le_phy.c      **** 				timer1_wait_fs_lock();
 707:le_phy.c      **** 			}
 708:le_phy.c      **** 		}
 709:le_phy.c      **** 	}
 710:le_phy.c      **** }
 711:le_phy.c      **** 
 712:le_phy.c      **** static void blink(int tx, int rx, int usr) {
 713:le_phy.c      **** 	if (tx)
 714:le_phy.c      **** 		TXLED_SET;
 715:le_phy.c      **** 	if (rx)
 716:le_phy.c      **** 		RXLED_SET;
 717:le_phy.c      **** 	if (usr)
 718:le_phy.c      **** 		USRLED_SET;
 719:le_phy.c      **** 
 720:le_phy.c      **** 	// blink for 10 ms
 721:le_phy.c      **** 	T1MR1 = NOW + MSEC(10);
 722:le_phy.c      **** 	T1MCR |= TMCR_MR1I;
 723:le_phy.c      **** }
 724:le_phy.c      **** 
 725:le_phy.c      **** // helper function to dewhiten length from whitened data (only used
 726:le_phy.c      **** // during DMA)
 727:le_phy.c      **** static uint8_t dewhiten_length(unsigned channel, uint8_t data) {
 728:le_phy.c      **** 	unsigned int i, bit;
 729:le_phy.c      **** 	int idx = whitening_index[btle_channel_index(channel)];
 730:le_phy.c      **** 	uint8_t out = 0;
 731:le_phy.c      **** 
 732:le_phy.c      **** 	// length is second byte of packet
 733:le_phy.c      **** 	idx = (idx + 8) % sizeof(whitening);
 734:le_phy.c      **** 
 735:le_phy.c      **** 	for (i = 0; i < 8; ++i) {
ARM GAS  /tmp/ccXJY3ni.s 			page 18


 736:le_phy.c      **** 		bit = (data >> (7-i)) & 1;
 737:le_phy.c      **** 		bit ^= whitening[idx];
 738:le_phy.c      **** 		idx = (idx + 1) % sizeof(whitening);
 739:le_phy.c      **** 		out |= bit << i;
 740:le_phy.c      **** 	}
 741:le_phy.c      **** 
 742:le_phy.c      **** 	return out;
 743:le_phy.c      **** }
 744:le_phy.c      **** 
 745:le_phy.c      **** // enqueue a packet for USB
 746:le_phy.c      **** // FIXME this is cribbed from existing code, but does not have enough
 747:le_phy.c      **** // room for larger LE packets
 748:le_phy.c      **** static int usb_enqueue_le(le_rx_t *packet) {
 749:le_phy.c      **** 	usb_pkt_rx* f = usb_enqueue();
 750:le_phy.c      **** 
 751:le_phy.c      **** 	// fail if queue is full
 752:le_phy.c      **** 	if (f == NULL) {
 753:le_phy.c      **** 		return 0;
 754:le_phy.c      **** 	}
 755:le_phy.c      **** 
 756:le_phy.c      **** 	f->pkt_type = LE_PACKET;
 757:le_phy.c      **** 
 758:le_phy.c      **** 	f->clkn_high = 0;
 759:le_phy.c      **** 	f->clk100ns = packet->timestamp;
 760:le_phy.c      **** 
 761:le_phy.c      **** 	f->channel = (uint8_t)((packet->channel - 2402) & 0xff);
 762:le_phy.c      **** 	f->rssi_avg = packet->rssi_sum / packet->size;
 763:le_phy.c      **** 	f->rssi_min = packet->rssi_min;
 764:le_phy.c      **** 	f->rssi_max = packet->rssi_max;
 765:le_phy.c      **** 	f->rssi_count = 0;
 766:le_phy.c      **** 
 767:le_phy.c      **** 	memcpy(f->data, &packet->access_address, 4);
 768:le_phy.c      **** 	memcpy(f->data+4, packet->data, DMA_SIZE-4);
 769:le_phy.c      **** 
 770:le_phy.c      **** 	f->status = 0;
 771:le_phy.c      **** 
 772:le_phy.c      **** 	return 1;
 773:le_phy.c      **** }
 774:le_phy.c      **** 
 775:le_phy.c      **** static unsigned extract_field(le_rx_t *buf, size_t offset, unsigned size) {
 231              		.loc 1 775 75 is_stmt 1 view -0
 232              		.cfi_startproc
 233              		@ args = 0, pretend = 0, frame = 0
 234              		@ frame_needed = 0, uses_anonymous_args = 0
 235              		.loc 1 775 75 is_stmt 0 view .LVU66
 236 0000 30B5     		push	{r4, r5, lr}
 237              		.cfi_def_cfa_offset 12
 238              		.cfi_offset 4, -12
 239              		.cfi_offset 5, -8
 240              		.cfi_offset 14, -4
 776:le_phy.c      **** 	unsigned i, ret = 0;
 241              		.loc 1 776 2 is_stmt 1 view .LVU67
 242              	.LVL4:
 777:le_phy.c      **** 
 778:le_phy.c      **** 	// this could just be replaced by memcpy... right?
 779:le_phy.c      **** 	for (i = 0; i < size; ++i)
 243              		.loc 1 779 2 view .LVU68
ARM GAS  /tmp/ccXJY3ni.s 			page 19


 244              		.loc 1 779 14 view .LVU69
 245 0002 0144     		add	r1, r1, r0
 246              	.LVL5:
 776:le_phy.c      **** 	unsigned i, ret = 0;
 247              		.loc 1 776 14 is_stmt 0 view .LVU70
 248 0004 0020     		movs	r0, #0
 249              	.LVL6:
 250              		.loc 1 779 9 view .LVU71
 251 0006 0346     		mov	r3, r0
 252              	.LVL7:
 253              	.L14:
 780:le_phy.c      **** 		ret |= buf->data[offset + i] << (i*8);
 254              		.loc 1 780 3 is_stmt 1 discriminator 3 view .LVU72
 255              		.loc 1 780 19 is_stmt 0 discriminator 3 view .LVU73
 256 0008 11F8014B 		ldrb	r4, [r1], #1	@ zero_extendqisi2
 257              		.loc 1 780 32 discriminator 3 view .LVU74
 258 000c DD00     		lsls	r5, r3, #3
 779:le_phy.c      **** 		ret |= buf->data[offset + i] << (i*8);
 259              		.loc 1 779 24 discriminator 3 view .LVU75
 260 000e 0133     		adds	r3, r3, #1
 261              	.LVL8:
 262              		.loc 1 780 32 discriminator 3 view .LVU76
 263 0010 AC40     		lsls	r4, r4, r5
 779:le_phy.c      **** 		ret |= buf->data[offset + i] << (i*8);
 264              		.loc 1 779 2 discriminator 3 view .LVU77
 265 0012 9A42     		cmp	r2, r3
 266              		.loc 1 780 7 discriminator 3 view .LVU78
 267 0014 40EA0400 		orr	r0, r0, r4
 268              	.LVL9:
 779:le_phy.c      **** 		ret |= buf->data[offset + i] << (i*8);
 269              		.loc 1 779 24 is_stmt 1 discriminator 3 view .LVU79
 779:le_phy.c      **** 		ret |= buf->data[offset + i] << (i*8);
 270              		.loc 1 779 14 discriminator 3 view .LVU80
 779:le_phy.c      **** 		ret |= buf->data[offset + i] << (i*8);
 271              		.loc 1 779 2 is_stmt 0 discriminator 3 view .LVU81
 272 0018 F6D1     		bne	.L14
 781:le_phy.c      **** 
 782:le_phy.c      **** 	return ret;
 783:le_phy.c      **** }
 273              		.loc 1 783 1 view .LVU82
 274 001a 30BD     		pop	{r4, r5, pc}
 275              		.cfi_endproc
 276              	.LFE34:
 278              		.section	.text.bd_addr_cmp,"ax",%progbits
 279              		.align	1
 280              		.syntax unified
 281              		.thumb
 282              		.thumb_func
 283              		.fpu softvfp
 285              	bd_addr_cmp:
 286              	.LVL10:
 287              	.LFB39:
 784:le_phy.c      **** 
 785:le_phy.c      **** static void le_connect_handler(le_rx_t *buf) {
 786:le_phy.c      **** 	uint32_t aa, crc_init;
 787:le_phy.c      **** 	uint32_t win_size, max_win_size;
 788:le_phy.c      **** 
ARM GAS  /tmp/ccXJY3ni.s 			page 20


 789:le_phy.c      **** 	if (!le.do_follow)
 790:le_phy.c      **** 		return;
 791:le_phy.c      **** 
 792:le_phy.c      **** 	if (buf->size != 2 + 6 + 6 + 22 + 3)
 793:le_phy.c      **** 		return;
 794:le_phy.c      **** 
 795:le_phy.c      **** 	// FIXME ugly hack
 796:le_phy.c      **** 	if (cancel_follow)
 797:le_phy.c      **** 		cancel_follow = 0;
 798:le_phy.c      **** 
 799:le_phy.c      **** 	conn.access_address     = extract_field(buf, 14, 4);
 800:le_phy.c      **** 	conn.crc_init           = extract_field(buf, 18, 3);
 801:le_phy.c      **** 	conn.crc_init_reversed  = rbit(conn.crc_init);
 802:le_phy.c      **** 	conn.win_size           = extract_field(buf, 21, 1);
 803:le_phy.c      **** 	conn.win_offset         = extract_field(buf, 22, 2);
 804:le_phy.c      **** 	conn.conn_interval      = extract_field(buf, 24, 2);
 805:le_phy.c      **** 	conn.supervision_timeout = extract_field(buf, 28, 2);
 806:le_phy.c      **** 	conn.hop_increment      = extract_field(buf, 35, 1) & 0x1f;
 807:le_phy.c      **** 
 808:le_phy.c      **** 	if (conn.conn_interval < 6 || conn.conn_interval > 3200) {
 809:le_phy.c      **** 		goto err_out;
 810:le_phy.c      **** 	} else {
 811:le_phy.c      **** 		conn.conn_interval *= USEC(1250);
 812:le_phy.c      **** 	}
 813:le_phy.c      **** 
 814:le_phy.c      **** 	// window offset is in range [0, conn_interval]
 815:le_phy.c      **** 	conn.win_offset *= USEC(1250);
 816:le_phy.c      **** 	if (conn.win_offset > conn.conn_interval)
 817:le_phy.c      **** 		goto err_out;
 818:le_phy.c      **** 
 819:le_phy.c      **** 	// win size is in range [1.25 ms, MIN(10 ms, conn_interval - 1.25 ms)]
 820:le_phy.c      **** 	win_size = conn.win_size * USEC(1250);
 821:le_phy.c      **** 	max_win_size = conn.conn_interval - USEC(1250);
 822:le_phy.c      **** 	if (max_win_size > MSEC(10))
 823:le_phy.c      **** 		max_win_size = MSEC(10);
 824:le_phy.c      **** 	if (win_size < USEC(1250) || win_size > max_win_size)
 825:le_phy.c      **** 		goto err_out;
 826:le_phy.c      **** 
 827:le_phy.c      **** 	// The connSupervisionTimeout shall be a multiple of 10 ms in the
 828:le_phy.c      **** 	// range of 100 ms to 32.0 s and it shall be larger than (1 +
 829:le_phy.c      **** 	// connSlaveLatency) * connInterval * 2
 830:le_phy.c      **** 	conn.supervision_timeout *= MSEC(10);
 831:le_phy.c      **** 	if (conn.supervision_timeout < MSEC(100) || conn.supervision_timeout > SEC(32))
 832:le_phy.c      **** 		goto err_out;
 833:le_phy.c      **** 	// TODO handle slave latency
 834:le_phy.c      **** 
 835:le_phy.c      **** 	le_parse_channel_map(&buf->data[30], &conn.remapping);
 836:le_phy.c      **** 	if (conn.remapping.total_channels == 0)
 837:le_phy.c      **** 		goto err_out;
 838:le_phy.c      **** 
 839:le_phy.c      **** 	// cancel RX on advertising channel
 840:le_phy.c      **** 	timer1_cancel_fs_lock();
 841:le_phy.c      **** 
 842:le_phy.c      **** 	reset_conn_event();
 843:le_phy.c      **** 	timer1_set_match(buf->timestamp + PACKET_DURATION(buf) +
 844:le_phy.c      **** 			conn.win_offset + USEC(1250) - RX_WARMUP_TIME);
 845:le_phy.c      **** 	return;
ARM GAS  /tmp/ccXJY3ni.s 			page 21


 846:le_phy.c      **** 
 847:le_phy.c      **** 	// error condition: reset conn and return
 848:le_phy.c      **** err_out:
 849:le_phy.c      **** 	reset_conn();
 850:le_phy.c      **** }
 851:le_phy.c      **** 
 852:le_phy.c      **** static void connection_update_handler(le_rx_t *buf) {
 853:le_phy.c      **** 	conn.win_size            = extract_field(buf, 3, 1);
 854:le_phy.c      **** 	conn.win_offset          = extract_field(buf, 4, 2);
 855:le_phy.c      **** 	conn.conn_update_pending_interval = extract_field(buf, 6, 2);
 856:le_phy.c      **** 	conn.conn_update_pending_supervision_timeout = extract_field(buf, 10, 2);
 857:le_phy.c      **** 	conn.conn_update_instant = extract_field(buf, 12, 2);
 858:le_phy.c      **** 
 859:le_phy.c      **** 	// TODO check for invalid values. XXX what do we even do in that
 860:le_phy.c      **** 	// case? we will probably drop the connection, but at least it's on
 861:le_phy.c      **** 	// our own terms and not some impossibly long supervision timeout.
 862:le_phy.c      **** 	conn.win_size   *= USEC(1250);
 863:le_phy.c      **** 	conn.win_offset *= USEC(1250);
 864:le_phy.c      **** 	conn.conn_update_pending_interval *= USEC(1250);
 865:le_phy.c      **** 	conn.conn_update_pending_supervision_timeout *= MSEC(10);
 866:le_phy.c      **** 
 867:le_phy.c      **** 	conn.conn_update_pending = 1;
 868:le_phy.c      **** }
 869:le_phy.c      **** 
 870:le_phy.c      **** static void channel_map_update_handler(le_rx_t *buf) {
 871:le_phy.c      **** 	conn.channel_map_update_pending = 1;
 872:le_phy.c      **** 	conn.channel_map_update_instant = extract_field(buf, 8, 2);
 873:le_phy.c      **** 	le_parse_channel_map(&buf->data[3], &conn.pending_remapping);
 874:le_phy.c      **** }
 875:le_phy.c      **** 
 876:le_phy.c      **** static void packet_handler(le_rx_t *buf) {
 877:le_phy.c      **** 	// advertising packet
 878:le_phy.c      **** 	if (btle_channel_index(buf->channel) >= 37) {
 879:le_phy.c      **** 		switch (buf->data[0] & 0xf) {
 880:le_phy.c      **** 			// CONNECT_REQ
 881:le_phy.c      **** 			case 0x05:
 882:le_phy.c      **** 				// TODO validate length
 883:le_phy.c      **** 				le_connect_handler(buf);
 884:le_phy.c      **** 				break;
 885:le_phy.c      **** 		}
 886:le_phy.c      **** 	}
 887:le_phy.c      **** 
 888:le_phy.c      **** 	// data packet
 889:le_phy.c      **** 	else {
 890:le_phy.c      **** 		// LL control PDU
 891:le_phy.c      **** 		if ((buf->data[0] & 0b11) == 0b11 && buf->data[1] > 0) {
 892:le_phy.c      **** 			switch (buf->data[2]) {
 893:le_phy.c      **** 				// LE_CONNECTION_UPDATE_REQ -- update connection parameters
 894:le_phy.c      **** 				case 0x0:
 895:le_phy.c      **** 					if (buf->data[1] == 12)
 896:le_phy.c      **** 						connection_update_handler(buf);
 897:le_phy.c      **** 					break;
 898:le_phy.c      **** 
 899:le_phy.c      **** 				// LE_CHANNEL_MAP_REQ -- update channel map
 900:le_phy.c      **** 				case 0x1:
 901:le_phy.c      **** 					if (buf->data[1] == 8)
 902:le_phy.c      **** 						channel_map_update_handler(buf);
ARM GAS  /tmp/ccXJY3ni.s 			page 22


 903:le_phy.c      **** 					break;
 904:le_phy.c      **** 			}
 905:le_phy.c      **** 		}
 906:le_phy.c      **** 	}
 907:le_phy.c      **** }
 908:le_phy.c      **** 
 909:le_phy.c      **** // compare a BD addr against target with mask
 910:le_phy.c      **** static int bd_addr_cmp(uint8_t *bd_addr) {
 288              		.loc 1 910 42 is_stmt 1 view -0
 289              		.cfi_startproc
 290              		@ args = 0, pretend = 0, frame = 0
 291              		@ frame_needed = 0, uses_anonymous_args = 0
 292              		.loc 1 910 42 is_stmt 0 view .LVU84
 293 0000 70B5     		push	{r4, r5, r6, lr}
 294              		.cfi_def_cfa_offset 16
 295              		.cfi_offset 4, -16
 296              		.cfi_offset 5, -12
 297              		.cfi_offset 6, -8
 298              		.cfi_offset 14, -4
 911:le_phy.c      **** 	unsigned i;
 299              		.loc 1 911 2 is_stmt 1 view .LVU85
 912:le_phy.c      **** 	for (i = 0; i < 6; ++i)
 300              		.loc 1 912 2 view .LVU86
 301              	.LVL11:
 302              		.loc 1 912 14 view .LVU87
 303 0002 0A49     		ldr	r1, .L21
 304 0004 421E     		subs	r2, r0, #1
 305 0006 0530     		adds	r0, r0, #5
 306              	.LVL12:
 307              	.L18:
 913:le_phy.c      **** 		if ((bd_addr[i] & le.target_mask[i]) != le.target[i])
 308              		.loc 1 913 3 view .LVU88
 309 0008 0B46     		mov	r3, r1
 310              		.loc 1 913 40 is_stmt 0 view .LVU89
 311 000a 8E79     		ldrb	r6, [r1, #6]	@ zero_extendqisi2
 312 000c 12F8014F 		ldrb	r4, [r2, #1]!	@ zero_extendqisi2
 313              	.LVL13:
 314              		.loc 1 913 6 view .LVU90
 315 0010 1D78     		ldrb	r5, [r3]	@ zero_extendqisi2
 316 0012 04EA0603 		and	r3, r4, r6
 317 0016 9D42     		cmp	r5, r3
 318              		.loc 1 913 40 view .LVU91
 319 0018 01F10101 		add	r1, r1, #1
 320              		.loc 1 913 6 view .LVU92
 321 001c 03D1     		bne	.L19
 912:le_phy.c      **** 	for (i = 0; i < 6; ++i)
 322              		.loc 1 912 21 is_stmt 1 discriminator 2 view .LVU93
 323              	.LVL14:
 912:le_phy.c      **** 	for (i = 0; i < 6; ++i)
 324              		.loc 1 912 14 discriminator 2 view .LVU94
 912:le_phy.c      **** 	for (i = 0; i < 6; ++i)
 325              		.loc 1 912 2 is_stmt 0 discriminator 2 view .LVU95
 326 001e 8242     		cmp	r2, r0
 327 0020 F2D1     		bne	.L18
 914:le_phy.c      **** 			return 0;
 915:le_phy.c      **** 	return 1;
 328              		.loc 1 915 9 view .LVU96
ARM GAS  /tmp/ccXJY3ni.s 			page 23


 329 0022 0120     		movs	r0, #1
 330              	.LVL15:
 331              	.L16:
 916:le_phy.c      **** }
 332              		.loc 1 916 1 view .LVU97
 333 0024 70BD     		pop	{r4, r5, r6, pc}
 334              	.LVL16:
 335              	.L19:
 914:le_phy.c      **** 			return 0;
 336              		.loc 1 914 11 view .LVU98
 337 0026 0020     		movs	r0, #0
 338 0028 FCE7     		b	.L16
 339              	.L22:
 340 002a 00BF     		.align	2
 341              	.L21:
 342 002c 38000000 		.word	le+56
 343              		.cfi_endproc
 344              	.LFE39:
 346              		.section	.text.reset_conn,"ax",%progbits
 347              		.align	1
 348              		.syntax unified
 349              		.thumb
 350              		.thumb_func
 351              		.fpu softvfp
 353              	reset_conn:
 354              	.LFB9:
 141:le_phy.c      **** 	memset(&conn, 0, sizeof(conn));
 355              		.loc 1 141 30 is_stmt 1 view -0
 356              		.cfi_startproc
 357              		@ args = 0, pretend = 0, frame = 0
 358              		@ frame_needed = 0, uses_anonymous_args = 0
 359 0000 10B5     		push	{r4, lr}
 360              		.cfi_def_cfa_offset 8
 361              		.cfi_offset 4, -8
 362              		.cfi_offset 14, -4
 142:le_phy.c      **** 	conn.access_address = ADVERTISING_AA;
 363              		.loc 1 142 2 view .LVU100
 364 0002 054C     		ldr	r4, .L24
 365 0004 4FF4E472 		mov	r2, #456
 366 0008 0021     		movs	r1, #0
 367 000a 04F12000 		add	r0, r4, #32
 368 000e FFF7FEFF 		bl	memset
 369              	.LVL17:
 143:le_phy.c      **** }
 370              		.loc 1 143 2 view .LVU101
 143:le_phy.c      **** }
 371              		.loc 1 143 22 is_stmt 0 view .LVU102
 372 0012 024B     		ldr	r3, .L24+4
 373 0014 2362     		str	r3, [r4, #32]
 144:le_phy.c      **** 
 374              		.loc 1 144 1 view .LVU103
 375 0016 10BD     		pop	{r4, pc}
 376              	.L25:
 377              		.align	2
 378              	.L24:
 379 0018 00000000 		.word	.LANCHOR0
 380 001c D6BE898E 		.word	-1903575338
ARM GAS  /tmp/ccXJY3ni.s 			page 24


 381              		.cfi_endproc
 382              	.LFE9:
 384              		.section	.text.buffer_get,"ax",%progbits
 385              		.align	1
 386              		.syntax unified
 387              		.thumb
 388              		.thumb_func
 389              		.fpu softvfp
 391              	buffer_get:
 392              	.LFB12:
 186:le_phy.c      **** 	int i;
 393              		.loc 1 186 34 is_stmt 1 view -0
 394              		.cfi_startproc
 395              		@ args = 0, pretend = 0, frame = 0
 396              		@ frame_needed = 0, uses_anonymous_args = 0
 397 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 398              		.cfi_def_cfa_offset 24
 399              		.cfi_offset 3, -24
 400              		.cfi_offset 4, -20
 401              		.cfi_offset 5, -16
 402              		.cfi_offset 6, -12
 403              		.cfi_offset 7, -8
 404              		.cfi_offset 14, -4
 187:le_phy.c      **** 
 405              		.loc 1 187 2 view .LVU105
 189:le_phy.c      **** 		if (le_buffer_pool[i].available) {
 406              		.loc 1 189 2 view .LVU106
 407              	.LVL18:
 189:le_phy.c      **** 		if (le_buffer_pool[i].available) {
 408              		.loc 1 189 14 view .LVU107
 409 0002 124A     		ldr	r2, .L31
 189:le_phy.c      **** 		if (le_buffer_pool[i].available) {
 410              		.loc 1 189 9 is_stmt 0 view .LVU108
 411 0004 0023     		movs	r3, #0
 412 0006 1146     		mov	r1, r2
 413              	.LVL19:
 414              	.L29:
 190:le_phy.c      **** 			le_buffer_pool[i].available = 0;
 415              		.loc 1 190 3 is_stmt 1 view .LVU109
 190:le_phy.c      **** 			le_buffer_pool[i].available = 0;
 416              		.loc 1 190 6 is_stmt 0 view .LVU110
 417 0008 D2F81841 		ldr	r4, [r2, #280]
 418 000c C4B1     		cbz	r4, .L27
 191:le_phy.c      **** 			buffer_clear(&le_buffer_pool[i]);
 419              		.loc 1 191 4 is_stmt 1 view .LVU111
 191:le_phy.c      **** 			buffer_clear(&le_buffer_pool[i]);
 420              		.loc 1 191 32 is_stmt 0 view .LVU112
 421 000e 4FF49274 		mov	r4, #292
 422 0012 0026     		movs	r6, #0
 423 0014 5C43     		muls	r4, r3, r4
 424 0016 0E4D     		ldr	r5, .L31+4
 425              	.LBB24:
 426              	.LBB25:
 177:le_phy.c      **** 	buf->rssi_min = INT8_MAX;
 427              		.loc 1 177 2 view .LVU113
 428 0018 4FF48272 		mov	r2, #260
 429              	.LBE25:
ARM GAS  /tmp/ccXJY3ni.s 			page 25


 430              	.LBE24:
 191:le_phy.c      **** 			buffer_clear(&le_buffer_pool[i]);
 431              		.loc 1 191 32 view .LVU114
 432 001c 2544     		add	r5, r5, r4
 192:le_phy.c      **** 			return &le_buffer_pool[i];
 433              		.loc 1 192 4 view .LVU115
 434 001e 0C44     		add	r4, r4, r1
 435              	.LBB28:
 436              	.LBB26:
 177:le_phy.c      **** 	buf->rssi_min = INT8_MAX;
 437              		.loc 1 177 2 view .LVU116
 438 0020 2046     		mov	r0, r4
 439 0022 3146     		mov	r1, r6
 176:le_phy.c      **** 	memset(buf->data, 0, sizeof(buf->data));
 440              		.loc 1 176 12 view .LVU117
 441 0024 C5E9BB66 		strd	r6, r6, [r5, #748]
 442              	.LBE26:
 443              	.LBE28:
 191:le_phy.c      **** 			buffer_clear(&le_buffer_pool[i]);
 444              		.loc 1 191 32 view .LVU118
 445 0028 C5F80063 		str	r6, [r5, #768]
 192:le_phy.c      **** 			return &le_buffer_pool[i];
 446              		.loc 1 192 4 is_stmt 1 view .LVU119
 447              	.LVL20:
 448              	.LBB29:
 449              	.LBI24:
 174:le_phy.c      **** 	buf->pos = 0;
 450              		.loc 1 174 13 view .LVU120
 451              	.LBB27:
 175:le_phy.c      **** 	buf->size = 0;
 452              		.loc 1 175 2 view .LVU121
 177:le_phy.c      **** 	buf->rssi_min = INT8_MAX;
 453              		.loc 1 177 2 view .LVU122
 454 002c FFF7FEFF 		bl	memset
 455              	.LVL21:
 178:le_phy.c      **** 	buf->rssi_max = INT8_MIN;
 456              		.loc 1 178 2 view .LVU123
 179:le_phy.c      **** 	buf->rssi_sum = 0;
 457              		.loc 1 179 2 view .LVU124
 178:le_phy.c      **** 	buf->rssi_max = INT8_MIN;
 458              		.loc 1 178 16 is_stmt 0 view .LVU125
 459 0030 48F27F03 		movw	r3, #32895
 180:le_phy.c      **** }
 460              		.loc 1 180 16 view .LVU126
 461 0034 C5F80863 		str	r6, [r5, #776]
 178:le_phy.c      **** 	buf->rssi_max = INT8_MIN;
 462              		.loc 1 178 16 view .LVU127
 463 0038 A5F80433 		strh	r3, [r5, #772]	@ movhi
 180:le_phy.c      **** }
 464              		.loc 1 180 2 is_stmt 1 view .LVU128
 465              	.LVL22:
 466              	.L26:
 180:le_phy.c      **** }
 467              		.loc 1 180 2 is_stmt 0 view .LVU129
 468              	.LBE27:
 469              	.LBE29:
 198:le_phy.c      **** 
ARM GAS  /tmp/ccXJY3ni.s 			page 26


 470              		.loc 1 198 1 view .LVU130
 471 003c 2046     		mov	r0, r4
 472 003e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 473              	.LVL23:
 474              	.L27:
 189:le_phy.c      **** 		if (le_buffer_pool[i].available) {
 475              		.loc 1 189 39 is_stmt 1 discriminator 2 view .LVU131
 476 0040 0133     		adds	r3, r3, #1
 477              	.LVL24:
 189:le_phy.c      **** 		if (le_buffer_pool[i].available) {
 478              		.loc 1 189 14 discriminator 2 view .LVU132
 189:le_phy.c      **** 		if (le_buffer_pool[i].available) {
 479              		.loc 1 189 2 is_stmt 0 discriminator 2 view .LVU133
 480 0042 042B     		cmp	r3, #4
 481 0044 02F59272 		add	r2, r2, #292
 482 0048 DED1     		bne	.L29
 483 004a F7E7     		b	.L26
 484              	.L32:
 485              		.align	2
 486              	.L31:
 487 004c E8010000 		.word	.LANCHOR0+488
 488 0050 00000000 		.word	.LANCHOR0
 489              		.cfi_endproc
 490              	.LFE12:
 492              		.section	.text.le_cc2400_init_rf,"ax",%progbits
 493              		.align	1
 494              		.syntax unified
 495              		.thumb
 496              		.thumb_func
 497              		.fpu softvfp
 499              	le_cc2400_init_rf:
 500              	.LFB19:
 449:le_phy.c      **** 	u16 grmdm, mdmctrl;
 501              		.loc 1 449 37 is_stmt 1 view -0
 502              		.cfi_startproc
 503              		@ args = 0, pretend = 0, frame = 0
 504              		@ frame_needed = 0, uses_anonymous_args = 0
 505 0000 10B5     		push	{r4, lr}
 506              		.cfi_def_cfa_offset 8
 507              		.cfi_offset 4, -8
 508              		.cfi_offset 14, -4
 450:le_phy.c      **** 	uint32_t sync = rbit(conn.access_address);
 509              		.loc 1 450 2 view .LVU135
 451:le_phy.c      **** 
 510              		.loc 1 451 2 view .LVU136
 451:le_phy.c      **** 
 511              		.loc 1 451 18 is_stmt 0 view .LVU137
 512 0002 1B4B     		ldr	r3, .L37
 513 0004 186A     		ldr	r0, [r3, #32]
 514 0006 FFF7FEFF 		bl	rbit
 515              	.LVL25:
 516 000a 0446     		mov	r4, r0
 517              	.LVL26:
 453:le_phy.c      **** 	grmdm = 0x44E1; // un-buffered mode, packet w/ sync word detection
 518              		.loc 1 453 2 is_stmt 1 view .LVU138
 454:le_phy.c      **** 	// 0 10 00 1 001 11 0 00 0 1
 519              		.loc 1 454 2 view .LVU139
ARM GAS  /tmp/ccXJY3ni.s 			page 27


 463:le_phy.c      **** 	cc2400_set(LMTST,   0x2b22);
 520              		.loc 1 463 2 view .LVU140
 521 000c 47F6FE71 		movw	r1, #32766
 522 0010 0D20     		movs	r0, #13
 523              	.LVL27:
 463:le_phy.c      **** 	cc2400_set(LMTST,   0x2b22);
 524              		.loc 1 463 2 is_stmt 0 view .LVU141
 525 0012 FFF7FEFF 		bl	cc2400_set
 526              	.LVL28:
 464:le_phy.c      **** 
 527              		.loc 1 464 2 is_stmt 1 view .LVU142
 528 0016 42F62231 		movw	r1, #11042
 529 001a 1220     		movs	r0, #18
 530 001c FFF7FEFF 		bl	cc2400_set
 531              	.LVL29:
 466:le_phy.c      **** 	// 1      2      4b
 532              		.loc 1 466 2 view .LVU143
 533 0020 41F24B21 		movw	r1, #4683
 534 0024 1420     		movs	r0, #20
 535 0026 FFF7FEFF 		bl	cc2400_set
 536              	.LVL30:
 479:le_phy.c      **** 
 537              		.loc 1 479 2 view .LVU144
 538 002a 44F2E141 		movw	r1, #17633
 539 002e 2020     		movs	r0, #32
 540 0030 FFF7FEFF 		bl	cc2400_set
 541              	.LVL31:
 481:le_phy.c      **** 	cc2400_set(SYNCH,   (sync >> 16) & 0xffff);
 542              		.loc 1 481 2 view .LVU145
 543 0034 2C20     		movs	r0, #44
 544 0036 A1B2     		uxth	r1, r4
 545 0038 FFF7FEFF 		bl	cc2400_set
 546              	.LVL32:
 482:le_phy.c      **** 
 547              		.loc 1 482 2 view .LVU146
 548 003c 2D20     		movs	r0, #45
 549 003e 210C     		lsrs	r1, r4, #16
 550 0040 FFF7FEFF 		bl	cc2400_set
 551              	.LVL33:
 484:le_phy.c      **** 	cc2400_set(MDMCTRL, mdmctrl);
 552              		.loc 1 484 2 view .LVU147
 553 0044 0B4B     		ldr	r3, .L37+4
 554 0046 0220     		movs	r0, #2
 555 0048 1988     		ldrh	r1, [r3]
 556 004a 0139     		subs	r1, r1, #1
 557 004c 89B2     		uxth	r1, r1
 558 004e FFF7FEFF 		bl	cc2400_set
 559              	.LVL34:
 485:le_phy.c      **** 
 560              		.loc 1 485 2 view .LVU148
 561 0052 4021     		movs	r1, #64
 562 0054 0320     		movs	r0, #3
 563 0056 FFF7FEFF 		bl	cc2400_set
 564              	.LVL35:
 488:le_phy.c      **** 
 565              		.loc 1 488 2 view .LVU149
 566              	.L34:
ARM GAS  /tmp/ccXJY3ni.s 			page 28


 488:le_phy.c      **** 
 567              		.loc 1 488 45 discriminator 1 view .LVU150
 488:le_phy.c      **** 
 568              		.loc 1 488 8 discriminator 1 view .LVU151
 488:le_phy.c      **** 
 569              		.loc 1 488 11 is_stmt 0 discriminator 1 view .LVU152
 570 005a FFF7FEFF 		bl	cc2400_status
 571              	.LVL36:
 488:le_phy.c      **** 
 572              		.loc 1 488 8 discriminator 1 view .LVU153
 573 005e 4306     		lsls	r3, r0, #25
 574 0060 FBD5     		bpl	.L34
 491:le_phy.c      **** 	timer1_wait_fs_lock();
 575              		.loc 1 491 2 is_stmt 1 view .LVU154
 576 0062 6120     		movs	r0, #97
 577 0064 FFF7FEFF 		bl	cc2400_strobe
 578              	.LVL37:
 492:le_phy.c      **** }
 579              		.loc 1 492 2 view .LVU155
 493:le_phy.c      **** 
 580              		.loc 1 493 1 is_stmt 0 view .LVU156
 581 0068 BDE81040 		pop	{r4, lr}
 582              		.cfi_restore 14
 583              		.cfi_restore 4
 584              		.cfi_def_cfa_offset 0
 585              	.LVL38:
 492:le_phy.c      **** }
 586              		.loc 1 492 2 view .LVU157
 587 006c FFF7FEBF 		b	timer1_wait_fs_lock
 588              	.LVL39:
 589              	.L38:
 590              		.align	2
 591              	.L37:
 592 0070 00000000 		.word	.LANCHOR0
 593 0074 00000000 		.word	rf_channel
 594              		.cfi_endproc
 595              	.LFE19:
 597              		.section	.text.change_channel,"ax",%progbits
 598              		.align	1
 599              		.syntax unified
 600              		.thumb
 601              		.thumb_func
 602              		.fpu softvfp
 604              	change_channel:
 605              	.LFB21:
 505:le_phy.c      **** 	uint8_t channel_idx = 0;
 606              		.loc 1 505 34 is_stmt 1 view -0
 607              		.cfi_startproc
 608              		@ args = 0, pretend = 0, frame = 0
 609              		@ frame_needed = 0, uses_anonymous_args = 0
 610 0000 70B5     		push	{r4, r5, r6, lr}
 611              		.cfi_def_cfa_offset 16
 612              		.cfi_offset 4, -16
 613              		.cfi_offset 5, -12
 614              		.cfi_offset 6, -8
 615              		.cfi_offset 14, -4
 506:le_phy.c      **** 
ARM GAS  /tmp/ccXJY3ni.s 			page 29


 616              		.loc 1 506 2 view .LVU159
 617              	.LVL40:
 508:le_phy.c      **** 
 618              		.loc 1 508 2 view .LVU160
 619 0002 6420     		movs	r0, #100
 620 0004 FFF7FEFF 		bl	cc2400_strobe
 621              	.LVL41:
 511:le_phy.c      **** 	while (SSP1SR & SSPSR_RNE) {
 622              		.loc 1 511 2 view .LVU161
 511:le_phy.c      **** 	while (SSP1SR & SSPSR_RNE) {
 623              		.loc 1 511 16 is_stmt 0 view .LVU162
 624 0008 264A     		ldr	r2, .L46
 625 000a 1368     		ldr	r3, [r2]
 626              	.LBB33:
 513:le_phy.c      **** 	}
 627              		.loc 1 513 26 view .LVU163
 628 000c 1C3A     		subs	r2, r2, #28
 629              	.LBE33:
 511:le_phy.c      **** 	while (SSP1SR & SSPSR_RNE) {
 630              		.loc 1 511 16 view .LVU164
 631 000e 23F00103 		bic	r3, r3, #1
 632 0012 D361     		str	r3, [r2, #28]
 512:le_phy.c      **** 		uint8_t tmp = (uint8_t)DIO_SSP_DR;
 633              		.loc 1 512 2 is_stmt 1 view .LVU165
 512:le_phy.c      **** 		uint8_t tmp = (uint8_t)DIO_SSP_DR;
 634              		.loc 1 512 9 is_stmt 0 view .LVU166
 635 0014 244B     		ldr	r3, .L46+4
 636              	.L40:
 512:le_phy.c      **** 		uint8_t tmp = (uint8_t)DIO_SSP_DR;
 637              		.loc 1 512 8 is_stmt 1 view .LVU167
 512:le_phy.c      **** 		uint8_t tmp = (uint8_t)DIO_SSP_DR;
 638              		.loc 1 512 9 is_stmt 0 view .LVU168
 639 0016 1C68     		ldr	r4, [r3]
 512:le_phy.c      **** 		uint8_t tmp = (uint8_t)DIO_SSP_DR;
 640              		.loc 1 512 8 view .LVU169
 641 0018 14F00404 		ands	r4, r4, #4
 642 001c 2CD1     		bne	.L41
 516:le_phy.c      **** 	le_dma_init();
 643              		.loc 1 516 2 is_stmt 1 view .LVU170
 644 001e 234D     		ldr	r5, .L46+8
 645              	.LBB34:
 646              	.LBB35:
 177:le_phy.c      **** 	buf->rssi_min = INT8_MAX;
 647              		.loc 1 177 2 is_stmt 0 view .LVU171
 648 0020 4FF48272 		mov	r2, #260
 649              	.LBE35:
 650              	.LBE34:
 516:le_phy.c      **** 	le_dma_init();
 651              		.loc 1 516 2 view .LVU172
 652 0024 D5F87866 		ldr	r6, [r5, #1656]
 653              	.LVL42:
 654              	.LBB37:
 655              	.LBI34:
 174:le_phy.c      **** 	buf->pos = 0;
 656              		.loc 1 174 13 is_stmt 1 view .LVU173
 657              	.LBB36:
 175:le_phy.c      **** 	buf->size = 0;
ARM GAS  /tmp/ccXJY3ni.s 			page 30


 658              		.loc 1 175 2 view .LVU174
 177:le_phy.c      **** 	buf->rssi_min = INT8_MAX;
 659              		.loc 1 177 2 is_stmt 0 view .LVU175
 660 0028 2146     		mov	r1, r4
 661 002a 3046     		mov	r0, r6
 176:le_phy.c      **** 	memset(buf->data, 0, sizeof(buf->data));
 662              		.loc 1 176 12 view .LVU176
 663 002c C6E94144 		strd	r4, r4, [r6, #260]
 177:le_phy.c      **** 	buf->rssi_min = INT8_MAX;
 664              		.loc 1 177 2 is_stmt 1 view .LVU177
 665 0030 FFF7FEFF 		bl	memset
 666              	.LVL43:
 178:le_phy.c      **** 	buf->rssi_max = INT8_MIN;
 667              		.loc 1 178 2 view .LVU178
 179:le_phy.c      **** 	buf->rssi_sum = 0;
 668              		.loc 1 179 2 view .LVU179
 178:le_phy.c      **** 	buf->rssi_max = INT8_MIN;
 669              		.loc 1 178 16 is_stmt 0 view .LVU180
 670 0034 48F27F03 		movw	r3, #32895
 180:le_phy.c      **** }
 671              		.loc 1 180 16 view .LVU181
 672 0038 C6F82041 		str	r4, [r6, #288]
 178:le_phy.c      **** 	buf->rssi_max = INT8_MIN;
 673              		.loc 1 178 16 view .LVU182
 674 003c A6F81C31 		strh	r3, [r6, #284]	@ movhi
 180:le_phy.c      **** }
 675              		.loc 1 180 2 is_stmt 1 view .LVU183
 676              	.LVL44:
 180:le_phy.c      **** }
 677              		.loc 1 180 2 is_stmt 0 view .LVU184
 678              	.LBE36:
 679              	.LBE37:
 517:le_phy.c      **** 	dio_ssp_start();
 680              		.loc 1 517 2 is_stmt 1 view .LVU185
 681 0040 FFF7FEFF 		bl	le_dma_init
 682              	.LVL45:
 518:le_phy.c      **** 
 683              		.loc 1 518 2 view .LVU186
 684 0044 FFF7FEFF 		bl	dio_ssp_start
 685              	.LVL46:
 520:le_phy.c      **** 		// FIXME
 686              		.loc 1 520 2 view .LVU187
 520:le_phy.c      **** 		// FIXME
 687              		.loc 1 520 5 is_stmt 0 view .LVU188
 688 0048 2A6A     		ldr	r2, [r5, #32]
 689 004a 194B     		ldr	r3, .L46+12
 690 004c 9A42     		cmp	r2, r3
 691 004e 15D1     		bne	.L42
 522:le_phy.c      **** 			case 2402: channel_idx = 37; break;
 692              		.loc 1 522 3 is_stmt 1 view .LVU189
 693 0050 40F67A12 		movw	r2, #2426
 694 0054 174B     		ldr	r3, .L46+16
 695 0056 1B88     		ldrh	r3, [r3]
 696 0058 9BB2     		uxth	r3, r3
 697 005a 9342     		cmp	r3, r2
 698 005c 20D0     		beq	.L44
 525:le_phy.c      **** 			default:   channel_idx = 37; break;
ARM GAS  /tmp/ccXJY3ni.s 			page 31


 699              		.loc 1 525 27 is_stmt 0 view .LVU190
 700 005e B3F51B6F 		cmp	r3, #2480
 701 0062 14BF     		ite	ne
 702 0064 2520     		movne	r0, #37
 703 0066 2720     		moveq	r0, #39
 704              	.LVL47:
 705              	.L43:
 533:le_phy.c      **** 	le_cc2400_init_rf();
 706              		.loc 1 533 2 is_stmt 1 view .LVU191
 533:le_phy.c      **** 	le_cc2400_init_rf();
 707              		.loc 1 533 15 is_stmt 0 view .LVU192
 708 0068 FFF7FEFF 		bl	btle_channel_index_to_phys
 709              	.LVL48:
 535:le_phy.c      **** 
 710              		.loc 1 535 1 view .LVU193
 711 006c BDE87040 		pop	{r4, r5, r6, lr}
 712              		.cfi_remember_state
 713              		.cfi_restore 14
 714              		.cfi_restore 6
 715              		.cfi_restore 5
 716              		.cfi_restore 4
 717              		.cfi_def_cfa_offset 0
 533:le_phy.c      **** 	le_cc2400_init_rf();
 718              		.loc 1 533 13 view .LVU194
 719 0070 114B     		ldr	r3, .L46+20
 720 0072 1880     		strh	r0, [r3]	@ movhi
 534:le_phy.c      **** }
 721              		.loc 1 534 2 is_stmt 1 view .LVU195
 722 0074 FFF7FEBF 		b	le_cc2400_init_rf
 723              	.LVL49:
 724              	.L41:
 725              		.cfi_restore_state
 726              	.LBB38:
 513:le_phy.c      **** 	}
 727              		.loc 1 513 3 view .LVU196
 513:le_phy.c      **** 	}
 728              		.loc 1 513 26 is_stmt 0 view .LVU197
 729 0078 1168     		ldr	r1, [r2]
 730 007a CCE7     		b	.L40
 731              	.L42:
 732              	.LBE38:
 529:le_phy.c      **** 		channel_idx = le_map_channel(conn.channel_idx, &conn.remapping);
 733              		.loc 1 529 3 is_stmt 1 view .LVU198
 529:le_phy.c      **** 		channel_idx = le_map_channel(conn.channel_idx, &conn.remapping);
 734              		.loc 1 529 62 is_stmt 0 view .LVU199
 735 007c 2522     		movs	r2, #37
 529:le_phy.c      **** 		channel_idx = le_map_channel(conn.channel_idx, &conn.remapping);
 736              		.loc 1 529 27 view .LVU200
 737 007e 95F82C00 		ldrb	r0, [r5, #44]	@ zero_extendqisi2
 529:le_phy.c      **** 		channel_idx = le_map_channel(conn.channel_idx, &conn.remapping);
 738              		.loc 1 529 46 view .LVU201
 739 0082 95F82D30 		ldrb	r3, [r5, #45]	@ zero_extendqisi2
 530:le_phy.c      **** 	}
 740              		.loc 1 530 17 view .LVU202
 741 0086 05F14001 		add	r1, r5, #64
 529:le_phy.c      **** 		channel_idx = le_map_channel(conn.channel_idx, &conn.remapping);
 742              		.loc 1 529 40 view .LVU203
ARM GAS  /tmp/ccXJY3ni.s 			page 32


 743 008a 0344     		add	r3, r3, r0
 529:le_phy.c      **** 		channel_idx = le_map_channel(conn.channel_idx, &conn.remapping);
 744              		.loc 1 529 62 view .LVU204
 745 008c B3FBF2F0 		udiv	r0, r3, r2
 746 0090 02FB1030 		mls	r0, r2, r0, r3
 529:le_phy.c      **** 		channel_idx = le_map_channel(conn.channel_idx, &conn.remapping);
 747              		.loc 1 529 20 view .LVU205
 748 0094 C0B2     		uxtb	r0, r0
 749 0096 85F82C00 		strb	r0, [r5, #44]
 530:le_phy.c      **** 	}
 750              		.loc 1 530 3 is_stmt 1 view .LVU206
 530:le_phy.c      **** 	}
 751              		.loc 1 530 17 is_stmt 0 view .LVU207
 752 009a FFF7FEFF 		bl	le_map_channel
 753              	.LVL50:
 530:le_phy.c      **** 	}
 754              		.loc 1 530 17 view .LVU208
 755 009e E3E7     		b	.L43
 756              	.LVL51:
 757              	.L44:
 522:le_phy.c      **** 			case 2402: channel_idx = 37; break;
 758              		.loc 1 522 3 view .LVU209
 759 00a0 2620     		movs	r0, #38
 760 00a2 E1E7     		b	.L43
 761              	.L47:
 762              		.align	2
 763              	.L46:
 764 00a4 24000340 		.word	1073938468
 765 00a8 0C000340 		.word	1073938444
 766 00ac 00000000 		.word	.LANCHOR0
 767 00b0 D6BE898E 		.word	-1903575338
 768 00b4 00000000 		.word	le_adv_channel
 769 00b8 00000000 		.word	rf_channel
 770              		.cfi_endproc
 771              	.LFE21:
 773              		.section	.text.finish_conn_event,"ax",%progbits
 774              		.align	1
 775              		.syntax unified
 776              		.thumb
 777              		.thumb_func
 778              		.fpu softvfp
 780              	finish_conn_event:
 781              	.LFB15:
 229:le_phy.c      **** 	uint32_t last_anchor = 0;
 782              		.loc 1 229 37 is_stmt 1 view -0
 783              		.cfi_startproc
 784              		@ args = 0, pretend = 0, frame = 0
 785              		@ frame_needed = 0, uses_anonymous_args = 0
 786 0000 70B5     		push	{r4, r5, r6, lr}
 787              		.cfi_def_cfa_offset 16
 788              		.cfi_offset 4, -16
 789              		.cfi_offset 5, -12
 790              		.cfi_offset 6, -8
 791              		.cfi_offset 14, -4
 230:le_phy.c      **** 	int last_anchor_set = 0;
 792              		.loc 1 230 2 view .LVU211
 793              	.LVL52:
ARM GAS  /tmp/ccXJY3ni.s 			page 33


 231:le_phy.c      **** 
 794              		.loc 1 231 2 view .LVU212
 234:le_phy.c      **** 		last_anchor = conn_event.anchor;
 795              		.loc 1 234 2 view .LVU213
 234:le_phy.c      **** 		last_anchor = conn_event.anchor;
 796              		.loc 1 234 16 is_stmt 0 view .LVU214
 797 0002 294A     		ldr	r2, .L68
 798 0004 294B     		ldr	r3, .L68+4
 799 0006 5468     		ldr	r4, [r2, #4]
 800 0008 2948     		ldr	r0, .L68+8
 234:le_phy.c      **** 		last_anchor = conn_event.anchor;
 801              		.loc 1 234 5 view .LVU215
 802 000a 022C     		cmp	r4, #2
 803 000c 1ED1     		bne	.L49
 235:le_phy.c      **** 		last_anchor_set = 1;
 804              		.loc 1 235 3 is_stmt 1 view .LVU216
 235:le_phy.c      **** 		last_anchor_set = 1;
 805              		.loc 1 235 15 is_stmt 0 view .LVU217
 806 000e 1568     		ldr	r5, [r2]
 807              	.LVL53:
 236:le_phy.c      **** 	}
 808              		.loc 1 236 3 is_stmt 1 view .LVU218
 253:le_phy.c      **** 		conn.last_anchor = last_anchor;
 809              		.loc 1 253 2 view .LVU219
 810              	.L50:
 254:le_phy.c      **** 		conn.anchor_set = 1;
 811              		.loc 1 254 3 view .LVU220
 255:le_phy.c      **** 	}
 812              		.loc 1 255 19 is_stmt 0 view .LVU221
 813 0010 0121     		movs	r1, #1
 254:le_phy.c      **** 		conn.anchor_set = 1;
 814              		.loc 1 254 20 view .LVU222
 815 0012 C3F80051 		str	r5, [r3, #256]
 255:le_phy.c      **** 	}
 816              		.loc 1 255 3 is_stmt 1 view .LVU223
 255:le_phy.c      **** 	}
 817              		.loc 1 255 19 is_stmt 0 view .LVU224
 818 0016 C3F80411 		str	r1, [r3, #260]
 819              	.L54:
 270:le_phy.c      **** 		conn.last_packet_ts = NOW;
 820              		.loc 1 270 2 is_stmt 1 view .LVU225
 270:le_phy.c      **** 		conn.last_packet_ts = NOW;
 821              		.loc 1 270 5 is_stmt 0 view .LVU226
 822 001a 14B1     		cbz	r4, .L55
 271:le_phy.c      **** 	}
 823              		.loc 1 271 3 is_stmt 1 view .LVU227
 271:le_phy.c      **** 	}
 824              		.loc 1 271 25 is_stmt 0 view .LVU228
 825 001c 0168     		ldr	r1, [r0]
 271:le_phy.c      **** 	}
 826              		.loc 1 271 23 view .LVU229
 827 001e C3F80811 		str	r1, [r3, #264]
 828              	.L55:
 274:le_phy.c      **** 
 829              		.loc 1 274 2 is_stmt 1 view .LVU230
 830              	.LBB42:
 831              	.LBI42:
ARM GAS  /tmp/ccXJY3ni.s 			page 34


 206:le_phy.c      **** 	conn_event.num_packets = 0;
 832              		.loc 1 206 13 view .LVU231
 833              	.LBB43:
 207:le_phy.c      **** 	conn_event.opened = 0;
 834              		.loc 1 207 2 view .LVU232
 207:le_phy.c      **** 	conn_event.opened = 0;
 835              		.loc 1 207 25 is_stmt 0 view .LVU233
 836 0022 0021     		movs	r1, #0
 208:le_phy.c      **** }
 837              		.loc 1 208 20 view .LVU234
 838 0024 C2E90111 		strd	r1, r1, [r2, #4]
 839              	.LBE43:
 840              	.LBE42:
 277:le_phy.c      **** 
 841              		.loc 1 277 2 is_stmt 1 view .LVU235
 842 0028 B3F80C21 		ldrh	r2, [r3, #268]
 843 002c 0132     		adds	r2, r2, #1
 844 002e A3F80C21 		strh	r2, [r3, #268]	@ movhi
 280:le_phy.c      **** 		reset_conn();
 845              		.loc 1 280 2 view .LVU236
 280:le_phy.c      **** 		reset_conn();
 846              		.loc 1 280 6 is_stmt 0 view .LVU237
 847 0032 0268     		ldr	r2, [r0]
 280:le_phy.c      **** 		reset_conn();
 848              		.loc 1 280 10 view .LVU238
 849 0034 D3F80801 		ldr	r0, [r3, #264]
 850 0038 121A     		subs	r2, r2, r0
 280:le_phy.c      **** 		reset_conn();
 851              		.loc 1 280 5 view .LVU239
 852 003a 586B     		ldr	r0, [r3, #52]
 853 003c 8242     		cmp	r2, r0
 854 003e 23D9     		bls	.L56
 855              	.L67:
 288:le_phy.c      **** 		change_channel();
 856              		.loc 1 288 3 is_stmt 1 view .LVU240
 857 0040 FFF7FEFF 		bl	reset_conn
 858              	.LVL54:
 289:le_phy.c      **** 	}
 859              		.loc 1 289 3 view .LVU241
 296:le_phy.c      **** 
 860              		.loc 1 296 1 is_stmt 0 view .LVU242
 861 0044 BDE87040 		pop	{r4, r5, r6, lr}
 862              		.cfi_remember_state
 863              		.cfi_restore 14
 864              		.cfi_restore 6
 865              		.cfi_restore 5
 866              		.cfi_restore 4
 867              		.cfi_def_cfa_offset 0
 289:le_phy.c      **** 	}
 868              		.loc 1 289 3 view .LVU243
 869 0048 FFF7FEBF 		b	change_channel
 870              	.LVL55:
 871              	.L49:
 872              		.cfi_restore_state
 240:le_phy.c      **** 		// calculate the difference between the estimated and observed anchor
 873              		.loc 1 240 7 is_stmt 1 view .LVU244
 240:le_phy.c      **** 		// calculate the difference between the estimated and observed anchor
ARM GAS  /tmp/ccXJY3ni.s 			page 35


 874              		.loc 1 240 10 is_stmt 0 view .LVU245
 875 004c 012C     		cmp	r4, #1
 876 004e D3F80411 		ldr	r1, [r3, #260]
 877 0052 10D1     		bne	.L51
 240:le_phy.c      **** 		// calculate the difference between the estimated and observed anchor
 878              		.loc 1 240 39 discriminator 1 view .LVU246
 879 0054 89B1     		cbz	r1, .L52
 880              	.LBB44:
 242:le_phy.c      **** 		uint32_t delta = estimated_anchor - conn_event.anchor;
 881              		.loc 1 242 12 view .LVU247
 882 0056 D3F80011 		ldr	r1, [r3, #256]
 883 005a 1E6B     		ldr	r6, [r3, #48]
 884 005c 1568     		ldr	r5, [r2]
 242:le_phy.c      **** 		uint32_t delta = estimated_anchor - conn_event.anchor;
 885              		.loc 1 242 3 is_stmt 1 view .LVU248
 886              	.LVL56:
 243:le_phy.c      **** 		// see whether the observed anchor is within 3 us of the estimate
 887              		.loc 1 243 3 view .LVU249
 245:le_phy.c      **** 		if (delta < 2 * ANCHOR_EPSILON) {
 888              		.loc 1 245 3 view .LVU250
 246:le_phy.c      **** 			last_anchor = conn_event.anchor;
 889              		.loc 1 246 3 view .LVU251
 242:le_phy.c      **** 		uint32_t delta = estimated_anchor - conn_event.anchor;
 890              		.loc 1 242 12 is_stmt 0 view .LVU252
 891 005e 3144     		add	r1, r1, r6
 892              	.LVL57:
 245:le_phy.c      **** 		if (delta < 2 * ANCHOR_EPSILON) {
 893              		.loc 1 245 9 view .LVU253
 894 0060 1E31     		adds	r1, r1, #30
 895              	.LVL58:
 245:le_phy.c      **** 		if (delta < 2 * ANCHOR_EPSILON) {
 896              		.loc 1 245 9 view .LVU254
 897 0062 491B     		subs	r1, r1, r5
 898              	.LVL59:
 246:le_phy.c      **** 			last_anchor = conn_event.anchor;
 899              		.loc 1 246 6 view .LVU255
 900 0064 3B29     		cmp	r1, #59
 901 0066 D3D9     		bls	.L50
 902              	.LVL60:
 903              	.L53:
 246:le_phy.c      **** 			last_anchor = conn_event.anchor;
 904              		.loc 1 246 6 view .LVU256
 905              	.LBE44:
 260:le_phy.c      **** 	}
 906              		.loc 1 260 3 is_stmt 1 view .LVU257
 260:le_phy.c      **** 	}
 907              		.loc 1 260 20 is_stmt 0 view .LVU258
 908 0068 D3F80011 		ldr	r1, [r3, #256]
 909 006c 1D6B     		ldr	r5, [r3, #48]
 910 006e 2944     		add	r1, r1, r5
 911 0070 C3F80011 		str	r1, [r3, #256]
 912 0074 D1E7     		b	.L54
 913              	.LVL61:
 914              	.L51:
 259:le_phy.c      **** 		conn.last_anchor += conn.conn_interval;
 915              		.loc 1 259 7 is_stmt 1 view .LVU259
 259:le_phy.c      **** 		conn.last_anchor += conn.conn_interval;
ARM GAS  /tmp/ccXJY3ni.s 			page 36


 916              		.loc 1 259 10 is_stmt 0 view .LVU260
 917 0076 0029     		cmp	r1, #0
 918 0078 F6D1     		bne	.L53
 919              	.L52:
 265:le_phy.c      **** 		conn.last_packet_ts = NOW; // FIXME gross hack
 920              		.loc 1 265 3 is_stmt 1 view .LVU261
 265:le_phy.c      **** 		conn.last_packet_ts = NOW; // FIXME gross hack
 921              		.loc 1 265 20 is_stmt 0 view .LVU262
 922 007a 1168     		ldr	r1, [r2]
 923 007c C3F80011 		str	r1, [r3, #256]
 266:le_phy.c      **** 	}
 924              		.loc 1 266 3 is_stmt 1 view .LVU263
 266:le_phy.c      **** 	}
 925              		.loc 1 266 25 is_stmt 0 view .LVU264
 926 0080 0168     		ldr	r1, [r0]
 266:le_phy.c      **** 	}
 927              		.loc 1 266 23 view .LVU265
 928 0082 C3F80811 		str	r1, [r3, #264]
 929 0086 C8E7     		b	.L54
 930              	.L56:
 286:le_phy.c      **** 		cancel_follow = 0;
 931              		.loc 1 286 7 is_stmt 1 view .LVU266
 286:le_phy.c      **** 		cancel_follow = 0;
 932              		.loc 1 286 11 is_stmt 0 view .LVU267
 933 0088 0A4A     		ldr	r2, .L68+12
 934 008a 1068     		ldr	r0, [r2]
 286:le_phy.c      **** 		cancel_follow = 0;
 935              		.loc 1 286 10 view .LVU268
 936 008c 08B1     		cbz	r0, .L57
 287:le_phy.c      **** 		reset_conn();
 937              		.loc 1 287 3 is_stmt 1 view .LVU269
 287:le_phy.c      **** 		reset_conn();
 938              		.loc 1 287 17 is_stmt 0 view .LVU270
 939 008e 1160     		str	r1, [r2]
 940 0090 D6E7     		b	.L67
 941              	.L57:
 294:le_phy.c      **** 	}
 942              		.loc 1 294 3 is_stmt 1 view .LVU271
 294:le_phy.c      **** 	}
 943              		.loc 1 294 37 is_stmt 0 view .LVU272
 944 0092 D3F80001 		ldr	r0, [r3, #256]
 945 0096 1B6B     		ldr	r3, [r3, #48]
 296:le_phy.c      **** 
 946              		.loc 1 296 1 view .LVU273
 947 0098 BDE87040 		pop	{r4, r5, r6, lr}
 948              		.cfi_restore 14
 949              		.cfi_restore 6
 950              		.cfi_restore 5
 951              		.cfi_restore 4
 952              		.cfi_def_cfa_offset 0
 294:le_phy.c      **** 	}
 953              		.loc 1 294 37 view .LVU274
 954 009c 1844     		add	r0, r0, r3
 294:le_phy.c      **** 	}
 955              		.loc 1 294 3 view .LVU275
 956 009e A0F6B830 		subw	r0, r0, #3000
 957 00a2 FFF7FEBF 		b	timer1_set_match
ARM GAS  /tmp/ccXJY3ni.s 			page 37


 958              	.LVL62:
 959              	.L69:
 960 00a6 00BF     		.align	2
 961              	.L68:
 962 00a8 00000000 		.word	conn_event
 963 00ac 00000000 		.word	.LANCHOR0
 964 00b0 08800040 		.word	1073774600
 965 00b4 00000000 		.word	cancel_follow
 966              		.cfi_endproc
 967              	.LFE15:
 969              		.section	.rodata.str1.1,"aMS",%progbits,1
 970              	.LC0:
 971 0000 6375725F 		.ascii	"cur_bit_pos: byte >= TAPE_LEN: %d\012\000"
 971      6269745F 
 971      706F733A 
 971      20627974 
 971      65203E3D 
 972              		.section	.text.get_next_bit,"ax",%progbits
 973              		.align	1
 974              		.global	get_next_bit
 975              		.syntax unified
 976              		.thumb
 977              		.thumb_func
 978              		.fpu softvfp
 980              	get_next_bit:
 981              	.LFB0:
 982              		.file 2 "fsm.c"
   1:fsm.c         **** #include <stdbool.h>
   2:fsm.c         **** #include "debug_uart.h"
   3:fsm.c         **** 
   4:fsm.c         **** #define INF -1
   5:fsm.c         **** #define NINF -2
   6:fsm.c         **** 
   7:fsm.c         **** typedef enum {
   8:fsm.c         ****     BIT,
   9:fsm.c         ****     BYTE
  10:fsm.c         **** } dataunit;
  11:fsm.c         **** 
  12:fsm.c         **** typedef enum {
  13:fsm.c         ****     LSB,
  14:fsm.c         ****     MSB
  15:fsm.c         **** } endianness;
  16:fsm.c         **** 
  17:fsm.c         **** typedef struct {
  18:fsm.c         ****     int start_byte;
  19:fsm.c         ****     int start_bit;
  20:fsm.c         ****     int end_byte;
  21:fsm.c         ****     int end_bit;
  22:fsm.c         **** } parsed_result;
  23:fsm.c         **** 
  24:fsm.c         **** int cur_byte_pos = 0;
  25:fsm.c         **** int cur_bit_pos = 0;
  26:fsm.c         **** 
  27:fsm.c         **** unsigned char* TAPE;
  28:fsm.c         **** int TAPE_LEN;
  29:fsm.c         **** 
  30:fsm.c         **** /*@ requires TAPE_LEN >= 0;
ARM GAS  /tmp/ccXJY3ni.s 			page 38


  31:fsm.c         ****  *  requires \valid(TAPE+(0..(TAPE_LEN-1)));
  32:fsm.c         ****  *  requires \valid(p.fsm_table+(0..(p.table_length-1)));
  33:fsm.c         ****  *  requires cur_byte_pos < TAPE_LEN;
  34:fsm.c         ****  *  assigns cur_byte_pos, cur_bit_pos;
  35:fsm.c         ****  */
  36:fsm.c         **** bool get_next_bit() {
 983              		.loc 2 36 21 is_stmt 1 view -0
 984              		.cfi_startproc
 985              		@ args = 0, pretend = 0, frame = 0
 986              		@ frame_needed = 0, uses_anonymous_args = 0
 987 0000 08B5     		push	{r3, lr}
 988              		.cfi_def_cfa_offset 8
 989              		.cfi_offset 3, -8
 990              		.cfi_offset 14, -4
  37:fsm.c         ****     bool cur_symbol;
 991              		.loc 2 37 5 view .LVU277
  38:fsm.c         ****     if (cur_byte_pos >= TAPE_LEN) {
 992              		.loc 2 38 5 view .LVU278
 993              		.loc 2 38 22 is_stmt 0 view .LVU279
 994 0002 114A     		ldr	r2, .L74
 995 0004 114B     		ldr	r3, .L74+4
 996 0006 D2F87C16 		ldr	r1, [r2, #1660]
 997              		.loc 2 38 8 view .LVU280
 998 000a 1B68     		ldr	r3, [r3]
 999 000c 9942     		cmp	r1, r3
 1000 000e 04DB     		blt	.L71
  39:fsm.c         ****         debug_printf("cur_bit_pos: byte >= TAPE_LEN: %d\n", cur_byte_pos);
 1001              		.loc 2 39 9 is_stmt 1 view .LVU281
 1002 0010 0F48     		ldr	r0, .L74+8
 1003 0012 FFF7FEFF 		bl	debug_printf
 1004              	.LVL63:
  40:fsm.c         ****         return 0;
 1005              		.loc 2 40 9 view .LVU282
 1006              		.loc 2 40 16 is_stmt 0 view .LVU283
 1007 0016 0020     		movs	r0, #0
 1008              	.L72:
  41:fsm.c         ****     }
  42:fsm.c         ****     char cur_char = TAPE[cur_byte_pos];
  43:fsm.c         ****     cur_symbol = 1 & (cur_char >> cur_bit_pos);
  44:fsm.c         ****     cur_bit_pos++;
  45:fsm.c         ****     if (cur_bit_pos >= 8) {
  46:fsm.c         ****         cur_bit_pos = cur_bit_pos % 8;
  47:fsm.c         ****         cur_byte_pos++;
  48:fsm.c         ****     }
  49:fsm.c         ****     return cur_symbol;
  50:fsm.c         **** }
 1009              		.loc 2 50 1 view .LVU284
 1010 0018 08BD     		pop	{r3, pc}
 1011              	.L71:
  42:fsm.c         ****     cur_symbol = 1 & (cur_char >> cur_bit_pos);
 1012              		.loc 2 42 5 is_stmt 1 view .LVU285
 1013              	.LVL64:
  43:fsm.c         ****     cur_bit_pos++;
 1014              		.loc 2 43 5 view .LVU286
  42:fsm.c         ****     cur_symbol = 1 & (cur_char >> cur_bit_pos);
 1015              		.loc 2 42 10 is_stmt 0 view .LVU287
 1016 001a 0E48     		ldr	r0, .L74+12
ARM GAS  /tmp/ccXJY3ni.s 			page 39


 1017              	.LVL65:
  43:fsm.c         ****     cur_bit_pos++;
 1018              		.loc 2 43 32 view .LVU288
 1019 001c D2F88036 		ldr	r3, [r2, #1664]
  42:fsm.c         ****     cur_symbol = 1 & (cur_char >> cur_bit_pos);
 1020              		.loc 2 42 10 view .LVU289
 1021 0020 0068     		ldr	r0, [r0]
 1022              	.LVL66:
  43:fsm.c         ****     cur_bit_pos++;
 1023              		.loc 2 43 32 view .LVU290
 1024 0022 405C     		ldrb	r0, [r0, r1]	@ zero_extendqisi2
 1025              	.LVL67:
  43:fsm.c         ****     cur_bit_pos++;
 1026              		.loc 2 43 32 view .LVU291
 1027 0024 1841     		asrs	r0, r0, r3
  44:fsm.c         ****     if (cur_bit_pos >= 8) {
 1028              		.loc 2 44 16 view .LVU292
 1029 0026 0133     		adds	r3, r3, #1
  45:fsm.c         ****         cur_bit_pos = cur_bit_pos % 8;
 1030              		.loc 2 45 8 view .LVU293
 1031 0028 072B     		cmp	r3, #7
  46:fsm.c         ****         cur_byte_pos++;
 1032              		.loc 2 46 35 view .LVU294
 1033 002a C4BF     		itt	gt
 1034 002c 03F00703 		andgt	r3, r3, #7
  47:fsm.c         ****     }
 1035              		.loc 2 47 21 view .LVU295
 1036 0030 0131     		addgt	r1, r1, #1
 1037              	.LVL68:
  43:fsm.c         ****     cur_bit_pos++;
 1038              		.loc 2 43 16 view .LVU296
 1039 0032 00F00100 		and	r0, r0, #1
 1040              	.LVL69:
  44:fsm.c         ****     if (cur_bit_pos >= 8) {
 1041              		.loc 2 44 5 is_stmt 1 view .LVU297
  45:fsm.c         ****         cur_bit_pos = cur_bit_pos % 8;
 1042              		.loc 2 45 5 view .LVU298
  44:fsm.c         ****     if (cur_bit_pos >= 8) {
 1043              		.loc 2 44 16 is_stmt 0 view .LVU299
 1044 0036 D2BF     		itee	le
 1045 0038 C2F88036 		strle	r3, [r2, #1664]
 1046              	.LVL70:
  46:fsm.c         ****         cur_byte_pos++;
 1047              		.loc 2 46 9 is_stmt 1 view .LVU300
  46:fsm.c         ****         cur_byte_pos++;
 1048              		.loc 2 46 21 is_stmt 0 view .LVU301
 1049 003c C2F88036 		strgt	r3, [r2, #1664]
  47:fsm.c         ****     }
 1050              		.loc 2 47 9 is_stmt 1 view .LVU302
  47:fsm.c         ****     }
 1051              		.loc 2 47 21 is_stmt 0 view .LVU303
 1052 0040 C2F87C16 		strgt	r1, [r2, #1660]
 1053 0044 E8E7     		b	.L72
 1054              	.L75:
 1055 0046 00BF     		.align	2
 1056              	.L74:
 1057 0048 00000000 		.word	.LANCHOR0
ARM GAS  /tmp/ccXJY3ni.s 			page 40


 1058 004c 00000000 		.word	TAPE_LEN
 1059 0050 00000000 		.word	.LC0
 1060 0054 00000000 		.word	TAPE
 1061              		.cfi_endproc
 1062              	.LFE0:
 1064              		.section	.text.is_tape_available,"ax",%progbits
 1065              		.align	1
 1066              		.global	is_tape_available
 1067              		.syntax unified
 1068              		.thumb
 1069              		.thumb_func
 1070              		.fpu softvfp
 1072              	is_tape_available:
 1073              	.LFB1:
  51:fsm.c         **** 
  52:fsm.c         **** bool is_tape_available() {
 1074              		.loc 2 52 26 is_stmt 1 view -0
 1075              		.cfi_startproc
 1076              		@ args = 0, pretend = 0, frame = 0
 1077              		@ frame_needed = 0, uses_anonymous_args = 0
 1078              		@ link register save eliminated.
  53:fsm.c         ****     if ((cur_byte_pos + 1) < TAPE_LEN) {
 1079              		.loc 2 53 5 view .LVU305
 1080              		.loc 2 53 23 is_stmt 0 view .LVU306
 1081 0000 094A     		ldr	r2, .L80
 1082              		.loc 2 53 28 view .LVU307
 1083 0002 0A49     		ldr	r1, .L80+4
 1084              		.loc 2 53 23 view .LVU308
 1085 0004 D2F87C36 		ldr	r3, [r2, #1660]
 1086              		.loc 2 53 28 view .LVU309
 1087 0008 0968     		ldr	r1, [r1]
 1088              		.loc 2 53 23 view .LVU310
 1089 000a 0133     		adds	r3, r3, #1
 1090              		.loc 2 53 8 view .LVU311
 1091 000c 8B42     		cmp	r3, r1
 1092 000e 07DB     		blt	.L78
  54:fsm.c         ****         // some bytes remaining
  55:fsm.c         ****         return 1;
  56:fsm.c         ****     } else {
  57:fsm.c         ****         if ((cur_byte_pos + 1) == TAPE_LEN) {
 1093              		.loc 2 57 9 is_stmt 1 view .LVU312
 1094              		.loc 2 57 12 is_stmt 0 view .LVU313
 1095 0010 08D1     		bne	.L79
 1096              	.LBB47:
 1097              	.LBI47:
  52:fsm.c         ****     if ((cur_byte_pos + 1) < TAPE_LEN) {
 1098              		.loc 2 52 6 is_stmt 1 view .LVU314
 1099              	.LBB48:
  58:fsm.c         ****             // some bits left
  59:fsm.c         ****             if (cur_bit_pos < 7) {
 1100              		.loc 2 59 13 view .LVU315
 1101              		.loc 2 59 16 is_stmt 0 view .LVU316
 1102 0012 D2F88006 		ldr	r0, [r2, #1664]
 1103 0016 0628     		cmp	r0, #6
 1104 0018 CCBF     		ite	gt
 1105 001a 0020     		movgt	r0, #0
 1106 001c 0120     		movle	r0, #1
ARM GAS  /tmp/ccXJY3ni.s 			page 41


 1107 001e 7047     		bx	lr
 1108              	.L78:
 1109              	.LBE48:
 1110              	.LBE47:
  55:fsm.c         ****     } else {
 1111              		.loc 2 55 16 view .LVU317
 1112 0020 0120     		movs	r0, #1
 1113 0022 7047     		bx	lr
 1114              	.L79:
  60:fsm.c         ****                 return 1;
  61:fsm.c         ****             }
  62:fsm.c         ****         }
  63:fsm.c         ****     }
  64:fsm.c         ****     return 0;
 1115              		.loc 2 64 12 view .LVU318
 1116 0024 0020     		movs	r0, #0
  65:fsm.c         **** }
 1117              		.loc 2 65 1 view .LVU319
 1118 0026 7047     		bx	lr
 1119              	.L81:
 1120              		.align	2
 1121              	.L80:
 1122 0028 00000000 		.word	.LANCHOR0
 1123 002c 00000000 		.word	TAPE_LEN
 1124              		.cfi_endproc
 1125              	.LFE1:
 1127              		.section	.text.set_pos_end,"ax",%progbits
 1128              		.align	1
 1129              		.global	set_pos_end
 1130              		.syntax unified
 1131              		.thumb
 1132              		.thumb_func
 1133              		.fpu softvfp
 1135              	set_pos_end:
 1136              	.LVL71:
 1137              	.LFB2:
  66:fsm.c         **** 
  67:fsm.c         **** void set_pos_end(parsed_result* r)
  68:fsm.c         **** {
 1138              		.loc 2 68 1 is_stmt 1 view -0
 1139              		.cfi_startproc
 1140              		@ args = 0, pretend = 0, frame = 0
 1141              		@ frame_needed = 0, uses_anonymous_args = 0
 1142              		@ link register save eliminated.
 1143              		.loc 2 68 1 is_stmt 0 view .LVU321
  69:fsm.c         ****     r->end_bit  = cur_bit_pos;
 1144              		.loc 2 69 5 is_stmt 1 view .LVU322
 1145              		.loc 2 69 17 is_stmt 0 view .LVU323
 1146 0000 034B     		ldr	r3, .L83
 1147 0002 D3F88026 		ldr	r2, [r3, #1664]
  70:fsm.c         ****     r->end_byte = cur_byte_pos;
 1148              		.loc 2 70 17 view .LVU324
 1149 0006 D3F87C36 		ldr	r3, [r3, #1660]
  69:fsm.c         ****     r->end_bit  = cur_bit_pos;
 1150              		.loc 2 69 17 view .LVU325
 1151 000a C260     		str	r2, [r0, #12]
 1152              		.loc 2 70 5 is_stmt 1 view .LVU326
ARM GAS  /tmp/ccXJY3ni.s 			page 42


 1153              		.loc 2 70 17 is_stmt 0 view .LVU327
 1154 000c 8360     		str	r3, [r0, #8]
  71:fsm.c         ****     return;
 1155              		.loc 2 71 5 is_stmt 1 view .LVU328
  72:fsm.c         **** }
 1156              		.loc 2 72 1 is_stmt 0 view .LVU329
 1157 000e 7047     		bx	lr
 1158              	.L84:
 1159              		.align	2
 1160              	.L83:
 1161 0010 00000000 		.word	.LANCHOR0
 1162              		.cfi_endproc
 1163              	.LFE2:
 1165              		.section	.text.set_pos_start,"ax",%progbits
 1166              		.align	1
 1167              		.global	set_pos_start
 1168              		.syntax unified
 1169              		.thumb
 1170              		.thumb_func
 1171              		.fpu softvfp
 1173              	set_pos_start:
 1174              	.LVL72:
 1175              	.LFB3:
  73:fsm.c         **** 
  74:fsm.c         **** void set_pos_start(parsed_result* r)
  75:fsm.c         **** {
 1176              		.loc 2 75 1 is_stmt 1 view -0
 1177              		.cfi_startproc
 1178              		@ args = 0, pretend = 0, frame = 0
 1179              		@ frame_needed = 0, uses_anonymous_args = 0
 1180              		@ link register save eliminated.
 1181              		.loc 2 75 1 is_stmt 0 view .LVU331
  76:fsm.c         ****     r->start_bit  = cur_bit_pos;
 1182              		.loc 2 76 5 is_stmt 1 view .LVU332
 1183              		.loc 2 76 19 is_stmt 0 view .LVU333
 1184 0000 034B     		ldr	r3, .L86
 1185 0002 D3F88026 		ldr	r2, [r3, #1664]
  77:fsm.c         ****     r->start_byte = cur_byte_pos;
 1186              		.loc 2 77 19 view .LVU334
 1187 0006 D3F87C36 		ldr	r3, [r3, #1660]
  76:fsm.c         ****     r->start_bit  = cur_bit_pos;
 1188              		.loc 2 76 19 view .LVU335
 1189 000a 4260     		str	r2, [r0, #4]
 1190              		.loc 2 77 5 is_stmt 1 view .LVU336
 1191              		.loc 2 77 19 is_stmt 0 view .LVU337
 1192 000c 0360     		str	r3, [r0]
  78:fsm.c         ****     return;
 1193              		.loc 2 78 5 is_stmt 1 view .LVU338
  79:fsm.c         **** }
 1194              		.loc 2 79 1 is_stmt 0 view .LVU339
 1195 000e 7047     		bx	lr
 1196              	.L87:
 1197              		.align	2
 1198              	.L86:
 1199 0010 00000000 		.word	.LANCHOR0
 1200              		.cfi_endproc
 1201              	.LFE3:
ARM GAS  /tmp/ccXJY3ni.s 			page 43


 1203              		.section	.rodata.str1.1
 1204              	.LC1:
 1205 0023 6375725F 		.ascii	"cur_byte_pos: >= TAPE_LEN: %d \012\000"
 1205      62797465 
 1205      5F706F73 
 1205      3A203E3D 
 1205      20544150 
 1206              		.section	.text.get_next_byte,"ax",%progbits
 1207              		.align	1
 1208              		.global	get_next_byte
 1209              		.syntax unified
 1210              		.thumb
 1211              		.thumb_func
 1212              		.fpu softvfp
 1214              	get_next_byte:
 1215              	.LFB4:
  80:fsm.c         **** 
  81:fsm.c         **** /*@ requires TAPE_LEN >= 0
  82:fsm.c         **** */
  83:fsm.c         **** unsigned char get_next_byte() {
 1216              		.loc 2 83 31 is_stmt 1 view -0
 1217              		.cfi_startproc
 1218              		@ args = 0, pretend = 0, frame = 0
 1219              		@ frame_needed = 0, uses_anonymous_args = 0
 1220 0000 08B5     		push	{r3, lr}
 1221              		.cfi_def_cfa_offset 8
 1222              		.cfi_offset 3, -8
 1223              		.cfi_offset 14, -4
  84:fsm.c         ****     if (cur_byte_pos >= TAPE_LEN) {
 1224              		.loc 2 84 5 view .LVU341
 1225              		.loc 2 84 22 is_stmt 0 view .LVU342
 1226 0002 094B     		ldr	r3, .L91
 1227 0004 094A     		ldr	r2, .L91+4
 1228 0006 D3F87C16 		ldr	r1, [r3, #1660]
 1229              		.loc 2 84 8 view .LVU343
 1230 000a 1268     		ldr	r2, [r2]
 1231 000c 9142     		cmp	r1, r2
 1232 000e 04DB     		blt	.L89
  85:fsm.c         ****         debug_printf("cur_byte_pos: >= TAPE_LEN: %d \n", cur_byte_pos);
 1233              		.loc 2 85 9 is_stmt 1 view .LVU344
 1234 0010 0748     		ldr	r0, .L91+8
 1235 0012 FFF7FEFF 		bl	debug_printf
 1236              	.LVL73:
  86:fsm.c         ****         return 0;
 1237              		.loc 2 86 9 view .LVU345
 1238              		.loc 2 86 16 is_stmt 0 view .LVU346
 1239 0016 0020     		movs	r0, #0
 1240              	.L90:
  87:fsm.c         ****     }
  88:fsm.c         **** 
  89:fsm.c         ****     bool cur_symbol;
  90:fsm.c         ****     char cur_char = TAPE[cur_byte_pos];
  91:fsm.c         ****     // printf("Read %d from tape at loc %d\n", cur_char, cur_byte_pos);
  92:fsm.c         ****     cur_byte_pos++;
  93:fsm.c         ****     return cur_char;
  94:fsm.c         **** }
 1241              		.loc 2 94 1 view .LVU347
ARM GAS  /tmp/ccXJY3ni.s 			page 44


 1242 0018 08BD     		pop	{r3, pc}
 1243              	.L89:
  89:fsm.c         ****     char cur_char = TAPE[cur_byte_pos];
 1244              		.loc 2 89 5 is_stmt 1 view .LVU348
  90:fsm.c         ****     // printf("Read %d from tape at loc %d\n", cur_char, cur_byte_pos);
 1245              		.loc 2 90 5 view .LVU349
  90:fsm.c         ****     // printf("Read %d from tape at loc %d\n", cur_char, cur_byte_pos);
 1246              		.loc 2 90 10 is_stmt 0 view .LVU350
 1247 001a 064A     		ldr	r2, .L91+12
 1248 001c 1268     		ldr	r2, [r2]
 1249 001e 505C     		ldrb	r0, [r2, r1]	@ zero_extendqisi2
 1250              	.LVL74:
  92:fsm.c         ****     return cur_char;
 1251              		.loc 2 92 5 is_stmt 1 view .LVU351
  92:fsm.c         ****     return cur_char;
 1252              		.loc 2 92 17 is_stmt 0 view .LVU352
 1253 0020 0131     		adds	r1, r1, #1
 1254 0022 C3F87C16 		str	r1, [r3, #1660]
  93:fsm.c         **** }
 1255              		.loc 2 93 5 is_stmt 1 view .LVU353
  93:fsm.c         **** }
 1256              		.loc 2 93 12 is_stmt 0 view .LVU354
 1257 0026 F7E7     		b	.L90
 1258              	.L92:
 1259              		.align	2
 1260              	.L91:
 1261 0028 00000000 		.word	.LANCHOR0
 1262 002c 00000000 		.word	TAPE_LEN
 1263 0030 23000000 		.word	.LC1
 1264 0034 00000000 		.word	TAPE
 1265              		.cfi_endproc
 1266              	.LFE4:
 1268              		.section	.rodata.str1.1
 1269              	.LC2:
 1270 0043 73697A65 		.ascii	"size error in tag_cons\012\000"
 1270      20657272 
 1270      6F722069 
 1270      6E207461 
 1270      675F636F 
 1271              	.LC3:
 1272 005b 7C207461 		.ascii	"| tagval: %d \012\000"
 1272      6776616C 
 1272      3A202564 
 1272      200A00
 1273              		.section	.text.tag_cons,"ax",%progbits
 1274              		.align	1
 1275              		.global	tag_cons
 1276              		.syntax unified
 1277              		.thumb
 1278              		.thumb_func
 1279              		.fpu softvfp
 1281              	tag_cons:
 1282              	.LVL75:
 1283              	.LFB5:
  95:fsm.c         **** 
  96:fsm.c         **** // set the value of the register to T
  97:fsm.c         **** int tag_cons(dataunit unit, int size) {
ARM GAS  /tmp/ccXJY3ni.s 			page 45


 1284              		.loc 2 97 39 is_stmt 1 view -0
 1285              		.cfi_startproc
 1286              		@ args = 0, pretend = 0, frame = 0
 1287              		@ frame_needed = 0, uses_anonymous_args = 0
 1288              		.loc 2 97 39 is_stmt 0 view .LVU356
 1289 0000 70B5     		push	{r4, r5, r6, lr}
 1290              		.cfi_def_cfa_offset 16
 1291              		.cfi_offset 4, -16
 1292              		.cfi_offset 5, -12
 1293              		.cfi_offset 6, -8
 1294              		.cfi_offset 14, -4
  98:fsm.c         ****     unsigned int tag_val = 0;
 1295              		.loc 2 98 5 is_stmt 1 view .LVU357
 1296              	.LVL76:
  99:fsm.c         **** 
 100:fsm.c         ****     if (unit == BIT) {
 1297              		.loc 2 100 5 view .LVU358
  97:fsm.c         ****     unsigned int tag_val = 0;
 1298              		.loc 2 97 39 is_stmt 0 view .LVU359
 1299 0002 0E46     		mov	r6, r1
 1300              		.loc 2 100 8 view .LVU360
 1301 0004 0546     		mov	r5, r0
 1302 0006 D0B1     		cbz	r0, .L101
 101:fsm.c         ****         for (int i = 0; i < size; ++i) {
 102:fsm.c         ****             tag_val = tag_val | get_next_bit();
 103:fsm.c         ****             tag_val = tag_val << 1;
 104:fsm.c         ****         }
 105:fsm.c         ****     } else {
 106:fsm.c         ****         if (!(size <= 4)) { debug_write("size error in tag_cons\n");}
 1303              		.loc 2 106 9 is_stmt 1 view .LVU361
 1304              		.loc 2 106 12 is_stmt 0 view .LVU362
 1305 0008 0429     		cmp	r1, #4
 1306 000a 02DD     		ble	.L98
 1307              		.loc 2 106 29 is_stmt 1 discriminator 1 view .LVU363
 1308 000c 0D48     		ldr	r0, .L103
 1309              	.LVL77:
 1310              		.loc 2 106 29 is_stmt 0 discriminator 1 view .LVU364
 1311 000e FFF7FEFF 		bl	debug_write
 1312              	.LVL78:
 1313              	.L98:
  98:fsm.c         **** 
 1314              		.loc 2 98 18 discriminator 1 view .LVU365
 1315 0012 0025     		movs	r5, #0
 1316 0014 2C46     		mov	r4, r5
 1317              	.LVL79:
 1318              	.L99:
 1319              	.LBB49:
 107:fsm.c         ****         for (int i = 0; i < size; ++i) {
 1320              		.loc 2 107 25 is_stmt 1 discriminator 1 view .LVU366
 1321              		.loc 2 107 9 is_stmt 0 discriminator 1 view .LVU367
 1322 0016 B542     		cmp	r5, r6
 1323 0018 0BDA     		bge	.L97
 108:fsm.c         ****             tag_val = get_next_byte();
 1324              		.loc 2 108 13 is_stmt 1 discriminator 3 view .LVU368
 1325              		.loc 2 108 23 is_stmt 0 discriminator 3 view .LVU369
 1326 001a FFF7FEFF 		bl	get_next_byte
 1327              	.LVL80:
ARM GAS  /tmp/ccXJY3ni.s 			page 46


 109:fsm.c         ****             tag_val = tag_val << 8;
 1328              		.loc 2 109 13 is_stmt 1 discriminator 3 view .LVU370
 107:fsm.c         ****         for (int i = 0; i < size; ++i) {
 1329              		.loc 2 107 35 is_stmt 0 discriminator 3 view .LVU371
 1330 001e 0135     		adds	r5, r5, #1
 1331              	.LVL81:
 1332              		.loc 2 109 21 discriminator 3 view .LVU372
 1333 0020 0402     		lsls	r4, r0, #8
 1334              	.LVL82:
 107:fsm.c         ****         for (int i = 0; i < size; ++i) {
 1335              		.loc 2 107 35 is_stmt 1 discriminator 3 view .LVU373
 107:fsm.c         ****         for (int i = 0; i < size; ++i) {
 1336              		.loc 2 107 35 is_stmt 0 discriminator 3 view .LVU374
 1337 0022 F8E7     		b	.L99
 1338              	.LVL83:
 1339              	.L96:
 107:fsm.c         ****         for (int i = 0; i < size; ++i) {
 1340              		.loc 2 107 35 discriminator 3 view .LVU375
 1341              	.LBE49:
 1342              	.LBB50:
 102:fsm.c         ****             tag_val = tag_val << 1;
 1343              		.loc 2 102 13 is_stmt 1 discriminator 3 view .LVU376
 102:fsm.c         ****             tag_val = tag_val << 1;
 1344              		.loc 2 102 33 is_stmt 0 discriminator 3 view .LVU377
 1345 0024 FFF7FEFF 		bl	get_next_bit
 1346              	.LVL84:
 102:fsm.c         ****             tag_val = tag_val << 1;
 1347              		.loc 2 102 21 discriminator 3 view .LVU378
 1348 0028 0443     		orrs	r4, r4, r0
 1349              	.LVL85:
 103:fsm.c         ****         }
 1350              		.loc 2 103 13 is_stmt 1 discriminator 3 view .LVU379
 103:fsm.c         ****         }
 1351              		.loc 2 103 21 is_stmt 0 discriminator 3 view .LVU380
 1352 002a 6400     		lsls	r4, r4, #1
 1353              	.LVL86:
 101:fsm.c         ****             tag_val = tag_val | get_next_bit();
 1354              		.loc 2 101 35 is_stmt 1 discriminator 3 view .LVU381
 1355 002c 0135     		adds	r5, r5, #1
 1356              	.LVL87:
 1357              	.L94:
 101:fsm.c         ****             tag_val = tag_val | get_next_bit();
 1358              		.loc 2 101 25 discriminator 1 view .LVU382
 101:fsm.c         ****             tag_val = tag_val | get_next_bit();
 1359              		.loc 2 101 9 is_stmt 0 discriminator 1 view .LVU383
 1360 002e B542     		cmp	r5, r6
 1361 0030 F8DB     		blt	.L96
 1362              	.LVL88:
 1363              	.L97:
 101:fsm.c         ****             tag_val = tag_val | get_next_bit();
 1364              		.loc 2 101 9 discriminator 1 view .LVU384
 1365              	.LBE50:
 110:fsm.c         ****         }
 111:fsm.c         ****     }
 112:fsm.c         ****     debug_printf("| tagval: %d \n", tag_val);
 1366              		.loc 2 112 5 is_stmt 1 view .LVU385
 1367 0032 2146     		mov	r1, r4
ARM GAS  /tmp/ccXJY3ni.s 			page 47


 1368 0034 0448     		ldr	r0, .L103+4
 1369 0036 FFF7FEFF 		bl	debug_printf
 1370              	.LVL89:
 113:fsm.c         ****     return tag_val;
 1371              		.loc 2 113 5 view .LVU386
 114:fsm.c         **** };
 1372              		.loc 2 114 1 is_stmt 0 view .LVU387
 1373 003a 2046     		mov	r0, r4
 1374 003c 70BD     		pop	{r4, r5, r6, pc}
 1375              	.LVL90:
 1376              	.L101:
  98:fsm.c         **** 
 1377              		.loc 2 98 18 view .LVU388
 1378 003e 0446     		mov	r4, r0
 1379 0040 F5E7     		b	.L94
 1380              	.L104:
 1381 0042 00BF     		.align	2
 1382              	.L103:
 1383 0044 43000000 		.word	.LC2
 1384 0048 5B000000 		.word	.LC3
 1385              		.cfi_endproc
 1386              	.LFE5:
 1388              		.section	.text.len_cons,"ax",%progbits
 1389              		.align	1
 1390              		.global	len_cons
 1391              		.syntax unified
 1392              		.thumb
 1393              		.thumb_func
 1394              		.fpu softvfp
 1396              	len_cons:
 1397              	.LVL91:
 1398              	.LFB6:
 115:fsm.c         **** 
 116:fsm.c         **** // set the value of the counter register to L.
 117:fsm.c         **** int len_cons(dataunit unit, endianness e, int size) {
 1399              		.loc 2 117 53 is_stmt 1 view -0
 1400              		.cfi_startproc
 1401              		@ args = 0, pretend = 0, frame = 0
 1402              		@ frame_needed = 0, uses_anonymous_args = 0
 1403              		.loc 2 117 53 is_stmt 0 view .LVU390
 1404 0000 70B5     		push	{r4, r5, r6, lr}
 1405              		.cfi_def_cfa_offset 16
 1406              		.cfi_offset 4, -16
 1407              		.cfi_offset 5, -12
 1408              		.cfi_offset 6, -8
 1409              		.cfi_offset 14, -4
 118:fsm.c         ****     int len_val = 0;
 1410              		.loc 2 118 5 is_stmt 1 view .LVU391
 1411              	.LVL92:
 119:fsm.c         ****     if (unit == BIT) {
 1412              		.loc 2 119 5 view .LVU392
 117:fsm.c         ****     int len_val = 0;
 1413              		.loc 2 117 53 is_stmt 0 view .LVU393
 1414 0002 1646     		mov	r6, r2
 1415              		.loc 2 119 8 view .LVU394
 1416 0004 0546     		mov	r5, r0
 1417 0006 B0B1     		cbz	r0, .L113
ARM GAS  /tmp/ccXJY3ni.s 			page 48


 1418              	.LVL93:
 1419              	.LBB56:
 1420              	.LBI56:
 117:fsm.c         ****     int len_val = 0;
 1421              		.loc 2 117 5 is_stmt 1 view .LVU395
 1422              	.LBB57:
 1423              	.LBB58:
 120:fsm.c         ****         int i = 0;
 121:fsm.c         ****         for (i = 0; i < size; ++i) {
 122:fsm.c         ****             len_val = len_val | get_next_bit();
 123:fsm.c         ****             len_val = len_val << 1;
 124:fsm.c         ****         }
 125:fsm.c         ****     } else {
 126:fsm.c         ****         int i = 0;
 1424              		.loc 2 126 9 view .LVU396
 127:fsm.c         ****         if (!(size <= 4)) { debug_write("size error in tag_cons\n");}
 1425              		.loc 2 127 9 view .LVU397
 1426              		.loc 2 127 12 is_stmt 0 view .LVU398
 1427 0008 042A     		cmp	r2, #4
 1428 000a 02DD     		ble	.L110
 1429              		.loc 2 127 29 is_stmt 1 view .LVU399
 1430 000c 0B48     		ldr	r0, .L115
 1431              	.LVL94:
 1432              		.loc 2 127 29 is_stmt 0 view .LVU400
 1433 000e FFF7FEFF 		bl	debug_write
 1434              	.LVL95:
 1435              	.L110:
 1436              		.loc 2 127 29 view .LVU401
 1437              	.LBE58:
 1438              	.LBE57:
 1439              	.LBE56:
 118:fsm.c         ****     if (unit == BIT) {
 1440              		.loc 2 118 9 view .LVU402
 1441 0012 0025     		movs	r5, #0
 1442              	.LVL96:
 118:fsm.c         ****     if (unit == BIT) {
 1443              		.loc 2 118 9 view .LVU403
 1444 0014 2C46     		mov	r4, r5
 1445              	.LVL97:
 1446              	.L111:
 1447              	.LBB61:
 1448              	.LBB60:
 1449              	.LBB59:
 128:fsm.c         ****         for (i = 0; i < size; ++i) {
 1450              		.loc 2 128 21 is_stmt 1 view .LVU404
 1451              		.loc 2 128 9 is_stmt 0 view .LVU405
 1452 0016 AE42     		cmp	r6, r5
 1453 0018 0BDD     		ble	.L105
 129:fsm.c         ****             len_val = get_next_byte();
 1454              		.loc 2 129 13 is_stmt 1 view .LVU406
 1455              		.loc 2 129 23 is_stmt 0 view .LVU407
 1456 001a FFF7FEFF 		bl	get_next_byte
 1457              	.LVL98:
 130:fsm.c         ****             len_val = len_val << 8;
 1458              		.loc 2 130 13 is_stmt 1 view .LVU408
 128:fsm.c         ****         for (i = 0; i < size; ++i) {
 1459              		.loc 2 128 31 is_stmt 0 view .LVU409
ARM GAS  /tmp/ccXJY3ni.s 			page 49


 1460 001e 0135     		adds	r5, r5, #1
 1461              	.LVL99:
 1462              		.loc 2 130 21 view .LVU410
 1463 0020 0402     		lsls	r4, r0, #8
 1464              	.LVL100:
 128:fsm.c         ****         for (i = 0; i < size; ++i) {
 1465              		.loc 2 128 31 is_stmt 1 view .LVU411
 128:fsm.c         ****         for (i = 0; i < size; ++i) {
 1466              		.loc 2 128 31 is_stmt 0 view .LVU412
 1467 0022 F8E7     		b	.L111
 1468              	.LVL101:
 1469              	.L108:
 128:fsm.c         ****         for (i = 0; i < size; ++i) {
 1470              		.loc 2 128 31 view .LVU413
 1471              	.LBE59:
 1472              	.LBE60:
 1473              	.LBE61:
 1474              	.LBB62:
 122:fsm.c         ****             len_val = len_val << 1;
 1475              		.loc 2 122 13 is_stmt 1 discriminator 3 view .LVU414
 122:fsm.c         ****             len_val = len_val << 1;
 1476              		.loc 2 122 33 is_stmt 0 discriminator 3 view .LVU415
 1477 0024 FFF7FEFF 		bl	get_next_bit
 1478              	.LVL102:
 122:fsm.c         ****             len_val = len_val << 1;
 1479              		.loc 2 122 21 discriminator 3 view .LVU416
 1480 0028 0443     		orrs	r4, r4, r0
 1481              	.LVL103:
 123:fsm.c         ****         }
 1482              		.loc 2 123 13 is_stmt 1 discriminator 3 view .LVU417
 123:fsm.c         ****         }
 1483              		.loc 2 123 21 is_stmt 0 discriminator 3 view .LVU418
 1484 002a 6400     		lsls	r4, r4, #1
 1485              	.LVL104:
 121:fsm.c         ****             len_val = len_val | get_next_bit();
 1486              		.loc 2 121 31 is_stmt 1 discriminator 3 view .LVU419
 1487 002c 0135     		adds	r5, r5, #1
 1488              	.LVL105:
 1489              	.L106:
 121:fsm.c         ****             len_val = len_val | get_next_bit();
 1490              		.loc 2 121 21 discriminator 1 view .LVU420
 121:fsm.c         ****             len_val = len_val | get_next_bit();
 1491              		.loc 2 121 9 is_stmt 0 discriminator 1 view .LVU421
 1492 002e B542     		cmp	r5, r6
 1493 0030 F8DB     		blt	.L108
 1494              	.LVL106:
 1495              	.L105:
 121:fsm.c         ****             len_val = len_val | get_next_bit();
 1496              		.loc 2 121 9 discriminator 1 view .LVU422
 1497              	.LBE62:
 131:fsm.c         ****         }
 132:fsm.c         ****     }
 133:fsm.c         ****     // TODO: verify by lookahead
 134:fsm.c         **** 
 135:fsm.c         ****     // return read value
 136:fsm.c         ****     return len_val;
 137:fsm.c         **** };
ARM GAS  /tmp/ccXJY3ni.s 			page 50


 1498              		.loc 2 137 1 view .LVU423
 1499 0032 2046     		mov	r0, r4
 1500 0034 70BD     		pop	{r4, r5, r6, pc}
 1501              	.LVL107:
 1502              	.L113:
 118:fsm.c         ****     if (unit == BIT) {
 1503              		.loc 2 118 9 view .LVU424
 1504 0036 0446     		mov	r4, r0
 1505 0038 F9E7     		b	.L106
 1506              	.L116:
 1507 003a 00BF     		.align	2
 1508              	.L115:
 1509 003c 43000000 		.word	.LC2
 1510              		.cfi_endproc
 1511              	.LFE6:
 1513              		.section	.rodata.str1.1
 1514              	.LC4:
 1515 006a 72657065 		.ascii	"repeat_cons: start\012\000"
 1515      61745F63 
 1515      6F6E733A 
 1515      20737461 
 1515      72740A00 
 1516              	.LC5:
 1517 007e 6572726F 		.ascii	"error in  repeat_cons\000"
 1517      7220696E 
 1517      20207265 
 1517      70656174 
 1517      5F636F6E 
 1518              		.section	.text.repeat_cons,"ax",%progbits
 1519              		.align	1
 1520              		.global	repeat_cons
 1521              		.syntax unified
 1522              		.thumb
 1523              		.thumb_func
 1524              		.fpu softvfp
 1526              	repeat_cons:
 1527              	.LVL108:
 1528              	.LFB7:
 138:fsm.c         **** 
 139:fsm.c         **** // make lookup table and call that function.
 140:fsm.c         **** // case function: generate this with code
 141:fsm.c         **** 
 142:fsm.c         **** // repeats construct r, n times
 143:fsm.c         **** parsed_result repeat_cons(dataunit u, int n, int min, int max) {
 1529              		.loc 2 143 64 is_stmt 1 view -0
 1530              		.cfi_startproc
 1531              		@ args = 4, pretend = 0, frame = 16
 1532              		@ frame_needed = 0, uses_anonymous_args = 0
 1533              		.loc 2 143 64 is_stmt 0 view .LVU426
 1534 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 1535              		.cfi_def_cfa_offset 28
 1536              		.cfi_offset 4, -28
 1537              		.cfi_offset 5, -24
 1538              		.cfi_offset 6, -20
 1539              		.cfi_offset 7, -16
 1540              		.cfi_offset 8, -12
 1541              		.cfi_offset 9, -8
ARM GAS  /tmp/ccXJY3ni.s 			page 51


 1542              		.cfi_offset 14, -4
 1543 0004 85B0     		sub	sp, sp, #20
 1544              		.cfi_def_cfa_offset 48
 144:fsm.c         ****     debug_write("repeat_cons: start\n");
 1545              		.loc 2 144 5 is_stmt 1 view .LVU427
 145:fsm.c         ****     parsed_result r;
 146:fsm.c         ****     set_pos_start(&r);
 1546              		.loc 2 146 5 is_stmt 0 view .LVU428
 1547 0006 6F46     		mov	r7, sp
 143:fsm.c         ****     debug_write("repeat_cons: start\n");
 1548              		.loc 2 143 64 view .LVU429
 1549 0008 9146     		mov	r9, r2
 1550 000a 0646     		mov	r6, r0
 144:fsm.c         ****     debug_write("repeat_cons: start\n");
 1551              		.loc 2 144 5 view .LVU430
 1552 000c 2848     		ldr	r0, .L138
 1553              	.LVL109:
 143:fsm.c         ****     debug_write("repeat_cons: start\n");
 1554              		.loc 2 143 64 view .LVU431
 1555 000e 0D46     		mov	r5, r1
 1556 0010 1C46     		mov	r4, r3
 1557 0012 DDF83080 		ldr	r8, [sp, #48]
 144:fsm.c         ****     debug_write("repeat_cons: start\n");
 1558              		.loc 2 144 5 view .LVU432
 1559 0016 FFF7FEFF 		bl	debug_write
 1560              	.LVL110:
 145:fsm.c         ****     parsed_result r;
 1561              		.loc 2 145 5 is_stmt 1 view .LVU433
 1562              		.loc 2 146 5 view .LVU434
 1563 001a 3846     		mov	r0, r7
 1564 001c FFF7FEFF 		bl	set_pos_start
 1565              	.LVL111:
 147:fsm.c         ****     if (n == INF) {
 1566              		.loc 2 147 5 view .LVU435
 1567              		.loc 2 147 8 is_stmt 0 view .LVU436
 1568 0020 B9F1FF3F 		cmp	r9, #-1
 1569 0024 2ED1     		bne	.L118
 148:fsm.c         ****         // at least min items and at most max items
 149:fsm.c         ****         if (u == BIT) {
 1570              		.loc 2 149 9 is_stmt 1 view .LVU437
 1571              		.loc 2 149 12 is_stmt 0 view .LVU438
 1572 0026 85B1     		cbz	r5, .L119
 1573              	.LBB63:
 150:fsm.c         ****             int i = 0;
 151:fsm.c         ****             for (i = 0; i < min; ++i) {
 152:fsm.c         ****                 get_next_bit();
 153:fsm.c         ****             }
 154:fsm.c         ****             while (i <= max) {
 155:fsm.c         ****                 if (is_tape_available()) {
 156:fsm.c         ****                     break;
 157:fsm.c         ****                 }
 158:fsm.c         ****                 get_next_bit();
 159:fsm.c         ****                 i++;
 160:fsm.c         ****             }
 161:fsm.c         **** 
 162:fsm.c         ****             set_pos_end(&r);
 163:fsm.c         ****             return r;
ARM GAS  /tmp/ccXJY3ni.s 			page 52


 164:fsm.c         ****         } else {
 165:fsm.c         ****             int i = 0;
 166:fsm.c         ****             for (i = 0; i < min; ++i) {
 1574              		.loc 2 166 20 view .LVU439
 1575 0028 0025     		movs	r5, #0
 1576              	.L120:
 1577              	.LVL112:
 1578              		.loc 2 166 25 is_stmt 1 discriminator 1 view .LVU440
 1579              		.loc 2 166 13 is_stmt 0 discriminator 1 view .LVU441
 1580 002a A542     		cmp	r5, r4
 1581 002c 26DB     		blt	.L127
 1582 002e 24EAE474 		bic	r4, r4, r4, asr #31
 1583              	.LVL113:
 1584              	.L128:
 167:fsm.c         ****                 get_next_byte();
 168:fsm.c         ****             }
 169:fsm.c         **** 
 170:fsm.c         ****             while (i <= max) {
 1585              		.loc 2 170 19 is_stmt 1 view .LVU442
 1586 0032 4445     		cmp	r4, r8
 1587 0034 0FDC     		bgt	.L124
 171:fsm.c         ****                 if (is_tape_available()) {
 1588              		.loc 2 171 17 view .LVU443
 1589              		.loc 2 171 21 is_stmt 0 view .LVU444
 1590 0036 FFF7FEFF 		bl	is_tape_available
 1591              	.LVL114:
 1592              		.loc 2 171 20 view .LVU445
 1593 003a 60B9     		cbnz	r0, .L124
 172:fsm.c         ****                     break;
 173:fsm.c         ****                 }
 174:fsm.c         ****                 get_next_byte();
 1594              		.loc 2 174 17 is_stmt 1 view .LVU446
 1595 003c FFF7FEFF 		bl	get_next_byte
 1596              	.LVL115:
 175:fsm.c         ****                 i++;
 1597              		.loc 2 175 17 view .LVU447
 1598              		.loc 2 175 18 is_stmt 0 view .LVU448
 1599 0040 0134     		adds	r4, r4, #1
 1600              	.LVL116:
 1601              		.loc 2 175 18 view .LVU449
 1602 0042 F6E7     		b	.L128
 1603              	.LVL117:
 1604              	.L121:
 1605              		.loc 2 175 18 view .LVU450
 1606              	.LBE63:
 1607              	.LBB64:
 152:fsm.c         ****             }
 1608              		.loc 2 152 17 is_stmt 1 discriminator 3 view .LVU451
 1609 0044 FFF7FEFF 		bl	get_next_bit
 1610              	.LVL118:
 151:fsm.c         ****                 get_next_bit();
 1611              		.loc 2 151 34 discriminator 3 view .LVU452
 1612 0048 0135     		adds	r5, r5, #1
 1613              	.LVL119:
 1614              	.L119:
 151:fsm.c         ****                 get_next_bit();
 1615              		.loc 2 151 25 discriminator 1 view .LVU453
ARM GAS  /tmp/ccXJY3ni.s 			page 53


 151:fsm.c         ****                 get_next_bit();
 1616              		.loc 2 151 13 is_stmt 0 discriminator 1 view .LVU454
 1617 004a A542     		cmp	r5, r4
 1618 004c FADB     		blt	.L121
 1619 004e 24EAE474 		bic	r4, r4, r4, asr #31
 1620              	.LVL120:
 1621              	.L122:
 154:fsm.c         ****                 if (is_tape_available()) {
 1622              		.loc 2 154 19 is_stmt 1 view .LVU455
 1623 0052 4445     		cmp	r4, r8
 1624 0054 0ADD     		ble	.L125
 1625              	.LVL121:
 1626              	.L124:
 162:fsm.c         ****             return r;
 1627              		.loc 2 162 13 view .LVU456
 1628 0056 3846     		mov	r0, r7
 1629 0058 FFF7FEFF 		bl	set_pos_end
 1630              	.LVL122:
 163:fsm.c         ****         } else {
 1631              		.loc 2 163 13 view .LVU457
 163:fsm.c         ****         } else {
 1632              		.loc 2 163 20 is_stmt 0 view .LVU458
 1633 005c 97E80F00 		ldm	r7, {r0, r1, r2, r3}
 1634 0060 86E80F00 		stm	r6, {r0, r1, r2, r3}
 1635              	.LBE64:
 176:fsm.c         ****             }
 177:fsm.c         **** 
 178:fsm.c         ****             set_pos_end(&r);
 179:fsm.c         ****             return r;
 180:fsm.c         ****         }
 181:fsm.c         ****     } else {
 182:fsm.c         ****         if (u == BIT) {
 183:fsm.c         ****             if (!(n <= 8)) {
 184:fsm.c         ****                 debug_write("error in  repeat_cons");
 185:fsm.c         ****             }
 186:fsm.c         ****             for (int i = 0; i < n; ++i) {
 187:fsm.c         ****                 get_next_bit();
 188:fsm.c         ****             }
 189:fsm.c         ****             set_pos_end(&r);
 190:fsm.c         ****             return r;
 191:fsm.c         ****         } else {
 192:fsm.c         ****             for (int i = 0; i < n; ++i) {
 193:fsm.c         ****                 get_next_byte();
 194:fsm.c         ****             }
 195:fsm.c         ****             set_pos_end(&r);
 196:fsm.c         ****             return r;
 197:fsm.c         ****         }
 198:fsm.c         ****     }
 199:fsm.c         **** };
 1636              		.loc 2 199 1 view .LVU459
 1637 0064 3046     		mov	r0, r6
 1638 0066 05B0     		add	sp, sp, #20
 1639              		.cfi_remember_state
 1640              		.cfi_def_cfa_offset 28
 1641              		@ sp needed
 1642 0068 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 1643              	.LVL123:
ARM GAS  /tmp/ccXJY3ni.s 			page 54


 1644              	.L125:
 1645              		.cfi_restore_state
 1646              	.LBB65:
 155:fsm.c         ****                     break;
 1647              		.loc 2 155 17 is_stmt 1 view .LVU460
 155:fsm.c         ****                     break;
 1648              		.loc 2 155 21 is_stmt 0 view .LVU461
 1649 006c FFF7FEFF 		bl	is_tape_available
 1650              	.LVL124:
 155:fsm.c         ****                     break;
 1651              		.loc 2 155 20 view .LVU462
 1652 0070 0028     		cmp	r0, #0
 1653 0072 F0D1     		bne	.L124
 158:fsm.c         ****                 i++;
 1654              		.loc 2 158 17 is_stmt 1 view .LVU463
 1655 0074 FFF7FEFF 		bl	get_next_bit
 1656              	.LVL125:
 159:fsm.c         ****             }
 1657              		.loc 2 159 17 view .LVU464
 159:fsm.c         ****             }
 1658              		.loc 2 159 18 is_stmt 0 view .LVU465
 1659 0078 0134     		adds	r4, r4, #1
 1660              	.LVL126:
 159:fsm.c         ****             }
 1661              		.loc 2 159 18 view .LVU466
 1662 007a EAE7     		b	.L122
 1663              	.LVL127:
 1664              	.L127:
 159:fsm.c         ****             }
 1665              		.loc 2 159 18 view .LVU467
 1666              	.LBE65:
 1667              	.LBB66:
 167:fsm.c         ****             }
 1668              		.loc 2 167 17 is_stmt 1 discriminator 3 view .LVU468
 1669 007c FFF7FEFF 		bl	get_next_byte
 1670              	.LVL128:
 166:fsm.c         ****                 get_next_byte();
 1671              		.loc 2 166 34 discriminator 3 view .LVU469
 1672 0080 0135     		adds	r5, r5, #1
 1673              	.LVL129:
 166:fsm.c         ****                 get_next_byte();
 1674              		.loc 2 166 34 is_stmt 0 discriminator 3 view .LVU470
 1675 0082 D2E7     		b	.L120
 1676              	.LVL130:
 1677              	.L118:
 166:fsm.c         ****                 get_next_byte();
 1678              		.loc 2 166 34 discriminator 3 view .LVU471
 1679              	.LBE66:
 182:fsm.c         ****             if (!(n <= 8)) {
 1680              		.loc 2 182 9 is_stmt 1 view .LVU472
 182:fsm.c         ****             if (!(n <= 8)) {
 1681              		.loc 2 182 12 is_stmt 0 view .LVU473
 1682 0084 95B9     		cbnz	r5, .L136
 183:fsm.c         ****                 debug_write("error in  repeat_cons");
 1683              		.loc 2 183 13 is_stmt 1 view .LVU474
 183:fsm.c         ****                 debug_write("error in  repeat_cons");
 1684              		.loc 2 183 16 is_stmt 0 view .LVU475
ARM GAS  /tmp/ccXJY3ni.s 			page 55


 1685 0086 B9F1080F 		cmp	r9, #8
 1686 008a 02DD     		ble	.L131
 184:fsm.c         ****             }
 1687              		.loc 2 184 17 is_stmt 1 view .LVU476
 1688 008c 0948     		ldr	r0, .L138+4
 1689 008e FFF7FEFF 		bl	debug_write
 1690              	.LVL131:
 1691              	.L131:
 1692              	.LBB67:
 166:fsm.c         ****                 get_next_byte();
 1693              		.loc 2 166 20 is_stmt 0 discriminator 1 view .LVU477
 1694 0092 0024     		movs	r4, #0
 1695              	.LVL132:
 1696              	.L132:
 166:fsm.c         ****                 get_next_byte();
 1697              		.loc 2 166 20 discriminator 1 view .LVU478
 1698              	.LBE67:
 1699              	.LBB68:
 186:fsm.c         ****                 get_next_bit();
 1700              		.loc 2 186 29 is_stmt 1 discriminator 1 view .LVU479
 186:fsm.c         ****                 get_next_bit();
 1701              		.loc 2 186 13 is_stmt 0 discriminator 1 view .LVU480
 1702 0094 4C45     		cmp	r4, r9
 1703 0096 DEDA     		bge	.L124
 187:fsm.c         ****             }
 1704              		.loc 2 187 17 is_stmt 1 discriminator 3 view .LVU481
 1705 0098 FFF7FEFF 		bl	get_next_bit
 1706              	.LVL133:
 186:fsm.c         ****                 get_next_bit();
 1707              		.loc 2 186 36 discriminator 3 view .LVU482
 1708 009c 0134     		adds	r4, r4, #1
 1709              	.LVL134:
 186:fsm.c         ****                 get_next_bit();
 1710              		.loc 2 186 36 is_stmt 0 discriminator 3 view .LVU483
 1711 009e F9E7     		b	.L132
 1712              	.LVL135:
 1713              	.L134:
 186:fsm.c         ****                 get_next_bit();
 1714              		.loc 2 186 36 discriminator 3 view .LVU484
 1715              	.LBE68:
 1716              	.LBB69:
 193:fsm.c         ****             }
 1717              		.loc 2 193 17 is_stmt 1 discriminator 3 view .LVU485
 1718 00a0 FFF7FEFF 		bl	get_next_byte
 1719              	.LVL136:
 192:fsm.c         ****                 get_next_byte();
 1720              		.loc 2 192 36 discriminator 3 view .LVU486
 1721 00a4 0134     		adds	r4, r4, #1
 1722              	.LVL137:
 1723              	.L130:
 192:fsm.c         ****                 get_next_byte();
 1724              		.loc 2 192 29 discriminator 1 view .LVU487
 192:fsm.c         ****                 get_next_byte();
 1725              		.loc 2 192 13 is_stmt 0 discriminator 1 view .LVU488
 1726 00a6 4C45     		cmp	r4, r9
 1727 00a8 FADB     		blt	.L134
 1728 00aa D4E7     		b	.L124
ARM GAS  /tmp/ccXJY3ni.s 			page 56


 1729              	.LVL138:
 1730              	.L136:
 192:fsm.c         ****                 get_next_byte();
 1731              		.loc 2 192 22 view .LVU489
 1732 00ac 0024     		movs	r4, #0
 1733              	.LVL139:
 192:fsm.c         ****                 get_next_byte();
 1734              		.loc 2 192 22 view .LVU490
 1735 00ae FAE7     		b	.L130
 1736              	.L139:
 1737              		.align	2
 1738              	.L138:
 1739 00b0 6A000000 		.word	.LC4
 1740 00b4 7E000000 		.word	.LC5
 1741              	.LBE69:
 1742              		.cfi_endproc
 1743              	.LFE7:
 1745              		.section	.rodata.str1.1
 1746              	.LC6:
 1747 0094 7C206C65 		.ascii	"| len cons: %d, tag: %04x \012\000"
 1747      6E20636F 
 1747      6E733A20 
 1747      25642C20 
 1747      7461673A 
 1748              	.LC7:
 1749 00b0 74616720 		.ascii	"tag 0b0001 and adv_direct_ind\012\000"
 1749      30623030 
 1749      30312061 
 1749      6E642061 
 1749      64765F64 
 1750              	.LC8:
 1751 00cf 74616720 		.ascii	"tag 0b0011 and scan_req\012\000"
 1751      30623030 
 1751      31312061 
 1751      6E642073 
 1751      63616E5F 
 1752              	.LC9:
 1753 00e8 74616720 		.ascii	"tag 0000 and ADV_IDV\012\000"
 1753      30303030 
 1753      20616E64 
 1753      20414456 
 1753      5F494456 
 1754              	.LC10:
 1755 00fe 74616720 		.ascii	"tag CONNECT_IND\012\000"
 1755      434F4E4E 
 1755      4543545F 
 1755      494E440A 
 1755      00
 1756              	.LC11:
 1757 010f 74616720 		.ascii	"tag ADV_CONNECT_IND\012\000"
 1757      4144565F 
 1757      434F4E4E 
 1757      4543545F 
 1757      494E440A 
 1758              	.LC12:
 1759 0124 74616720 		.ascii	"tag ADV_EXT_IND\012\000"
 1759      4144565F 
ARM GAS  /tmp/ccXJY3ni.s 			page 57


 1759      4558545F 
 1759      494E440A 
 1759      00
 1760              	.LC13:
 1761 0135 74616720 		.ascii	"tag AUX_CONNECT_RSP\012\000"
 1761      4155585F 
 1761      434F4E4E 
 1761      4543545F 
 1761      5253500A 
 1762              	.LC14:
 1763 014a 74616720 		.ascii	"tag SCAN_RSP\012\000"
 1763      5343414E 
 1763      5F525350 
 1763      0A00
 1764              	.LC15:
 1765 0158 74616720 		.ascii	"tag ADV_SCAN_IND\012\000"
 1765      4144565F 
 1765      5343414E 
 1765      5F494E44 
 1765      0A00
 1766              	.LC16:
 1767 016a 4552524F 		.ascii	"ERROR: None matched case expression!\000"
 1767      523A204E 
 1767      6F6E6520 
 1767      6D617463 
 1767      68656420 
 1768              	.LC17:
 1769 018f 70617273 		.ascii	"parse finished.\012\000"
 1769      65206669 
 1769      6E697368 
 1769      65642E0A 
 1769      00
 1770              		.section	.text.run_parser,"ax",%progbits
 1771              		.align	1
 1772              		.global	run_parser
 1773              		.syntax unified
 1774              		.thumb
 1775              		.thumb_func
 1776              		.fpu softvfp
 1778              	run_parser:
 1779              	.LVL140:
 1780              	.LFB8:
 200:fsm.c         **** 
 201:fsm.c         **** 
 202:fsm.c         **** // We define a gloabl list of registers which store results.
 203:fsm.c         **** unsigned int run_parser(unsigned char* input_buffer, int buffer_len) {
 1781              		.loc 2 203 70 is_stmt 1 view -0
 1782              		.cfi_startproc
 1783              		@ args = 0, pretend = 0, frame = 192
 1784              		@ frame_needed = 0, uses_anonymous_args = 0
 1785              		.loc 2 203 70 is_stmt 0 view .LVU492
 1786 0000 30B5     		push	{r4, r5, lr}
 1787              		.cfi_def_cfa_offset 12
 1788              		.cfi_offset 4, -12
 1789              		.cfi_offset 5, -8
 1790              		.cfi_offset 14, -4
 1791 0002 B3B0     		sub	sp, sp, #204
ARM GAS  /tmp/ccXJY3ni.s 			page 58


 1792              		.cfi_def_cfa_offset 216
 204:fsm.c         ****     cur_bit_pos = 0;
 1793              		.loc 2 204 5 is_stmt 1 view .LVU493
 1794              		.loc 2 204 17 is_stmt 0 view .LVU494
 1795 0004 0024     		movs	r4, #0
 1796 0006 764B     		ldr	r3, .L167
 1797 0008 C3F88046 		str	r4, [r3, #1664]
 205:fsm.c         ****     cur_byte_pos = 0;
 1798              		.loc 2 205 5 is_stmt 1 view .LVU495
 1799              		.loc 2 205 18 is_stmt 0 view .LVU496
 1800 000c C3F87C46 		str	r4, [r3, #1660]
 206:fsm.c         ****     TAPE = input_buffer;
 1801              		.loc 2 206 5 is_stmt 1 view .LVU497
 1802              		.loc 2 206 10 is_stmt 0 view .LVU498
 1803 0010 744B     		ldr	r3, .L167+4
 1804 0012 1860     		str	r0, [r3]
 207:fsm.c         ****     TAPE_LEN = buffer_len;
 1805              		.loc 2 207 5 is_stmt 1 view .LVU499
 1806              		.loc 2 207 14 is_stmt 0 view .LVU500
 1807 0014 744B     		ldr	r3, .L167+8
 208:fsm.c         **** 
 209:fsm.c         ****     // PDU
 210:fsm.c         ****     int reg4144 = tag_cons(BIT, 4);
 1808              		.loc 2 210 19 view .LVU501
 1809 0016 2046     		mov	r0, r4
 1810              	.LVL141:
 207:fsm.c         ****     TAPE_LEN = buffer_len;
 1811              		.loc 2 207 14 view .LVU502
 1812 0018 1960     		str	r1, [r3]
 1813              		.loc 2 210 5 is_stmt 1 view .LVU503
 1814              		.loc 2 210 19 is_stmt 0 view .LVU504
 1815 001a 0421     		movs	r1, #4
 1816              	.LVL142:
 1817              		.loc 2 210 19 view .LVU505
 1818 001c FFF7FEFF 		bl	tag_cons
 1819              	.LVL143:
 211:fsm.c         ****     // // RFU
 212:fsm.c         ****     int reg4145 = tag_cons(BIT, 1);
 1820              		.loc 2 212 19 view .LVU506
 1821 0020 0121     		movs	r1, #1
 210:fsm.c         ****     // // RFU
 1822              		.loc 2 210 19 view .LVU507
 1823 0022 0546     		mov	r5, r0
 1824              	.LVL144:
 1825              		.loc 2 212 5 is_stmt 1 view .LVU508
 1826              		.loc 2 212 19 is_stmt 0 view .LVU509
 1827 0024 2046     		mov	r0, r4
 1828              	.LVL145:
 1829              		.loc 2 212 19 view .LVU510
 1830 0026 FFF7FEFF 		bl	tag_cons
 1831              	.LVL146:
 213:fsm.c         ****     // ChSel
 214:fsm.c         ****     int reg4146 = tag_cons(BIT, 1);
 1832              		.loc 2 214 5 is_stmt 1 view .LVU511
 1833              		.loc 2 214 19 is_stmt 0 view .LVU512
 1834 002a 0121     		movs	r1, #1
 1835 002c 2046     		mov	r0, r4
ARM GAS  /tmp/ccXJY3ni.s 			page 59


 1836 002e FFF7FEFF 		bl	tag_cons
 1837              	.LVL147:
 215:fsm.c         ****     // TxAdd
 216:fsm.c         ****     int reg4147 = tag_cons(BIT, 1);
 1838              		.loc 2 216 5 is_stmt 1 view .LVU513
 1839              		.loc 2 216 19 is_stmt 0 view .LVU514
 1840 0032 0121     		movs	r1, #1
 1841 0034 2046     		mov	r0, r4
 1842 0036 FFF7FEFF 		bl	tag_cons
 1843              	.LVL148:
 217:fsm.c         ****     // RxAdd
 218:fsm.c         ****     int reg4148 = tag_cons(BIT, 1);
 1844              		.loc 2 218 5 is_stmt 1 view .LVU515
 1845              		.loc 2 218 19 is_stmt 0 view .LVU516
 1846 003a 0121     		movs	r1, #1
 1847 003c 2046     		mov	r0, r4
 1848 003e FFF7FEFF 		bl	tag_cons
 1849              	.LVL149:
 219:fsm.c         ****     int reg4149 = len_cons(BYTE, LSB, 2);
 1850              		.loc 2 219 5 is_stmt 1 view .LVU517
 1851              	.LBB87:
 1852              	.LBI87:
 117:fsm.c         ****     int len_val = 0;
 1853              		.loc 2 117 5 view .LVU518
 1854              	.LBB88:
 118:fsm.c         ****     if (unit == BIT) {
 1855              		.loc 2 118 5 view .LVU519
 119:fsm.c         ****         int i = 0;
 1856              		.loc 2 119 5 view .LVU520
 1857              	.LBB89:
 1858              	.LBI89:
 117:fsm.c         ****     int len_val = 0;
 1859              		.loc 2 117 5 view .LVU521
 1860              	.LBB90:
 1861              	.LBB91:
 126:fsm.c         ****         if (!(size <= 4)) { debug_write("size error in tag_cons\n");}
 1862              		.loc 2 126 9 view .LVU522
 127:fsm.c         ****         for (i = 0; i < size; ++i) {
 1863              		.loc 2 127 9 view .LVU523
 128:fsm.c         ****             len_val = get_next_byte();
 1864              		.loc 2 128 21 view .LVU524
 129:fsm.c         ****             len_val = len_val << 8;
 1865              		.loc 2 129 13 view .LVU525
 129:fsm.c         ****             len_val = len_val << 8;
 1866              		.loc 2 129 23 is_stmt 0 view .LVU526
 1867 0042 FFF7FEFF 		bl	get_next_byte
 1868              	.LVL150:
 130:fsm.c         ****         }
 1869              		.loc 2 130 13 is_stmt 1 view .LVU527
 128:fsm.c         ****             len_val = get_next_byte();
 1870              		.loc 2 128 31 view .LVU528
 128:fsm.c         ****             len_val = get_next_byte();
 1871              		.loc 2 128 21 view .LVU529
 129:fsm.c         ****             len_val = len_val << 8;
 1872              		.loc 2 129 13 view .LVU530
 129:fsm.c         ****             len_val = len_val << 8;
 1873              		.loc 2 129 23 is_stmt 0 view .LVU531
ARM GAS  /tmp/ccXJY3ni.s 			page 60


 1874 0046 FFF7FEFF 		bl	get_next_byte
 1875              	.LVL151:
 130:fsm.c         ****         }
 1876              		.loc 2 130 13 is_stmt 1 view .LVU532
 128:fsm.c         ****             len_val = get_next_byte();
 1877              		.loc 2 128 31 view .LVU533
 128:fsm.c         ****             len_val = get_next_byte();
 1878              		.loc 2 128 21 view .LVU534
 128:fsm.c         ****             len_val = get_next_byte();
 1879              		.loc 2 128 21 is_stmt 0 view .LVU535
 1880              	.LBE91:
 136:fsm.c         **** };
 1881              		.loc 2 136 5 is_stmt 1 view .LVU536
 136:fsm.c         **** };
 1882              		.loc 2 136 5 is_stmt 0 view .LVU537
 1883              	.LBE90:
 1884              	.LBE89:
 136:fsm.c         **** };
 1885              		.loc 2 136 5 is_stmt 1 view .LVU538
 136:fsm.c         **** };
 1886              		.loc 2 136 5 is_stmt 0 view .LVU539
 1887              	.LBE88:
 1888              	.LBE87:
 220:fsm.c         **** 
 221:fsm.c         ****     debug_printf("| len cons: %d, tag: %04x \n", reg4149, reg4144);
 1889              		.loc 2 221 5 is_stmt 1 view .LVU540
 1890 004a 2A46     		mov	r2, r5
 1891 004c 0102     		lsls	r1, r0, #8
 1892              	.LVL152:
 1893              		.loc 2 221 5 is_stmt 0 view .LVU541
 1894 004e 6748     		ldr	r0, .L167+12
 1895 0050 FFF7FEFF 		bl	debug_printf
 1896              	.LVL153:
 222:fsm.c         **** 
 223:fsm.c         ****     switch (reg4144) {
 1897              		.loc 2 223 5 is_stmt 1 view .LVU542
 1898 0054 082D     		cmp	r5, #8
 1899 0056 00F2BF80 		bhi	.L141
 1900 005a DFE805F0 		tbb	[pc, r5]
 1901              	.L143:
 1902 005e 22       		.byte	(.L151-.L143)/2
 1903 005f 05       		.byte	(.L150-.L143)/2
 1904 0060 93       		.byte	(.L149-.L143)/2
 1905 0061 20       		.byte	(.L148-.L143)/2
 1906 0062 B9       		.byte	(.L147-.L143)/2
 1907 0063 31       		.byte	(.L146-.L143)/2
 1908 0064 BB       		.byte	(.L145-.L143)/2
 1909 0065 95       		.byte	(.L144-.L143)/2
 1910 0066 B7       		.byte	(.L142-.L143)/2
 1911 0067 00       		.p2align 1
 1912              	.L150:
 1913              	.LBB92:
 224:fsm.c         ****         case 0b0001: {
 225:fsm.c         ****                         debug_write("tag 0b0001 and adv_direct_ind\n");
 1914              		.loc 2 225 25 view .LVU543
 1915 0068 6148     		ldr	r0, .L167+16
 1916              	.L161:
ARM GAS  /tmp/ccXJY3ni.s 			page 61


 1917              	.LBE92:
 1918              	.LBB93:
 226:fsm.c         ****                          // :ADV_DIRECT_IND
 227:fsm.c         ****                          // AdvA
 228:fsm.c         ****                          parsed_result reg4150 = repeat_cons(BYTE, 6, NINF, INF);
 229:fsm.c         ****                          // Target A
 230:fsm.c         ****                          parsed_result reg4151 = repeat_cons(BYTE, 6, NINF, INF);
 231:fsm.c         ****                          break;
 232:fsm.c         ****                      }
 233:fsm.c         ****         case 0b0011: {
 234:fsm.c         ****                         debug_write("tag 0b0011 and scan_req\n");
 235:fsm.c         ****                          // :SCAN_REQ
 236:fsm.c         ****                          // ScanA
 237:fsm.c         ****                          parsed_result  reg4152 = repeat_cons(BYTE, 6, NINF, INF);
 1919              		.loc 2 237 51 is_stmt 0 view .LVU544
 1920 006a 4FF0FF34 		mov	r4, #-1
 234:fsm.c         ****                          // :SCAN_REQ
 1921              		.loc 2 234 25 view .LVU545
 1922 006e FFF7FEFF 		bl	debug_write
 1923              	.LVL154:
 1924              		.loc 2 237 26 is_stmt 1 view .LVU546
 1925              		.loc 2 237 51 is_stmt 0 view .LVU547
 1926 0072 6FF00103 		mvn	r3, #1
 1927 0076 0622     		movs	r2, #6
 1928 0078 0121     		movs	r1, #1
 1929 007a 0094     		str	r4, [sp]
 1930 007c 2AA8     		add	r0, sp, #168
 1931 007e FFF7FEFF 		bl	repeat_cons
 1932              	.LVL155:
 238:fsm.c         ****                          // AdvA
 239:fsm.c         ****                          parsed_result  reg4153 = repeat_cons(BYTE, 6, NINF, INF);
 1933              		.loc 2 239 26 is_stmt 1 view .LVU548
 1934              		.loc 2 239 51 is_stmt 0 view .LVU549
 1935 0082 6FF00103 		mvn	r3, #1
 1936 0086 0622     		movs	r2, #6
 1937 0088 0094     		str	r4, [sp]
 1938              	.L162:
 1939 008a 0121     		movs	r1, #1
 1940 008c 2EA8     		add	r0, sp, #184
 1941 008e FFF7FEFF 		bl	repeat_cons
 1942              	.LVL156:
 240:fsm.c         ****                          break;
 1943              		.loc 2 240 26 is_stmt 1 view .LVU550
 1944              	.L152:
 1945              	.LBE93:
 241:fsm.c         ****                      }
 242:fsm.c         ****         case 0b0000: {
 243:fsm.c         ****                      debug_write("tag 0000 and ADV_IDV\n");
 244:fsm.c         ****                      // :ADV_IDV
 245:fsm.c         ****                      // AdvA
 246:fsm.c         ****                      parsed_result  reg4154 = repeat_cons(BYTE, 6, NINF, INF);
 247:fsm.c         ****                      // repeat 0 31 bytes
 248:fsm.c         ****                      parsed_result  reg4155 = repeat_cons(BYTE, INF, 0, 31);
 249:fsm.c         ****                      break;
 250:fsm.c         ****                  }
 251:fsm.c         ****         case 0b0101: {
 252:fsm.c         ****                      debug_write("tag CONNECT_IND\n");
ARM GAS  /tmp/ccXJY3ni.s 			page 62


 253:fsm.c         ****                          // :CONNECT_IND
 254:fsm.c         ****                          // InitA
 255:fsm.c         ****                          parsed_result  reg4156 = repeat_cons(BYTE, 6, NINF, INF);
 256:fsm.c         ****                          // AdvA
 257:fsm.c         ****                          parsed_result  reg4157 = repeat_cons(BYTE, 6, NINF, INF);
 258:fsm.c         ****                          // AA
 259:fsm.c         ****                          parsed_result  reg4158 = repeat_cons(BYTE, 4, NINF, INF);
 260:fsm.c         ****                          // CRCInit
 261:fsm.c         ****                          parsed_result  reg4159 = repeat_cons(BYTE, 3, NINF, INF);
 262:fsm.c         ****                          // WinSize
 263:fsm.c         ****                          parsed_result  reg4160 = repeat_cons(BYTE, 1, NINF, INF);
 264:fsm.c         ****                          // WinOffset
 265:fsm.c         ****                          parsed_result  reg4161 = repeat_cons(BYTE, 2, NINF, INF);
 266:fsm.c         ****                          // Interval
 267:fsm.c         ****                          parsed_result  reg4162 = repeat_cons(BYTE, 2, NINF, INF);
 268:fsm.c         ****                          // Latency
 269:fsm.c         ****                          parsed_result  reg4163 = repeat_cons(BYTE, 2, NINF, INF);
 270:fsm.c         ****                          // Timeout
 271:fsm.c         ****                          parsed_result  reg4164 = repeat_cons(BYTE, 2, NINF, INF);
 272:fsm.c         ****                          // ChM
 273:fsm.c         ****                          parsed_result  reg4165 = repeat_cons(BYTE, 5, NINF, INF);
 274:fsm.c         ****                          // Hop
 275:fsm.c         ****                          parsed_result  reg4166 = repeat_cons(BYTE, 5, NINF, INF);
 276:fsm.c         ****                          // SCA
 277:fsm.c         ****                          parsed_result  reg4167 = repeat_cons(BYTE, 3, NINF, INF);
 278:fsm.c         ****                          break;
 279:fsm.c         ****                      }
 280:fsm.c         ****         case 0b0010: {
 281:fsm.c         ****             debug_write("tag ADV_CONNECT_IND\n");
 282:fsm.c         ****                          // :ADV_NONCONN_IND
 283:fsm.c         ****                          // AdvA
 284:fsm.c         ****                          parsed_result  reg4168 = repeat_cons(BYTE, 6, NINF, INF);
 285:fsm.c         ****                          // repeat 0 31 bytes
 286:fsm.c         ****                          parsed_result  reg4169 = repeat_cons(BYTE, INF, 0, 31);
 287:fsm.c         ****                          break;
 288:fsm.c         ****                      }
 289:fsm.c         ****         case 0b0111: {
 290:fsm.c         ****             debug_write("tag ADV_EXT_IND\n");
 291:fsm.c         ****                          // :ADV_EXT_IND
 292:fsm.c         ****                          int reg4170 = len_cons(BIT, LSB, 6);
 293:fsm.c         ****                          // AdvMode
 294:fsm.c         ****                          parsed_result  reg4171 = repeat_cons(BYTE, 2, NINF, INF);
 295:fsm.c         ****                          if (reg4170 == 0) {} else {
 296:fsm.c         ****                              // repeat 0 63 bytes
 297:fsm.c         ****                              parsed_result  reg4172 = repeat_cons(BYTE, reg4170, 0, 63);
 298:fsm.c         ****                          }
 299:fsm.c         ****                          // repeat 0 - 254 bytes
 300:fsm.c         ****                          parsed_result  reg4173 = repeat_cons(BYTE, INF, 0, 254);
 301:fsm.c         ****                          break;
 302:fsm.c         ****                      }
 303:fsm.c         ****         case 0b1000: {
 304:fsm.c         ****             debug_write("tag AUX_CONNECT_RSP\n");
 305:fsm.c         ****                          // :AUX_CONNECT_RSP
 306:fsm.c         ****                          int reg4174 = len_cons(BIT, LSB, 6);
 307:fsm.c         ****                          // AdvMode
 308:fsm.c         ****                          parsed_result  reg4175 = repeat_cons(BYTE, 2, NINF, INF);
 309:fsm.c         ****                          if (reg4174 == 0) {} else {
ARM GAS  /tmp/ccXJY3ni.s 			page 63


 310:fsm.c         ****                              // repeat 0 63 bytes
 311:fsm.c         ****                              parsed_result  reg4176 = repeat_cons(BYTE, reg4174, 0, 63);
 312:fsm.c         ****                          }
 313:fsm.c         ****                          // repeat 0 - 254 bytes
 314:fsm.c         ****                          parsed_result  reg4177 = repeat_cons(BYTE, INF, 0, 254);
 315:fsm.c         ****                          break;
 316:fsm.c         ****                      }
 317:fsm.c         ****         case 0b0100: {
 318:fsm.c         ****             debug_write("tag SCAN_RSP\n");
 319:fsm.c         ****                          // :SCAN_RSP
 320:fsm.c         ****                          // AdvA
 321:fsm.c         ****                          parsed_result  reg4178 = repeat_cons(BYTE, 6, NINF, INF);
 322:fsm.c         ****                          // repeat 0 31 bytes
 323:fsm.c         ****                          parsed_result  reg4179 = repeat_cons(BYTE, INF, 0, 31);
 324:fsm.c         ****                          break;
 325:fsm.c         ****                      }
 326:fsm.c         ****         case 0b0110: {
 327:fsm.c         ****             debug_write("tag ADV_SCAN_IND\n");
 328:fsm.c         ****                          // :ADV_SCAN_IND
 329:fsm.c         ****                          // AdvA
 330:fsm.c         ****                          parsed_result  reg4180 = repeat_cons(BYTE, 6, NINF, INF);
 331:fsm.c         ****                          // repeat 0 31 bytes
 332:fsm.c         ****                          parsed_result  reg4181 = repeat_cons(BYTE, INF, 0, 31);
 333:fsm.c         ****                          break;
 334:fsm.c         ****                      }
 335:fsm.c         ****         default:
 336:fsm.c         ****                 debug_write("ERROR: None matched case expression!");
 337:fsm.c         ****     }
 338:fsm.c         ****     debug_write("parse finished.\n");
 1946              		.loc 2 338 5 view .LVU551
 1947 0092 5848     		ldr	r0, .L167+20
 1948 0094 FFF7FEFF 		bl	debug_write
 1949              	.LVL157:
 339:fsm.c         ****     return 0;
 1950              		.loc 2 339 5 view .LVU552
 340:fsm.c         **** };
 1951              		.loc 2 340 1 is_stmt 0 view .LVU553
 1952 0098 0020     		movs	r0, #0
 1953 009a 33B0     		add	sp, sp, #204
 1954              		.cfi_remember_state
 1955              		.cfi_def_cfa_offset 12
 1956              		@ sp needed
 1957 009c 30BD     		pop	{r4, r5, pc}
 1958              	.LVL158:
 1959              	.L148:
 1960              		.cfi_restore_state
 1961              	.LBB94:
 234:fsm.c         ****                          // :SCAN_REQ
 1962              		.loc 2 234 25 is_stmt 1 view .LVU554
 1963 009e 5648     		ldr	r0, .L167+24
 1964 00a0 E3E7     		b	.L161
 1965              	.L151:
 1966              	.LBE94:
 1967              	.LBB95:
 243:fsm.c         ****                      // :ADV_IDV
 1968              		.loc 2 243 22 view .LVU555
 1969 00a2 5648     		ldr	r0, .L167+28
ARM GAS  /tmp/ccXJY3ni.s 			page 64


 1970              	.L163:
 1971              	.LBE95:
 1972              	.LBB96:
 330:fsm.c         ****                          // repeat 0 31 bytes
 1973              		.loc 2 330 51 is_stmt 0 view .LVU556
 1974 00a4 4FF0FF34 		mov	r4, #-1
 327:fsm.c         ****                          // :ADV_SCAN_IND
 1975              		.loc 2 327 13 view .LVU557
 1976 00a8 FFF7FEFF 		bl	debug_write
 1977              	.LVL159:
 330:fsm.c         ****                          // repeat 0 31 bytes
 1978              		.loc 2 330 26 is_stmt 1 view .LVU558
 330:fsm.c         ****                          // repeat 0 31 bytes
 1979              		.loc 2 330 51 is_stmt 0 view .LVU559
 1980 00ac 6FF00103 		mvn	r3, #1
 1981 00b0 0622     		movs	r2, #6
 1982 00b2 0121     		movs	r1, #1
 1983 00b4 0094     		str	r4, [sp]
 1984 00b6 2AA8     		add	r0, sp, #168
 1985 00b8 FFF7FEFF 		bl	repeat_cons
 1986              	.LVL160:
 332:fsm.c         ****                          break;
 1987              		.loc 2 332 26 is_stmt 1 view .LVU560
 332:fsm.c         ****                          break;
 1988              		.loc 2 332 51 is_stmt 0 view .LVU561
 1989 00bc 1F23     		movs	r3, #31
 1990 00be 80E0     		b	.L164
 1991              	.L146:
 1992              	.LBE96:
 1993              	.LBB97:
 252:fsm.c         ****                          // :CONNECT_IND
 1994              		.loc 2 252 22 is_stmt 1 view .LVU562
 255:fsm.c         ****                          // AdvA
 1995              		.loc 2 255 51 is_stmt 0 view .LVU563
 1996 00c0 4FF0FF34 		mov	r4, #-1
 252:fsm.c         ****                          // :CONNECT_IND
 1997              		.loc 2 252 22 view .LVU564
 1998 00c4 4E48     		ldr	r0, .L167+32
 1999 00c6 FFF7FEFF 		bl	debug_write
 2000              	.LVL161:
 255:fsm.c         ****                          // AdvA
 2001              		.loc 2 255 26 is_stmt 1 view .LVU565
 255:fsm.c         ****                          // AdvA
 2002              		.loc 2 255 51 is_stmt 0 view .LVU566
 2003 00ca 6FF00103 		mvn	r3, #1
 2004 00ce 0622     		movs	r2, #6
 2005 00d0 0121     		movs	r1, #1
 2006 00d2 02A8     		add	r0, sp, #8
 2007 00d4 0094     		str	r4, [sp]
 2008 00d6 FFF7FEFF 		bl	repeat_cons
 2009              	.LVL162:
 257:fsm.c         ****                          // AA
 2010              		.loc 2 257 26 is_stmt 1 view .LVU567
 257:fsm.c         ****                          // AA
 2011              		.loc 2 257 51 is_stmt 0 view .LVU568
 2012 00da 6FF00103 		mvn	r3, #1
 2013 00de 0622     		movs	r2, #6
ARM GAS  /tmp/ccXJY3ni.s 			page 65


 2014 00e0 0121     		movs	r1, #1
 2015 00e2 06A8     		add	r0, sp, #24
 2016 00e4 0094     		str	r4, [sp]
 2017 00e6 FFF7FEFF 		bl	repeat_cons
 2018              	.LVL163:
 259:fsm.c         ****                          // CRCInit
 2019              		.loc 2 259 26 is_stmt 1 view .LVU569
 259:fsm.c         ****                          // CRCInit
 2020              		.loc 2 259 51 is_stmt 0 view .LVU570
 2021 00ea 6FF00103 		mvn	r3, #1
 2022 00ee 0422     		movs	r2, #4
 2023 00f0 0121     		movs	r1, #1
 2024 00f2 0AA8     		add	r0, sp, #40
 2025 00f4 0094     		str	r4, [sp]
 2026 00f6 FFF7FEFF 		bl	repeat_cons
 2027              	.LVL164:
 261:fsm.c         ****                          // WinSize
 2028              		.loc 2 261 26 is_stmt 1 view .LVU571
 261:fsm.c         ****                          // WinSize
 2029              		.loc 2 261 51 is_stmt 0 view .LVU572
 2030 00fa 6FF00103 		mvn	r3, #1
 2031 00fe 0322     		movs	r2, #3
 2032 0100 0121     		movs	r1, #1
 2033 0102 0EA8     		add	r0, sp, #56
 2034 0104 0094     		str	r4, [sp]
 2035 0106 FFF7FEFF 		bl	repeat_cons
 2036              	.LVL165:
 263:fsm.c         ****                          // WinOffset
 2037              		.loc 2 263 26 is_stmt 1 view .LVU573
 263:fsm.c         ****                          // WinOffset
 2038              		.loc 2 263 51 is_stmt 0 view .LVU574
 2039 010a 0122     		movs	r2, #1
 2040 010c 6FF00103 		mvn	r3, #1
 2041 0110 1146     		mov	r1, r2
 2042 0112 12A8     		add	r0, sp, #72
 2043 0114 0094     		str	r4, [sp]
 2044 0116 FFF7FEFF 		bl	repeat_cons
 2045              	.LVL166:
 265:fsm.c         ****                          // Interval
 2046              		.loc 2 265 26 is_stmt 1 view .LVU575
 265:fsm.c         ****                          // Interval
 2047              		.loc 2 265 51 is_stmt 0 view .LVU576
 2048 011a 6FF00103 		mvn	r3, #1
 2049 011e 0222     		movs	r2, #2
 2050 0120 0121     		movs	r1, #1
 2051 0122 16A8     		add	r0, sp, #88
 2052 0124 0094     		str	r4, [sp]
 2053 0126 FFF7FEFF 		bl	repeat_cons
 2054              	.LVL167:
 267:fsm.c         ****                          // Latency
 2055              		.loc 2 267 26 is_stmt 1 view .LVU577
 267:fsm.c         ****                          // Latency
 2056              		.loc 2 267 51 is_stmt 0 view .LVU578
 2057 012a 6FF00103 		mvn	r3, #1
 2058 012e 0222     		movs	r2, #2
 2059 0130 0121     		movs	r1, #1
 2060 0132 1AA8     		add	r0, sp, #104
ARM GAS  /tmp/ccXJY3ni.s 			page 66


 2061 0134 0094     		str	r4, [sp]
 2062 0136 FFF7FEFF 		bl	repeat_cons
 2063              	.LVL168:
 269:fsm.c         ****                          // Timeout
 2064              		.loc 2 269 26 is_stmt 1 view .LVU579
 269:fsm.c         ****                          // Timeout
 2065              		.loc 2 269 51 is_stmt 0 view .LVU580
 2066 013a 6FF00103 		mvn	r3, #1
 2067 013e 0222     		movs	r2, #2
 2068 0140 0121     		movs	r1, #1
 2069 0142 1EA8     		add	r0, sp, #120
 2070 0144 0094     		str	r4, [sp]
 2071 0146 FFF7FEFF 		bl	repeat_cons
 2072              	.LVL169:
 271:fsm.c         ****                          // ChM
 2073              		.loc 2 271 26 is_stmt 1 view .LVU581
 271:fsm.c         ****                          // ChM
 2074              		.loc 2 271 51 is_stmt 0 view .LVU582
 2075 014a 6FF00103 		mvn	r3, #1
 2076 014e 0222     		movs	r2, #2
 2077 0150 0121     		movs	r1, #1
 2078 0152 22A8     		add	r0, sp, #136
 2079 0154 0094     		str	r4, [sp]
 2080 0156 FFF7FEFF 		bl	repeat_cons
 2081              	.LVL170:
 273:fsm.c         ****                          // Hop
 2082              		.loc 2 273 26 is_stmt 1 view .LVU583
 273:fsm.c         ****                          // Hop
 2083              		.loc 2 273 51 is_stmt 0 view .LVU584
 2084 015a 6FF00103 		mvn	r3, #1
 2085 015e 0522     		movs	r2, #5
 2086 0160 0121     		movs	r1, #1
 2087 0162 26A8     		add	r0, sp, #152
 2088 0164 0094     		str	r4, [sp]
 2089 0166 FFF7FEFF 		bl	repeat_cons
 2090              	.LVL171:
 275:fsm.c         ****                          // SCA
 2091              		.loc 2 275 26 is_stmt 1 view .LVU585
 275:fsm.c         ****                          // SCA
 2092              		.loc 2 275 51 is_stmt 0 view .LVU586
 2093 016a 6FF00103 		mvn	r3, #1
 2094 016e 0522     		movs	r2, #5
 2095 0170 0121     		movs	r1, #1
 2096 0172 0094     		str	r4, [sp]
 2097 0174 2AA8     		add	r0, sp, #168
 2098 0176 FFF7FEFF 		bl	repeat_cons
 2099              	.LVL172:
 277:fsm.c         ****                          break;
 2100              		.loc 2 277 26 is_stmt 1 view .LVU587
 277:fsm.c         ****                          break;
 2101              		.loc 2 277 51 is_stmt 0 view .LVU588
 2102 017a 6FF00103 		mvn	r3, #1
 2103 017e 0322     		movs	r2, #3
 2104 0180 0094     		str	r4, [sp]
 2105 0182 82E7     		b	.L162
 2106              	.L149:
 2107              	.LBE97:
ARM GAS  /tmp/ccXJY3ni.s 			page 67


 2108              	.LBB98:
 281:fsm.c         ****                          // :ADV_NONCONN_IND
 2109              		.loc 2 281 13 is_stmt 1 view .LVU589
 2110 0184 1F48     		ldr	r0, .L167+36
 2111 0186 8DE7     		b	.L163
 2112              	.L144:
 2113              	.LBE98:
 2114              	.LBB99:
 290:fsm.c         ****                          // :ADV_EXT_IND
 2115              		.loc 2 290 13 view .LVU590
 2116 0188 1F48     		ldr	r0, .L167+40
 2117              	.L166:
 2118              	.LBE99:
 2119              	.LBB100:
 304:fsm.c         ****                          // :AUX_CONNECT_RSP
 2120              		.loc 2 304 13 is_stmt 0 view .LVU591
 2121 018a FFF7FEFF 		bl	debug_write
 2122              	.LVL173:
 306:fsm.c         ****                          // AdvMode
 2123              		.loc 2 306 26 is_stmt 1 view .LVU592
 306:fsm.c         ****                          // AdvMode
 2124              		.loc 2 306 40 is_stmt 0 view .LVU593
 2125 018e 0021     		movs	r1, #0
 2126 0190 0622     		movs	r2, #6
 2127 0192 0846     		mov	r0, r1
 2128 0194 FFF7FEFF 		bl	len_cons
 2129              	.LVL174:
 308:fsm.c         ****                          if (reg4174 == 0) {} else {
 2130              		.loc 2 308 51 view .LVU594
 2131 0198 4FF0FF33 		mov	r3, #-1
 306:fsm.c         ****                          // AdvMode
 2132              		.loc 2 306 40 view .LVU595
 2133 019c 0446     		mov	r4, r0
 2134              	.LVL175:
 308:fsm.c         ****                          if (reg4174 == 0) {} else {
 2135              		.loc 2 308 26 is_stmt 1 view .LVU596
 308:fsm.c         ****                          if (reg4174 == 0) {} else {
 2136              		.loc 2 308 51 is_stmt 0 view .LVU597
 2137 019e 0093     		str	r3, [sp]
 2138 01a0 0222     		movs	r2, #2
 2139 01a2 6FF00103 		mvn	r3, #1
 2140 01a6 0121     		movs	r1, #1
 2141 01a8 2AA8     		add	r0, sp, #168
 2142              	.LVL176:
 308:fsm.c         ****                          if (reg4174 == 0) {} else {
 2143              		.loc 2 308 51 view .LVU598
 2144 01aa FFF7FEFF 		bl	repeat_cons
 2145              	.LVL177:
 309:fsm.c         ****                              // repeat 0 63 bytes
 2146              		.loc 2 309 26 is_stmt 1 view .LVU599
 309:fsm.c         ****                              // repeat 0 63 bytes
 2147              		.loc 2 309 29 is_stmt 0 view .LVU600
 2148 01ae 3CB1     		cbz	r4, .L154
 2149              	.LBB101:
 311:fsm.c         ****                          }
 2150              		.loc 2 311 30 is_stmt 1 view .LVU601
 311:fsm.c         ****                          }
ARM GAS  /tmp/ccXJY3ni.s 			page 68


 2151              		.loc 2 311 55 is_stmt 0 view .LVU602
 2152 01b0 3F23     		movs	r3, #63
 2153 01b2 2246     		mov	r2, r4
 2154 01b4 0093     		str	r3, [sp]
 2155 01b6 0121     		movs	r1, #1
 2156 01b8 0023     		movs	r3, #0
 2157 01ba 2EA8     		add	r0, sp, #184
 2158 01bc FFF7FEFF 		bl	repeat_cons
 2159              	.LVL178:
 2160              	.L154:
 2161              	.LBE101:
 314:fsm.c         ****                          break;
 2162              		.loc 2 314 26 is_stmt 1 view .LVU603
 314:fsm.c         ****                          break;
 2163              		.loc 2 314 51 is_stmt 0 view .LVU604
 2164 01c0 FE23     		movs	r3, #254
 2165              	.LVL179:
 2166              	.L164:
 314:fsm.c         ****                          break;
 2167              		.loc 2 314 51 view .LVU605
 2168 01c2 0093     		str	r3, [sp]
 2169 01c4 4FF0FF32 		mov	r2, #-1
 2170 01c8 0023     		movs	r3, #0
 2171 01ca 5EE7     		b	.L162
 2172              	.L142:
 304:fsm.c         ****                          // :AUX_CONNECT_RSP
 2173              		.loc 2 304 13 is_stmt 1 view .LVU606
 2174 01cc 0F48     		ldr	r0, .L167+44
 2175 01ce DCE7     		b	.L166
 2176              	.L147:
 2177              	.LBE100:
 2178              	.LBB102:
 318:fsm.c         ****                          // :SCAN_RSP
 2179              		.loc 2 318 13 view .LVU607
 2180 01d0 0F48     		ldr	r0, .L167+48
 2181 01d2 67E7     		b	.L163
 2182              	.L145:
 2183              	.LBE102:
 2184              	.LBB103:
 327:fsm.c         ****                          // :ADV_SCAN_IND
 2185              		.loc 2 327 13 view .LVU608
 2186 01d4 0F48     		ldr	r0, .L167+52
 2187 01d6 65E7     		b	.L163
 2188              	.L141:
 2189              	.LBE103:
 336:fsm.c         ****     }
 2190              		.loc 2 336 17 view .LVU609
 2191 01d8 0F48     		ldr	r0, .L167+56
 2192 01da FFF7FEFF 		bl	debug_write
 2193              	.LVL180:
 2194 01de 58E7     		b	.L152
 2195              	.L168:
 2196              		.align	2
 2197              	.L167:
 2198 01e0 00000000 		.word	.LANCHOR0
 2199 01e4 00000000 		.word	TAPE
 2200 01e8 00000000 		.word	TAPE_LEN
ARM GAS  /tmp/ccXJY3ni.s 			page 69


 2201 01ec 94000000 		.word	.LC6
 2202 01f0 B0000000 		.word	.LC7
 2203 01f4 8F010000 		.word	.LC17
 2204 01f8 CF000000 		.word	.LC8
 2205 01fc E8000000 		.word	.LC9
 2206 0200 FE000000 		.word	.LC10
 2207 0204 0F010000 		.word	.LC11
 2208 0208 24010000 		.word	.LC12
 2209 020c 35010000 		.word	.LC13
 2210 0210 4A010000 		.word	.LC14
 2211 0214 58010000 		.word	.LC15
 2212 0218 6A010000 		.word	.LC16
 2213              		.cfi_endproc
 2214              	.LFE8:
 2216              		.section	.text.le_DMA_IRQHandler,"ax",%progbits
 2217              		.align	1
 2218              		.global	le_DMA_IRQHandler
 2219              		.syntax unified
 2220              		.thumb
 2221              		.thumb_func
 2222              		.fpu softvfp
 2224              	le_DMA_IRQHandler:
 2225              	.LFB16:
 302:le_phy.c      **** 	unsigned pos;
 2226              		.loc 1 302 30 view -0
 2227              		.cfi_startproc
 2228              		@ args = 0, pretend = 0, frame = 0
 2229              		@ frame_needed = 0, uses_anonymous_args = 0
 2230 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2231              		.cfi_def_cfa_offset 24
 2232              		.cfi_offset 3, -24
 2233              		.cfi_offset 4, -20
 2234              		.cfi_offset 5, -16
 2235              		.cfi_offset 6, -12
 2236              		.cfi_offset 7, -8
 2237              		.cfi_offset 14, -4
 303:le_phy.c      **** 	int8_t rssi;
 2238              		.loc 1 303 2 view .LVU611
 304:le_phy.c      **** 	uint32_t timestamp = NOW; // sampled early for most accurate measurement
 2239              		.loc 1 304 2 view .LVU612
 305:le_phy.c      **** 
 2240              		.loc 1 305 2 view .LVU613
 305:le_phy.c      **** 
 2241              		.loc 1 305 11 is_stmt 0 view .LVU614
 2242 0002 6A4D     		ldr	r5, .L194
 308:le_phy.c      **** 		// terminal count - byte received
 2243              		.loc 1 308 6 view .LVU615
 2244 0004 6A4B     		ldr	r3, .L194+4
 305:le_phy.c      **** 
 2245              		.loc 1 305 11 view .LVU616
 2246 0006 2E68     		ldr	r6, [r5]
 2247              	.LVL181:
 308:le_phy.c      **** 		// terminal count - byte received
 2248              		.loc 1 308 2 is_stmt 1 view .LVU617
 308:le_phy.c      **** 		// terminal count - byte received
 2249              		.loc 1 308 6 is_stmt 0 view .LVU618
 2250 0008 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/ccXJY3ni.s 			page 70


 308:le_phy.c      **** 		// terminal count - byte received
 2251              		.loc 1 308 5 view .LVU619
 2252 000a DF07     		lsls	r7, r3, #31
 2253 000c 49D5     		bpl	.L169
 310:le_phy.c      **** 			DMACIntTCClear = (1 << 0);
 2254              		.loc 1 310 3 is_stmt 1 view .LVU620
 310:le_phy.c      **** 			DMACIntTCClear = (1 << 0);
 2255              		.loc 1 310 7 is_stmt 0 view .LVU621
 2256 000e 694B     		ldr	r3, .L194+8
 2257 0010 1B68     		ldr	r3, [r3]
 310:le_phy.c      **** 			DMACIntTCClear = (1 << 0);
 2258              		.loc 1 310 6 view .LVU622
 2259 0012 DC07     		lsls	r4, r3, #31
 2260 0014 3ED5     		bpl	.L179
 311:le_phy.c      **** 
 2261              		.loc 1 311 4 is_stmt 1 view .LVU623
 311:le_phy.c      **** 
 2262              		.loc 1 311 19 is_stmt 0 view .LVU624
 2263 0016 0123     		movs	r3, #1
 2264 0018 674F     		ldr	r7, .L194+12
 314:le_phy.c      **** 			current_rxbuf->rssi_sum += rssi;
 2265              		.loc 1 314 20 view .LVU625
 2266 001a 0620     		movs	r0, #6
 311:le_phy.c      **** 
 2267              		.loc 1 311 19 view .LVU626
 2268 001c 3B60     		str	r3, [r7]
 314:le_phy.c      **** 			current_rxbuf->rssi_sum += rssi;
 2269              		.loc 1 314 4 is_stmt 1 view .LVU627
 314:le_phy.c      **** 			current_rxbuf->rssi_sum += rssi;
 2270              		.loc 1 314 20 is_stmt 0 view .LVU628
 2271 001e FFF7FEFF 		bl	cc2400_get
 2272              	.LVL182:
 315:le_phy.c      **** 			if (rssi < current_rxbuf->rssi_min) current_rxbuf->rssi_min = rssi;
 2273              		.loc 1 315 28 view .LVU629
 2274 0022 664C     		ldr	r4, .L194+16
 314:le_phy.c      **** 			current_rxbuf->rssi_sum += rssi;
 2275              		.loc 1 314 9 view .LVU630
 2276 0024 40F30720 		sbfx	r0, r0, #8, #8
 2277              	.LVL183:
 315:le_phy.c      **** 			if (rssi < current_rxbuf->rssi_min) current_rxbuf->rssi_min = rssi;
 2278              		.loc 1 315 4 is_stmt 1 view .LVU631
 315:le_phy.c      **** 			if (rssi < current_rxbuf->rssi_min) current_rxbuf->rssi_min = rssi;
 2279              		.loc 1 315 28 is_stmt 0 view .LVU632
 2280 0028 D4F87836 		ldr	r3, [r4, #1656]
 2281 002c D3F82021 		ldr	r2, [r3, #288]
 2282 0030 0244     		add	r2, r2, r0
 2283 0032 C3F82021 		str	r2, [r3, #288]
 316:le_phy.c      **** 			if (rssi > current_rxbuf->rssi_max) current_rxbuf->rssi_max = rssi;
 2284              		.loc 1 316 4 is_stmt 1 view .LVU633
 316:le_phy.c      **** 			if (rssi > current_rxbuf->rssi_max) current_rxbuf->rssi_max = rssi;
 2285              		.loc 1 316 7 is_stmt 0 view .LVU634
 2286 0036 93F91C21 		ldrsb	r2, [r3, #284]
 2287 003a 8242     		cmp	r2, r0
 316:le_phy.c      **** 			if (rssi > current_rxbuf->rssi_max) current_rxbuf->rssi_max = rssi;
 2288              		.loc 1 316 40 is_stmt 1 view .LVU635
 317:le_phy.c      **** 
 2289              		.loc 1 317 7 is_stmt 0 view .LVU636
ARM GAS  /tmp/ccXJY3ni.s 			page 71


 2290 003c 93F91D21 		ldrsb	r2, [r3, #285]
 316:le_phy.c      **** 			if (rssi > current_rxbuf->rssi_max) current_rxbuf->rssi_max = rssi;
 2291              		.loc 1 316 64 view .LVU637
 2292 0040 C8BF     		it	gt
 2293 0042 83F81C01 		strbgt	r0, [r3, #284]
 317:le_phy.c      **** 
 2294              		.loc 1 317 4 is_stmt 1 view .LVU638
 317:le_phy.c      **** 
 2295              		.loc 1 317 7 is_stmt 0 view .LVU639
 2296 0046 8242     		cmp	r2, r0
 317:le_phy.c      **** 
 2297              		.loc 1 317 40 is_stmt 1 view .LVU640
 320:le_phy.c      **** 			current_rxbuf->data[pos] = le_dma_dest[pos & 1]; // dirty hack
 2298              		.loc 1 320 8 is_stmt 0 view .LVU641
 2299 0048 D3F80821 		ldr	r2, [r3, #264]
 317:le_phy.c      **** 
 2300              		.loc 1 317 64 view .LVU642
 2301 004c B8BF     		it	lt
 2302 004e 83F81D01 		strblt	r0, [r3, #285]
 320:le_phy.c      **** 			current_rxbuf->data[pos] = le_dma_dest[pos & 1]; // dirty hack
 2303              		.loc 1 320 4 is_stmt 1 view .LVU643
 2304              	.LVL184:
 321:le_phy.c      **** 			pos += 1;
 2305              		.loc 1 321 4 view .LVU644
 321:le_phy.c      **** 			pos += 1;
 2306              		.loc 1 321 29 is_stmt 0 view .LVU645
 2307 0052 5B48     		ldr	r0, .L194+20
 2308              	.LVL185:
 321:le_phy.c      **** 			pos += 1;
 2309              		.loc 1 321 47 view .LVU646
 2310 0054 02F00101 		and	r1, r2, #1
 321:le_phy.c      **** 			pos += 1;
 2311              		.loc 1 321 29 view .LVU647
 2312 0058 415C     		ldrb	r1, [r0, r1]	@ zero_extendqisi2
 2313 005a 9954     		strb	r1, [r3, r2]
 322:le_phy.c      **** 			current_rxbuf->pos = pos;
 2314              		.loc 1 322 4 is_stmt 1 view .LVU648
 322:le_phy.c      **** 			current_rxbuf->pos = pos;
 2315              		.loc 1 322 8 is_stmt 0 view .LVU649
 2316 005c 0132     		adds	r2, r2, #1
 2317              	.LVL186:
 323:le_phy.c      **** 
 2318              		.loc 1 323 4 is_stmt 1 view .LVU650
 325:le_phy.c      **** 				current_rxbuf->timestamp = timestamp - USEC(8 + 32); // packet starts at preamble
 2319              		.loc 1 325 7 is_stmt 0 view .LVU651
 2320 005e 012A     		cmp	r2, #1
 323:le_phy.c      **** 
 2321              		.loc 1 323 23 view .LVU652
 2322 0060 C3F80821 		str	r2, [r3, #264]
 325:le_phy.c      **** 				current_rxbuf->timestamp = timestamp - USEC(8 + 32); // packet starts at preamble
 2323              		.loc 1 325 4 is_stmt 1 view .LVU653
 325:le_phy.c      **** 				current_rxbuf->timestamp = timestamp - USEC(8 + 32); // packet starts at preamble
 2324              		.loc 1 325 7 is_stmt 0 view .LVU654
 2325 0064 1ED1     		bne	.L175
 326:le_phy.c      **** 				current_rxbuf->channel = rf_channel;
 2326              		.loc 1 326 5 is_stmt 1 view .LVU655
 327:le_phy.c      **** 				current_rxbuf->access_address = conn.access_address;
ARM GAS  /tmp/ccXJY3ni.s 			page 72


 2327              		.loc 1 327 28 is_stmt 0 view .LVU656
 2328 0066 5749     		ldr	r1, .L194+24
 326:le_phy.c      **** 				current_rxbuf->channel = rf_channel;
 2329              		.loc 1 326 42 view .LVU657
 2330 0068 A6F5C876 		sub	r6, r6, #400
 2331              	.LVL187:
 327:le_phy.c      **** 				current_rxbuf->access_address = conn.access_address;
 2332              		.loc 1 327 28 view .LVU658
 2333 006c 0A88     		ldrh	r2, [r1]
 2334              	.LVL188:
 332:le_phy.c      **** 					timer1_clear_match();
 2335              		.loc 1 332 9 view .LVU659
 2336 006e 0888     		ldrh	r0, [r1]
 327:le_phy.c      **** 				current_rxbuf->access_address = conn.access_address;
 2337              		.loc 1 327 28 view .LVU660
 2338 0070 92B2     		uxth	r2, r2
 2339 0072 C3F81021 		str	r2, [r3, #272]
 328:le_phy.c      **** 
 2340              		.loc 1 328 35 view .LVU661
 2341 0076 226A     		ldr	r2, [r4, #32]
 326:le_phy.c      **** 				current_rxbuf->channel = rf_channel;
 2342              		.loc 1 326 30 view .LVU662
 2343 0078 C3F80C61 		str	r6, [r3, #268]
 327:le_phy.c      **** 				current_rxbuf->access_address = conn.access_address;
 2344              		.loc 1 327 5 is_stmt 1 view .LVU663
 328:le_phy.c      **** 
 2345              		.loc 1 328 5 view .LVU664
 328:le_phy.c      **** 
 2346              		.loc 1 328 35 is_stmt 0 view .LVU665
 2347 007c C3F81421 		str	r2, [r3, #276]
 332:le_phy.c      **** 					timer1_clear_match();
 2348              		.loc 1 332 5 is_stmt 1 view .LVU666
 332:le_phy.c      **** 					timer1_clear_match();
 2349              		.loc 1 332 9 is_stmt 0 view .LVU667
 2350 0080 80B2     		uxth	r0, r0
 2351 0082 FFF7FEFF 		bl	btle_channel_index
 2352              	.LVL189:
 332:le_phy.c      **** 					timer1_clear_match();
 2353              		.loc 1 332 8 view .LVU668
 2354 0086 2428     		cmp	r0, #36
 2355 0088 04D8     		bhi	.L179
 333:le_phy.c      **** 				}
 2356              		.loc 1 333 6 is_stmt 1 view .LVU669
 2357              	.LBB110:
 2358              	.LBI110:
 561:le_phy.c      **** 	T1MCR &= ~TMCR_MR0I;
 2359              		.loc 1 561 13 view .LVU670
 2360              	.LBB111:
 562:le_phy.c      **** }
 2361              		.loc 1 562 2 view .LVU671
 562:le_phy.c      **** }
 2362              		.loc 1 562 8 is_stmt 0 view .LVU672
 2363 008a 4F4A     		ldr	r2, .L194+28
 2364 008c 1368     		ldr	r3, [r2]
 2365 008e 23F00103 		bic	r3, r3, #1
 2366 0092 1360     		str	r3, [r2]
 2367              	.LVL190:
ARM GAS  /tmp/ccXJY3ni.s 			page 73


 2368              	.L179:
 562:le_phy.c      **** }
 2369              		.loc 1 562 8 view .LVU673
 2370              	.LBE111:
 2371              	.LBE110:
 397:le_phy.c      **** 			// TODO error state transition
 2372              		.loc 1 397 3 is_stmt 1 view .LVU674
 397:le_phy.c      **** 			// TODO error state transition
 2373              		.loc 1 397 7 is_stmt 0 view .LVU675
 2374 0094 4D4B     		ldr	r3, .L194+32
 2375 0096 1B68     		ldr	r3, [r3]
 397:le_phy.c      **** 			// TODO error state transition
 2376              		.loc 1 397 6 view .LVU676
 2377 0098 DB07     		lsls	r3, r3, #31
 399:le_phy.c      **** 		}
 2378              		.loc 1 399 4 is_stmt 1 view .LVU677
 399:le_phy.c      **** 		}
 2379              		.loc 1 399 18 is_stmt 0 view .LVU678
 2380 009a 42BF     		ittt	mi
 2381 009c 0122     		movmi	r2, #1
 2382 009e 4C4B     		ldrmi	r3, .L194+36
 2383 00a0 1A60     		strmi	r2, [r3]
 2384              	.L169:
 402:le_phy.c      **** 
 2385              		.loc 1 402 1 view .LVU679
 2386 00a2 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2387              	.LVL191:
 2388              	.L175:
 338:le_phy.c      **** 				uint8_t length = dewhiten_length(current_rxbuf->channel, current_rxbuf->data[1]);
 2389              		.loc 1 338 4 is_stmt 1 view .LVU680
 338:le_phy.c      **** 				uint8_t length = dewhiten_length(current_rxbuf->channel, current_rxbuf->data[1]);
 2390              		.loc 1 338 7 is_stmt 0 view .LVU681
 2391 00a4 022A     		cmp	r2, #2
 2392 00a6 3FD0     		beq	.L176
 344:le_phy.c      **** 				// stop the CC2400 before flushing SSP
 2393              		.loc 1 344 4 is_stmt 1 view .LVU682
 344:le_phy.c      **** 				// stop the CC2400 before flushing SSP
 2394              		.loc 1 344 7 is_stmt 0 view .LVU683
 2395 00a8 F4D9     		bls	.L179
 344:le_phy.c      **** 				// stop the CC2400 before flushing SSP
 2396              		.loc 1 344 16 discriminator 1 view .LVU684
 2397 00aa D3F80431 		ldr	r3, [r3, #260]
 2398 00ae 9342     		cmp	r3, r2
 2399 00b0 F0D8     		bhi	.L179
 346:le_phy.c      **** 
 2400              		.loc 1 346 5 is_stmt 1 view .LVU685
 2401 00b2 6120     		movs	r0, #97
 2402 00b4 FFF7FEFF 		bl	cc2400_strobe
 2403              	.LVL192:
 349:le_phy.c      **** 				DMACIntTCClear = (1 << 0); // if we don't clear a second time, data is corrupt
 2404              		.loc 1 349 5 view .LVU686
 349:le_phy.c      **** 				DMACIntTCClear = (1 << 0); // if we don't clear a second time, data is corrupt
 2405              		.loc 1 349 18 is_stmt 0 view .LVU687
 2406 00b8 0022     		movs	r2, #0
 2407 00ba 464B     		ldr	r3, .L194+40
 2408              	.LBB112:
 354:le_phy.c      **** 				}
ARM GAS  /tmp/ccXJY3ni.s 			page 74


 2409              		.loc 1 354 29 view .LVU688
 2410 00bc 4649     		ldr	r1, .L194+44
 2411              	.LBE112:
 349:le_phy.c      **** 				DMACIntTCClear = (1 << 0); // if we don't clear a second time, data is corrupt
 2412              		.loc 1 349 18 view .LVU689
 2413 00be 1A60     		str	r2, [r3]
 350:le_phy.c      **** 
 2414              		.loc 1 350 5 is_stmt 1 view .LVU690
 350:le_phy.c      **** 
 2415              		.loc 1 350 20 is_stmt 0 view .LVU691
 2416 00c0 0123     		movs	r3, #1
 352:le_phy.c      **** 				while (SSP1SR & SSPSR_RNE) {
 2417              		.loc 1 352 19 view .LVU692
 2418 00c2 464A     		ldr	r2, .L194+48
 350:le_phy.c      **** 
 2419              		.loc 1 350 20 view .LVU693
 2420 00c4 3B60     		str	r3, [r7]
 352:le_phy.c      **** 				while (SSP1SR & SSPSR_RNE) {
 2421              		.loc 1 352 5 is_stmt 1 view .LVU694
 352:le_phy.c      **** 				while (SSP1SR & SSPSR_RNE) {
 2422              		.loc 1 352 19 is_stmt 0 view .LVU695
 2423 00c6 1368     		ldr	r3, [r2]
 353:le_phy.c      **** 					uint8_t tmp = (uint8_t)DIO_SSP_DR;
 2424              		.loc 1 353 12 view .LVU696
 2425 00c8 183A     		subs	r2, r2, #24
 352:le_phy.c      **** 				while (SSP1SR & SSPSR_RNE) {
 2426              		.loc 1 352 19 view .LVU697
 2427 00ca 23F00103 		bic	r3, r3, #1
 2428 00ce 9361     		str	r3, [r2, #24]
 353:le_phy.c      **** 					uint8_t tmp = (uint8_t)DIO_SSP_DR;
 2429              		.loc 1 353 5 is_stmt 1 view .LVU698
 2430              	.L180:
 353:le_phy.c      **** 					uint8_t tmp = (uint8_t)DIO_SSP_DR;
 2431              		.loc 1 353 11 view .LVU699
 353:le_phy.c      **** 					uint8_t tmp = (uint8_t)DIO_SSP_DR;
 2432              		.loc 1 353 12 is_stmt 0 view .LVU700
 2433 00d0 1368     		ldr	r3, [r2]
 353:le_phy.c      **** 					uint8_t tmp = (uint8_t)DIO_SSP_DR;
 2434              		.loc 1 353 11 view .LVU701
 2435 00d2 5807     		lsls	r0, r3, #29
 2436 00d4 57D4     		bmi	.L181
 358:le_phy.c      **** 
 2437              		.loc 1 358 5 is_stmt 1 view .LVU702
 358:le_phy.c      **** 
 2438              		.loc 1 358 11 is_stmt 0 view .LVU703
 2439 00d6 4FF08062 		mov	r2, #67108864
 2440 00da 414B     		ldr	r3, .L194+52
 361:le_phy.c      **** 
 2441              		.loc 1 361 5 view .LVU704
 2442 00dc D4F87816 		ldr	r1, [r4, #1656]
 358:le_phy.c      **** 
 2443              		.loc 1 358 11 view .LVU705
 2444 00e0 1A60     		str	r2, [r3]
 361:le_phy.c      **** 
 2445              		.loc 1 361 5 is_stmt 1 view .LVU706
 2446 00e2 4048     		ldr	r0, .L194+56
 2447 00e4 FFF7FEFF 		bl	queue_insert
ARM GAS  /tmp/ccXJY3ni.s 			page 75


 2448              	.LVL193:
 364:le_phy.c      **** 					++conn_event.num_packets;
 2449              		.loc 1 364 5 view .LVU707
 364:le_phy.c      **** 					++conn_event.num_packets;
 2450              		.loc 1 364 9 is_stmt 0 view .LVU708
 2451 00e8 364B     		ldr	r3, .L194+24
 2452 00ea 1888     		ldrh	r0, [r3]
 2453 00ec 80B2     		uxth	r0, r0
 2454 00ee FFF7FEFF 		bl	btle_channel_index
 2455              	.LVL194:
 364:le_phy.c      **** 					++conn_event.num_packets;
 2456              		.loc 1 364 8 view .LVU709
 2457 00f2 2428     		cmp	r0, #36
 2458 00f4 0FD8     		bhi	.L184
 365:le_phy.c      **** 
 2459              		.loc 1 365 6 is_stmt 1 view .LVU710
 365:le_phy.c      **** 
 2460              		.loc 1 365 18 is_stmt 0 view .LVU711
 2461 00f6 3C4A     		ldr	r2, .L194+60
 365:le_phy.c      **** 
 2462              		.loc 1 365 6 view .LVU712
 2463 00f8 5368     		ldr	r3, [r2, #4]
 2464 00fa 0133     		adds	r3, r3, #1
 368:le_phy.c      **** 						conn_event.anchor = current_rxbuf->timestamp;
 2465              		.loc 1 368 9 view .LVU713
 2466 00fc 012B     		cmp	r3, #1
 365:le_phy.c      **** 
 2467              		.loc 1 365 6 view .LVU714
 2468 00fe 5360     		str	r3, [r2, #4]
 368:le_phy.c      **** 						conn_event.anchor = current_rxbuf->timestamp;
 2469              		.loc 1 368 6 is_stmt 1 view .LVU715
 368:le_phy.c      **** 						conn_event.anchor = current_rxbuf->timestamp;
 2470              		.loc 1 368 9 is_stmt 0 view .LVU716
 2471 0100 43D1     		bne	.L183
 369:le_phy.c      **** 						timer1_set_match(NOW + IFS_TIMEOUT); // set a timeout for next packet
 2472              		.loc 1 369 7 is_stmt 1 view .LVU717
 369:le_phy.c      **** 						timer1_set_match(NOW + IFS_TIMEOUT); // set a timeout for next packet
 2473              		.loc 1 369 40 is_stmt 0 view .LVU718
 2474 0102 D4F87836 		ldr	r3, [r4, #1656]
 369:le_phy.c      **** 						timer1_set_match(NOW + IFS_TIMEOUT); // set a timeout for next packet
 2475              		.loc 1 369 25 view .LVU719
 2476 0106 D3F80C31 		ldr	r3, [r3, #268]
 2477 010a 1360     		str	r3, [r2]
 370:le_phy.c      **** 					}
 2478              		.loc 1 370 7 is_stmt 1 view .LVU720
 370:le_phy.c      **** 					}
 2479              		.loc 1 370 24 is_stmt 0 view .LVU721
 2480 010c 2868     		ldr	r0, [r5]
 370:le_phy.c      **** 					}
 2481              		.loc 1 370 7 view .LVU722
 2482 010e 00F6B830 		addw	r0, r0, #3000
 2483 0112 FFF7FEFF 		bl	timer1_set_match
 2484              	.LVL195:
 2485              	.L184:
 385:le_phy.c      **** 				if (current_rxbuf == NULL) {
 2486              		.loc 1 385 5 is_stmt 1 view .LVU723
 385:le_phy.c      **** 				if (current_rxbuf == NULL) {
ARM GAS  /tmp/ccXJY3ni.s 			page 76


 2487              		.loc 1 385 21 is_stmt 0 view .LVU724
 2488 0116 FFF7FEFF 		bl	buffer_get
 2489              	.LVL196:
 385:le_phy.c      **** 				if (current_rxbuf == NULL) {
 2490              		.loc 1 385 19 view .LVU725
 2491 011a C4F87806 		str	r0, [r4, #1656]
 386:le_phy.c      **** 					// if all buffers are in use, wait for one to free up in background
 2492              		.loc 1 386 5 is_stmt 1 view .LVU726
 386:le_phy.c      **** 					// if all buffers are in use, wait for one to free up in background
 2493              		.loc 1 386 8 is_stmt 0 view .LVU727
 2494 011e 0028     		cmp	r0, #0
 2495 0120 40D1     		bne	.L185
 388:le_phy.c      **** 				} else {
 2496              		.loc 1 388 6 is_stmt 1 view .LVU728
 2497 0122 FFF7FEFF 		bl	timer1_wait_buffer
 2498              	.LVL197:
 2499 0126 B5E7     		b	.L179
 2500              	.LVL198:
 2501              	.L176:
 2502              	.LBB113:
 339:le_phy.c      **** 				current_rxbuf->size = length + 2 + 3; // two bytes for header and three for CRC
 2503              		.loc 1 339 5 view .LVU729
 2504              	.LBB114:
 2505              	.LBB115:
 729:le_phy.c      **** 	uint8_t out = 0;
 2506              		.loc 1 729 28 is_stmt 0 view .LVU730
 2507 0128 B3F81001 		ldrh	r0, [r3, #272]
 2508              	.LBE115:
 2509              	.LBE114:
 339:le_phy.c      **** 				current_rxbuf->size = length + 2 + 3; // two bytes for header and three for CRC
 2510              		.loc 1 339 22 view .LVU731
 2511 012c 5E78     		ldrb	r6, [r3, #1]	@ zero_extendqisi2
 2512              	.LVL199:
 2513              	.LBB117:
 2514              	.LBI114:
 727:le_phy.c      **** 	unsigned int i, bit;
 2515              		.loc 1 727 16 is_stmt 1 view .LVU732
 2516              	.LBB116:
 728:le_phy.c      **** 	int idx = whitening_index[btle_channel_index(channel)];
 2517              		.loc 1 728 2 view .LVU733
 729:le_phy.c      **** 	uint8_t out = 0;
 2518              		.loc 1 729 2 view .LVU734
 729:le_phy.c      **** 	uint8_t out = 0;
 2519              		.loc 1 729 28 is_stmt 0 view .LVU735
 2520 012e FFF7FEFF 		bl	btle_channel_index
 2521              	.LVL200:
 730:le_phy.c      **** 
 2522              		.loc 1 730 2 is_stmt 1 view .LVU736
 733:le_phy.c      **** 
 2523              		.loc 1 733 2 view .LVU737
 733:le_phy.c      **** 
 2524              		.loc 1 733 18 is_stmt 0 view .LVU738
 2525 0132 7F27     		movs	r7, #127
 730:le_phy.c      **** 
 2526              		.loc 1 730 10 view .LVU739
 2527 0134 0021     		movs	r1, #0
 729:le_phy.c      **** 	uint8_t out = 0;
ARM GAS  /tmp/ccXJY3ni.s 			page 77


 2528              		.loc 1 729 27 view .LVU740
 2529 0136 2D4D     		ldr	r5, .L194+64
 729:le_phy.c      **** 	uint8_t out = 0;
 2530              		.loc 1 729 6 view .LVU741
 2531 0138 2B5C     		ldrb	r3, [r5, r0]	@ zero_extendqisi2
 2532 013a AC46     		mov	ip, r5
 733:le_phy.c      **** 
 2533              		.loc 1 733 13 view .LVU742
 2534 013c 0833     		adds	r3, r3, #8
 733:le_phy.c      **** 
 2535              		.loc 1 733 18 view .LVU743
 2536 013e B3FBF7F2 		udiv	r2, r3, r7
 735:le_phy.c      **** 		bit = (data >> (7-i)) & 1;
 2537              		.loc 1 735 9 view .LVU744
 2538 0142 0846     		mov	r0, r1
 2539              	.LVL201:
 733:le_phy.c      **** 
 2540              		.loc 1 733 18 view .LVU745
 2541 0144 C2EBC212 		rsb	r2, r2, r2, lsl #7
 2542 0148 9B1A     		subs	r3, r3, r2
 2543              	.LVL202:
 735:le_phy.c      **** 		bit = (data >> (7-i)) & 1;
 2544              		.loc 1 735 2 is_stmt 1 view .LVU746
 735:le_phy.c      **** 		bit = (data >> (7-i)) & 1;
 2545              		.loc 1 735 14 view .LVU747
 2546              	.L178:
 736:le_phy.c      **** 		bit ^= whitening[idx];
 2547              		.loc 1 736 3 view .LVU748
 736:le_phy.c      **** 		bit ^= whitening[idx];
 2548              		.loc 1 736 20 is_stmt 0 view .LVU749
 2549 014a C0F10702 		rsb	r2, r0, #7
 736:le_phy.c      **** 		bit ^= whitening[idx];
 2550              		.loc 1 736 15 view .LVU750
 2551 014e 46FA02F2 		asr	r2, r6, r2
 736:le_phy.c      **** 		bit ^= whitening[idx];
 2552              		.loc 1 736 7 view .LVU751
 2553 0152 02F00105 		and	r5, r2, #1
 2554              	.LVL203:
 737:le_phy.c      **** 		idx = (idx + 1) % sizeof(whitening);
 2555              		.loc 1 737 3 is_stmt 1 view .LVU752
 737:le_phy.c      **** 		idx = (idx + 1) % sizeof(whitening);
 2556              		.loc 1 737 19 is_stmt 0 view .LVU753
 2557 0156 0CEB0302 		add	r2, ip, r3
 2558 015a 92F82820 		ldrb	r2, [r2, #40]	@ zero_extendqisi2
 738:le_phy.c      **** 		out |= bit << i;
 2559              		.loc 1 738 14 view .LVU754
 2560 015e 0133     		adds	r3, r3, #1
 2561              	.LVL204:
 737:le_phy.c      **** 		idx = (idx + 1) % sizeof(whitening);
 2562              		.loc 1 737 7 view .LVU755
 2563 0160 6A40     		eors	r2, r2, r5
 2564              	.LVL205:
 738:le_phy.c      **** 		out |= bit << i;
 2565              		.loc 1 738 3 is_stmt 1 view .LVU756
 738:le_phy.c      **** 		out |= bit << i;
 2566              		.loc 1 738 19 is_stmt 0 view .LVU757
 2567 0162 B3FBF7F5 		udiv	r5, r3, r7
ARM GAS  /tmp/ccXJY3ni.s 			page 78


 739:le_phy.c      **** 	}
 2568              		.loc 1 739 14 view .LVU758
 2569 0166 8240     		lsls	r2, r2, r0
 2570              	.LVL206:
 735:le_phy.c      **** 		bit = (data >> (7-i)) & 1;
 2571              		.loc 1 735 21 view .LVU759
 2572 0168 0130     		adds	r0, r0, #1
 2573              	.LVL207:
 738:le_phy.c      **** 		out |= bit << i;
 2574              		.loc 1 738 19 view .LVU760
 2575 016a C5EBC515 		rsb	r5, r5, r5, lsl #7
 739:le_phy.c      **** 	}
 2576              		.loc 1 739 7 view .LVU761
 2577 016e 0A43     		orrs	r2, r2, r1
 735:le_phy.c      **** 		bit = (data >> (7-i)) & 1;
 2578              		.loc 1 735 2 view .LVU762
 2579 0170 0828     		cmp	r0, #8
 738:le_phy.c      **** 		out |= bit << i;
 2580              		.loc 1 738 19 view .LVU763
 2581 0172 A3EB0503 		sub	r3, r3, r5
 2582              	.LVL208:
 739:le_phy.c      **** 	}
 2583              		.loc 1 739 3 is_stmt 1 view .LVU764
 739:le_phy.c      **** 	}
 2584              		.loc 1 739 7 is_stmt 0 view .LVU765
 2585 0176 D1B2     		uxtb	r1, r2
 2586              	.LVL209:
 735:le_phy.c      **** 		bit = (data >> (7-i)) & 1;
 2587              		.loc 1 735 21 is_stmt 1 view .LVU766
 735:le_phy.c      **** 		bit = (data >> (7-i)) & 1;
 2588              		.loc 1 735 14 view .LVU767
 735:le_phy.c      **** 		bit = (data >> (7-i)) & 1;
 2589              		.loc 1 735 2 is_stmt 0 view .LVU768
 2590 0178 E7D1     		bne	.L178
 742:le_phy.c      **** }
 2591              		.loc 1 742 2 is_stmt 1 view .LVU769
 2592              	.LVL210:
 742:le_phy.c      **** }
 2593              		.loc 1 742 2 is_stmt 0 view .LVU770
 2594              	.LBE116:
 2595              	.LBE117:
 340:le_phy.c      **** 			}
 2596              		.loc 1 340 5 is_stmt 1 view .LVU771
 340:le_phy.c      **** 			}
 2597              		.loc 1 340 25 is_stmt 0 view .LVU772
 2598 017a D4F87836 		ldr	r3, [r4, #1656]
 340:le_phy.c      **** 			}
 2599              		.loc 1 340 38 view .LVU773
 2600 017e 0531     		adds	r1, r1, #5
 2601              	.LVL211:
 340:le_phy.c      **** 			}
 2602              		.loc 1 340 25 view .LVU774
 2603 0180 C3F80411 		str	r1, [r3, #260]
 2604              	.LBE113:
 344:le_phy.c      **** 				// stop the CC2400 before flushing SSP
 2605              		.loc 1 344 4 is_stmt 1 view .LVU775
 2606 0184 86E7     		b	.L179
ARM GAS  /tmp/ccXJY3ni.s 			page 79


 2607              	.LVL212:
 2608              	.L181:
 2609              	.LBB118:
 354:le_phy.c      **** 				}
 2610              		.loc 1 354 6 view .LVU776
 354:le_phy.c      **** 				}
 2611              		.loc 1 354 29 is_stmt 0 view .LVU777
 2612 0186 0B68     		ldr	r3, [r1]
 2613 0188 A2E7     		b	.L180
 2614              	.L183:
 2615              	.LBE118:
 374:le_phy.c      **** 						cc2400_strobe(SRFOFF);
 2616              		.loc 1 374 11 is_stmt 1 view .LVU778
 374:le_phy.c      **** 						cc2400_strobe(SRFOFF);
 2617              		.loc 1 374 14 is_stmt 0 view .LVU779
 2618 018a 022B     		cmp	r3, #2
 2619 018c C3D1     		bne	.L184
 375:le_phy.c      **** 						current_rxbuf = buffer_get();
 2620              		.loc 1 375 7 is_stmt 1 view .LVU780
 2621 018e 6420     		movs	r0, #100
 2622 0190 FFF7FEFF 		bl	cc2400_strobe
 2623              	.LVL213:
 376:le_phy.c      **** 						// TODO handle NULL
 2624              		.loc 1 376 7 view .LVU781
 376:le_phy.c      **** 						// TODO handle NULL
 2625              		.loc 1 376 23 is_stmt 0 view .LVU782
 2626 0194 FFF7FEFF 		bl	buffer_get
 2627              	.LVL214:
 376:le_phy.c      **** 						// TODO handle NULL
 2628              		.loc 1 376 21 view .LVU783
 2629 0198 C4F87806 		str	r0, [r4, #1656]
 378:le_phy.c      **** 						return;
 2630              		.loc 1 378 7 is_stmt 1 view .LVU784
 402:le_phy.c      **** 
 2631              		.loc 1 402 1 is_stmt 0 view .LVU785
 2632 019c BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 2633              		.cfi_remember_state
 2634              		.cfi_restore 14
 2635              		.cfi_restore 7
 2636              		.cfi_restore 6
 2637              		.cfi_restore 5
 2638              		.cfi_restore 4
 2639              		.cfi_restore 3
 2640              		.cfi_def_cfa_offset 0
 2641              	.LVL215:
 378:le_phy.c      **** 						return;
 2642              		.loc 1 378 7 view .LVU786
 2643 01a0 FFF7FEBF 		b	finish_conn_event
 2644              	.LVL216:
 2645              	.L185:
 2646              		.cfi_restore_state
 391:le_phy.c      **** 				}
 2647              		.loc 1 391 6 is_stmt 1 view .LVU787
 2648 01a4 FFF7FEFF 		bl	timer1_wait_fs_lock
 2649              	.LVL217:
 2650 01a8 74E7     		b	.L179
 2651              	.L195:
ARM GAS  /tmp/ccXJY3ni.s 			page 80


 2652 01aa 00BF     		.align	2
 2653              	.L194:
 2654 01ac 08800040 		.word	1073774600
 2655 01b0 00400050 		.word	1342193664
 2656 01b4 04400050 		.word	1342193668
 2657 01b8 08400050 		.word	1342193672
 2658 01bc 00000000 		.word	.LANCHOR0
 2659 01c0 00000000 		.word	le_dma_dest
 2660 01c4 00000000 		.word	rf_channel
 2661 01c8 14800040 		.word	1073774612
 2662 01cc 0C400050 		.word	1342193676
 2663 01d0 10400050 		.word	1342193680
 2664 01d4 10410050 		.word	1342193936
 2665 01d8 08000340 		.word	1073938440
 2666 01dc 24000340 		.word	1073938468
 2667 01e0 80E100E0 		.word	-536813184
 2668 01e4 00000000 		.word	packet_queue
 2669 01e8 00000000 		.word	conn_event
 2670 01ec 00000000 		.word	.LANCHOR1
 2671              		.cfi_endproc
 2672              	.LFE16:
 2674              		.section	.text.TIMER1_IRQHandler,"ax",%progbits
 2675              		.align	1
 2676              		.global	TIMER1_IRQHandler
 2677              		.syntax unified
 2678              		.thumb
 2679              		.thumb_func
 2680              		.fpu softvfp
 2682              	TIMER1_IRQHandler:
 2683              	.LFB30:
 583:le_phy.c      **** 	// MR0: connection events
 2684              		.loc 1 583 30 view -0
 2685              		.cfi_startproc
 2686              		@ args = 0, pretend = 0, frame = 0
 2687              		@ frame_needed = 0, uses_anonymous_args = 0
 2688 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2689              		.cfi_def_cfa_offset 24
 2690              		.cfi_offset 3, -24
 2691              		.cfi_offset 4, -20
 2692              		.cfi_offset 5, -16
 2693              		.cfi_offset 6, -12
 2694              		.cfi_offset 7, -8
 2695              		.cfi_offset 14, -4
 585:le_phy.c      **** 		// ack the interrupt
 2696              		.loc 1 585 2 view .LVU789
 585:le_phy.c      **** 		// ack the interrupt
 2697              		.loc 1 585 6 is_stmt 0 view .LVU790
 2698 0002 5E4B     		ldr	r3, .L229
 2699 0004 1A68     		ldr	r2, [r3]
 585:le_phy.c      **** 		// ack the interrupt
 2700              		.loc 1 585 5 view .LVU791
 2701 0006 D507     		lsls	r5, r2, #31
 2702 0008 56D5     		bpl	.L197
 587:le_phy.c      **** 
 2703              		.loc 1 587 3 is_stmt 1 view .LVU792
 587:le_phy.c      **** 
 2704              		.loc 1 587 8 is_stmt 0 view .LVU793
ARM GAS  /tmp/ccXJY3ni.s 			page 81


 2705 000a 0127     		movs	r7, #1
 2706 000c 1F60     		str	r7, [r3]
 590:le_phy.c      **** 				conn.conn_event_counter == conn.conn_update_instant) {
 2707              		.loc 1 590 3 is_stmt 1 view .LVU794
 590:le_phy.c      **** 				conn.conn_event_counter == conn.conn_update_instant) {
 2708              		.loc 1 590 11 is_stmt 0 view .LVU795
 2709 000e 5C4B     		ldr	r3, .L229+4
 2710 0010 5C49     		ldr	r1, .L229+8
 590:le_phy.c      **** 				conn.conn_event_counter == conn.conn_update_instant) {
 2711              		.loc 1 590 6 view .LVU796
 2712 0012 D3F81021 		ldr	r2, [r3, #272]
 2713 0016 0D46     		mov	r5, r1
 2714 0018 1C46     		mov	r4, r3
 2715 001a 8E68     		ldr	r6, [r1, #8]
 2716 001c 6AB3     		cbz	r2, .L198
 590:le_phy.c      **** 				conn.conn_event_counter == conn.conn_update_instant) {
 2717              		.loc 1 590 32 discriminator 1 view .LVU797
 2718 001e B3F80C01 		ldrh	r0, [r3, #268]
 2719 0022 B3F81C21 		ldrh	r2, [r3, #284]
 2720 0026 9042     		cmp	r0, r2
 2721 0028 27D1     		bne	.L198
 595:le_phy.c      **** 				timer1_set_match(conn.last_anchor + conn.conn_interval +
 2722              		.loc 1 595 4 is_stmt 1 view .LVU798
 2723 002a DA6B     		ldr	r2, [r3, #60]
 2724 002c D3F80001 		ldr	r0, [r3, #256]
 2725 0030 1044     		add	r0, r0, r2
 595:le_phy.c      **** 				timer1_set_match(conn.last_anchor + conn.conn_interval +
 2726              		.loc 1 595 7 is_stmt 0 view .LVU799
 2727 0032 46B9     		cbnz	r6, .L199
 595:le_phy.c      **** 				timer1_set_match(conn.last_anchor + conn.conn_interval +
 2728              		.loc 1 595 27 discriminator 1 view .LVU800
 2729 0034 3AB1     		cbz	r2, .L199
 596:le_phy.c      **** 						conn.win_offset - RX_WARMUP_TIME);
 2730              		.loc 1 596 5 is_stmt 1 view .LVU801
 2731 0036 1B6B     		ldr	r3, [r3, #48]
 2732 0038 A0F6B830 		subw	r0, r0, #3000
 2733 003c 1844     		add	r0, r0, r3
 2734 003e FFF7FEFF 		bl	timer1_set_match
 2735              	.LVL218:
 598:le_phy.c      **** 			}
 2736              		.loc 1 598 5 view .LVU802
 598:le_phy.c      **** 			}
 2737              		.loc 1 598 23 is_stmt 0 view .LVU803
 2738 0042 8F60     		str	r7, [r1, #8]
 2739              	.L196:
 710:le_phy.c      **** 
 2740              		.loc 1 710 1 view .LVU804
 2741 0044 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2742              	.L199:
 605:le_phy.c      **** 
 2743              		.loc 1 605 5 is_stmt 1 view .LVU805
 605:le_phy.c      **** 
 2744              		.loc 1 605 23 is_stmt 0 view .LVU806
 2745 0046 0123     		movs	r3, #1
 609:le_phy.c      **** 				conn.conn_interval = conn.conn_update_pending_interval;
 2746              		.loc 1 609 21 view .LVU807
 2747 0048 0022     		movs	r2, #0
ARM GAS  /tmp/ccXJY3ni.s 			page 82


 605:le_phy.c      **** 
 2748              		.loc 1 605 23 view .LVU808
 2749 004a AB60     		str	r3, [r5, #8]
 609:le_phy.c      **** 				conn.conn_interval = conn.conn_update_pending_interval;
 2750              		.loc 1 609 5 is_stmt 1 view .LVU809
 615:le_phy.c      **** 						conn.win_offset + conn.win_size + USEC(2120));
 2751              		.loc 1 615 5 is_stmt 0 view .LVU810
 2752 004c 00F5A540 		add	r0, r0, #21120
 610:le_phy.c      **** 				conn.supervision_timeout = conn.conn_update_pending_supervision_timeout;
 2753              		.loc 1 610 30 view .LVU811
 2754 0050 D4F81431 		ldr	r3, [r4, #276]
 615:le_phy.c      **** 						conn.win_offset + conn.win_size + USEC(2120));
 2755              		.loc 1 615 5 view .LVU812
 2756 0054 5030     		adds	r0, r0, #80
 610:le_phy.c      **** 				conn.supervision_timeout = conn.conn_update_pending_supervision_timeout;
 2757              		.loc 1 610 24 view .LVU813
 2758 0056 2363     		str	r3, [r4, #48]
 615:le_phy.c      **** 						conn.win_offset + conn.win_size + USEC(2120));
 2759              		.loc 1 615 5 view .LVU814
 2760 0058 1844     		add	r0, r0, r3
 616:le_phy.c      **** 				change_channel();
 2761              		.loc 1 616 29 view .LVU815
 2762 005a 94F83830 		ldrb	r3, [r4, #56]	@ zero_extendqisi2
 611:le_phy.c      **** 				conn.conn_update_pending = 0;
 2763              		.loc 1 611 30 view .LVU816
 2764 005e D4F81811 		ldr	r1, [r4, #280]
 615:le_phy.c      **** 						conn.win_offset + conn.win_size + USEC(2120));
 2765              		.loc 1 615 5 view .LVU817
 2766 0062 1844     		add	r0, r0, r3
 609:le_phy.c      **** 				conn.conn_interval = conn.conn_update_pending_interval;
 2767              		.loc 1 609 21 view .LVU818
 2768 0064 C4F80421 		str	r2, [r4, #260]
 610:le_phy.c      **** 				conn.supervision_timeout = conn.conn_update_pending_supervision_timeout;
 2769              		.loc 1 610 5 is_stmt 1 view .LVU819
 611:le_phy.c      **** 				conn.conn_update_pending = 0;
 2770              		.loc 1 611 5 view .LVU820
 611:le_phy.c      **** 				conn.conn_update_pending = 0;
 2771              		.loc 1 611 30 is_stmt 0 view .LVU821
 2772 0068 6163     		str	r1, [r4, #52]
 612:le_phy.c      **** 
 2773              		.loc 1 612 5 is_stmt 1 view .LVU822
 612:le_phy.c      **** 
 2774              		.loc 1 612 30 is_stmt 0 view .LVU823
 2775 006a C4F81021 		str	r2, [r4, #272]
 615:le_phy.c      **** 						conn.win_offset + conn.win_size + USEC(2120));
 2776              		.loc 1 615 5 is_stmt 1 view .LVU824
 2777 006e FFF7FEFF 		bl	timer1_set_match
 2778              	.LVL219:
 617:le_phy.c      **** 			}
 2779              		.loc 1 617 5 view .LVU825
 710:le_phy.c      **** 
 2780              		.loc 1 710 1 is_stmt 0 view .LVU826
 2781 0072 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 2782              		.cfi_remember_state
 2783              		.cfi_restore 14
 2784              		.cfi_restore 7
 2785              		.cfi_restore 6
ARM GAS  /tmp/ccXJY3ni.s 			page 83


 2786              		.cfi_restore 5
 2787              		.cfi_restore 4
 2788              		.cfi_restore 3
 2789              		.cfi_def_cfa_offset 0
 617:le_phy.c      **** 			}
 2790              		.loc 1 617 5 view .LVU827
 2791 0076 FFF7FEBF 		b	change_channel
 2792              	.LVL220:
 2793              	.L198:
 2794              		.cfi_restore_state
 623:le_phy.c      **** 				conn.conn_event_counter == conn.channel_map_update_instant) {
 2795              		.loc 1 623 3 is_stmt 1 view .LVU828
 623:le_phy.c      **** 				conn.conn_event_counter == conn.channel_map_update_instant) {
 2796              		.loc 1 623 6 is_stmt 0 view .LVU829
 2797 007a D4F82031 		ldr	r3, [r4, #288]
 2798 007e 73B1     		cbz	r3, .L201
 623:le_phy.c      **** 				conn.conn_event_counter == conn.channel_map_update_instant) {
 2799              		.loc 1 623 39 discriminator 1 view .LVU830
 2800 0080 B4F80C21 		ldrh	r2, [r4, #268]
 2801 0084 B4F82431 		ldrh	r3, [r4, #292]
 2802 0088 9A42     		cmp	r2, r3
 2803 008a 08D1     		bne	.L201
 625:le_phy.c      **** 			conn.channel_map_update_pending = 0;
 2804              		.loc 1 625 4 is_stmt 1 view .LVU831
 625:le_phy.c      **** 			conn.channel_map_update_pending = 0;
 2805              		.loc 1 625 19 is_stmt 0 view .LVU832
 2806 008c 3E49     		ldr	r1, .L229+12
 2807 008e C022     		movs	r2, #192
 2808 0090 A1F1E800 		sub	r0, r1, #232
 2809 0094 FFF7FEFF 		bl	memcpy
 2810              	.LVL221:
 626:le_phy.c      **** 		}
 2811              		.loc 1 626 4 is_stmt 1 view .LVU833
 626:le_phy.c      **** 		}
 2812              		.loc 1 626 36 is_stmt 0 view .LVU834
 2813 0098 0023     		movs	r3, #0
 2814 009a C4F82031 		str	r3, [r4, #288]
 2815              	.L201:
 630:le_phy.c      **** 			conn_event.opened = 1;
 2816              		.loc 1 630 3 is_stmt 1 view .LVU835
 630:le_phy.c      **** 			conn_event.opened = 1;
 2817              		.loc 1 630 6 is_stmt 0 view .LVU836
 2818 009e 002E     		cmp	r6, #0
 2819 00a0 4CD1     		bne	.L202
 631:le_phy.c      **** 			// timeout is max packet length + warmup time (slack)
 2820              		.loc 1 631 4 is_stmt 1 view .LVU837
 631:le_phy.c      **** 			// timeout is max packet length + warmup time (slack)
 2821              		.loc 1 631 22 is_stmt 0 view .LVU838
 2822 00a2 0123     		movs	r3, #1
 2823 00a4 AB60     		str	r3, [r5, #8]
 633:le_phy.c      **** 			change_channel();
 2824              		.loc 1 633 4 is_stmt 1 view .LVU839
 633:le_phy.c      **** 			change_channel();
 2825              		.loc 1 633 21 is_stmt 0 view .LVU840
 2826 00a6 394B     		ldr	r3, .L229+16
 2827 00a8 1868     		ldr	r0, [r3]
 633:le_phy.c      **** 			change_channel();
ARM GAS  /tmp/ccXJY3ni.s 			page 84


 2828              		.loc 1 633 4 view .LVU841
 2829 00aa 00F5BD40 		add	r0, r0, #24192
 2830 00ae 0830     		adds	r0, r0, #8
 2831 00b0 FFF7FEFF 		bl	timer1_set_match
 2832              	.LVL222:
 634:le_phy.c      **** 		}
 2833              		.loc 1 634 4 is_stmt 1 view .LVU842
 2834 00b4 FFF7FEFF 		bl	change_channel
 2835              	.LVL223:
 2836              	.L197:
 660:le_phy.c      **** 		T1IR = TIR_MR1_Interrupt;
 2837              		.loc 1 660 2 view .LVU843
 660:le_phy.c      **** 		T1IR = TIR_MR1_Interrupt;
 2838              		.loc 1 660 6 is_stmt 0 view .LVU844
 2839 00b8 304B     		ldr	r3, .L229
 2840 00ba 1A68     		ldr	r2, [r3]
 660:le_phy.c      **** 		T1IR = TIR_MR1_Interrupt;
 2841              		.loc 1 660 5 view .LVU845
 2842 00bc 9407     		lsls	r4, r2, #30
 2843 00be 0DD5     		bpl	.L203
 661:le_phy.c      **** 		T1MCR &= ~TMCR_MR1I;
 2844              		.loc 1 661 3 is_stmt 1 view .LVU846
 661:le_phy.c      **** 		T1MCR &= ~TMCR_MR1I;
 2845              		.loc 1 661 8 is_stmt 0 view .LVU847
 2846 00c0 0222     		movs	r2, #2
 662:le_phy.c      **** 
 2847              		.loc 1 662 9 view .LVU848
 2848 00c2 3349     		ldr	r1, .L229+20
 661:le_phy.c      **** 		T1MCR &= ~TMCR_MR1I;
 2849              		.loc 1 661 8 view .LVU849
 2850 00c4 1A60     		str	r2, [r3]
 662:le_phy.c      **** 
 2851              		.loc 1 662 3 is_stmt 1 view .LVU850
 662:le_phy.c      **** 
 2852              		.loc 1 662 9 is_stmt 0 view .LVU851
 2853 00c6 0B68     		ldr	r3, [r1]
 2854 00c8 23F00803 		bic	r3, r3, #8
 2855 00cc 0B60     		str	r3, [r1]
 664:le_phy.c      **** 		RXLED_CLR;
 2856              		.loc 1 664 3 is_stmt 1 view .LVU852
 2857 00ce 4FF48071 		mov	r1, #256
 2858 00d2 304B     		ldr	r3, .L229+24
 2859 00d4 1960     		str	r1, [r3]
 665:le_phy.c      **** 		USRLED_CLR;
 2860              		.loc 1 665 3 view .LVU853
 2861 00d6 1021     		movs	r1, #16
 2862 00d8 1960     		str	r1, [r3]
 666:le_phy.c      **** 	}
 2863              		.loc 1 666 3 view .LVU854
 2864 00da 1A60     		str	r2, [r3]
 2865              	.L203:
 670:le_phy.c      **** 		T1IR = TIR_MR2_Interrupt;
 2866              		.loc 1 670 2 view .LVU855
 670:le_phy.c      **** 		T1IR = TIR_MR2_Interrupt;
 2867              		.loc 1 670 6 is_stmt 0 view .LVU856
 2868 00dc 274B     		ldr	r3, .L229
 2869 00de 1A68     		ldr	r2, [r3]
ARM GAS  /tmp/ccXJY3ni.s 			page 85


 670:le_phy.c      **** 		T1IR = TIR_MR2_Interrupt;
 2870              		.loc 1 670 5 view .LVU857
 2871 00e0 5007     		lsls	r0, r2, #29
 2872 00e2 1BD5     		bpl	.L204
 671:le_phy.c      **** 
 2873              		.loc 1 671 3 is_stmt 1 view .LVU858
 671:le_phy.c      **** 
 2874              		.loc 1 671 8 is_stmt 0 view .LVU859
 2875 00e4 0422     		movs	r2, #4
 2876 00e6 1A60     		str	r2, [r3]
 674:le_phy.c      **** 			// restart DMA and SSP
 2877              		.loc 1 674 3 is_stmt 1 view .LVU860
 674:le_phy.c      **** 			// restart DMA and SSP
 2878              		.loc 1 674 7 is_stmt 0 view .LVU861
 2879 00e8 FFF7FEFF 		bl	cc2400_status
 2880              	.LVL224:
 674:le_phy.c      **** 			// restart DMA and SSP
 2881              		.loc 1 674 6 view .LVU862
 2882 00ec 4107     		lsls	r1, r0, #29
 2883 00ee 28D5     		bpl	.L205
 676:le_phy.c      **** 			dio_ssp_start();
 2884              		.loc 1 676 4 is_stmt 1 view .LVU863
 2885 00f0 FFF7FEFF 		bl	le_dma_init
 2886              	.LVL225:
 677:le_phy.c      **** 			ISER0 = ISER0_ISE_DMA;
 2887              		.loc 1 677 4 view .LVU864
 2888 00f4 FFF7FEFF 		bl	dio_ssp_start
 2889              	.LVL226:
 678:le_phy.c      **** 
 2890              		.loc 1 678 4 view .LVU865
 678:le_phy.c      **** 
 2891              		.loc 1 678 10 is_stmt 0 view .LVU866
 2892 00f8 4FF08062 		mov	r2, #67108864
 2893 00fc 264B     		ldr	r3, .L229+28
 2894              	.LBB123:
 2895              	.LBB124:
 497:le_phy.c      **** #ifdef UBERTOOTH_ONE
 2896              		.loc 1 497 2 view .LVU867
 2897 00fe 6220     		movs	r0, #98
 2898              	.LBE124:
 2899              	.LBE123:
 678:le_phy.c      **** 
 2900              		.loc 1 678 10 view .LVU868
 2901 0100 1A60     		str	r2, [r3]
 680:le_phy.c      **** 			T1MCR &= ~TMCR_MR2I;
 2902              		.loc 1 680 4 is_stmt 1 view .LVU869
 2903              	.LBB126:
 2904              	.LBI123:
 496:le_phy.c      **** 	cc2400_strobe(SRX);
 2905              		.loc 1 496 13 view .LVU870
 2906              	.LBB125:
 497:le_phy.c      **** #ifdef UBERTOOTH_ONE
 2907              		.loc 1 497 2 view .LVU871
 2908 0102 FFF7FEFF 		bl	cc2400_strobe
 2909              	.LVL227:
 499:le_phy.c      **** 	HGM_SET;
 2910              		.loc 1 499 2 view .LVU872
ARM GAS  /tmp/ccXJY3ni.s 			page 86


 2911 0106 8022     		movs	r2, #128
 2912 0108 244B     		ldr	r3, .L229+32
 2913 010a 1A60     		str	r2, [r3]
 500:le_phy.c      **** #endif
 2914              		.loc 1 500 2 view .LVU873
 2915 010c 4FF48072 		mov	r2, #256
 2916 0110 1A60     		str	r2, [r3]
 2917              	.LBE125:
 2918              	.LBE126:
 681:le_phy.c      **** 		}
 2919              		.loc 1 681 4 view .LVU874
 681:le_phy.c      **** 		}
 2920              		.loc 1 681 10 is_stmt 0 view .LVU875
 2921 0112 1F4A     		ldr	r2, .L229+20
 2922 0114 1368     		ldr	r3, [r2]
 2923 0116 23F04003 		bic	r3, r3, #64
 2924 011a 1360     		str	r3, [r2]
 2925              	.L204:
 691:le_phy.c      **** 		T1IR = TIR_MR3_Interrupt;
 2926              		.loc 1 691 2 is_stmt 1 view .LVU876
 691:le_phy.c      **** 		T1IR = TIR_MR3_Interrupt;
 2927              		.loc 1 691 6 is_stmt 0 view .LVU877
 2928 011c 174B     		ldr	r3, .L229
 2929 011e 1A68     		ldr	r2, [r3]
 691:le_phy.c      **** 		T1IR = TIR_MR3_Interrupt;
 2930              		.loc 1 691 5 view .LVU878
 2931 0120 1207     		lsls	r2, r2, #28
 2932 0122 8FD5     		bpl	.L196
 692:le_phy.c      **** 
 2933              		.loc 1 692 3 is_stmt 1 view .LVU879
 692:le_phy.c      **** 
 2934              		.loc 1 692 8 is_stmt 0 view .LVU880
 2935 0124 0822     		movs	r2, #8
 2936 0126 1A60     		str	r2, [r3]
 694:le_phy.c      **** 		if (current_rxbuf == NULL) {
 2937              		.loc 1 694 3 is_stmt 1 view .LVU881
 694:le_phy.c      **** 		if (current_rxbuf == NULL) {
 2938              		.loc 1 694 19 is_stmt 0 view .LVU882
 2939 0128 FFF7FEFF 		bl	buffer_get
 2940              	.LVL228:
 694:le_phy.c      **** 		if (current_rxbuf == NULL) {
 2941              		.loc 1 694 17 view .LVU883
 2942 012c 144B     		ldr	r3, .L229+4
 2943 012e C3F87806 		str	r0, [r3, #1656]
 695:le_phy.c      **** 			timer1_wait_buffer();
 2944              		.loc 1 695 3 is_stmt 1 view .LVU884
 695:le_phy.c      **** 			timer1_wait_buffer();
 2945              		.loc 1 695 6 is_stmt 0 view .LVU885
 2946 0132 48B9     		cbnz	r0, .L206
 696:le_phy.c      **** 		} else {
 2947              		.loc 1 696 4 is_stmt 1 view .LVU886
 710:le_phy.c      **** 
 2948              		.loc 1 710 1 is_stmt 0 view .LVU887
 2949 0134 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 2950              		.cfi_remember_state
 2951              		.cfi_restore 14
 2952              		.cfi_restore 7
ARM GAS  /tmp/ccXJY3ni.s 			page 87


 2953              		.cfi_restore 6
 2954              		.cfi_restore 5
 2955              		.cfi_restore 4
 2956              		.cfi_restore 3
 2957              		.cfi_def_cfa_offset 0
 696:le_phy.c      **** 		} else {
 2958              		.loc 1 696 4 view .LVU888
 2959 0138 FFF7FEBF 		b	timer1_wait_buffer
 2960              	.LVL229:
 2961              	.L202:
 2962              		.cfi_restore_state
 644:le_phy.c      **** 				conn_event.opened = 1;
 2963              		.loc 1 644 4 is_stmt 1 view .LVU889
 654:le_phy.c      **** 			}
 2964              		.loc 1 654 5 view .LVU890
 2965 013c FFF7FEFF 		bl	finish_conn_event
 2966              	.LVL230:
 2967 0140 BAE7     		b	.L197
 2968              	.L205:
 686:le_phy.c      **** 		}
 2969              		.loc 1 686 4 view .LVU891
 2970 0142 FFF7FEFF 		bl	timer1_wait_fs_lock
 2971              	.LVL231:
 2972 0146 E9E7     		b	.L204
 2973              	.L206:
 698:le_phy.c      **** 				// restart DMA and SSP
 2974              		.loc 1 698 4 view .LVU892
 698:le_phy.c      **** 				// restart DMA and SSP
 2975              		.loc 1 698 8 is_stmt 0 view .LVU893
 2976 0148 FFF7FEFF 		bl	cc2400_status
 2977              	.LVL232:
 698:le_phy.c      **** 				// restart DMA and SSP
 2978              		.loc 1 698 7 view .LVU894
 2979 014c 4307     		lsls	r3, r0, #29
 2980 014e 11D5     		bpl	.L207
 700:le_phy.c      **** 				dio_ssp_start();
 2981              		.loc 1 700 5 is_stmt 1 view .LVU895
 2982 0150 FFF7FEFF 		bl	le_dma_init
 2983              	.LVL233:
 701:le_phy.c      **** 				ISER0 = ISER0_ISE_DMA;
 2984              		.loc 1 701 5 view .LVU896
 2985 0154 FFF7FEFF 		bl	dio_ssp_start
 2986              	.LVL234:
 702:le_phy.c      **** 
 2987              		.loc 1 702 5 view .LVU897
 702:le_phy.c      **** 
 2988              		.loc 1 702 11 is_stmt 0 view .LVU898
 2989 0158 4FF08062 		mov	r2, #67108864
 2990 015c 0E4B     		ldr	r3, .L229+28
 2991              	.LBB127:
 2992              	.LBB128:
 497:le_phy.c      **** #ifdef UBERTOOTH_ONE
 2993              		.loc 1 497 2 view .LVU899
 2994 015e 6220     		movs	r0, #98
 2995              	.LBE128:
 2996              	.LBE127:
 702:le_phy.c      **** 
ARM GAS  /tmp/ccXJY3ni.s 			page 88


 2997              		.loc 1 702 11 view .LVU900
 2998 0160 1A60     		str	r2, [r3]
 704:le_phy.c      **** 			} else {
 2999              		.loc 1 704 5 is_stmt 1 view .LVU901
 3000              	.LBB130:
 3001              	.LBI127:
 496:le_phy.c      **** 	cc2400_strobe(SRX);
 3002              		.loc 1 496 13 view .LVU902
 3003              	.LBB129:
 497:le_phy.c      **** #ifdef UBERTOOTH_ONE
 3004              		.loc 1 497 2 view .LVU903
 3005 0162 FFF7FEFF 		bl	cc2400_strobe
 3006              	.LVL235:
 499:le_phy.c      **** 	HGM_SET;
 3007              		.loc 1 499 2 view .LVU904
 3008 0166 8022     		movs	r2, #128
 3009 0168 0C4B     		ldr	r3, .L229+32
 3010 016a 1A60     		str	r2, [r3]
 500:le_phy.c      **** #endif
 3011              		.loc 1 500 2 view .LVU905
 3012 016c 4FF48072 		mov	r2, #256
 3013 0170 1A60     		str	r2, [r3]
 502:le_phy.c      **** 
 3014              		.loc 1 502 1 is_stmt 0 view .LVU906
 3015 0172 67E7     		b	.L196
 3016              	.L207:
 3017              	.LBE129:
 3018              	.LBE130:
 706:le_phy.c      **** 			}
 3019              		.loc 1 706 5 is_stmt 1 view .LVU907
 710:le_phy.c      **** 
 3020              		.loc 1 710 1 is_stmt 0 view .LVU908
 3021 0174 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 3022              		.cfi_restore 14
 3023              		.cfi_restore 7
 3024              		.cfi_restore 6
 3025              		.cfi_restore 5
 3026              		.cfi_restore 4
 3027              		.cfi_restore 3
 3028              		.cfi_def_cfa_offset 0
 706:le_phy.c      **** 			}
 3029              		.loc 1 706 5 view .LVU909
 3030 0178 FFF7FEBF 		b	timer1_wait_fs_lock
 3031              	.LVL236:
 3032              	.L230:
 3033              		.align	2
 3034              	.L229:
 3035 017c 00800040 		.word	1073774592
 3036 0180 00000000 		.word	.LANCHOR0
 3037 0184 00000000 		.word	conn_event
 3038 0188 28010000 		.word	.LANCHOR0+296
 3039 018c 08800040 		.word	1073774600
 3040 0190 14800040 		.word	1073774612
 3041 0194 3CC00920 		.word	537509948
 3042 0198 00E100E0 		.word	-536813312
 3043 019c 58C00920 		.word	537509976
 3044              		.cfi_endproc
ARM GAS  /tmp/ccXJY3ni.s 			page 89


 3045              	.LFE30:
 3047              		.section	.rodata.str1.1
 3048              	.LC18:
 3049 01a0 63616C6C 		.ascii	"calling run_parser...\000"
 3049      696E6720 
 3049      72756E5F 
 3049      70617273 
 3049      65722E2E 
 3050              		.section	.text.le_phy_main,"ax",%progbits
 3051              		.align	1
 3052              		.global	le_phy_main
 3053              		.syntax unified
 3054              		.thumb
 3055              		.thumb_func
 3056              		.fpu softvfp
 3058              	le_phy_main:
 3059              	.LFB41:
 917:le_phy.c      **** 
 918:le_phy.c      **** static int filter_match(le_rx_t *buf) {
 919:le_phy.c      **** 	if (!le.target_set)
 920:le_phy.c      **** 		return 1;
 921:le_phy.c      **** 
 922:le_phy.c      **** 	// allow all data channel packets
 923:le_phy.c      **** 	if (btle_channel_index(buf->channel) < 37)
 924:le_phy.c      **** 		return 1;
 925:le_phy.c      **** 
 926:le_phy.c      **** 	switch (buf->data[0] & 0xf) {
 927:le_phy.c      **** 		// ADV_IND, ADV_NONCONN_IND, ADV_SCAN_IND, SCAN_RSP
 928:le_phy.c      **** 		case 0x00:
 929:le_phy.c      **** 		case 0x02:
 930:le_phy.c      **** 		case 0x06:
 931:le_phy.c      **** 		case 0x04:
 932:le_phy.c      **** 			// header + one address
 933:le_phy.c      **** 			if (buf->size < 2 + 6)
 934:le_phy.c      **** 				return 0;
 935:le_phy.c      **** 			return bd_addr_cmp(&buf->data[2]);
 936:le_phy.c      **** 			break;
 937:le_phy.c      **** 
 938:le_phy.c      **** 		// ADV_DIRECT_IND, SCAN_REQ, CONNECT_REQ
 939:le_phy.c      **** 		case 0x01:
 940:le_phy.c      **** 		case 0x03:
 941:le_phy.c      **** 		case 0x05:
 942:le_phy.c      **** 			// header + two addresses
 943:le_phy.c      **** 			if (buf->size < 2 + 6 + 6)
 944:le_phy.c      **** 				return 0;
 945:le_phy.c      **** 			return bd_addr_cmp(&buf->data[2]) ||
 946:le_phy.c      **** 				   bd_addr_cmp(&buf->data[8]);
 947:le_phy.c      **** 			break;
 948:le_phy.c      **** 
 949:le_phy.c      **** 		default:
 950:le_phy.c      **** 			break;
 951:le_phy.c      **** 	}
 952:le_phy.c      **** 
 953:le_phy.c      **** 	return 0;
 954:le_phy.c      **** }
 955:le_phy.c      **** 
 956:le_phy.c      **** void le_phy_main(void) {
ARM GAS  /tmp/ccXJY3ni.s 			page 90


 3060              		.loc 1 956 24 is_stmt 1 view -0
 3061              		.cfi_startproc
 3062              		@ args = 0, pretend = 0, frame = 24
 3063              		@ frame_needed = 0, uses_anonymous_args = 0
 3064 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 3065              		.cfi_def_cfa_offset 36
 3066              		.cfi_offset 4, -36
 3067              		.cfi_offset 5, -32
 3068              		.cfi_offset 6, -28
 3069              		.cfi_offset 7, -24
 3070              		.cfi_offset 8, -20
 3071              		.cfi_offset 9, -16
 3072              		.cfi_offset 10, -12
 3073              		.cfi_offset 11, -8
 3074              		.cfi_offset 14, -4
 3075 0004 87B0     		sub	sp, sp, #28
 3076              		.cfi_def_cfa_offset 64
 957:le_phy.c      ****     // int c = 'A';
 958:le_phy.c      **** 
 959:le_phy.c      ****     // ubertooth_init();
 960:le_phy.c      ****     // usb_serial_init();
 961:le_phy.c      **** 
 962:le_phy.c      **** 	// disable USB interrupts -- we poll them below
 963:le_phy.c      **** 	// n.b., they should not be enabled but let's be careful
 964:le_phy.c      **** 	ICER0 = ICER0_ICE_USB;
 3077              		.loc 1 964 2 view .LVU911
 3078              		.loc 1 964 8 is_stmt 0 view .LVU912
 3079 0006 4FF08073 		mov	r3, #16777216
 3080              	.LBB161:
 3081              	.LBB162:
 170:le_phy.c      **** }
 3082              		.loc 1 170 31 view .LVU913
 3083 000a 0125     		movs	r5, #1
 3084              	.LBE162:
 3085              	.LBE161:
 3086              		.loc 1 964 8 view .LVU914
 3087 000c BD4F     		ldr	r7, .L272
 3088              	.LBB166:
 3089              	.LBB163:
 170:le_phy.c      **** }
 3090              		.loc 1 170 31 view .LVU915
 3091 000e BE4C     		ldr	r4, .L272+4
 3092              	.LBE163:
 3093              	.LBE166:
 3094              		.loc 1 964 8 view .LVU916
 3095 0010 3B60     		str	r3, [r7]
 965:le_phy.c      **** 	// disable clkn and timer0
 966:le_phy.c      **** 	clkn_disable();
 3096              		.loc 1 966 2 is_stmt 1 view .LVU917
 3097 0012 FFF7FEFF 		bl	clkn_disable
 3098              	.LVL237:
 967:le_phy.c      **** 
 968:le_phy.c      **** 	buffers_init();
 3099              		.loc 1 968 2 view .LVU918
 3100              	.LBB167:
 3101              	.LBI161:
 166:le_phy.c      **** 	int i;
ARM GAS  /tmp/ccXJY3ni.s 			page 91


 3102              		.loc 1 166 13 view .LVU919
 3103              	.LBB164:
 167:le_phy.c      **** 
 3104              		.loc 1 167 2 view .LVU920
 169:le_phy.c      **** 		le_buffer_pool[i].available = 1;
 3105              		.loc 1 169 2 view .LVU921
 169:le_phy.c      **** 		le_buffer_pool[i].available = 1;
 3106              		.loc 1 169 14 view .LVU922
 170:le_phy.c      **** }
 3107              		.loc 1 170 3 view .LVU923
 3108              	.LBE164:
 3109              	.LBE167:
 969:le_phy.c      **** 	queue_init(&packet_queue);
 3110              		.loc 1 969 2 is_stmt 0 view .LVU924
 3111 0016 BD48     		ldr	r0, .L272+8
 3112              	.LBB168:
 3113              	.LBB165:
 170:le_phy.c      **** }
 3114              		.loc 1 170 31 view .LVU925
 3115 0018 C4F80053 		str	r5, [r4, #768]
 169:le_phy.c      **** 		le_buffer_pool[i].available = 1;
 3116              		.loc 1 169 39 is_stmt 1 view .LVU926
 3117              	.LVL238:
 169:le_phy.c      **** 		le_buffer_pool[i].available = 1;
 3118              		.loc 1 169 14 view .LVU927
 170:le_phy.c      **** }
 3119              		.loc 1 170 3 view .LVU928
 170:le_phy.c      **** }
 3120              		.loc 1 170 31 is_stmt 0 view .LVU929
 3121 001c C4F82454 		str	r5, [r4, #1060]
 169:le_phy.c      **** 		le_buffer_pool[i].available = 1;
 3122              		.loc 1 169 39 is_stmt 1 view .LVU930
 3123              	.LVL239:
 169:le_phy.c      **** 		le_buffer_pool[i].available = 1;
 3124              		.loc 1 169 14 view .LVU931
 170:le_phy.c      **** }
 3125              		.loc 1 170 3 view .LVU932
 170:le_phy.c      **** }
 3126              		.loc 1 170 31 is_stmt 0 view .LVU933
 3127 0020 C4F84855 		str	r5, [r4, #1352]
 169:le_phy.c      **** 		le_buffer_pool[i].available = 1;
 3128              		.loc 1 169 39 is_stmt 1 view .LVU934
 3129              	.LVL240:
 169:le_phy.c      **** 		le_buffer_pool[i].available = 1;
 3130              		.loc 1 169 14 view .LVU935
 170:le_phy.c      **** }
 3131              		.loc 1 170 3 view .LVU936
 170:le_phy.c      **** }
 3132              		.loc 1 170 31 is_stmt 0 view .LVU937
 3133 0024 C4F86C56 		str	r5, [r4, #1644]
 169:le_phy.c      **** 		le_buffer_pool[i].available = 1;
 3134              		.loc 1 169 39 is_stmt 1 view .LVU938
 3135              	.LVL241:
 169:le_phy.c      **** 		le_buffer_pool[i].available = 1;
 3136              		.loc 1 169 14 view .LVU939
 169:le_phy.c      **** 		le_buffer_pool[i].available = 1;
 3137              		.loc 1 169 14 is_stmt 0 view .LVU940
ARM GAS  /tmp/ccXJY3ni.s 			page 92


 3138              	.LBE165:
 3139              	.LBE168:
 3140              		.loc 1 969 2 is_stmt 1 view .LVU941
 3141 0028 FFF7FEFF 		bl	queue_init
 3142              	.LVL242:
 970:le_phy.c      **** 	timer1_start();
 3143              		.loc 1 970 2 view .LVU942
 3144              	.LBB169:
 3145              	.LBI169:
 540:le_phy.c      **** 	T1TCR = TCR_Counter_Reset;
 3146              		.loc 1 540 13 view .LVU943
 3147              	.LBB170:
 541:le_phy.c      **** 	T1PR = 4; // 100 ns
 3148              		.loc 1 541 2 view .LVU944
 541:le_phy.c      **** 	T1PR = 4; // 100 ns
 3149              		.loc 1 541 8 is_stmt 0 view .LVU945
 3150 002c 0223     		movs	r3, #2
 3151 002e B84E     		ldr	r6, .L272+12
 542:le_phy.c      **** 	T1TCR = TCR_Counter_Enable;
 3152              		.loc 1 542 7 view .LVU946
 3153 0030 B84A     		ldr	r2, .L272+16
 541:le_phy.c      **** 	T1PR = 4; // 100 ns
 3154              		.loc 1 541 8 view .LVU947
 3155 0032 3360     		str	r3, [r6]
 542:le_phy.c      **** 	T1TCR = TCR_Counter_Enable;
 3156              		.loc 1 542 2 is_stmt 1 view .LVU948
 542:le_phy.c      **** 	T1TCR = TCR_Counter_Enable;
 3157              		.loc 1 542 7 is_stmt 0 view .LVU949
 3158 0034 0423     		movs	r3, #4
 3159 0036 1360     		str	r3, [r2]
 543:le_phy.c      **** 
 3160              		.loc 1 543 2 is_stmt 1 view .LVU950
 546:le_phy.c      **** }
 3161              		.loc 1 546 8 is_stmt 0 view .LVU951
 3162 0038 B74A     		ldr	r2, .L272+20
 543:le_phy.c      **** 
 3163              		.loc 1 543 8 view .LVU952
 3164 003a 3560     		str	r5, [r6]
 546:le_phy.c      **** }
 3165              		.loc 1 546 2 is_stmt 1 view .LVU953
 546:le_phy.c      **** }
 3166              		.loc 1 546 8 is_stmt 0 view .LVU954
 3167 003c 1360     		str	r3, [r2]
 3168              	.LBE170:
 3169              	.LBE169:
 971:le_phy.c      **** 
 972:le_phy.c      **** 	current_rxbuf = buffer_get();
 3170              		.loc 1 972 2 is_stmt 1 view .LVU955
 3171              		.loc 1 972 18 is_stmt 0 view .LVU956
 3172 003e FFF7FEFF 		bl	buffer_get
 3173              	.LVL243:
 973:le_phy.c      **** 	rf_channel = le_adv_channel; // FIXME
 3174              		.loc 1 973 13 view .LVU957
 3175 0042 B64B     		ldr	r3, .L272+24
 3176 0044 B64A     		ldr	r2, .L272+28
 3177 0046 1B88     		ldrh	r3, [r3]
 972:le_phy.c      **** 	rf_channel = le_adv_channel; // FIXME
ARM GAS  /tmp/ccXJY3ni.s 			page 93


 3178              		.loc 1 972 16 view .LVU958
 3179 0048 C4F87806 		str	r0, [r4, #1656]
 3180              		.loc 1 973 2 is_stmt 1 view .LVU959
 3181              		.loc 1 973 13 is_stmt 0 view .LVU960
 3182 004c 9BB2     		uxth	r3, r3
 3183 004e 1380     		strh	r3, [r2]	@ movhi
 974:le_phy.c      **** 	conn.access_address = ADVERTISING_AA;
 3184              		.loc 1 974 2 is_stmt 1 view .LVU961
 3185              		.loc 1 974 22 is_stmt 0 view .LVU962
 3186 0050 B44B     		ldr	r3, .L272+32
 3187              	.LBB171:
 3188              	.LBB172:
 3189              	.LBB173:
 919:le_phy.c      **** 		return 1;
 3190              		.loc 1 919 9 view .LVU963
 3191 0052 DFF804B3 		ldr	fp, .L272+84
 3192              	.LBE173:
 3193              	.LBE172:
 3194              	.LBE171:
 3195              		.loc 1 974 22 view .LVU964
 3196 0056 2362     		str	r3, [r4, #32]
 975:le_phy.c      **** 	le_sys_init();
 3197              		.loc 1 975 2 is_stmt 1 view .LVU965
 3198              	.LBB206:
 3199              	.LBI206:
 441:le_phy.c      **** 	usb_queue_init(); // USB FIFO FIXME replace with safer queue
 3200              		.loc 1 441 13 view .LVU966
 3201              	.LBB207:
 442:le_phy.c      **** 	dio_ssp_init();   // init SSP and raise !CS (self-routed GPIO)
 3202              		.loc 1 442 2 view .LVU967
 3203 0058 FFF7FEFF 		bl	usb_queue_init
 3204              	.LVL244:
 443:le_phy.c      **** 	le_dma_init();    // prepare DMA + interrupts
 3205              		.loc 1 443 2 view .LVU968
 3206 005c FFF7FEFF 		bl	dio_ssp_init
 3207              	.LVL245:
 444:le_phy.c      **** 	dio_ssp_start();  // enable SSP + DMA
 3208              		.loc 1 444 2 view .LVU969
 3209 0060 FFF7FEFF 		bl	le_dma_init
 3210              	.LVL246:
 445:le_phy.c      **** }
 3211              		.loc 1 445 2 view .LVU970
 3212 0064 FFF7FEFF 		bl	dio_ssp_start
 3213              	.LVL247:
 3214              	.LBE207:
 3215              	.LBE206:
 976:le_phy.c      **** 	le_cc2400_init_rf();
 3216              		.loc 1 976 2 view .LVU971
 3217 0068 FFF7FEFF 		bl	le_cc2400_init_rf
 3218              	.LVL248:
 977:le_phy.c      **** 
 978:le_phy.c      **** 	cancel_follow = 0;
 3219              		.loc 1 978 2 view .LVU972
 3220              		.loc 1 978 16 is_stmt 0 view .LVU973
 3221 006c AE4B     		ldr	r3, .L272+36
 3222 006e 0022     		movs	r2, #0
 3223 0070 9846     		mov	r8, r3
ARM GAS  /tmp/ccXJY3ni.s 			page 94


 3224 0072 CDE90176 		strd	r7, r6, [sp, #4]
 3225 0076 1A60     		str	r2, [r3]
 979:le_phy.c      **** 
 980:le_phy.c      **** 	while (requested_mode == MODE_BT_FOLLOW_LE) {
 3226              		.loc 1 980 2 is_stmt 1 view .LVU974
 3227              	.L232:
 3228              		.loc 1 980 8 view .LVU975
 3229              		.loc 1 980 24 is_stmt 0 view .LVU976
 3230 0078 AC4B     		ldr	r3, .L272+40
 3231 007a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3232              		.loc 1 980 8 view .LVU977
 3233 007c 092B     		cmp	r3, #9
 3234 007e 11D0     		beq	.L251
 981:le_phy.c      **** 		le_rx_t *packet = NULL;
 982:le_phy.c      **** 		if (queue_remove(&packet_queue, (void **)&packet)) {
 983:le_phy.c      **** 			le_dewhiten(packet->data, packet->size, packet->channel);
 984:le_phy.c      **** 
 985:le_phy.c      ****                         if (filter_match(packet)) {
 986:le_phy.c      ****                             // write char to serial port
 987:le_phy.c      ****                             // if (c != EOF) {
 988:le_phy.c      ****                             //     VCOM_putchar(c);
 989:le_phy.c      ****                             //     c++;
 990:le_phy.c      ****                             //     if (c > 'Z') {
 991:le_phy.c      ****                             //         c = 'A';
 992:le_phy.c      ****                             //     }
 993:le_phy.c      ****                             //     if (USRLED)
 994:le_phy.c      ****                             //         USRLED_CLR;
 995:le_phy.c      ****                             //     else
 996:le_phy.c      ****                             //         USRLED_SET;
 997:le_phy.c      ****                             // }
 998:le_phy.c      ****                             debug_write("calling run_parser...");
 999:le_phy.c      ****                             unsigned int ret = run_parser(packet->data, packet->size);
1000:le_phy.c      ****                             if (ret == 0) {
1001:le_phy.c      ****                                 blink(0, 1, 0); // RX LED
1002:le_phy.c      ****                             }
1003:le_phy.c      ****                             int i = 0;
1004:le_phy.c      ****                             while (i < 10000000) {
1005:le_phy.c      ****                                 i++;
1006:le_phy.c      ****                             }
1007:le_phy.c      ****                             usb_enqueue_le(packet);
1008:le_phy.c      ****                             packet_handler(packet);
1009:le_phy.c      **** 			}
1010:le_phy.c      **** 
1011:le_phy.c      **** 			buffer_release(packet);
1012:le_phy.c      **** 		}
1013:le_phy.c      **** 
1014:le_phy.c      **** 		// polled USB handling
1015:le_phy.c      **** 		handle_usb(0);
1016:le_phy.c      **** 
1017:le_phy.c      **** 		// XXX maybe LED light show?
1018:le_phy.c      **** 	}
1019:le_phy.c      **** 
1020:le_phy.c      **** 	timer1_stop();
 3235              		.loc 1 1020 2 is_stmt 1 view .LVU978
 3236              	.LBB208:
 3237              	.LBI208:
 549:le_phy.c      **** 	T1TCR = TCR_Counter_Reset;
ARM GAS  /tmp/ccXJY3ni.s 			page 95


 3238              		.loc 1 549 13 view .LVU979
 3239              	.LBB209:
 550:le_phy.c      **** 
 3240              		.loc 1 550 2 view .LVU980
 550:le_phy.c      **** 
 3241              		.loc 1 550 8 is_stmt 0 view .LVU981
 3242 0080 0222     		movs	r2, #2
 3243 0082 029B     		ldr	r3, [sp, #8]
 553:le_phy.c      **** }
 3244              		.loc 1 553 8 view .LVU982
 3245 0084 0199     		ldr	r1, [sp, #4]
 550:le_phy.c      **** 
 3246              		.loc 1 550 8 view .LVU983
 3247 0086 1A60     		str	r2, [r3]
 553:le_phy.c      **** }
 3248              		.loc 1 553 2 is_stmt 1 view .LVU984
 553:le_phy.c      **** }
 3249              		.loc 1 553 8 is_stmt 0 view .LVU985
 3250 0088 0423     		movs	r3, #4
 3251 008a 0B60     		str	r3, [r1]
 3252              	.LBE209:
 3253              	.LBE208:
1021:le_phy.c      **** 
1022:le_phy.c      **** 	// reset state
1023:le_phy.c      **** 	RXLED_CLR;
 3254              		.loc 1 1023 2 is_stmt 1 view .LVU986
 3255 008c 1021     		movs	r1, #16
 3256 008e A84B     		ldr	r3, .L272+44
 3257 0090 1960     		str	r1, [r3]
1024:le_phy.c      **** 	TXLED_CLR;
 3258              		.loc 1 1024 2 view .LVU987
 3259 0092 4FF48071 		mov	r1, #256
 3260 0096 1960     		str	r1, [r3]
1025:le_phy.c      **** 	USRLED_CLR;
 3261              		.loc 1 1025 2 view .LVU988
 3262 0098 1A60     		str	r2, [r3]
1026:le_phy.c      **** 	clkn_init();
 3263              		.loc 1 1026 2 view .LVU989
 3264 009a FFF7FEFF 		bl	clkn_init
 3265              	.LVL249:
1027:le_phy.c      **** 
1028:le_phy.c      **** 	// TODO kill CC2400
1029:le_phy.c      **** }
 3266              		.loc 1 1029 1 is_stmt 0 view .LVU990
 3267 009e 07B0     		add	sp, sp, #28
 3268              		.cfi_remember_state
 3269              		.cfi_def_cfa_offset 36
 3270              		@ sp needed
 3271 00a0 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 3272              	.L251:
 3273              		.cfi_restore_state
 3274              	.LBB210:
 981:le_phy.c      **** 		if (queue_remove(&packet_queue, (void **)&packet)) {
 3275              		.loc 1 981 3 is_stmt 1 view .LVU991
 981:le_phy.c      **** 		if (queue_remove(&packet_queue, (void **)&packet)) {
 3276              		.loc 1 981 12 is_stmt 0 view .LVU992
 3277 00a4 0023     		movs	r3, #0
ARM GAS  /tmp/ccXJY3ni.s 			page 96


 982:le_phy.c      **** 			le_dewhiten(packet->data, packet->size, packet->channel);
 3278              		.loc 1 982 7 view .LVU993
 3279 00a6 9948     		ldr	r0, .L272+8
 3280 00a8 05A9     		add	r1, sp, #20
 981:le_phy.c      **** 		if (queue_remove(&packet_queue, (void **)&packet)) {
 3281              		.loc 1 981 12 view .LVU994
 3282 00aa 0593     		str	r3, [sp, #20]
 982:le_phy.c      **** 			le_dewhiten(packet->data, packet->size, packet->channel);
 3283              		.loc 1 982 3 is_stmt 1 view .LVU995
 982:le_phy.c      **** 			le_dewhiten(packet->data, packet->size, packet->channel);
 3284              		.loc 1 982 7 is_stmt 0 view .LVU996
 3285 00ac FFF7FEFF 		bl	queue_remove
 3286              	.LVL250:
 982:le_phy.c      **** 			le_dewhiten(packet->data, packet->size, packet->channel);
 3287              		.loc 1 982 6 view .LVU997
 3288 00b0 0028     		cmp	r0, #0
 3289 00b2 00F01281 		beq	.L233
 983:le_phy.c      **** 
 3290              		.loc 1 983 4 is_stmt 1 view .LVU998
 983:le_phy.c      **** 
 3291              		.loc 1 983 22 is_stmt 0 view .LVU999
 3292 00b6 0598     		ldr	r0, [sp, #20]
 983:le_phy.c      **** 
 3293              		.loc 1 983 4 view .LVU1000
 3294 00b8 D0F81021 		ldr	r2, [r0, #272]
 3295 00bc D0F80411 		ldr	r1, [r0, #260]
 3296 00c0 FFF7FEFF 		bl	le_dewhiten
 3297              	.LVL251:
 985:le_phy.c      ****                             // write char to serial port
 3298              		.loc 1 985 25 is_stmt 1 view .LVU1001
 3299              	.LBB177:
 3300              	.LBI172:
 918:le_phy.c      **** 	if (!le.target_set)
 3301              		.loc 1 918 12 view .LVU1002
 3302              	.LBB174:
 919:le_phy.c      **** 		return 1;
 3303              		.loc 1 919 2 view .LVU1003
 919:le_phy.c      **** 		return 1;
 3304              		.loc 1 919 5 is_stmt 0 view .LVU1004
 3305 00c4 DBF84430 		ldr	r3, [fp, #68]
 3306 00c8 002B     		cmp	r3, #0
 3307 00ca 40F0E580 		bne	.L234
 3308              	.LVL252:
 3309              	.L237:
 919:le_phy.c      **** 		return 1;
 3310              		.loc 1 919 5 view .LVU1005
 3311              	.LBE174:
 3312              	.LBE177:
 3313              	.LBB178:
 998:le_phy.c      ****                             unsigned int ret = run_parser(packet->data, packet->size);
 3314              		.loc 1 998 29 is_stmt 1 view .LVU1006
 3315 00ce 9948     		ldr	r0, .L272+48
 3316 00d0 FFF7FEFF 		bl	debug_write
 3317              	.LVL253:
 999:le_phy.c      ****                             if (ret == 0) {
 3318              		.loc 1 999 29 view .LVU1007
 999:le_phy.c      ****                             if (ret == 0) {
ARM GAS  /tmp/ccXJY3ni.s 			page 97


 3319              		.loc 1 999 65 is_stmt 0 view .LVU1008
 3320 00d4 0598     		ldr	r0, [sp, #20]
 999:le_phy.c      ****                             if (ret == 0) {
 3321              		.loc 1 999 48 view .LVU1009
 3322 00d6 D0F80411 		ldr	r1, [r0, #260]
 3323 00da FFF7FEFF 		bl	run_parser
 3324              	.LVL254:
1000:le_phy.c      ****                                 blink(0, 1, 0); // RX LED
 3325              		.loc 1 1000 29 is_stmt 1 view .LVU1010
1000:le_phy.c      ****                                 blink(0, 1, 0); // RX LED
 3326              		.loc 1 1000 32 is_stmt 0 view .LVU1011
 3327 00de 78B9     		cbnz	r0, .L236
1001:le_phy.c      ****                             }
 3328              		.loc 1 1001 33 is_stmt 1 view .LVU1012
 3329              	.LBB179:
 3330              	.LBI179:
 712:le_phy.c      **** 	if (tx)
 3331              		.loc 1 712 13 view .LVU1013
 3332              	.LVL255:
 3333              	.LBB180:
 713:le_phy.c      **** 		TXLED_SET;
 3334              		.loc 1 713 2 view .LVU1014
 715:le_phy.c      **** 		RXLED_SET;
 3335              		.loc 1 715 2 view .LVU1015
 716:le_phy.c      **** 	if (usr)
 3336              		.loc 1 716 3 view .LVU1016
 3337 00e0 1022     		movs	r2, #16
 3338 00e2 954B     		ldr	r3, .L272+52
 3339 00e4 1A60     		str	r2, [r3]
 717:le_phy.c      **** 		USRLED_SET;
 3340              		.loc 1 717 2 view .LVU1017
 721:le_phy.c      **** 	T1MCR |= TMCR_MR1I;
 3341              		.loc 1 721 2 view .LVU1018
 721:le_phy.c      **** 	T1MCR |= TMCR_MR1I;
 3342              		.loc 1 721 10 is_stmt 0 view .LVU1019
 3343 00e6 954B     		ldr	r3, .L272+56
 721:le_phy.c      **** 	T1MCR |= TMCR_MR1I;
 3344              		.loc 1 721 8 view .LVU1020
 3345 00e8 954A     		ldr	r2, .L272+60
 721:le_phy.c      **** 	T1MCR |= TMCR_MR1I;
 3346              		.loc 1 721 10 view .LVU1021
 3347 00ea 1B68     		ldr	r3, [r3]
 721:le_phy.c      **** 	T1MCR |= TMCR_MR1I;
 3348              		.loc 1 721 14 view .LVU1022
 3349 00ec 03F5C333 		add	r3, r3, #99840
 3350 00f0 A033     		adds	r3, r3, #160
 721:le_phy.c      **** 	T1MCR |= TMCR_MR1I;
 3351              		.loc 1 721 8 view .LVU1023
 3352 00f2 1360     		str	r3, [r2]
 722:le_phy.c      **** }
 3353              		.loc 1 722 2 is_stmt 1 view .LVU1024
 722:le_phy.c      **** }
 3354              		.loc 1 722 8 is_stmt 0 view .LVU1025
 3355 00f4 52F8083C 		ldr	r3, [r2, #-8]
 3356 00f8 43F00803 		orr	r3, r3, #8
 3357 00fc 42F8083C 		str	r3, [r2, #-8]
 3358              	.LVL256:
ARM GAS  /tmp/ccXJY3ni.s 			page 98


 3359              	.L236:
 722:le_phy.c      **** }
 3360              		.loc 1 722 8 view .LVU1026
 3361              	.LBE180:
 3362              	.LBE179:
1003:le_phy.c      ****                             while (i < 10000000) {
 3363              		.loc 1 1003 29 is_stmt 1 view .LVU1027
1004:le_phy.c      ****                                 i++;
 3364              		.loc 1 1004 29 view .LVU1028
1004:le_phy.c      ****                                 i++;
 3365              		.loc 1 1004 35 view .LVU1029
1007:le_phy.c      ****                             packet_handler(packet);
 3366              		.loc 1 1007 29 view .LVU1030
 3367 0100 059E     		ldr	r6, [sp, #20]
 3368              	.LVL257:
 3369              	.LBB181:
 3370              	.LBI181:
 748:le_phy.c      **** 	usb_pkt_rx* f = usb_enqueue();
 3371              		.loc 1 748 12 view .LVU1031
 3372              	.LBB182:
 749:le_phy.c      **** 
 3373              		.loc 1 749 2 view .LVU1032
 749:le_phy.c      **** 
 3374              		.loc 1 749 18 is_stmt 0 view .LVU1033
 3375 0102 FFF7FEFF 		bl	usb_enqueue
 3376              	.LVL258:
 752:le_phy.c      **** 		return 0;
 3377              		.loc 1 752 2 is_stmt 1 view .LVU1034
 752:le_phy.c      **** 		return 0;
 3378              		.loc 1 752 5 is_stmt 0 view .LVU1035
 3379 0106 0546     		mov	r5, r0
 3380 0108 50B3     		cbz	r0, .L245
 756:le_phy.c      **** 
 3381              		.loc 1 756 2 is_stmt 1 view .LVU1036
 758:le_phy.c      **** 	f->clk100ns = packet->timestamp;
 3382              		.loc 1 758 15 is_stmt 0 view .LVU1037
 3383 010a 0027     		movs	r7, #0
 756:le_phy.c      **** 
 3384              		.loc 1 756 14 view .LVU1038
 3385 010c 0123     		movs	r3, #1
 758:le_phy.c      **** 	f->clk100ns = packet->timestamp;
 3386              		.loc 1 758 15 view .LVU1039
 3387 010e C770     		strb	r7, [r0, #3]
 756:le_phy.c      **** 
 3388              		.loc 1 756 14 view .LVU1040
 3389 0110 0370     		strb	r3, [r0]
 758:le_phy.c      **** 	f->clk100ns = packet->timestamp;
 3390              		.loc 1 758 2 is_stmt 1 view .LVU1041
 759:le_phy.c      **** 
 3391              		.loc 1 759 2 view .LVU1042
 759:le_phy.c      **** 
 3392              		.loc 1 759 14 is_stmt 0 view .LVU1043
 3393 0112 D6F80C31 		ldr	r3, [r6, #268]
 767:le_phy.c      **** 	memcpy(f->data+4, packet->data, DMA_SIZE-4);
 3394              		.loc 1 767 2 view .LVU1044
 3395 0116 06F58A71 		add	r1, r6, #276
 759:le_phy.c      **** 
ARM GAS  /tmp/ccXJY3ni.s 			page 99


 3396              		.loc 1 759 14 view .LVU1045
 3397 011a 4360     		str	r3, [r0, #4]
 761:le_phy.c      **** 	f->rssi_avg = packet->rssi_sum / packet->size;
 3398              		.loc 1 761 2 is_stmt 1 view .LVU1046
 761:le_phy.c      **** 	f->rssi_avg = packet->rssi_sum / packet->size;
 3399              		.loc 1 761 15 is_stmt 0 view .LVU1047
 3400 011c D6F81031 		ldr	r3, [r6, #272]
 767:le_phy.c      **** 	memcpy(f->data+4, packet->data, DMA_SIZE-4);
 3401              		.loc 1 767 2 view .LVU1048
 3402 0120 0E30     		adds	r0, r0, #14
 3403              	.LVL259:
 761:le_phy.c      **** 	f->rssi_avg = packet->rssi_sum / packet->size;
 3404              		.loc 1 761 15 view .LVU1049
 3405 0122 623B     		subs	r3, r3, #98
 761:le_phy.c      **** 	f->rssi_avg = packet->rssi_sum / packet->size;
 3406              		.loc 1 761 13 view .LVU1050
 3407 0124 00F80C3C 		strb	r3, [r0, #-12]
 762:le_phy.c      **** 	f->rssi_min = packet->rssi_min;
 3408              		.loc 1 762 2 is_stmt 1 view .LVU1051
 762:le_phy.c      **** 	f->rssi_min = packet->rssi_min;
 3409              		.loc 1 762 33 is_stmt 0 view .LVU1052
 3410 0128 D6F80421 		ldr	r2, [r6, #260]
 3411 012c D6F82031 		ldr	r3, [r6, #288]
 3412 0130 B3FBF2F3 		udiv	r3, r3, r2
 762:le_phy.c      **** 	f->rssi_min = packet->rssi_min;
 3413              		.loc 1 762 14 view .LVU1053
 3414 0134 00F8043C 		strb	r3, [r0, #-4]
 763:le_phy.c      **** 	f->rssi_max = packet->rssi_max;
 3415              		.loc 1 763 2 is_stmt 1 view .LVU1054
 763:le_phy.c      **** 	f->rssi_max = packet->rssi_max;
 3416              		.loc 1 763 14 is_stmt 0 view .LVU1055
 3417 0138 96F81C31 		ldrb	r3, [r6, #284]	@ zero_extendqisi2
 767:le_phy.c      **** 	memcpy(f->data+4, packet->data, DMA_SIZE-4);
 3418              		.loc 1 767 2 view .LVU1056
 3419 013c 0422     		movs	r2, #4
 763:le_phy.c      **** 	f->rssi_max = packet->rssi_max;
 3420              		.loc 1 763 14 view .LVU1057
 3421 013e 00F8053C 		strb	r3, [r0, #-5]
 764:le_phy.c      **** 	f->rssi_count = 0;
 3422              		.loc 1 764 2 is_stmt 1 view .LVU1058
 764:le_phy.c      **** 	f->rssi_count = 0;
 3423              		.loc 1 764 14 is_stmt 0 view .LVU1059
 3424 0142 96F81D31 		ldrb	r3, [r6, #285]	@ zero_extendqisi2
 765:le_phy.c      **** 
 3425              		.loc 1 765 16 view .LVU1060
 3426 0146 00F8037C 		strb	r7, [r0, #-3]
 764:le_phy.c      **** 	f->rssi_count = 0;
 3427              		.loc 1 764 14 view .LVU1061
 3428 014a 00F8063C 		strb	r3, [r0, #-6]
 765:le_phy.c      **** 
 3429              		.loc 1 765 2 is_stmt 1 view .LVU1062
 767:le_phy.c      **** 	memcpy(f->data+4, packet->data, DMA_SIZE-4);
 3430              		.loc 1 767 2 view .LVU1063
 3431 014e FFF7FEFF 		bl	memcpy
 3432              	.LVL260:
 768:le_phy.c      **** 
 3433              		.loc 1 768 2 view .LVU1064
ARM GAS  /tmp/ccXJY3ni.s 			page 100


 3434 0152 2E22     		movs	r2, #46
 3435 0154 3146     		mov	r1, r6
 3436 0156 05F11200 		add	r0, r5, #18
 3437 015a FFF7FEFF 		bl	memcpy
 3438              	.LVL261:
 770:le_phy.c      **** 
 3439              		.loc 1 770 2 view .LVU1065
 770:le_phy.c      **** 
 3440              		.loc 1 770 12 is_stmt 0 view .LVU1066
 3441 015e 6F70     		strb	r7, [r5, #1]
 772:le_phy.c      **** }
 3442              		.loc 1 772 2 is_stmt 1 view .LVU1067
 3443              	.L245:
 3444              	.LVL262:
 772:le_phy.c      **** }
 3445              		.loc 1 772 2 is_stmt 0 view .LVU1068
 3446              	.LBE182:
 3447              	.LBE181:
1008:le_phy.c      **** 			}
 3448              		.loc 1 1008 29 is_stmt 1 view .LVU1069
 3449 0160 059D     		ldr	r5, [sp, #20]
 3450              	.LVL263:
 3451              	.LBB183:
 3452              	.LBI183:
 876:le_phy.c      **** 	// advertising packet
 3453              		.loc 1 876 13 view .LVU1070
 3454              	.LBB184:
 878:le_phy.c      **** 		switch (buf->data[0] & 0xf) {
 3455              		.loc 1 878 2 view .LVU1071
 878:le_phy.c      **** 		switch (buf->data[0] & 0xf) {
 3456              		.loc 1 878 6 is_stmt 0 view .LVU1072
 3457 0162 B5F81001 		ldrh	r0, [r5, #272]
 3458 0166 FFF7FEFF 		bl	btle_channel_index
 3459              	.LVL264:
 878:le_phy.c      **** 		switch (buf->data[0] & 0xf) {
 3460              		.loc 1 878 5 view .LVU1073
 3461 016a 2428     		cmp	r0, #36
 3462 016c 2978     		ldrb	r1, [r5]	@ zero_extendqisi2
 3463 016e 40F2F580 		bls	.L246
 879:le_phy.c      **** 			// CONNECT_REQ
 3464              		.loc 1 879 3 is_stmt 1 view .LVU1074
 3465 0172 01F00F01 		and	r1, r1, #15
 3466 0176 0529     		cmp	r1, #5
 3467 0178 40F0AB80 		bne	.L242
 883:le_phy.c      **** 				break;
 3468              		.loc 1 883 5 view .LVU1075
 3469              	.LVL265:
 3470              	.LBB185:
 3471              	.LBI185:
 785:le_phy.c      **** 	uint32_t aa, crc_init;
 3472              		.loc 1 785 13 view .LVU1076
 3473              	.LBB186:
 786:le_phy.c      **** 	uint32_t win_size, max_win_size;
 3474              		.loc 1 786 2 view .LVU1077
 787:le_phy.c      **** 
 3475              		.loc 1 787 2 view .LVU1078
 789:le_phy.c      **** 		return;
ARM GAS  /tmp/ccXJY3ni.s 			page 101


 3476              		.loc 1 789 2 view .LVU1079
 789:le_phy.c      **** 		return;
 3477              		.loc 1 789 5 is_stmt 0 view .LVU1080
 3478 017c DBF83430 		ldr	r3, [fp, #52]
 3479 0180 002B     		cmp	r3, #0
 3480 0182 00F0A680 		beq	.L242
 792:le_phy.c      **** 		return;
 3481              		.loc 1 792 2 is_stmt 1 view .LVU1081
 792:le_phy.c      **** 		return;
 3482              		.loc 1 792 5 is_stmt 0 view .LVU1082
 3483 0186 D5F80431 		ldr	r3, [r5, #260]
 3484 018a 272B     		cmp	r3, #39
 3485 018c 40F0A180 		bne	.L242
 796:le_phy.c      **** 		cancel_follow = 0;
 3486              		.loc 1 796 2 is_stmt 1 view .LVU1083
 796:le_phy.c      **** 		cancel_follow = 0;
 3487              		.loc 1 796 6 is_stmt 0 view .LVU1084
 3488 0190 D8F80030 		ldr	r3, [r8]
 796:le_phy.c      **** 		cancel_follow = 0;
 3489              		.loc 1 796 5 view .LVU1085
 3490 0194 13B1     		cbz	r3, .L247
 797:le_phy.c      **** 
 3491              		.loc 1 797 3 is_stmt 1 view .LVU1086
 797:le_phy.c      **** 
 3492              		.loc 1 797 17 is_stmt 0 view .LVU1087
 3493 0196 0023     		movs	r3, #0
 3494 0198 C8F80030 		str	r3, [r8]
 3495              	.L247:
 799:le_phy.c      **** 	conn.crc_init           = extract_field(buf, 18, 3);
 3496              		.loc 1 799 2 is_stmt 1 view .LVU1088
 799:le_phy.c      **** 	conn.crc_init           = extract_field(buf, 18, 3);
 3497              		.loc 1 799 28 is_stmt 0 view .LVU1089
 3498 019c 0422     		movs	r2, #4
 3499 019e 0E21     		movs	r1, #14
 3500 01a0 2846     		mov	r0, r5
 3501 01a2 FFF7FEFF 		bl	extract_field
 3502              	.LVL266:
 800:le_phy.c      **** 	conn.crc_init_reversed  = rbit(conn.crc_init);
 3503              		.loc 1 800 28 view .LVU1090
 3504 01a6 0322     		movs	r2, #3
 3505 01a8 1221     		movs	r1, #18
 799:le_phy.c      **** 	conn.crc_init           = extract_field(buf, 18, 3);
 3506              		.loc 1 799 26 view .LVU1091
 3507 01aa 2062     		str	r0, [r4, #32]
 800:le_phy.c      **** 	conn.crc_init_reversed  = rbit(conn.crc_init);
 3508              		.loc 1 800 2 is_stmt 1 view .LVU1092
 800:le_phy.c      **** 	conn.crc_init_reversed  = rbit(conn.crc_init);
 3509              		.loc 1 800 28 is_stmt 0 view .LVU1093
 3510 01ac 2846     		mov	r0, r5
 3511 01ae FFF7FEFF 		bl	extract_field
 3512              	.LVL267:
 800:le_phy.c      **** 	conn.crc_init_reversed  = rbit(conn.crc_init);
 3513              		.loc 1 800 26 view .LVU1094
 3514 01b2 6062     		str	r0, [r4, #36]
 801:le_phy.c      **** 	conn.win_size           = extract_field(buf, 21, 1);
 3515              		.loc 1 801 2 is_stmt 1 view .LVU1095
 801:le_phy.c      **** 	conn.win_size           = extract_field(buf, 21, 1);
ARM GAS  /tmp/ccXJY3ni.s 			page 102


 3516              		.loc 1 801 28 is_stmt 0 view .LVU1096
 3517 01b4 FFF7FEFF 		bl	rbit
 3518              	.LVL268:
 802:le_phy.c      **** 	conn.win_offset         = extract_field(buf, 22, 2);
 3519              		.loc 1 802 28 view .LVU1097
 3520 01b8 0122     		movs	r2, #1
 3521 01ba 1521     		movs	r1, #21
 801:le_phy.c      **** 	conn.win_size           = extract_field(buf, 21, 1);
 3522              		.loc 1 801 26 view .LVU1098
 3523 01bc A062     		str	r0, [r4, #40]
 802:le_phy.c      **** 	conn.win_offset         = extract_field(buf, 22, 2);
 3524              		.loc 1 802 2 is_stmt 1 view .LVU1099
 802:le_phy.c      **** 	conn.win_offset         = extract_field(buf, 22, 2);
 3525              		.loc 1 802 28 is_stmt 0 view .LVU1100
 3526 01be 2846     		mov	r0, r5
 3527 01c0 FFF7FEFF 		bl	extract_field
 3528              	.LVL269:
 803:le_phy.c      **** 	conn.conn_interval      = extract_field(buf, 24, 2);
 3529              		.loc 1 803 28 view .LVU1101
 3530 01c4 0222     		movs	r2, #2
 3531 01c6 1621     		movs	r1, #22
 802:le_phy.c      **** 	conn.win_offset         = extract_field(buf, 22, 2);
 3532              		.loc 1 802 26 view .LVU1102
 3533 01c8 84F83800 		strb	r0, [r4, #56]
 803:le_phy.c      **** 	conn.conn_interval      = extract_field(buf, 24, 2);
 3534              		.loc 1 803 2 is_stmt 1 view .LVU1103
 802:le_phy.c      **** 	conn.win_offset         = extract_field(buf, 22, 2);
 3535              		.loc 1 802 28 is_stmt 0 view .LVU1104
 3536 01cc 8146     		mov	r9, r0
 803:le_phy.c      **** 	conn.conn_interval      = extract_field(buf, 24, 2);
 3537              		.loc 1 803 28 view .LVU1105
 3538 01ce 2846     		mov	r0, r5
 3539 01d0 FFF7FEFF 		bl	extract_field
 3540              	.LVL270:
 804:le_phy.c      **** 	conn.supervision_timeout = extract_field(buf, 28, 2);
 3541              		.loc 1 804 28 view .LVU1106
 3542 01d4 0222     		movs	r2, #2
 3543 01d6 1821     		movs	r1, #24
 803:le_phy.c      **** 	conn.conn_interval      = extract_field(buf, 24, 2);
 3544              		.loc 1 803 26 view .LVU1107
 3545 01d8 E063     		str	r0, [r4, #60]
 804:le_phy.c      **** 	conn.supervision_timeout = extract_field(buf, 28, 2);
 3546              		.loc 1 804 2 is_stmt 1 view .LVU1108
 803:le_phy.c      **** 	conn.conn_interval      = extract_field(buf, 24, 2);
 3547              		.loc 1 803 28 is_stmt 0 view .LVU1109
 3548 01da 0746     		mov	r7, r0
 804:le_phy.c      **** 	conn.supervision_timeout = extract_field(buf, 28, 2);
 3549              		.loc 1 804 28 view .LVU1110
 3550 01dc 2846     		mov	r0, r5
 3551 01de FFF7FEFF 		bl	extract_field
 3552              	.LVL271:
 805:le_phy.c      **** 	conn.hop_increment      = extract_field(buf, 35, 1) & 0x1f;
 3553              		.loc 1 805 29 view .LVU1111
 3554 01e2 0222     		movs	r2, #2
 804:le_phy.c      **** 	conn.supervision_timeout = extract_field(buf, 28, 2);
 3555              		.loc 1 804 28 view .LVU1112
 3556 01e4 0646     		mov	r6, r0
ARM GAS  /tmp/ccXJY3ni.s 			page 103


 805:le_phy.c      **** 	conn.hop_increment      = extract_field(buf, 35, 1) & 0x1f;
 3557              		.loc 1 805 29 view .LVU1113
 3558 01e6 1C21     		movs	r1, #28
 804:le_phy.c      **** 	conn.supervision_timeout = extract_field(buf, 28, 2);
 3559              		.loc 1 804 26 view .LVU1114
 3560 01e8 2063     		str	r0, [r4, #48]
 805:le_phy.c      **** 	conn.hop_increment      = extract_field(buf, 35, 1) & 0x1f;
 3561              		.loc 1 805 2 is_stmt 1 view .LVU1115
 805:le_phy.c      **** 	conn.hop_increment      = extract_field(buf, 35, 1) & 0x1f;
 3562              		.loc 1 805 29 is_stmt 0 view .LVU1116
 3563 01ea 2846     		mov	r0, r5
 3564 01ec FFF7FEFF 		bl	extract_field
 3565              	.LVL272:
 806:le_phy.c      **** 
 3566              		.loc 1 806 28 view .LVU1117
 3567 01f0 0122     		movs	r2, #1
 805:le_phy.c      **** 	conn.hop_increment      = extract_field(buf, 35, 1) & 0x1f;
 3568              		.loc 1 805 27 view .LVU1118
 3569 01f2 6063     		str	r0, [r4, #52]
 806:le_phy.c      **** 
 3570              		.loc 1 806 2 is_stmt 1 view .LVU1119
 805:le_phy.c      **** 	conn.hop_increment      = extract_field(buf, 35, 1) & 0x1f;
 3571              		.loc 1 805 29 is_stmt 0 view .LVU1120
 3572 01f4 8246     		mov	r10, r0
 806:le_phy.c      **** 
 3573              		.loc 1 806 28 view .LVU1121
 3574 01f6 2321     		movs	r1, #35
 3575 01f8 2846     		mov	r0, r5
 3576 01fa FFF7FEFF 		bl	extract_field
 3577              	.LVL273:
 808:le_phy.c      **** 		goto err_out;
 3578              		.loc 1 808 5 view .LVU1122
 3579 01fe 40F67A43 		movw	r3, #3194
 808:le_phy.c      **** 		goto err_out;
 3580              		.loc 1 808 29 view .LVU1123
 3581 0202 B21F     		subs	r2, r6, #6
 806:le_phy.c      **** 
 3582              		.loc 1 806 54 view .LVU1124
 3583 0204 00F01F00 		and	r0, r0, #31
 808:le_phy.c      **** 		goto err_out;
 3584              		.loc 1 808 5 view .LVU1125
 3585 0208 9A42     		cmp	r2, r3
 806:le_phy.c      **** 
 3586              		.loc 1 806 26 view .LVU1126
 3587 020a 84F82D00 		strb	r0, [r4, #45]
 808:le_phy.c      **** 		goto err_out;
 3588              		.loc 1 808 2 is_stmt 1 view .LVU1127
 808:le_phy.c      **** 		goto err_out;
 3589              		.loc 1 808 5 is_stmt 0 view .LVU1128
 3590 020e 75D8     		bhi	.L248
 811:le_phy.c      **** 	}
 3591              		.loc 1 811 3 is_stmt 1 view .LVU1129
 811:le_phy.c      **** 	}
 3592              		.loc 1 811 22 is_stmt 0 view .LVU1130
 3593 0210 43F2D403 		movw	r3, #12500
 3594 0214 5E43     		muls	r6, r3, r6
 815:le_phy.c      **** 	if (conn.win_offset > conn.conn_interval)
ARM GAS  /tmp/ccXJY3ni.s 			page 104


 3595              		.loc 1 815 18 view .LVU1131
 3596 0216 5F43     		muls	r7, r3, r7
 816:le_phy.c      **** 		goto err_out;
 3597              		.loc 1 816 5 view .LVU1132
 3598 0218 BE42     		cmp	r6, r7
 811:le_phy.c      **** 	}
 3599              		.loc 1 811 22 view .LVU1133
 3600 021a 2663     		str	r6, [r4, #48]
 815:le_phy.c      **** 	if (conn.win_offset > conn.conn_interval)
 3601              		.loc 1 815 2 is_stmt 1 view .LVU1134
 815:le_phy.c      **** 	if (conn.win_offset > conn.conn_interval)
 3602              		.loc 1 815 18 is_stmt 0 view .LVU1135
 3603 021c E763     		str	r7, [r4, #60]
 816:le_phy.c      **** 		goto err_out;
 3604              		.loc 1 816 2 is_stmt 1 view .LVU1136
 816:le_phy.c      **** 		goto err_out;
 3605              		.loc 1 816 5 is_stmt 0 view .LVU1137
 3606 021e 6DD3     		bcc	.L248
 820:le_phy.c      **** 	max_win_size = conn.conn_interval - USEC(1250);
 3607              		.loc 1 820 2 is_stmt 1 view .LVU1138
 824:le_phy.c      **** 		goto err_out;
 3608              		.loc 1 824 5 is_stmt 0 view .LVU1139
 3609 0220 43F2D302 		movw	r2, #12499
 820:le_phy.c      **** 	max_win_size = conn.conn_interval - USEC(1250);
 3610              		.loc 1 820 17 view .LVU1140
 3611 0224 5FFA89F9 		uxtb	r9, r9
 820:le_phy.c      **** 	max_win_size = conn.conn_interval - USEC(1250);
 3612              		.loc 1 820 27 view .LVU1141
 3613 0228 03FB09F3 		mul	r3, r3, r9
 3614              	.LVL274:
 821:le_phy.c      **** 	if (max_win_size > MSEC(10))
 3615              		.loc 1 821 2 is_stmt 1 view .LVU1142
 822:le_phy.c      **** 		max_win_size = MSEC(10);
 3616              		.loc 1 822 2 view .LVU1143
 824:le_phy.c      **** 		goto err_out;
 3617              		.loc 1 824 2 view .LVU1144
 824:le_phy.c      **** 		goto err_out;
 3618              		.loc 1 824 5 is_stmt 0 view .LVU1145
 3619 022c 9342     		cmp	r3, r2
 3620 022e 65DD     		ble	.L248
 824:le_phy.c      **** 		goto err_out;
 3621              		.loc 1 824 28 view .LVU1146
 3622 0230 4448     		ldr	r0, .L272+64
 821:le_phy.c      **** 	if (max_win_size > MSEC(10))
 3623              		.loc 1 821 15 view .LVU1147
 3624 0232 A6F54356 		sub	r6, r6, #12480
 3625              	.LVL275:
 821:le_phy.c      **** 	if (max_win_size > MSEC(10))
 3626              		.loc 1 821 15 view .LVU1148
 3627 0236 143E     		subs	r6, r6, #20
 824:le_phy.c      **** 		goto err_out;
 3628              		.loc 1 824 28 view .LVU1149
 3629 0238 8642     		cmp	r6, r0
 3630 023a 28BF     		it	cs
 3631 023c 0646     		movcs	r6, r0
 3632 023e B342     		cmp	r3, r6
 3633 0240 5CD8     		bhi	.L248
ARM GAS  /tmp/ccXJY3ni.s 			page 105


 830:le_phy.c      **** 	if (conn.supervision_timeout < MSEC(100) || conn.supervision_timeout > SEC(32))
 3634              		.loc 1 830 2 is_stmt 1 view .LVU1150
 830:le_phy.c      **** 	if (conn.supervision_timeout < MSEC(100) || conn.supervision_timeout > SEC(32))
 3635              		.loc 1 830 27 is_stmt 0 view .LVU1151
 3636 0242 00FB0AF0 		mul	r0, r0, r10
 831:le_phy.c      **** 		goto err_out;
 3637              		.loc 1 831 5 view .LVU1152
 3638 0246 404B     		ldr	r3, .L272+68
 3639              	.LVL276:
 831:le_phy.c      **** 		goto err_out;
 3640              		.loc 1 831 43 view .LVU1153
 3641 0248 A0F5742A 		sub	r10, r0, #999424
 3642 024c AAF5107A 		sub	r10, r10, #576
 831:le_phy.c      **** 		goto err_out;
 3643              		.loc 1 831 5 view .LVU1154
 3644 0250 9A45     		cmp	r10, r3
 830:le_phy.c      **** 	if (conn.supervision_timeout < MSEC(100) || conn.supervision_timeout > SEC(32))
 3645              		.loc 1 830 27 view .LVU1155
 3646 0252 6063     		str	r0, [r4, #52]
 831:le_phy.c      **** 		goto err_out;
 3647              		.loc 1 831 2 is_stmt 1 view .LVU1156
 831:le_phy.c      **** 		goto err_out;
 3648              		.loc 1 831 5 is_stmt 0 view .LVU1157
 3649 0254 52D8     		bhi	.L248
 835:le_phy.c      **** 	if (conn.remapping.total_channels == 0)
 3650              		.loc 1 835 2 is_stmt 1 view .LVU1158
 3651 0256 3D49     		ldr	r1, .L272+72
 3652 0258 05F11E00 		add	r0, r5, #30
 3653 025c FFF7FEFF 		bl	le_parse_channel_map
 3654              	.LVL277:
 836:le_phy.c      **** 		goto err_out;
 3655              		.loc 1 836 2 view .LVU1159
 836:le_phy.c      **** 		goto err_out;
 3656              		.loc 1 836 5 is_stmt 0 view .LVU1160
 3657 0260 D4F8FC30 		ldr	r3, [r4, #252]
 3658 0264 002B     		cmp	r3, #0
 3659 0266 49D0     		beq	.L248
 840:le_phy.c      **** 
 3660              		.loc 1 840 2 is_stmt 1 view .LVU1161
 3661              	.LBB187:
 3662              	.LBI187:
 570:le_phy.c      **** 	T1MCR &= ~TMCR_MR2I;
 3663              		.loc 1 570 13 view .LVU1162
 3664              	.LBB188:
 571:le_phy.c      **** }
 3665              		.loc 1 571 2 view .LVU1163
 571:le_phy.c      **** }
 3666              		.loc 1 571 8 is_stmt 0 view .LVU1164
 3667 0268 394A     		ldr	r2, .L272+76
 3668 026a 1368     		ldr	r3, [r2]
 3669 026c 23F04003 		bic	r3, r3, #64
 3670 0270 1360     		str	r3, [r2]
 3671              	.LBE188:
 3672              	.LBE187:
 842:le_phy.c      **** 	timer1_set_match(buf->timestamp + PACKET_DURATION(buf) +
 3673              		.loc 1 842 2 is_stmt 1 view .LVU1165
 3674              	.LBB189:
ARM GAS  /tmp/ccXJY3ni.s 			page 106


 3675              	.LBI189:
 206:le_phy.c      **** 	conn_event.num_packets = 0;
 3676              		.loc 1 206 13 view .LVU1166
 3677              	.LBB190:
 207:le_phy.c      **** 	conn_event.opened = 0;
 3678              		.loc 1 207 2 view .LVU1167
 207:le_phy.c      **** 	conn_event.opened = 0;
 3679              		.loc 1 207 25 is_stmt 0 view .LVU1168
 3680 0272 0022     		movs	r2, #0
 3681 0274 374B     		ldr	r3, .L272+80
 3682              	.LBE190:
 3683              	.LBE189:
 843:le_phy.c      **** 			conn.win_offset + USEC(1250) - RX_WARMUP_TIME);
 3684              		.loc 1 843 2 view .LVU1169
 3685 0276 E06B     		ldr	r0, [r4, #60]
 3686              	.LBB192:
 3687              	.LBB191:
 208:le_phy.c      **** }
 3688              		.loc 1 208 20 view .LVU1170
 3689 0278 C3E90122 		strd	r2, r2, [r3, #4]
 3690              	.LBE191:
 3691              	.LBE192:
 843:le_phy.c      **** 			conn.win_offset + USEC(1250) - RX_WARMUP_TIME);
 3692              		.loc 1 843 2 is_stmt 1 view .LVU1171
 3693 027c 5022     		movs	r2, #80
 3694 027e D5F80C31 		ldr	r3, [r5, #268]
 3695 0282 00F51A50 		add	r0, r0, #9856
 3696 0286 2C30     		adds	r0, r0, #44
 3697 0288 1844     		add	r0, r0, r3
 843:le_phy.c      **** 			conn.win_offset + USEC(1250) - RX_WARMUP_TIME);
 3698              		.loc 1 843 34 is_stmt 0 view .LVU1172
 3699 028a D5F80431 		ldr	r3, [r5, #260]
 843:le_phy.c      **** 			conn.win_offset + USEC(1250) - RX_WARMUP_TIME);
 3700              		.loc 1 843 2 view .LVU1173
 3701 028e 02FB0300 		mla	r0, r2, r3, r0
 3702 0292 FFF7FEFF 		bl	timer1_set_match
 3703              	.LVL278:
 845:le_phy.c      **** 
 3704              		.loc 1 845 2 is_stmt 1 view .LVU1174
 3705 0296 1CE0     		b	.L242
 3706              	.LVL279:
 3707              	.L234:
 845:le_phy.c      **** 
 3708              		.loc 1 845 2 is_stmt 0 view .LVU1175
 3709              	.LBE186:
 3710              	.LBE185:
 3711              	.LBE184:
 3712              	.LBE183:
 3713              	.LBE178:
 985:le_phy.c      ****                             // write char to serial port
 3714              		.loc 1 985 29 view .LVU1176
 3715 0298 059D     		ldr	r5, [sp, #20]
 3716              	.LBB201:
 3717              	.LBB175:
 923:le_phy.c      **** 		return 1;
 3718              		.loc 1 923 2 is_stmt 1 view .LVU1177
 923:le_phy.c      **** 		return 1;
ARM GAS  /tmp/ccXJY3ni.s 			page 107


 3719              		.loc 1 923 6 is_stmt 0 view .LVU1178
 3720 029a B5F81001 		ldrh	r0, [r5, #272]
 3721 029e FFF7FEFF 		bl	btle_channel_index
 3722              	.LVL280:
 923:le_phy.c      **** 		return 1;
 3723              		.loc 1 923 5 view .LVU1179
 3724 02a2 2428     		cmp	r0, #36
 3725 02a4 7FF613AF 		bls	.L237
 926:le_phy.c      **** 		// ADV_IND, ADV_NONCONN_IND, ADV_SCAN_IND, SCAN_RSP
 3726              		.loc 1 926 2 is_stmt 1 view .LVU1180
 3727 02a8 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 3728 02aa 03F00F03 		and	r3, r3, #15
 3729 02ae 062B     		cmp	r3, #6
 3730 02b0 0FD8     		bhi	.L242
 3731 02b2 DFE803F0 		tbb	[pc, r3]
 3732              	.L240:
 3733 02b6 04       		.byte	(.L239-.L240)/2
 3734 02b7 16       		.byte	(.L241-.L240)/2
 3735 02b8 04       		.byte	(.L239-.L240)/2
 3736 02b9 16       		.byte	(.L241-.L240)/2
 3737 02ba 04       		.byte	(.L239-.L240)/2
 3738 02bb 16       		.byte	(.L241-.L240)/2
 3739 02bc 04       		.byte	(.L239-.L240)/2
 3740 02bd 00       		.p2align 1
 3741              	.L239:
 933:le_phy.c      **** 				return 0;
 3742              		.loc 1 933 4 view .LVU1181
 933:le_phy.c      **** 				return 0;
 3743              		.loc 1 933 7 is_stmt 0 view .LVU1182
 3744 02be D5F80431 		ldr	r3, [r5, #260]
 3745 02c2 072B     		cmp	r3, #7
 3746 02c4 05D9     		bls	.L242
 935:le_phy.c      **** 			break;
 3747              		.loc 1 935 4 is_stmt 1 view .LVU1183
 935:le_phy.c      **** 			break;
 3748              		.loc 1 935 11 is_stmt 0 view .LVU1184
 3749 02c6 A81C     		adds	r0, r5, #2
 3750              	.L271:
 946:le_phy.c      **** 			break;
 3751              		.loc 1 946 8 view .LVU1185
 3752 02c8 FFF7FEFF 		bl	bd_addr_cmp
 3753              	.LVL281:
 945:le_phy.c      **** 				   bd_addr_cmp(&buf->data[8]);
 3754              		.loc 1 945 38 view .LVU1186
 3755 02cc 0028     		cmp	r0, #0
 3756 02ce 7FF4FEAE 		bne	.L237
 3757              	.L242:
 945:le_phy.c      **** 				   bd_addr_cmp(&buf->data[8]);
 3758              		.loc 1 945 38 view .LVU1187
 3759              	.LBE175:
 3760              	.LBE201:
1011:le_phy.c      **** 		}
 3761              		.loc 1 1011 4 is_stmt 1 view .LVU1188
 3762              	.LBB202:
 3763              	.LBI202:
 201:le_phy.c      **** 	buffer->available = 1;
 3764              		.loc 1 201 13 view .LVU1189
ARM GAS  /tmp/ccXJY3ni.s 			page 108


 3765              	.LVL282:
 3766              	.LBB203:
 202:le_phy.c      **** }
 3767              		.loc 1 202 2 view .LVU1190
 202:le_phy.c      **** }
 3768              		.loc 1 202 20 is_stmt 0 view .LVU1191
 3769 02d2 0122     		movs	r2, #1
 3770 02d4 059B     		ldr	r3, [sp, #20]
 3771 02d6 C3F81821 		str	r2, [r3, #280]
 3772              	.LVL283:
 3773              	.L233:
 202:le_phy.c      **** }
 3774              		.loc 1 202 20 view .LVU1192
 3775              	.LBE203:
 3776              	.LBE202:
1015:le_phy.c      **** 
 3777              		.loc 1 1015 3 is_stmt 1 view .LVU1193
 3778 02da 0020     		movs	r0, #0
 3779 02dc FFF7FEFF 		bl	handle_usb
 3780              	.LVL284:
 3781 02e0 CAE6     		b	.L232
 3782              	.L241:
 3783              	.LBB204:
 3784              	.LBB176:
 936:le_phy.c      **** 
 3785              		.loc 1 936 4 view .LVU1194
 943:le_phy.c      **** 				return 0;
 3786              		.loc 1 943 4 view .LVU1195
 943:le_phy.c      **** 				return 0;
 3787              		.loc 1 943 7 is_stmt 0 view .LVU1196
 3788 02e2 D5F80431 		ldr	r3, [r5, #260]
 3789 02e6 0D2B     		cmp	r3, #13
 3790 02e8 F3D9     		bls	.L242
 945:le_phy.c      **** 				   bd_addr_cmp(&buf->data[8]);
 3791              		.loc 1 945 4 is_stmt 1 view .LVU1197
 945:le_phy.c      **** 				   bd_addr_cmp(&buf->data[8]);
 3792              		.loc 1 945 11 is_stmt 0 view .LVU1198
 3793 02ea A81C     		adds	r0, r5, #2
 3794 02ec FFF7FEFF 		bl	bd_addr_cmp
 3795              	.LVL285:
 945:le_phy.c      **** 				   bd_addr_cmp(&buf->data[8]);
 3796              		.loc 1 945 38 view .LVU1199
 3797 02f0 0028     		cmp	r0, #0
 3798 02f2 7FF4ECAE 		bne	.L237
 946:le_phy.c      **** 			break;
 3799              		.loc 1 946 8 view .LVU1200
 3800 02f6 05F10800 		add	r0, r5, #8
 3801 02fa E5E7     		b	.L271
 3802              	.LVL286:
 3803              	.L248:
 3804              	.LDL1:
 946:le_phy.c      **** 			break;
 3805              		.loc 1 946 8 view .LVU1201
 3806              	.LBE176:
 3807              	.LBE204:
 3808              	.LBB205:
 3809              	.LBB200:
ARM GAS  /tmp/ccXJY3ni.s 			page 109


 3810              	.LBB199:
 3811              	.LBB194:
 3812              	.LBB193:
 849:le_phy.c      **** }
 3813              		.loc 1 849 2 is_stmt 1 view .LVU1202
 3814 02fc FFF7FEFF 		bl	reset_conn
 3815              	.LVL287:
 3816 0300 E7E7     		b	.L242
 3817              	.L273:
 3818 0302 00BF     		.align	2
 3819              	.L272:
 3820 0304 80E100E0 		.word	-536813184
 3821 0308 00000000 		.word	.LANCHOR0
 3822 030c 00000000 		.word	packet_queue
 3823 0310 04800040 		.word	1073774596
 3824 0314 0C800040 		.word	1073774604
 3825 0318 00E100E0 		.word	-536813312
 3826 031c 00000000 		.word	le_adv_channel
 3827 0320 00000000 		.word	rf_channel
 3828 0324 D6BE898E 		.word	-1903575338
 3829 0328 00000000 		.word	cancel_follow
 3830 032c 00000000 		.word	requested_mode
 3831 0330 3CC00920 		.word	537509948
 3832 0334 A0010000 		.word	.LC18
 3833 0338 38C00920 		.word	537509944
 3834 033c 08800040 		.word	1073774600
 3835 0340 1C800040 		.word	1073774620
 3836 0344 A0860100 		.word	100000
 3837 0348 C08D0313 		.word	319000000
 3838 034c 40000000 		.word	.LANCHOR0+64
 3839 0350 14800040 		.word	1073774612
 3840 0354 00000000 		.word	conn_event
 3841 0358 00000000 		.word	le
 3842              	.LVL288:
 3843              	.L246:
 849:le_phy.c      **** }
 3844              		.loc 1 849 2 is_stmt 0 view .LVU1203
 3845              	.LBE193:
 3846              	.LBE194:
 891:le_phy.c      **** 			switch (buf->data[2]) {
 3847              		.loc 1 891 3 is_stmt 1 view .LVU1204
 891:le_phy.c      **** 			switch (buf->data[2]) {
 3848              		.loc 1 891 6 is_stmt 0 view .LVU1205
 3849 035c 01F00301 		and	r1, r1, #3
 3850 0360 0329     		cmp	r1, #3
 3851 0362 B6D1     		bne	.L242
 891:le_phy.c      **** 			switch (buf->data[2]) {
 3852              		.loc 1 891 49 view .LVU1206
 3853 0364 95F80190 		ldrb	r9, [r5, #1]	@ zero_extendqisi2
 891:le_phy.c      **** 			switch (buf->data[2]) {
 3854              		.loc 1 891 37 view .LVU1207
 3855 0368 B9F1000F 		cmp	r9, #0
 3856 036c B1D0     		beq	.L242
 892:le_phy.c      **** 				// LE_CONNECTION_UPDATE_REQ -- update connection parameters
 3857              		.loc 1 892 4 is_stmt 1 view .LVU1208
 892:le_phy.c      **** 				// LE_CONNECTION_UPDATE_REQ -- update connection parameters
 3858              		.loc 1 892 21 is_stmt 0 view .LVU1209
ARM GAS  /tmp/ccXJY3ni.s 			page 110


 3859 036e AB78     		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 892:le_phy.c      **** 				// LE_CONNECTION_UPDATE_REQ -- update connection parameters
 3860              		.loc 1 892 4 view .LVU1210
 3861 0370 93B1     		cbz	r3, .L249
 3862 0372 012B     		cmp	r3, #1
 3863 0374 ADD1     		bne	.L242
 901:le_phy.c      **** 						channel_map_update_handler(buf);
 3864              		.loc 1 901 6 is_stmt 1 view .LVU1211
 901:le_phy.c      **** 						channel_map_update_handler(buf);
 3865              		.loc 1 901 9 is_stmt 0 view .LVU1212
 3866 0376 B9F1080F 		cmp	r9, #8
 3867 037a AAD1     		bne	.L242
 902:le_phy.c      **** 					break;
 3868              		.loc 1 902 7 is_stmt 1 view .LVU1213
 3869              	.LVL289:
 3870              	.LBB195:
 3871              	.LBI195:
 870:le_phy.c      **** 	conn.channel_map_update_pending = 1;
 3872              		.loc 1 870 13 view .LVU1214
 3873              	.LBB196:
 871:le_phy.c      **** 	conn.channel_map_update_instant = extract_field(buf, 8, 2);
 3874              		.loc 1 871 2 view .LVU1215
 872:le_phy.c      **** 	le_parse_channel_map(&buf->data[3], &conn.pending_remapping);
 3875              		.loc 1 872 36 is_stmt 0 view .LVU1216
 3876 037c 4946     		mov	r1, r9
 3877 037e 0222     		movs	r2, #2
 3878 0380 2846     		mov	r0, r5
 871:le_phy.c      **** 	conn.channel_map_update_instant = extract_field(buf, 8, 2);
 3879              		.loc 1 871 34 view .LVU1217
 3880 0382 C4F82031 		str	r3, [r4, #288]
 872:le_phy.c      **** 	le_parse_channel_map(&buf->data[3], &conn.pending_remapping);
 3881              		.loc 1 872 2 is_stmt 1 view .LVU1218
 872:le_phy.c      **** 	le_parse_channel_map(&buf->data[3], &conn.pending_remapping);
 3882              		.loc 1 872 36 is_stmt 0 view .LVU1219
 3883 0386 FFF7FEFF 		bl	extract_field
 3884              	.LVL290:
 873:le_phy.c      **** }
 3885              		.loc 1 873 2 view .LVU1220
 3886 038a 2449     		ldr	r1, .L274
 872:le_phy.c      **** 	le_parse_channel_map(&buf->data[3], &conn.pending_remapping);
 3887              		.loc 1 872 34 view .LVU1221
 3888 038c A4F82401 		strh	r0, [r4, #292]	@ movhi
 873:le_phy.c      **** }
 3889              		.loc 1 873 2 is_stmt 1 view .LVU1222
 3890 0390 E81C     		adds	r0, r5, #3
 3891 0392 FFF7FEFF 		bl	le_parse_channel_map
 3892              	.LVL291:
 874:le_phy.c      **** 
 3893              		.loc 1 874 1 is_stmt 0 view .LVU1223
 3894 0396 9CE7     		b	.L242
 3895              	.LVL292:
 3896              	.L249:
 874:le_phy.c      **** 
 3897              		.loc 1 874 1 view .LVU1224
 3898              	.LBE196:
 3899              	.LBE195:
 895:le_phy.c      **** 						connection_update_handler(buf);
ARM GAS  /tmp/ccXJY3ni.s 			page 111


 3900              		.loc 1 895 6 is_stmt 1 view .LVU1225
 895:le_phy.c      **** 						connection_update_handler(buf);
 3901              		.loc 1 895 9 is_stmt 0 view .LVU1226
 3902 0398 B9F10C0F 		cmp	r9, #12
 3903 039c 99D1     		bne	.L242
 896:le_phy.c      **** 					break;
 3904              		.loc 1 896 7 is_stmt 1 view .LVU1227
 3905              	.LVL293:
 3906              	.LBB197:
 3907              	.LBI197:
 852:le_phy.c      **** 	conn.win_size            = extract_field(buf, 3, 1);
 3908              		.loc 1 852 13 view .LVU1228
 3909              	.LBB198:
 853:le_phy.c      **** 	conn.win_offset          = extract_field(buf, 4, 2);
 3910              		.loc 1 853 2 view .LVU1229
 853:le_phy.c      **** 	conn.win_offset          = extract_field(buf, 4, 2);
 3911              		.loc 1 853 29 is_stmt 0 view .LVU1230
 3912 039e 0122     		movs	r2, #1
 3913 03a0 2846     		mov	r0, r5
 3914 03a2 FFF7FEFF 		bl	extract_field
 3915              	.LVL294:
 854:le_phy.c      **** 	conn.conn_update_pending_interval = extract_field(buf, 6, 2);
 3916              		.loc 1 854 29 view .LVU1231
 3917 03a6 0222     		movs	r2, #2
 853:le_phy.c      **** 	conn.win_offset          = extract_field(buf, 4, 2);
 3918              		.loc 1 853 27 view .LVU1232
 3919 03a8 C6B2     		uxtb	r6, r0
 854:le_phy.c      **** 	conn.conn_update_pending_interval = extract_field(buf, 6, 2);
 3920              		.loc 1 854 29 view .LVU1233
 3921 03aa 0421     		movs	r1, #4
 3922 03ac 2846     		mov	r0, r5
 853:le_phy.c      **** 	conn.win_offset          = extract_field(buf, 4, 2);
 3923              		.loc 1 853 27 view .LVU1234
 3924 03ae 84F83860 		strb	r6, [r4, #56]
 854:le_phy.c      **** 	conn.conn_update_pending_interval = extract_field(buf, 6, 2);
 3925              		.loc 1 854 2 is_stmt 1 view .LVU1235
 854:le_phy.c      **** 	conn.conn_update_pending_interval = extract_field(buf, 6, 2);
 3926              		.loc 1 854 29 is_stmt 0 view .LVU1236
 3927 03b2 FFF7FEFF 		bl	extract_field
 3928              	.LVL295:
 855:le_phy.c      **** 	conn.conn_update_pending_supervision_timeout = extract_field(buf, 10, 2);
 3929              		.loc 1 855 38 view .LVU1237
 3930 03b6 0222     		movs	r2, #2
 854:le_phy.c      **** 	conn.conn_update_pending_interval = extract_field(buf, 6, 2);
 3931              		.loc 1 854 29 view .LVU1238
 3932 03b8 0746     		mov	r7, r0
 855:le_phy.c      **** 	conn.conn_update_pending_supervision_timeout = extract_field(buf, 10, 2);
 3933              		.loc 1 855 38 view .LVU1239
 3934 03ba 0621     		movs	r1, #6
 854:le_phy.c      **** 	conn.conn_update_pending_interval = extract_field(buf, 6, 2);
 3935              		.loc 1 854 27 view .LVU1240
 3936 03bc E063     		str	r0, [r4, #60]
 855:le_phy.c      **** 	conn.conn_update_pending_supervision_timeout = extract_field(buf, 10, 2);
 3937              		.loc 1 855 2 is_stmt 1 view .LVU1241
 855:le_phy.c      **** 	conn.conn_update_pending_supervision_timeout = extract_field(buf, 10, 2);
 3938              		.loc 1 855 38 is_stmt 0 view .LVU1242
 3939 03be 2846     		mov	r0, r5
ARM GAS  /tmp/ccXJY3ni.s 			page 112


 3940 03c0 FFF7FEFF 		bl	extract_field
 3941              	.LVL296:
 856:le_phy.c      **** 	conn.conn_update_instant = extract_field(buf, 12, 2);
 3942              		.loc 1 856 49 view .LVU1243
 3943 03c4 0222     		movs	r2, #2
 3944 03c6 0A21     		movs	r1, #10
 855:le_phy.c      **** 	conn.conn_update_pending_supervision_timeout = extract_field(buf, 10, 2);
 3945              		.loc 1 855 36 view .LVU1244
 3946 03c8 C4F81401 		str	r0, [r4, #276]
 3947 03cc 0390     		str	r0, [sp, #12]
 856:le_phy.c      **** 	conn.conn_update_instant = extract_field(buf, 12, 2);
 3948              		.loc 1 856 2 is_stmt 1 view .LVU1245
 856:le_phy.c      **** 	conn.conn_update_instant = extract_field(buf, 12, 2);
 3949              		.loc 1 856 49 is_stmt 0 view .LVU1246
 3950 03ce 2846     		mov	r0, r5
 3951 03d0 FFF7FEFF 		bl	extract_field
 3952              	.LVL297:
 857:le_phy.c      **** 
 3953              		.loc 1 857 29 view .LVU1247
 3954 03d4 0222     		movs	r2, #2
 856:le_phy.c      **** 	conn.conn_update_instant = extract_field(buf, 12, 2);
 3955              		.loc 1 856 49 view .LVU1248
 3956 03d6 8246     		mov	r10, r0
 856:le_phy.c      **** 	conn.conn_update_instant = extract_field(buf, 12, 2);
 3957              		.loc 1 856 47 view .LVU1249
 3958 03d8 C4F81801 		str	r0, [r4, #280]
 857:le_phy.c      **** 
 3959              		.loc 1 857 2 is_stmt 1 view .LVU1250
 857:le_phy.c      **** 
 3960              		.loc 1 857 29 is_stmt 0 view .LVU1251
 3961 03dc 4946     		mov	r1, r9
 3962 03de 2846     		mov	r0, r5
 3963 03e0 FFF7FEFF 		bl	extract_field
 3964              	.LVL298:
 863:le_phy.c      **** 	conn.conn_update_pending_interval *= USEC(1250);
 3965              		.loc 1 863 18 view .LVU1252
 3966 03e4 43F2D402 		movw	r2, #12500
 864:le_phy.c      **** 	conn.conn_update_pending_supervision_timeout *= MSEC(10);
 3967              		.loc 1 864 36 view .LVU1253
 3968 03e8 039B     		ldr	r3, [sp, #12]
 857:le_phy.c      **** 
 3969              		.loc 1 857 27 view .LVU1254
 3970 03ea A4F81C01 		strh	r0, [r4, #284]	@ movhi
 862:le_phy.c      **** 	conn.win_offset *= USEC(1250);
 3971              		.loc 1 862 2 is_stmt 1 view .LVU1255
 864:le_phy.c      **** 	conn.conn_update_pending_supervision_timeout *= MSEC(10);
 3972              		.loc 1 864 36 is_stmt 0 view .LVU1256
 3973 03ee 5343     		muls	r3, r2, r3
 3974 03f0 C4F81431 		str	r3, [r4, #276]
 867:le_phy.c      **** }
 3975              		.loc 1 867 27 view .LVU1257
 3976 03f4 0123     		movs	r3, #1
 862:le_phy.c      **** 	conn.win_offset *= USEC(1250);
 3977              		.loc 1 862 18 view .LVU1258
 3978 03f6 06EB4600 		add	r0, r6, r6, lsl #1
 3979 03fa 06EB8000 		add	r0, r6, r0, lsl #2
 3980 03fe 06EB8006 		add	r6, r6, r0, lsl #2
ARM GAS  /tmp/ccXJY3ni.s 			page 113


 865:le_phy.c      **** 
 3981              		.loc 1 865 47 view .LVU1259
 3982 0402 0748     		ldr	r0, .L274+4
 863:le_phy.c      **** 	conn.conn_update_pending_interval *= USEC(1250);
 3983              		.loc 1 863 18 view .LVU1260
 3984 0404 5743     		muls	r7, r2, r7
 865:le_phy.c      **** 
 3985              		.loc 1 865 47 view .LVU1261
 3986 0406 00FB0AF0 		mul	r0, r0, r10
 862:le_phy.c      **** 	conn.win_offset *= USEC(1250);
 3987              		.loc 1 862 18 view .LVU1262
 3988 040a B600     		lsls	r6, r6, #2
 3989 040c 84F83860 		strb	r6, [r4, #56]
 863:le_phy.c      **** 	conn.conn_update_pending_interval *= USEC(1250);
 3990              		.loc 1 863 2 is_stmt 1 view .LVU1263
 863:le_phy.c      **** 	conn.conn_update_pending_interval *= USEC(1250);
 3991              		.loc 1 863 18 is_stmt 0 view .LVU1264
 3992 0410 E763     		str	r7, [r4, #60]
 864:le_phy.c      **** 	conn.conn_update_pending_supervision_timeout *= MSEC(10);
 3993              		.loc 1 864 2 is_stmt 1 view .LVU1265
 865:le_phy.c      **** 
 3994              		.loc 1 865 2 view .LVU1266
 865:le_phy.c      **** 
 3995              		.loc 1 865 47 is_stmt 0 view .LVU1267
 3996 0412 C4F81801 		str	r0, [r4, #280]
 867:le_phy.c      **** }
 3997              		.loc 1 867 2 is_stmt 1 view .LVU1268
 867:le_phy.c      **** }
 3998              		.loc 1 867 27 is_stmt 0 view .LVU1269
 3999 0416 C4F81031 		str	r3, [r4, #272]
 868:le_phy.c      **** 
 4000              		.loc 1 868 1 view .LVU1270
 4001 041a 5AE7     		b	.L242
 4002              	.L275:
 4003              		.align	2
 4004              	.L274:
 4005 041c 28010000 		.word	.LANCHOR0+296
 4006 0420 A0860100 		.word	100000
 4007              	.LBE198:
 4008              	.LBE197:
 4009              	.LBE199:
 4010              	.LBE200:
 4011              	.LBE205:
 4012              	.LBE210:
 4013              		.cfi_endproc
 4014              	.LFE41:
 4016              		.comm	conn_event,12,4
 4017              		.global	conn
 4018              		.comm	packet_queue,48,4
 4019              		.comm	le_dma_dest,2,1
 4020              		.comm	rf_channel,2,2
 4021              		.comm	TAPE_LEN,4,4
 4022              		.comm	TAPE,4,4
 4023              		.global	cur_bit_pos
 4024              		.global	cur_byte_pos
 4025              		.comm	rx_err,4,4
 4026              		.comm	rx_tc,4,4
ARM GAS  /tmp/ccXJY3ni.s 			page 114


 4027              		.comm	idle_rxbuf,4,4
 4028              		.comm	active_rxbuf,4,4
 4029              		.comm	rxbuf2,50,1
 4030              		.comm	rxbuf1,50,1
 4031              		.comm	clkn_next_drift_fix,4,4
 4032              		.comm	clkn_last_drift_fix,4,4
 4033              		.comm	clk_drift_correction,2,2
 4034              		.comm	clk_drift_ppm,2,2
 4035              		.comm	clk100ns_offset,2,2
 4036              		.comm	clkn_offset,4,4
 4037              		.comm	last_hop,4,4
 4038              		.comm	clkn,4,4
 4039              		.section	.rodata
 4040              		.set	.LANCHOR1,. + 0
 4043              	whitening_index:
 4044 0000 463E786F 		.ascii	"F>xoM.\017eB'\037\032PS}Y\012#\0106z\021!\000:s\006"
 4044      4D2E0F65 
 4044      42271F1A 
 4044      50537D59 
 4044      0A230836 
 4045 001b 5E563134 		.ascii	"^V14\024(\033TZ?p/f"
 4045      14281B54 
 4045      5A3F702F 
 4045      66
 4048              	whitening:
 4049 0028 01010101 		.ascii	"\001\001\001\001\000\001\000\001\000\001\000\000\000"
 4049      00010001 
 4049      00010000 
 4049      00
 4050 0035 00010001 		.ascii	"\000\001\000\001\001\000\001\001\001\001\000\000\001"
 4050      01000101 
 4050      01010000 
 4050      01
 4051 0042 01010000 		.ascii	"\001\001\000\000\001\000\001\000\001\001\000\000\001"
 4051      01000100 
 4051      01010000 
 4051      01
 4052 004f 01000000 		.ascii	"\001\000\000\000\000\000\001\001\000\001\001\000\001"
 4052      00000101 
 4052      00010100 
 4052      01
 4053 005c 00010101 		.ascii	"\000\001\001\001\000\001\000\000\000\001\001\000\000"
 4053      00010000 
 4053      00010100 
 4053      00
 4054 0069 01000000 		.ascii	"\001\000\000\000\001\000\000\000\000\000\000\001\000"
 4054      01000000 
 4054      00000001 
 4054      00
 4055 0076 00010000 		.ascii	"\000\001\000\000\001\001\000\001\000\000\001\001\001"
 4055      01010001 
 4055      00000101 
 4055      01
 4056 0083 01000101 		.ascii	"\001\000\001\001\001\000\000\000\000\001\001\001\001"
 4056      01000000 
 4056      00010101 
 4056      01
ARM GAS  /tmp/ccXJY3ni.s 			page 115


 4057 0090 01010100 		.ascii	"\001\001\001\000\000\000\001\001\001\000\001\001\000"
 4057      00000101 
 4057      01000101 
 4057      00
 4058 009d 00000100 		.ascii	"\000\000\001\000\001\000\000\001\000\001"
 4058      01000001 
 4058      0001
 4059              		.bss
 4060              		.align	2
 4061              		.set	.LANCHOR0,. + 0
 4064              	le_dma_lli.5257:
 4065 0000 00000000 		.space	32
 4065      00000000 
 4065      00000000 
 4065      00000000 
 4065      00000000 
 4068              	conn:
 4069 0020 00000000 		.space	456
 4069      00000000 
 4069      00000000 
 4069      00000000 
 4069      00000000 
 4072              	le_buffer_pool:
 4073 01e8 00000000 		.space	1168
 4073      00000000 
 4073      00000000 
 4073      00000000 
 4073      00000000 
 4076              	current_rxbuf:
 4077 0678 00000000 		.space	4
 4080              	cur_byte_pos:
 4081 067c 00000000 		.space	4
 4084              	cur_bit_pos:
 4085 0680 00000000 		.space	4
 4086              		.text
 4087              	.Letext0:
 4088              		.file 3 "/usr/lib/gcc/arm-none-eabi/9.2.1/include/stddef.h"
 4089              		.file 4 "/usr/include/newlib/sys/_types.h"
 4090              		.file 5 "/usr/include/newlib/sys/reent.h"
 4091              		.file 6 "/usr/include/newlib/sys/lock.h"
 4092              		.file 7 "/usr/include/newlib/stdlib.h"
 4093              		.file 8 "/usr/lib/gcc/arm-none-eabi/9.2.1/include/stdint.h"
 4094              		.file 9 "../../host/libubertooth/src/ubertooth_interface.h"
 4095              		.file 10 "../common/ubertooth.h"
 4096              		.file 11 "ubertooth_clock.h"
 4097              		.file 12 "ubertooth_dma.h"
 4098              		.file 13 "bluetooth_le.h"
 4099              		.file 14 "queue.h"
 4100              		.file 15 "debug_uart.h"
 4101              		.file 16 "ubertooth_usb.h"
 4102              		.file 17 "/usr/include/newlib/string.h"
 4103              		.file 18 "<built-in>"
ARM GAS  /tmp/ccXJY3ni.s 			page 116


DEFINED SYMBOLS
                            *ABS*:0000000000000000 le_phy.c
     /tmp/ccXJY3ni.s:16     .text.le_dma_init:0000000000000000 $t
     /tmp/ccXJY3ni.s:23     .text.le_dma_init:0000000000000000 le_dma_init
     /tmp/ccXJY3ni.s:95     .text.le_dma_init:0000000000000034 $d
                            *COM*:0000000000000002 le_dma_dest
     /tmp/ccXJY3ni.s:104    .text.timer1_set_match:0000000000000000 $t
     /tmp/ccXJY3ni.s:110    .text.timer1_set_match:0000000000000000 timer1_set_match
     /tmp/ccXJY3ni.s:136    .text.timer1_set_match:0000000000000010 $d
     /tmp/ccXJY3ni.s:142    .text.timer1_wait_fs_lock:0000000000000000 $t
     /tmp/ccXJY3ni.s:148    .text.timer1_wait_fs_lock:0000000000000000 timer1_wait_fs_lock
     /tmp/ccXJY3ni.s:176    .text.timer1_wait_fs_lock:0000000000000018 $d
     /tmp/ccXJY3ni.s:182    .text.timer1_wait_buffer:0000000000000000 $t
     /tmp/ccXJY3ni.s:188    .text.timer1_wait_buffer:0000000000000000 timer1_wait_buffer
     /tmp/ccXJY3ni.s:216    .text.timer1_wait_buffer:000000000000001c $d
     /tmp/ccXJY3ni.s:222    .text.extract_field:0000000000000000 $t
     /tmp/ccXJY3ni.s:228    .text.extract_field:0000000000000000 extract_field
     /tmp/ccXJY3ni.s:279    .text.bd_addr_cmp:0000000000000000 $t
     /tmp/ccXJY3ni.s:285    .text.bd_addr_cmp:0000000000000000 bd_addr_cmp
     /tmp/ccXJY3ni.s:342    .text.bd_addr_cmp:000000000000002c $d
     /tmp/ccXJY3ni.s:347    .text.reset_conn:0000000000000000 $t
     /tmp/ccXJY3ni.s:353    .text.reset_conn:0000000000000000 reset_conn
     /tmp/ccXJY3ni.s:379    .text.reset_conn:0000000000000018 $d
     /tmp/ccXJY3ni.s:385    .text.buffer_get:0000000000000000 $t
     /tmp/ccXJY3ni.s:391    .text.buffer_get:0000000000000000 buffer_get
     /tmp/ccXJY3ni.s:487    .text.buffer_get:000000000000004c $d
     /tmp/ccXJY3ni.s:493    .text.le_cc2400_init_rf:0000000000000000 $t
     /tmp/ccXJY3ni.s:499    .text.le_cc2400_init_rf:0000000000000000 le_cc2400_init_rf
     /tmp/ccXJY3ni.s:592    .text.le_cc2400_init_rf:0000000000000070 $d
                            *COM*:0000000000000002 rf_channel
     /tmp/ccXJY3ni.s:598    .text.change_channel:0000000000000000 $t
     /tmp/ccXJY3ni.s:604    .text.change_channel:0000000000000000 change_channel
     /tmp/ccXJY3ni.s:764    .text.change_channel:00000000000000a4 $d
     /tmp/ccXJY3ni.s:774    .text.finish_conn_event:0000000000000000 $t
     /tmp/ccXJY3ni.s:780    .text.finish_conn_event:0000000000000000 finish_conn_event
     /tmp/ccXJY3ni.s:962    .text.finish_conn_event:00000000000000a8 $d
                            *COM*:000000000000000c conn_event
     /tmp/ccXJY3ni.s:973    .text.get_next_bit:0000000000000000 $t
     /tmp/ccXJY3ni.s:980    .text.get_next_bit:0000000000000000 get_next_bit
     /tmp/ccXJY3ni.s:1057   .text.get_next_bit:0000000000000048 $d
                            *COM*:0000000000000004 TAPE_LEN
                            *COM*:0000000000000004 TAPE
     /tmp/ccXJY3ni.s:1065   .text.is_tape_available:0000000000000000 $t
     /tmp/ccXJY3ni.s:1072   .text.is_tape_available:0000000000000000 is_tape_available
     /tmp/ccXJY3ni.s:1122   .text.is_tape_available:0000000000000028 $d
     /tmp/ccXJY3ni.s:1128   .text.set_pos_end:0000000000000000 $t
     /tmp/ccXJY3ni.s:1135   .text.set_pos_end:0000000000000000 set_pos_end
     /tmp/ccXJY3ni.s:1161   .text.set_pos_end:0000000000000010 $d
     /tmp/ccXJY3ni.s:1166   .text.set_pos_start:0000000000000000 $t
     /tmp/ccXJY3ni.s:1173   .text.set_pos_start:0000000000000000 set_pos_start
     /tmp/ccXJY3ni.s:1199   .text.set_pos_start:0000000000000010 $d
     /tmp/ccXJY3ni.s:1207   .text.get_next_byte:0000000000000000 $t
     /tmp/ccXJY3ni.s:1214   .text.get_next_byte:0000000000000000 get_next_byte
     /tmp/ccXJY3ni.s:1261   .text.get_next_byte:0000000000000028 $d
     /tmp/ccXJY3ni.s:1274   .text.tag_cons:0000000000000000 $t
     /tmp/ccXJY3ni.s:1281   .text.tag_cons:0000000000000000 tag_cons
     /tmp/ccXJY3ni.s:1383   .text.tag_cons:0000000000000044 $d
ARM GAS  /tmp/ccXJY3ni.s 			page 117


     /tmp/ccXJY3ni.s:1389   .text.len_cons:0000000000000000 $t
     /tmp/ccXJY3ni.s:1396   .text.len_cons:0000000000000000 len_cons
     /tmp/ccXJY3ni.s:1509   .text.len_cons:000000000000003c $d
     /tmp/ccXJY3ni.s:1519   .text.repeat_cons:0000000000000000 $t
     /tmp/ccXJY3ni.s:1526   .text.repeat_cons:0000000000000000 repeat_cons
     /tmp/ccXJY3ni.s:1739   .text.repeat_cons:00000000000000b0 $d
     /tmp/ccXJY3ni.s:1771   .text.run_parser:0000000000000000 $t
     /tmp/ccXJY3ni.s:1778   .text.run_parser:0000000000000000 run_parser
     /tmp/ccXJY3ni.s:1902   .text.run_parser:000000000000005e $d
     /tmp/ccXJY3ni.s:2198   .text.run_parser:00000000000001e0 $d
     /tmp/ccXJY3ni.s:2217   .text.le_DMA_IRQHandler:0000000000000000 $t
     /tmp/ccXJY3ni.s:2224   .text.le_DMA_IRQHandler:0000000000000000 le_DMA_IRQHandler
     /tmp/ccXJY3ni.s:2654   .text.le_DMA_IRQHandler:00000000000001ac $d
                            *COM*:0000000000000030 packet_queue
     /tmp/ccXJY3ni.s:2675   .text.TIMER1_IRQHandler:0000000000000000 $t
     /tmp/ccXJY3ni.s:2682   .text.TIMER1_IRQHandler:0000000000000000 TIMER1_IRQHandler
     /tmp/ccXJY3ni.s:3035   .text.TIMER1_IRQHandler:000000000000017c $d
     /tmp/ccXJY3ni.s:3051   .text.le_phy_main:0000000000000000 $t
     /tmp/ccXJY3ni.s:3058   .text.le_phy_main:0000000000000000 le_phy_main
     /tmp/ccXJY3ni.s:3733   .text.le_phy_main:00000000000002b6 $d
     /tmp/ccXJY3ni.s:3820   .text.le_phy_main:0000000000000304 $d
     /tmp/ccXJY3ni.s:3849   .text.le_phy_main:000000000000035c $t
     /tmp/ccXJY3ni.s:4005   .text.le_phy_main:000000000000041c $d
     /tmp/ccXJY3ni.s:4068   .bss:0000000000000020 conn
     /tmp/ccXJY3ni.s:4084   .bss:0000000000000680 cur_bit_pos
     /tmp/ccXJY3ni.s:4080   .bss:000000000000067c cur_byte_pos
                            *COM*:0000000000000004 rx_err
                            *COM*:0000000000000004 rx_tc
                            *COM*:0000000000000004 idle_rxbuf
                            *COM*:0000000000000004 active_rxbuf
                            *COM*:0000000000000032 rxbuf2
                            *COM*:0000000000000032 rxbuf1
                            *COM*:0000000000000004 clkn_next_drift_fix
                            *COM*:0000000000000004 clkn_last_drift_fix
                            *COM*:0000000000000002 clk_drift_correction
                            *COM*:0000000000000002 clk_drift_ppm
                            *COM*:0000000000000002 clk100ns_offset
                            *COM*:0000000000000004 clkn_offset
                            *COM*:0000000000000004 last_hop
                            *COM*:0000000000000004 clkn
     /tmp/ccXJY3ni.s:4043   .rodata:0000000000000000 whitening_index
     /tmp/ccXJY3ni.s:4048   .rodata:0000000000000028 whitening
     /tmp/ccXJY3ni.s:4060   .bss:0000000000000000 $d
     /tmp/ccXJY3ni.s:4064   .bss:0000000000000000 le_dma_lli.5257
     /tmp/ccXJY3ni.s:4072   .bss:00000000000001e8 le_buffer_pool
     /tmp/ccXJY3ni.s:4076   .bss:0000000000000678 current_rxbuf
     /tmp/ccXJY3ni.s:1911   .text.run_parser:0000000000000067 $d
     /tmp/ccXJY3ni.s:1911   .text.run_parser:0000000000000068 $t
     /tmp/ccXJY3ni.s:3740   .text.le_phy_main:00000000000002bd $d
     /tmp/ccXJY3ni.s:3740   .text.le_phy_main:00000000000002be $t

UNDEFINED SYMBOLS
le
memset
rbit
cc2400_set
cc2400_status
ARM GAS  /tmp/ccXJY3ni.s 			page 118


cc2400_strobe
dio_ssp_start
btle_channel_index_to_phys
le_map_channel
le_adv_channel
cancel_follow
debug_printf
debug_write
cc2400_get
btle_channel_index
queue_insert
memcpy
clkn_disable
queue_init
usb_queue_init
dio_ssp_init
clkn_init
queue_remove
le_dewhiten
usb_enqueue
le_parse_channel_map
handle_usb
requested_mode
