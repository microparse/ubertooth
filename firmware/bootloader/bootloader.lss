
bootloader.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000019b8  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  000019b8  000019b8  000119b8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .persistent   00000020  10000000  10000000  00030000  2**0
                  ALLOC
  3 .data         00000588  10000020  000019c0  00020020  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          000001c6  100005a8  00001f48  000205a8  2**2
                  ALLOC
  5 .ARM.attributes 00000029  00000000  00000000  000205a8  2**0
                  CONTENTS, READONLY
  6 .comment      000000a7  00000000  00000000  000205d1  2**0
                  CONTENTS, READONLY
  7 .debug_line   00003b25  00000000  00000000  00020678  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_info   00009e1f  00000000  00000000  0002419d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_abbrev 00002862  00000000  00000000  0002dfbc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_aranges 00000498  00000000  00000000  00030820  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_str    0001d59d  00000000  00000000  00030cb8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_loc    00003bb2  00000000  00000000  0004e255  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_frame  00000b2c  00000000  00000000  00051e08  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_ranges 000005e0  00000000  00000000  00052934  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_macro  00006d20  00000000  00000000  00052f14  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00000000 <_NVIC_Handler_Functions>:
       0:	e0 3f 00 10 21 04 00 00 75 04 00 00 75 04 00 00     .?..!...u...u...
      10:	75 04 00 00 75 04 00 00 75 04 00 00 00 00 00 00     u...u...u.......
      20:	00 00 00 00 00 00 00 00 00 00 00 00 75 04 00 00     ............u...
      30:	75 04 00 00 00 00 00 00 75 04 00 00 75 04 00 00     u.......u...u...
      40:	75 04 00 00 75 04 00 00 75 04 00 00 75 04 00 00     u...u...u...u...
      50:	75 04 00 00 75 04 00 00 75 04 00 00 75 04 00 00     u...u...u...u...
      60:	75 04 00 00 75 04 00 00 75 04 00 00 75 04 00 00     u...u...u...u...
      70:	75 04 00 00 75 04 00 00 75 04 00 00 75 04 00 00     u...u...u...u...
      80:	75 04 00 00 75 04 00 00 75 04 00 00 75 04 00 00     u...u...u...u...
      90:	75 04 00 00 75 04 00 00 75 04 00 00 75 04 00 00     u...u...u...u...
      a0:	75 04 00 00 75 04 00 00 75 04 00 00 75 04 00 00     u...u...u...u...
      b0:	75 04 00 00 75 04 00 00 75 04 00 00 75 04 00 00     u...u...u...u...
      c0:	75 04 00 00 75 04 00 00 75 04 00 00                 u...u...u...

000000cc <deregister_tm_clones>:
      cc:	4803      	ldr	r0, [pc, #12]	; (dc <deregister_tm_clones+0x10>)
      ce:	4b04      	ldr	r3, [pc, #16]	; (e0 <deregister_tm_clones+0x14>)
      d0:	4283      	cmp	r3, r0
      d2:	d002      	beq.n	da <deregister_tm_clones+0xe>
      d4:	4b03      	ldr	r3, [pc, #12]	; (e4 <deregister_tm_clones+0x18>)
      d6:	b103      	cbz	r3, da <deregister_tm_clones+0xe>
      d8:	4718      	bx	r3
      da:	4770      	bx	lr
      dc:	100005a8 	.word	0x100005a8
      e0:	100005a8 	.word	0x100005a8
      e4:	00000000 	.word	0x00000000

000000e8 <register_tm_clones>:
      e8:	4805      	ldr	r0, [pc, #20]	; (100 <register_tm_clones+0x18>)
      ea:	4906      	ldr	r1, [pc, #24]	; (104 <register_tm_clones+0x1c>)
      ec:	1a0b      	subs	r3, r1, r0
      ee:	0fd9      	lsrs	r1, r3, #31
      f0:	eb01 01a3 	add.w	r1, r1, r3, asr #2
      f4:	1049      	asrs	r1, r1, #1
      f6:	d002      	beq.n	fe <register_tm_clones+0x16>
      f8:	4b03      	ldr	r3, [pc, #12]	; (108 <register_tm_clones+0x20>)
      fa:	b103      	cbz	r3, fe <register_tm_clones+0x16>
      fc:	4718      	bx	r3
      fe:	4770      	bx	lr
     100:	100005a8 	.word	0x100005a8
     104:	100005a8 	.word	0x100005a8
     108:	00000000 	.word	0x00000000

0000010c <__do_global_dtors_aux>:
     10c:	b510      	push	{r4, lr}
     10e:	4c06      	ldr	r4, [pc, #24]	; (128 <__do_global_dtors_aux+0x1c>)
     110:	7823      	ldrb	r3, [r4, #0]
     112:	b943      	cbnz	r3, 126 <__do_global_dtors_aux+0x1a>
     114:	f7ff ffda 	bl	cc <deregister_tm_clones>
     118:	4b04      	ldr	r3, [pc, #16]	; (12c <__do_global_dtors_aux+0x20>)
     11a:	b113      	cbz	r3, 122 <__do_global_dtors_aux+0x16>
     11c:	4804      	ldr	r0, [pc, #16]	; (130 <__do_global_dtors_aux+0x24>)
     11e:	f3af 8000 	nop.w
     122:	2301      	movs	r3, #1
     124:	7023      	strb	r3, [r4, #0]
     126:	bd10      	pop	{r4, pc}
     128:	100005a8 	.word	0x100005a8
     12c:	00000000 	.word	0x00000000
     130:	00001988 	.word	0x00001988

00000134 <frame_dummy>:
     134:	b508      	push	{r3, lr}
     136:	4b04      	ldr	r3, [pc, #16]	; (148 <frame_dummy+0x14>)
     138:	b11b      	cbz	r3, 142 <frame_dummy+0xe>
     13a:	4904      	ldr	r1, [pc, #16]	; (14c <frame_dummy+0x18>)
     13c:	4804      	ldr	r0, [pc, #16]	; (150 <frame_dummy+0x1c>)
     13e:	f3af 8000 	nop.w
     142:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     146:	e7cf      	b.n	e8 <register_tm_clones>
     148:	00000000 	.word	0x00000000
     14c:	100005ac 	.word	0x100005ac
     150:	00001988 	.word	0x00001988

00000154 <_stack_init>:
     154:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
     158:	4770      	bx	lr
     15a:	bf00      	nop

0000015c <_mainCRTStartup>:
     15c:	4b15      	ldr	r3, [pc, #84]	; (1b4 <_mainCRTStartup+0x58>)
     15e:	2b00      	cmp	r3, #0
     160:	bf08      	it	eq
     162:	4b11      	ldreq	r3, [pc, #68]	; (1a8 <_mainCRTStartup+0x4c>)
     164:	469d      	mov	sp, r3
     166:	f7ff fff5 	bl	154 <_stack_init>
     16a:	2100      	movs	r1, #0
     16c:	468b      	mov	fp, r1
     16e:	460f      	mov	r7, r1
     170:	4811      	ldr	r0, [pc, #68]	; (1b8 <_mainCRTStartup+0x5c>)
     172:	4a12      	ldr	r2, [pc, #72]	; (1bc <_mainCRTStartup+0x60>)
     174:	1a12      	subs	r2, r2, r0
     176:	f000 f879 	bl	26c <memset>
     17a:	4b0c      	ldr	r3, [pc, #48]	; (1ac <_mainCRTStartup+0x50>)
     17c:	2b00      	cmp	r3, #0
     17e:	d000      	beq.n	182 <_mainCRTStartup+0x26>
     180:	4798      	blx	r3
     182:	4b0b      	ldr	r3, [pc, #44]	; (1b0 <_mainCRTStartup+0x54>)
     184:	2b00      	cmp	r3, #0
     186:	d000      	beq.n	18a <_mainCRTStartup+0x2e>
     188:	4798      	blx	r3
     18a:	2000      	movs	r0, #0
     18c:	2100      	movs	r1, #0
     18e:	0004      	movs	r4, r0
     190:	000d      	movs	r5, r1
     192:	480b      	ldr	r0, [pc, #44]	; (1c0 <_mainCRTStartup+0x64>)
     194:	f000 f816 	bl	1c4 <atexit>
     198:	f000 f844 	bl	224 <__libc_init_array>
     19c:	0020      	movs	r0, r4
     19e:	0029      	movs	r1, r5
     1a0:	f001 f982 	bl	14a8 <main>
     1a4:	f000 f814 	bl	1d0 <exit>
     1a8:	00080000 	.word	0x00080000
     1ac:	00000000 	.word	0x00000000
     1b0:	00000000 	.word	0x00000000
     1b4:	00000000 	.word	0x00000000
     1b8:	100005a8 	.word	0x100005a8
     1bc:	1000076e 	.word	0x1000076e
     1c0:	000001f1 	.word	0x000001f1

000001c4 <atexit>:
     1c4:	2300      	movs	r3, #0
     1c6:	4601      	mov	r1, r0
     1c8:	461a      	mov	r2, r3
     1ca:	4618      	mov	r0, r3
     1cc:	f000 b89e 	b.w	30c <__register_exitproc>

000001d0 <exit>:
     1d0:	b508      	push	{r3, lr}
     1d2:	2100      	movs	r1, #0
     1d4:	4604      	mov	r4, r0
     1d6:	f000 f8cb 	bl	370 <__call_exitprocs>
     1da:	4b04      	ldr	r3, [pc, #16]	; (1ec <exit+0x1c>)
     1dc:	6818      	ldr	r0, [r3, #0]
     1de:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
     1e0:	b103      	cbz	r3, 1e4 <exit+0x14>
     1e2:	4798      	blx	r3
     1e4:	4620      	mov	r0, r4
     1e6:	f001 fbb3 	bl	1950 <_exit>
     1ea:	bf00      	nop
     1ec:	00001954 	.word	0x00001954

000001f0 <__libc_fini_array>:
     1f0:	b538      	push	{r3, r4, r5, lr}
     1f2:	4c0a      	ldr	r4, [pc, #40]	; (21c <__libc_fini_array+0x2c>)
     1f4:	4d0a      	ldr	r5, [pc, #40]	; (220 <__libc_fini_array+0x30>)
     1f6:	1b64      	subs	r4, r4, r5
     1f8:	10a4      	asrs	r4, r4, #2
     1fa:	d00a      	beq.n	212 <__libc_fini_array+0x22>
     1fc:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
     200:	3b01      	subs	r3, #1
     202:	eb05 0583 	add.w	r5, r5, r3, lsl #2
     206:	3c01      	subs	r4, #1
     208:	f855 3904 	ldr.w	r3, [r5], #-4
     20c:	4798      	blx	r3
     20e:	2c00      	cmp	r4, #0
     210:	d1f9      	bne.n	206 <__libc_fini_array+0x16>
     212:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     216:	f001 bbc5 	b.w	19a4 <_fini>
     21a:	bf00      	nop
     21c:	000019b4 	.word	0x000019b4
     220:	000019b0 	.word	0x000019b0

00000224 <__libc_init_array>:
     224:	b570      	push	{r4, r5, r6, lr}
     226:	4e0d      	ldr	r6, [pc, #52]	; (25c <__libc_init_array+0x38>)
     228:	4d0d      	ldr	r5, [pc, #52]	; (260 <__libc_init_array+0x3c>)
     22a:	1b76      	subs	r6, r6, r5
     22c:	10b6      	asrs	r6, r6, #2
     22e:	d006      	beq.n	23e <__libc_init_array+0x1a>
     230:	2400      	movs	r4, #0
     232:	3401      	adds	r4, #1
     234:	f855 3b04 	ldr.w	r3, [r5], #4
     238:	4798      	blx	r3
     23a:	42a6      	cmp	r6, r4
     23c:	d1f9      	bne.n	232 <__libc_init_array+0xe>
     23e:	4e09      	ldr	r6, [pc, #36]	; (264 <__libc_init_array+0x40>)
     240:	4d09      	ldr	r5, [pc, #36]	; (268 <__libc_init_array+0x44>)
     242:	f001 fba3 	bl	198c <_init>
     246:	1b76      	subs	r6, r6, r5
     248:	10b6      	asrs	r6, r6, #2
     24a:	d006      	beq.n	25a <__libc_init_array+0x36>
     24c:	2400      	movs	r4, #0
     24e:	3401      	adds	r4, #1
     250:	f855 3b04 	ldr.w	r3, [r5], #4
     254:	4798      	blx	r3
     256:	42a6      	cmp	r6, r4
     258:	d1f9      	bne.n	24e <__libc_init_array+0x2a>
     25a:	bd70      	pop	{r4, r5, r6, pc}
     25c:	00001998 	.word	0x00001998
     260:	00001998 	.word	0x00001998
     264:	000019a4 	.word	0x000019a4
     268:	00001998 	.word	0x00001998

0000026c <memset>:
     26c:	b4f0      	push	{r4, r5, r6, r7}
     26e:	0786      	lsls	r6, r0, #30
     270:	d046      	beq.n	300 <memset+0x94>
     272:	1e54      	subs	r4, r2, #1
     274:	2a00      	cmp	r2, #0
     276:	d03c      	beq.n	2f2 <memset+0x86>
     278:	b2ca      	uxtb	r2, r1
     27a:	4603      	mov	r3, r0
     27c:	e002      	b.n	284 <memset+0x18>
     27e:	f114 34ff 	adds.w	r4, r4, #4294967295	; 0xffffffff
     282:	d336      	bcc.n	2f2 <memset+0x86>
     284:	f803 2b01 	strb.w	r2, [r3], #1
     288:	079d      	lsls	r5, r3, #30
     28a:	d1f8      	bne.n	27e <memset+0x12>
     28c:	2c03      	cmp	r4, #3
     28e:	d929      	bls.n	2e4 <memset+0x78>
     290:	b2cd      	uxtb	r5, r1
     292:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
     296:	2c0f      	cmp	r4, #15
     298:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
     29c:	d933      	bls.n	306 <memset+0x9a>
     29e:	f1a4 0610 	sub.w	r6, r4, #16
     2a2:	0936      	lsrs	r6, r6, #4
     2a4:	f103 0720 	add.w	r7, r3, #32
     2a8:	eb07 1706 	add.w	r7, r7, r6, lsl #4
     2ac:	f103 0210 	add.w	r2, r3, #16
     2b0:	e942 5504 	strd	r5, r5, [r2, #-16]
     2b4:	e942 5502 	strd	r5, r5, [r2, #-8]
     2b8:	3210      	adds	r2, #16
     2ba:	42ba      	cmp	r2, r7
     2bc:	d1f8      	bne.n	2b0 <memset+0x44>
     2be:	1c72      	adds	r2, r6, #1
     2c0:	f014 0f0c 	tst.w	r4, #12
     2c4:	eb03 1202 	add.w	r2, r3, r2, lsl #4
     2c8:	f004 060f 	and.w	r6, r4, #15
     2cc:	d013      	beq.n	2f6 <memset+0x8a>
     2ce:	1f33      	subs	r3, r6, #4
     2d0:	f023 0303 	bic.w	r3, r3, #3
     2d4:	3304      	adds	r3, #4
     2d6:	4413      	add	r3, r2
     2d8:	f842 5b04 	str.w	r5, [r2], #4
     2dc:	4293      	cmp	r3, r2
     2de:	d1fb      	bne.n	2d8 <memset+0x6c>
     2e0:	f006 0403 	and.w	r4, r6, #3
     2e4:	b12c      	cbz	r4, 2f2 <memset+0x86>
     2e6:	b2c9      	uxtb	r1, r1
     2e8:	441c      	add	r4, r3
     2ea:	f803 1b01 	strb.w	r1, [r3], #1
     2ee:	429c      	cmp	r4, r3
     2f0:	d1fb      	bne.n	2ea <memset+0x7e>
     2f2:	bcf0      	pop	{r4, r5, r6, r7}
     2f4:	4770      	bx	lr
     2f6:	4634      	mov	r4, r6
     2f8:	4613      	mov	r3, r2
     2fa:	2c00      	cmp	r4, #0
     2fc:	d1f3      	bne.n	2e6 <memset+0x7a>
     2fe:	e7f8      	b.n	2f2 <memset+0x86>
     300:	4614      	mov	r4, r2
     302:	4603      	mov	r3, r0
     304:	e7c2      	b.n	28c <memset+0x20>
     306:	461a      	mov	r2, r3
     308:	4626      	mov	r6, r4
     30a:	e7e0      	b.n	2ce <memset+0x62>

0000030c <__register_exitproc>:
     30c:	b4f0      	push	{r4, r5, r6, r7}
     30e:	4c17      	ldr	r4, [pc, #92]	; (36c <__register_exitproc+0x60>)
     310:	6825      	ldr	r5, [r4, #0]
     312:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
     316:	b30c      	cbz	r4, 35c <__register_exitproc+0x50>
     318:	6865      	ldr	r5, [r4, #4]
     31a:	2d1f      	cmp	r5, #31
     31c:	dc23      	bgt.n	366 <__register_exitproc+0x5a>
     31e:	b938      	cbnz	r0, 330 <__register_exitproc+0x24>
     320:	2000      	movs	r0, #0
     322:	1c6b      	adds	r3, r5, #1
     324:	3502      	adds	r5, #2
     326:	6063      	str	r3, [r4, #4]
     328:	f844 1025 	str.w	r1, [r4, r5, lsl #2]
     32c:	bcf0      	pop	{r4, r5, r6, r7}
     32e:	4770      	bx	lr
     330:	2601      	movs	r6, #1
     332:	eb04 0c85 	add.w	ip, r4, r5, lsl #2
     336:	f8cc 2088 	str.w	r2, [ip, #136]	; 0x88
     33a:	f8d4 7188 	ldr.w	r7, [r4, #392]	; 0x188
     33e:	fa06 f205 	lsl.w	r2, r6, r5
     342:	4317      	orrs	r7, r2
     344:	2802      	cmp	r0, #2
     346:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
     34a:	f8cc 3108 	str.w	r3, [ip, #264]	; 0x108
     34e:	d1e7      	bne.n	320 <__register_exitproc+0x14>
     350:	f8d4 318c 	ldr.w	r3, [r4, #396]	; 0x18c
     354:	431a      	orrs	r2, r3
     356:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
     35a:	e7e1      	b.n	320 <__register_exitproc+0x14>
     35c:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
     360:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
     364:	e7d8      	b.n	318 <__register_exitproc+0xc>
     366:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     36a:	e7df      	b.n	32c <__register_exitproc+0x20>
     36c:	00001954 	.word	0x00001954

00000370 <__call_exitprocs>:
     370:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     374:	468a      	mov	sl, r1
     376:	f04f 0800 	mov.w	r8, #0
     37a:	4b23      	ldr	r3, [pc, #140]	; (408 <__call_exitprocs+0x98>)
     37c:	b083      	sub	sp, #12
     37e:	f8d3 b000 	ldr.w	fp, [r3]
     382:	9001      	str	r0, [sp, #4]
     384:	f8db 6148 	ldr.w	r6, [fp, #328]	; 0x148
     388:	b196      	cbz	r6, 3b0 <__call_exitprocs+0x40>
     38a:	6874      	ldr	r4, [r6, #4]
     38c:	1e65      	subs	r5, r4, #1
     38e:	d40f      	bmi.n	3b0 <__call_exitprocs+0x40>
     390:	2701      	movs	r7, #1
     392:	443c      	add	r4, r7
     394:	eb06 0484 	add.w	r4, r6, r4, lsl #2
     398:	f1ba 0f00 	cmp.w	sl, #0
     39c:	d00b      	beq.n	3b6 <__call_exitprocs+0x46>
     39e:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
     3a2:	4553      	cmp	r3, sl
     3a4:	d007      	beq.n	3b6 <__call_exitprocs+0x46>
     3a6:	3d01      	subs	r5, #1
     3a8:	1c6b      	adds	r3, r5, #1
     3aa:	f1a4 0404 	sub.w	r4, r4, #4
     3ae:	d1f3      	bne.n	398 <__call_exitprocs+0x28>
     3b0:	b003      	add	sp, #12
     3b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     3b6:	6873      	ldr	r3, [r6, #4]
     3b8:	6822      	ldr	r2, [r4, #0]
     3ba:	3b01      	subs	r3, #1
     3bc:	42ab      	cmp	r3, r5
     3be:	bf0c      	ite	eq
     3c0:	6075      	streq	r5, [r6, #4]
     3c2:	f8c4 8000 	strne.w	r8, [r4]
     3c6:	2a00      	cmp	r2, #0
     3c8:	d0ed      	beq.n	3a6 <__call_exitprocs+0x36>
     3ca:	f8d6 1188 	ldr.w	r1, [r6, #392]	; 0x188
     3ce:	fa07 fc05 	lsl.w	ip, r7, r5
     3d2:	ea1c 0f01 	tst.w	ip, r1
     3d6:	f8d6 9004 	ldr.w	r9, [r6, #4]
     3da:	d108      	bne.n	3ee <__call_exitprocs+0x7e>
     3dc:	4790      	blx	r2
     3de:	6872      	ldr	r2, [r6, #4]
     3e0:	454a      	cmp	r2, r9
     3e2:	d1cf      	bne.n	384 <__call_exitprocs+0x14>
     3e4:	f8db 3148 	ldr.w	r3, [fp, #328]	; 0x148
     3e8:	42b3      	cmp	r3, r6
     3ea:	d0dc      	beq.n	3a6 <__call_exitprocs+0x36>
     3ec:	e7ca      	b.n	384 <__call_exitprocs+0x14>
     3ee:	f8d6 318c 	ldr.w	r3, [r6, #396]	; 0x18c
     3f2:	f8d4 1080 	ldr.w	r1, [r4, #128]	; 0x80
     3f6:	ea1c 0f03 	tst.w	ip, r3
     3fa:	d102      	bne.n	402 <__call_exitprocs+0x92>
     3fc:	9801      	ldr	r0, [sp, #4]
     3fe:	4790      	blx	r2
     400:	e7ed      	b.n	3de <__call_exitprocs+0x6e>
     402:	4608      	mov	r0, r1
     404:	4790      	blx	r2
     406:	e7ea      	b.n	3de <__call_exitprocs+0x6e>
     408:	00001954 	.word	0x00001954

0000040c <register_fini>:
     40c:	4b02      	ldr	r3, [pc, #8]	; (418 <register_fini+0xc>)
     40e:	b113      	cbz	r3, 416 <register_fini+0xa>
     410:	4802      	ldr	r0, [pc, #8]	; (41c <register_fini+0x10>)
     412:	f7ff bed7 	b.w	1c4 <atexit>
     416:	4770      	bx	lr
     418:	00000000 	.word	0x00000000
     41c:	000001f1 	.word	0x000001f1

00000420 <Reset_Handler>:
extern void __libc_init_array(void);
extern int main(void);

/* Reset Handler */
void Reset_Handler(void)
{
     420:	b508      	push	{r3, lr}
	unsigned long *src, *dest;

	// Copy the data segment initializers from flash to SRAM
	src = &_etext;
	for(dest = &_data; dest < &_edata; )
     422:	4b0d      	ldr	r3, [pc, #52]	; (458 <Reset_Handler+0x38>)
	src = &_etext;
     424:	4a0d      	ldr	r2, [pc, #52]	; (45c <Reset_Handler+0x3c>)
	for(dest = &_data; dest < &_edata; )
     426:	490e      	ldr	r1, [pc, #56]	; (460 <Reset_Handler+0x40>)
     428:	428b      	cmp	r3, r1
     42a:	d30c      	bcc.n	446 <Reset_Handler+0x26>

	// Initialize the .bss segment of memory to zeros
	src = &_bss;
	while (src < &_ebss)
	{
		*src++ = 0;
     42c:	2100      	movs	r1, #0
	src = &_bss;
     42e:	4b0d      	ldr	r3, [pc, #52]	; (464 <Reset_Handler+0x44>)
	while (src < &_ebss)
     430:	4a0d      	ldr	r2, [pc, #52]	; (468 <Reset_Handler+0x48>)
     432:	4293      	cmp	r3, r2
     434:	d30c      	bcc.n	450 <Reset_Handler+0x30>
	}

	__libc_init_array();
     436:	f7ff fef5 	bl	224 <__libc_init_array>

	// Set the vector table location.
	SCB_VTOR = (uint32_t)&_interrupt_vector_table;
     43a:	4a0c      	ldr	r2, [pc, #48]	; (46c <Reset_Handler+0x4c>)
     43c:	4b0c      	ldr	r3, [pc, #48]	; (470 <Reset_Handler+0x50>)
     43e:	601a      	str	r2, [r3, #0]

	main();
     440:	f001 f832 	bl	14a8 <main>

	// In case main() fails, have something to breakpoint
	while (1) {;}
     444:	e7fe      	b.n	444 <Reset_Handler+0x24>
		*dest++ = *src++;
     446:	f852 0b04 	ldr.w	r0, [r2], #4
     44a:	f843 0b04 	str.w	r0, [r3], #4
     44e:	e7eb      	b.n	428 <Reset_Handler+0x8>
		*src++ = 0;
     450:	f843 1b04 	str.w	r1, [r3], #4
     454:	e7ed      	b.n	432 <Reset_Handler+0x12>
     456:	bf00      	nop
     458:	10000020 	.word	0x10000020
     45c:	000019c0 	.word	0x000019c0
     460:	100005a8 	.word	0x100005a8
     464:	100005a8 	.word	0x100005a8
     468:	1000076e 	.word	0x1000076e
     46c:	00000000 	.word	0x00000000
     470:	e000ed08 	.word	0xe000ed08

00000474 <ADC_IRQHandler>:
extern unsigned long _StackTop;

extern void Reset_Handler(void);

/* Default interrupt handler */
static void Default_Handler(void) { while(1) {;} }
     474:	e7fe      	b.n	474 <ADC_IRQHandler>
     476:	0000      	movs	r0, r0

00000478 <spi_delay>:
	cc2400_spi(16, out);
}

static volatile u32 delay_counter;
static void spi_delay() {
       delay_counter = 10;
     478:	220a      	movs	r2, #10
     47a:	4b04      	ldr	r3, [pc, #16]	; (48c <spi_delay+0x14>)
     47c:	601a      	str	r2, [r3, #0]
       while (--delay_counter);
     47e:	681a      	ldr	r2, [r3, #0]
     480:	3a01      	subs	r2, #1
     482:	601a      	str	r2, [r3, #0]
     484:	2a00      	cmp	r2, #0
     486:	d1fa      	bne.n	47e <spi_delay+0x6>
}
     488:	4770      	bx	lr
     48a:	bf00      	nop
     48c:	100005c4 	.word	0x100005c4

00000490 <rbit>:
  asm("rbit %0, %1" : "=r" (result) : "r" (value));
     490:	fa90 f0a0 	rbit	r0, r0
}
     494:	4770      	bx	lr
     496:	0000      	movs	r0, r0

00000498 <wait_us>:
		(us>>2) + (us>>3) + (us>>6) + (us>>7) + (us>>10) + (us>>11);
     498:	08c3      	lsrs	r3, r0, #3
     49a:	eb03 0390 	add.w	r3, r3, r0, lsr #2
     49e:	eb03 1390 	add.w	r3, r3, r0, lsr #6
     4a2:	eb03 13d0 	add.w	r3, r3, r0, lsr #7
     4a6:	eb03 2390 	add.w	r3, r3, r0, lsr #10
     4aa:	eb03 20d0 	add.w	r0, r3, r0, lsr #11
	wait_us_counter =
     4ae:	4b04      	ldr	r3, [pc, #16]	; (4c0 <wait_us+0x28>)
     4b0:	6058      	str	r0, [r3, #4]
	while(--wait_us_counter);
     4b2:	685a      	ldr	r2, [r3, #4]
     4b4:	3a01      	subs	r2, #1
     4b6:	605a      	str	r2, [r3, #4]
     4b8:	2a00      	cmp	r2, #0
     4ba:	d1fa      	bne.n	4b2 <wait_us+0x1a>
}
     4bc:	4770      	bx	lr
     4be:	bf00      	nop
     4c0:	100005c4 	.word	0x100005c4

000004c4 <wait>:
	wait_us(seconds * 1000000);
     4c4:	4b01      	ldr	r3, [pc, #4]	; (4cc <wait+0x8>)
     4c6:	4358      	muls	r0, r3
     4c8:	f7ff bfe6 	b.w	498 <wait_us>
     4cc:	000f4240 	.word	0x000f4240

000004d0 <wait_ms>:
	wait_us(ms * 1000);
     4d0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
     4d4:	4358      	muls	r0, r3
     4d6:	f7ff bfdf 	b.w	498 <wait_us>
     4da:	0000      	movs	r0, r0

000004dc <all_pins_off>:
	PINSEL0 = 0;
     4dc:	2300      	movs	r3, #0
     4de:	4a10      	ldr	r2, [pc, #64]	; (520 <all_pins_off+0x44>)
     4e0:	6013      	str	r3, [r2, #0]
	PINSEL1 = 0;
     4e2:	6053      	str	r3, [r2, #4]
	PINSEL2 = 0;
     4e4:	6093      	str	r3, [r2, #8]
	PINSEL3 = 0;
     4e6:	60d3      	str	r3, [r2, #12]
	PINSEL4 = 0;
     4e8:	6113      	str	r3, [r2, #16]
	PINSEL7 = 0;
     4ea:	61d3      	str	r3, [r2, #28]
	PINSEL9 = 0;
     4ec:	6253      	str	r3, [r2, #36]	; 0x24
	PINSEL10 = 0;
     4ee:	6293      	str	r3, [r2, #40]	; 0x28
	FIO0DIR = 0;
     4f0:	4a0c      	ldr	r2, [pc, #48]	; (524 <all_pins_off+0x48>)
     4f2:	6013      	str	r3, [r2, #0]
	FIO1DIR = 0;
     4f4:	6213      	str	r3, [r2, #32]
	FIO2DIR = 0;
     4f6:	6413      	str	r3, [r2, #64]	; 0x40
	FIO3DIR = 0;
     4f8:	6613      	str	r3, [r2, #96]	; 0x60
	FIO4DIR = 0;
     4fa:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
	PINMODE0 = 0;
     4fe:	4a0a      	ldr	r2, [pc, #40]	; (528 <all_pins_off+0x4c>)
     500:	6013      	str	r3, [r2, #0]
	PINMODE1 = 0;
     502:	6053      	str	r3, [r2, #4]
	PINMODE2 = 0;
     504:	6093      	str	r3, [r2, #8]
	PINMODE3 = 0;
     506:	60d3      	str	r3, [r2, #12]
	PINMODE4 = 0;
     508:	6113      	str	r3, [r2, #16]
	PINMODE7 = 0;
     50a:	61d3      	str	r3, [r2, #28]
	PINMODE9 = 0;
     50c:	6253      	str	r3, [r2, #36]	; 0x24
	FIO0PIN = 0;
     50e:	4a07      	ldr	r2, [pc, #28]	; (52c <all_pins_off+0x50>)
     510:	6013      	str	r3, [r2, #0]
	FIO1PIN = 0;
     512:	6213      	str	r3, [r2, #32]
	FIO2PIN = 0;
     514:	6413      	str	r3, [r2, #64]	; 0x40
	FIO3PIN = 0;
     516:	6613      	str	r3, [r2, #96]	; 0x60
	FIO4PIN = 0;
     518:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
}
     51c:	4770      	bx	lr
     51e:	bf00      	nop
     520:	4002c000 	.word	0x4002c000
     524:	2009c000 	.word	0x2009c000
     528:	4002c040 	.word	0x4002c040
     52c:	2009c014 	.word	0x2009c014

00000530 <gpio_init>:
{
     530:	b508      	push	{r3, lr}
	all_pins_off();
     532:	f7ff ffd3 	bl	4dc <all_pins_off>
	FIO0DIR = 0;
     536:	2300      	movs	r3, #0
	FIO1DIR = (PIN_USRLED | PIN_RXLED | PIN_TXLED | PIN_CC3V3 |
     538:	f24c 7112 	movw	r1, #50962	; 0xc712
	FIO0DIR = 0;
     53c:	4a08      	ldr	r2, [pc, #32]	; (560 <gpio_init+0x30>)
     53e:	6013      	str	r3, [r2, #0]
	FIO1DIR = (PIN_USRLED | PIN_RXLED | PIN_TXLED | PIN_CC3V3 |
     540:	6211      	str	r1, [r2, #32]
	FIO2DIR = (PIN_CSN | PIN_SCLK | PIN_MOSI | PIN_PAEN | PIN_HGM);
     542:	f240 11b1 	movw	r1, #433	; 0x1b1
     546:	6411      	str	r1, [r2, #64]	; 0x40
	FIO4DIR = (PIN_TX | PIN_SSEL1);
     548:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
	FIO3DIR = 0;
     54c:	6613      	str	r3, [r2, #96]	; 0x60
	FIO4DIR = (PIN_TX | PIN_SSEL1);
     54e:	f8c2 1080 	str.w	r1, [r2, #128]	; 0x80
	FIO0PIN = 0;
     552:	6153      	str	r3, [r2, #20]
	FIO1PIN = 0;
     554:	6353      	str	r3, [r2, #52]	; 0x34
	FIO2PIN = 0;
     556:	6553      	str	r3, [r2, #84]	; 0x54
	FIO3PIN = 0;
     558:	6753      	str	r3, [r2, #116]	; 0x74
	FIO4PIN = 0;
     55a:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
}
     55e:	bd08      	pop	{r3, pc}
     560:	2009c000 	.word	0x2009c000

00000564 <dio_ssp_init>:
	PINSEL0 = (PINSEL0 & ~(3 << 14)) | (2 << 14);
     564:	4b11      	ldr	r3, [pc, #68]	; (5ac <dio_ssp_init+0x48>)
     566:	681a      	ldr	r2, [r3, #0]
     568:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
     56c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
     570:	601a      	str	r2, [r3, #0]
	PINSEL0 = (PINSEL0 & ~(3 << 12)) | (2 << 12);
     572:	681a      	ldr	r2, [r3, #0]
     574:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
     578:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
     57c:	601a      	str	r2, [r3, #0]
	PINSEL0 = (PINSEL0 & ~(3 << 16)) | (2 << 16);
     57e:	681a      	ldr	r2, [r3, #0]
     580:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
     584:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
     588:	601a      	str	r2, [r3, #0]
	PINSEL0 = (PINSEL0 & ~(3 << 18)) | (2 << 18);
     58a:	681a      	ldr	r2, [r3, #0]
     58c:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
     590:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
     594:	601a      	str	r2, [r3, #0]
	DIO_SSEL_SET;
     596:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
     59a:	4b05      	ldr	r3, [pc, #20]	; (5b0 <dio_ssp_init+0x4c>)
     59c:	601a      	str	r2, [r3, #0]
	DIO_SSP_CR0 = (0x7 /* 8 bit transfer */ | SSPCR0_CPOL | SSPCR0_CPHA);
     59e:	22c7      	movs	r2, #199	; 0xc7
     5a0:	4b04      	ldr	r3, [pc, #16]	; (5b4 <dio_ssp_init+0x50>)
     5a2:	601a      	str	r2, [r3, #0]
	DIO_SSP_CR1 = (SSPCR1_MS | SSPCR1_SOD);
     5a4:	220c      	movs	r2, #12
     5a6:	605a      	str	r2, [r3, #4]
}
     5a8:	4770      	bx	lr
     5aa:	bf00      	nop
     5ac:	4002c000 	.word	0x4002c000
     5b0:	2009c098 	.word	0x2009c098
     5b4:	40030000 	.word	0x40030000

000005b8 <atest_init>:
	PINSEL1 &= ~((0x3 << 20) | (0x3 << 18)); // set as GPIO
     5b8:	4a09      	ldr	r2, [pc, #36]	; (5e0 <atest_init+0x28>)
     5ba:	6813      	ldr	r3, [r2, #0]
     5bc:	f423 1370 	bic.w	r3, r3, #3932160	; 0x3c0000
     5c0:	6013      	str	r3, [r2, #0]
	FIO0DIR &= ~(0x3 << 25); // set as input
     5c2:	4a08      	ldr	r2, [pc, #32]	; (5e4 <atest_init+0x2c>)
     5c4:	6813      	ldr	r3, [r2, #0]
     5c6:	f023 63c0 	bic.w	r3, r3, #100663296	; 0x6000000
     5ca:	6013      	str	r3, [r2, #0]
	PINMODE1 |= (0x5 << 19); // no pull-up/pull-down
     5cc:	4b06      	ldr	r3, [pc, #24]	; (5e8 <atest_init+0x30>)
     5ce:	681a      	ldr	r2, [r3, #0]
     5d0:	f442 1220 	orr.w	r2, r2, #2621440	; 0x280000
     5d4:	601a      	str	r2, [r3, #0]
	PINMODE1 &= ~(0x5 << 18); // no pull-up/pull-down
     5d6:	681a      	ldr	r2, [r3, #0]
     5d8:	f422 12a0 	bic.w	r2, r2, #1310720	; 0x140000
     5dc:	601a      	str	r2, [r3, #0]
}
     5de:	4770      	bx	lr
     5e0:	4002c004 	.word	0x4002c004
     5e4:	2009c000 	.word	0x2009c000
     5e8:	4002c044 	.word	0x4002c044

000005ec <cc2400_spi>:
{
     5ec:	b5f0      	push	{r4, r5, r6, r7, lr}
	u32 msb = 1 << (len - 1);
     5ee:	1e45      	subs	r5, r0, #1
{
     5f0:	4603      	mov	r3, r0
	CSN_CLR;
     5f2:	2020      	movs	r0, #32
	u32 msb = 1 << (len - 1);
     5f4:	2401      	movs	r4, #1
		SCLK_SET;
     5f6:	2710      	movs	r7, #16
	CSN_CLR;
     5f8:	4a0d      	ldr	r2, [pc, #52]	; (630 <cc2400_spi+0x44>)
		data |= !!MISO;
     5fa:	f8df c03c 	ldr.w	ip, [pc, #60]	; 638 <cc2400_spi+0x4c>
	CSN_CLR;
     5fe:	6010      	str	r0, [r2, #0]
	while (len--) {
     600:	4608      	mov	r0, r1
     602:	490c      	ldr	r1, [pc, #48]	; (634 <cc2400_spi+0x48>)
	u32 msb = 1 << (len - 1);
     604:	fa04 f505 	lsl.w	r5, r4, r5
	while (len--) {
     608:	3b01      	subs	r3, #1
     60a:	b2db      	uxtb	r3, r3
     60c:	2bff      	cmp	r3, #255	; 0xff
     60e:	d102      	bne.n	616 <cc2400_spi+0x2a>
	CSN_SET;
     610:	2320      	movs	r3, #32
     612:	600b      	str	r3, [r1, #0]
}
     614:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (data & msb)
     616:	4228      	tst	r0, r5
			MOSI_SET;
     618:	bf14      	ite	ne
     61a:	600c      	strne	r4, [r1, #0]
			MOSI_CLR;
     61c:	6014      	streq	r4, [r2, #0]
		SCLK_SET;
     61e:	600f      	str	r7, [r1, #0]
		data |= !!MISO;
     620:	f8dc 6000 	ldr.w	r6, [ip]
		SCLK_CLR;
     624:	6017      	str	r7, [r2, #0]
		data |= !!MISO;
     626:	f3c6 0640 	ubfx	r6, r6, #1, #1
     62a:	ea46 0040 	orr.w	r0, r6, r0, lsl #1
		SCLK_CLR;
     62e:	e7eb      	b.n	608 <cc2400_spi+0x1c>
     630:	2009c05c 	.word	0x2009c05c
     634:	2009c058 	.word	0x2009c058
     638:	2009c054 	.word	0x2009c054

0000063c <cc2400_init>:
{
     63c:	b508      	push	{r3, lr}
	atest_init();
     63e:	f7ff ffbb 	bl	5b8 <atest_init>
	CC1V8_SET;
     642:	f44f 7300 	mov.w	r3, #512	; 0x200
     646:	4908      	ldr	r1, [pc, #32]	; (668 <cc2400_init+0x2c>)
	wait_us(50);
     648:	2032      	movs	r0, #50	; 0x32
	CC1V8_SET;
     64a:	600b      	str	r3, [r1, #0]
	wait_us(50);
     64c:	f7ff ff24 	bl	498 <wait_us>
	CSN_SET;
     650:	2220      	movs	r2, #32
     652:	4b06      	ldr	r3, [pc, #24]	; (66c <cc2400_init+0x30>)
	cc2400_spi(24, out);
     654:	2018      	movs	r0, #24
	CSN_SET;
     656:	601a      	str	r2, [r3, #0]
	CC3V3_SET;
     658:	f44f 4380 	mov.w	r3, #16384	; 0x4000
     65c:	600b      	str	r3, [r1, #0]
	cc2400_spi(24, out);
     65e:	4904      	ldr	r1, [pc, #16]	; (670 <cc2400_init+0x34>)
}
     660:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	cc2400_spi(24, out);
     664:	f7ff bfc2 	b.w	5ec <cc2400_spi>
     668:	2009c038 	.word	0x2009c038
     66c:	2009c058 	.word	0x2009c058
     670:	000d7fff 	.word	0x000d7fff

00000674 <cc2400_get>:
{
     674:	b508      	push	{r3, lr}
	u32 out = (reg | 0x80) << 16;
     676:	f040 0180 	orr.w	r1, r0, #128	; 0x80
	in = cc2400_spi(24, out);
     67a:	0409      	lsls	r1, r1, #16
     67c:	2018      	movs	r0, #24
     67e:	f7ff ffb5 	bl	5ec <cc2400_spi>
}
     682:	b280      	uxth	r0, r0
     684:	bd08      	pop	{r3, pc}

00000686 <cc2400_set>:
	cc2400_spi(24, out);
     686:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
     68a:	2018      	movs	r0, #24
     68c:	f7ff bfae 	b.w	5ec <cc2400_spi>

00000690 <cc2400_get8>:
{
     690:	b508      	push	{r3, lr}
	u16 out = (reg | 0x80) << 8;
     692:	f040 0180 	orr.w	r1, r0, #128	; 0x80
	in = cc2400_spi(16, out);
     696:	0209      	lsls	r1, r1, #8
     698:	2010      	movs	r0, #16
     69a:	f7ff ffa7 	bl	5ec <cc2400_spi>
}
     69e:	b2c0      	uxtb	r0, r0
     6a0:	bd08      	pop	{r3, pc}

000006a2 <cc2400_set8>:
	cc2400_spi(16, out);
     6a2:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
     6a6:	2010      	movs	r0, #16
     6a8:	f7ff bfa0 	b.w	5ec <cc2400_spi>

000006ac <cc2400_fifo_write>:


/* write multiple bytes to SPI */
void cc2400_fifo_write(u8 len, u8 *data) {
     6ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u8 msb = 1 << 7;
	u8 reg = FIFOREG;
	u8 i, j, temp;

	/* start transaction by dropping CSN */
	CSN_CLR;
     6ae:	2220      	movs	r2, #32
     6b0:	4b1c      	ldr	r3, [pc, #112]	; (724 <cc2400_fifo_write+0x78>)
	u8 reg = FIFOREG;
     6b2:	2570      	movs	r5, #112	; 0x70
	CSN_CLR;
     6b4:	601a      	str	r2, [r3, #0]

	for (i = 0; i < 8; ++i) {
     6b6:	2701      	movs	r7, #1
	CSN_CLR;
     6b8:	2208      	movs	r2, #8
		if (reg & msb)
			MOSI_SET;
		else
			MOSI_CLR;
		reg <<= 1;
		SCLK_SET;
     6ba:	2610      	movs	r6, #16
     6bc:	4c1a      	ldr	r4, [pc, #104]	; (728 <cc2400_fifo_write+0x7c>)
		if (reg & msb)
     6be:	f015 0f80 	tst.w	r5, #128	; 0x80
			MOSI_SET;
     6c2:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
     6c6:	bf14      	ite	ne
     6c8:	6027      	strne	r7, [r4, #0]
			MOSI_CLR;
     6ca:	601f      	streq	r7, [r3, #0]
		reg <<= 1;
     6cc:	006d      	lsls	r5, r5, #1
	for (i = 0; i < 8; ++i) {
     6ce:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
		SCLK_SET;
     6d2:	6026      	str	r6, [r4, #0]
		reg <<= 1;
     6d4:	b2ed      	uxtb	r5, r5
		SCLK_CLR;
     6d6:	601e      	str	r6, [r3, #0]
	for (i = 0; i < 8; ++i) {
     6d8:	d1f1      	bne.n	6be <cc2400_fifo_write+0x12>
     6da:	2601      	movs	r6, #1
			if (temp & msb)
				MOSI_SET;
			else
				MOSI_CLR;
			temp <<= 1;
			SCLK_SET;
     6dc:	2710      	movs	r7, #16
     6de:	4408      	add	r0, r1
	for (i = 0; i < len; ++i) {
     6e0:	4288      	cmp	r0, r1
     6e2:	d10c      	bne.n	6fe <cc2400_fifo_write+0x52>
     6e4:	2208      	movs	r2, #8
		}
	}

	// this is necessary to clock in the last byte
	for (i = 0; i < 8; ++i) {
		SCLK_SET;
     6e6:	2110      	movs	r1, #16
     6e8:	3a01      	subs	r2, #1
	for (i = 0; i < 8; ++i) {
     6ea:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
		SCLK_SET;
     6ee:	6021      	str	r1, [r4, #0]
		SCLK_CLR;
     6f0:	6019      	str	r1, [r3, #0]
	for (i = 0; i < 8; ++i) {
     6f2:	d1f9      	bne.n	6e8 <cc2400_fifo_write+0x3c>
	}
	
	spi_delay();
     6f4:	f7ff fec0 	bl	478 <spi_delay>
	/* end transaction by raising CSN */
	CSN_SET;
     6f8:	2320      	movs	r3, #32
     6fa:	6023      	str	r3, [r4, #0]
}
     6fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		temp = data[i];
     6fe:	2208      	movs	r2, #8
     700:	f811 5b01 	ldrb.w	r5, [r1], #1
			if (temp & msb)
     704:	f015 0f80 	tst.w	r5, #128	; 0x80
				MOSI_SET;
     708:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
     70c:	bf14      	ite	ne
     70e:	6026      	strne	r6, [r4, #0]
				MOSI_CLR;
     710:	601e      	streq	r6, [r3, #0]
			temp <<= 1;
     712:	006d      	lsls	r5, r5, #1
		for (j = 0; j < 8; ++j) {
     714:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
			SCLK_SET;
     718:	6027      	str	r7, [r4, #0]
			temp <<= 1;
     71a:	b2ed      	uxtb	r5, r5
			SCLK_CLR;
     71c:	601f      	str	r7, [r3, #0]
		for (j = 0; j < 8; ++j) {
     71e:	d1f1      	bne.n	704 <cc2400_fifo_write+0x58>
     720:	e7de      	b.n	6e0 <cc2400_fifo_write+0x34>
     722:	bf00      	nop
     724:	2009c05c 	.word	0x2009c05c
     728:	2009c058 	.word	0x2009c058

0000072c <cc2400_fifo_read>:

/* read multiple bytes from SPI */
void cc2400_fifo_read(u8 len, u8 *buf) {
     72c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	u8 i, j, temp, reg;
	// Set first bit because it's a read
	reg = 0x80 | FIFOREG;

	/* start transaction by dropping CSN */
	CSN_CLR;
     730:	2320      	movs	r3, #32
     732:	4d1e      	ldr	r5, [pc, #120]	; (7ac <cc2400_fifo_read+0x80>)
	reg = 0x80 | FIFOREG;
     734:	22f0      	movs	r2, #240	; 0xf0
	CSN_CLR;
     736:	602b      	str	r3, [r5, #0]

	for (i = 0; i < 8; ++i) {
     738:	2601      	movs	r6, #1
	CSN_CLR;
     73a:	2308      	movs	r3, #8
		if (reg & msb)
			MOSI_SET;
		else
			MOSI_CLR;
		reg <<= 1;
		SCLK_SET;
     73c:	2410      	movs	r4, #16
     73e:	4f1c      	ldr	r7, [pc, #112]	; (7b0 <cc2400_fifo_read+0x84>)
		if (reg & msb)
     740:	f012 0f80 	tst.w	r2, #128	; 0x80
			MOSI_SET;
     744:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
     748:	bf14      	ite	ne
     74a:	603e      	strne	r6, [r7, #0]
			MOSI_CLR;
     74c:	602e      	streq	r6, [r5, #0]
		reg <<= 1;
     74e:	0052      	lsls	r2, r2, #1
	for (i = 0; i < 8; ++i) {
     750:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
		SCLK_SET;
     754:	603c      	str	r4, [r7, #0]
		reg <<= 1;
     756:	b2d2      	uxtb	r2, r2
		SCLK_CLR;
     758:	602c      	str	r4, [r5, #0]
	for (i = 0; i < 8; ++i) {
     75a:	d1f1      	bne.n	740 <cc2400_fifo_read+0x14>

	for (i = 0; i < len; ++i) {
		temp = 0;
		for (j = 0; j < 8; ++j) {
			spi_delay();
			SCLK_SET;
     75c:	f04f 0810 	mov.w	r8, #16
			temp <<= 1;
			if (MISO)
     760:	f8df 9050 	ldr.w	r9, [pc, #80]	; 7b4 <cc2400_fifo_read+0x88>
     764:	4408      	add	r0, r1
	for (i = 0; i < len; ++i) {
     766:	4281      	cmp	r1, r0
     768:	d105      	bne.n	776 <cc2400_fifo_read+0x4a>
		}
		buf[i] = temp;
	}

	/* end transaction by raising CSN */
	spi_delay();
     76a:	f7ff fe85 	bl	478 <spi_delay>
	CSN_SET;
     76e:	2320      	movs	r3, #32
     770:	603b      	str	r3, [r7, #0]
}
     772:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		temp = 0;
     776:	2400      	movs	r4, #0
     778:	2608      	movs	r6, #8
			spi_delay();
     77a:	f7ff fe7d 	bl	478 <spi_delay>
			SCLK_SET;
     77e:	f8c7 8000 	str.w	r8, [r7]
			if (MISO)
     782:	f8d9 3000 	ldr.w	r3, [r9]
			temp <<= 1;
     786:	0064      	lsls	r4, r4, #1
			if (MISO)
     788:	079b      	lsls	r3, r3, #30
			temp <<= 1;
     78a:	b2e4      	uxtb	r4, r4
				temp |= 1;
     78c:	f106 36ff 	add.w	r6, r6, #4294967295	; 0xffffffff
     790:	bf48      	it	mi
     792:	f044 0401 	orrmi.w	r4, r4, #1
			spi_delay();
     796:	f7ff fe6f 	bl	478 <spi_delay>
		for (j = 0; j < 8; ++j) {
     79a:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
			SCLK_CLR;
     79e:	f8c5 8000 	str.w	r8, [r5]
		for (j = 0; j < 8; ++j) {
     7a2:	d1ea      	bne.n	77a <cc2400_fifo_read+0x4e>
		buf[i] = temp;
     7a4:	f801 4b01 	strb.w	r4, [r1], #1
	for (i = 0; i < len; ++i) {
     7a8:	e7dd      	b.n	766 <cc2400_fifo_read+0x3a>
     7aa:	bf00      	nop
     7ac:	2009c05c 	.word	0x2009c05c
     7b0:	2009c058 	.word	0x2009c058
     7b4:	2009c054 	.word	0x2009c054

000007b8 <cc2400_status>:

/* get the status */
u8 cc2400_status()
{
     7b8:	b508      	push	{r3, lr}
	return cc2400_spi(8, 0);
     7ba:	2100      	movs	r1, #0
     7bc:	2008      	movs	r0, #8
     7be:	f7ff ff15 	bl	5ec <cc2400_spi>
}
     7c2:	b2c0      	uxtb	r0, r0
     7c4:	bd08      	pop	{r3, pc}

000007c6 <cc2400_strobe>:

/* strobe register, return status */
u8 cc2400_strobe(u8 reg)
{
     7c6:	b508      	push	{r3, lr}
     7c8:	4601      	mov	r1, r0
	return cc2400_spi(8, reg);
     7ca:	2008      	movs	r0, #8
     7cc:	f7ff ff0e 	bl	5ec <cc2400_spi>
}
     7d0:	b2c0      	uxtb	r0, r0
     7d2:	bd08      	pop	{r3, pc}

000007d4 <cc2400_reset>:
/*
 * Warning: This should only be called when running on the internal oscillator.
 * Otherwise use clock_start().
 */
void cc2400_reset()
{
     7d4:	b508      	push	{r3, lr}
	cc2400_spi(24, out);
     7d6:	2100      	movs	r1, #0
     7d8:	2018      	movs	r0, #24
     7da:	f7ff ff07 	bl	5ec <cc2400_spi>
	cc2400_set(MAIN, 0x0000);
	while (cc2400_get(MAIN) != 0x0000);
     7de:	2000      	movs	r0, #0
     7e0:	f7ff ff48 	bl	674 <cc2400_get>
     7e4:	2800      	cmp	r0, #0
     7e6:	d1fa      	bne.n	7de <cc2400_reset+0xa>
	cc2400_spi(24, out);
     7e8:	f44f 4100 	mov.w	r1, #32768	; 0x8000
     7ec:	2018      	movs	r0, #24
     7ee:	f7ff fefd 	bl	5ec <cc2400_spi>
	cc2400_set(MAIN, 0x8000);
	while (cc2400_get(MAIN) != 0x8000);
     7f2:	2000      	movs	r0, #0
     7f4:	f7ff ff3e 	bl	674 <cc2400_get>
     7f8:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
     7fc:	d1f9      	bne.n	7f2 <cc2400_reset+0x1e>
}
     7fe:	bd08      	pop	{r3, pc}

00000800 <clock_start>:

/* activate the CC2400's 16 MHz oscillator and sync LPC175x to it */
void clock_start()
{
     800:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	/* configure flash accelerator for higher clock rate */
	FLASHCFG = (0x03A | (FLASHTIM << 12));
     804:	f244 023a 	movw	r2, #16442	; 0x403a
     808:	4b40      	ldr	r3, [pc, #256]	; (90c <clock_start+0x10c>)

	/* switch to the internal oscillator if necessary */
	CLKSRCSEL = 0;
     80a:	4e41      	ldr	r6, [pc, #260]	; (910 <clock_start+0x110>)
	FLASHCFG = (0x03A | (FLASHTIM << 12));
     80c:	601a      	str	r2, [r3, #0]
	CLKSRCSEL = 0;
     80e:	2300      	movs	r3, #0

	/* disconnect PLL0 */
	PLL0CON &= ~PLL0CON_PLLC0;
     810:	4d40      	ldr	r5, [pc, #256]	; (914 <clock_start+0x114>)
	CLKSRCSEL = 0;
     812:	6033      	str	r3, [r6, #0]
	PLL0CON &= ~PLL0CON_PLLC0;
     814:	682b      	ldr	r3, [r5, #0]
	PLL0FEED_SEQUENCE;
     816:	4c40      	ldr	r4, [pc, #256]	; (918 <clock_start+0x118>)
	PLL0CON &= ~PLL0CON_PLLC0;
     818:	f023 0302 	bic.w	r3, r3, #2
     81c:	602b      	str	r3, [r5, #0]
	PLL0FEED_SEQUENCE;
     81e:	23aa      	movs	r3, #170	; 0xaa
     820:	6023      	str	r3, [r4, #0]
     822:	2355      	movs	r3, #85	; 0x55
     824:	6023      	str	r3, [r4, #0]
	while (PLL0STAT & PLL0STAT_PLLC0_STAT);
     826:	4b3d      	ldr	r3, [pc, #244]	; (91c <clock_start+0x11c>)
     828:	461f      	mov	r7, r3
     82a:	681a      	ldr	r2, [r3, #0]
     82c:	0190      	lsls	r0, r2, #6
     82e:	d4fc      	bmi.n	82a <clock_start+0x2a>

	/* turn off PLL0 */
	PLL0CON &= ~PLL0CON_PLLE0;
     830:	682b      	ldr	r3, [r5, #0]
     832:	f023 0301 	bic.w	r3, r3, #1
     836:	602b      	str	r3, [r5, #0]
	PLL0FEED_SEQUENCE;
     838:	23aa      	movs	r3, #170	; 0xaa
     83a:	6023      	str	r3, [r4, #0]
     83c:	2355      	movs	r3, #85	; 0x55
     83e:	6023      	str	r3, [r4, #0]
	while (PLL0STAT & PLL0STAT_PLLE0_STAT);
     840:	683b      	ldr	r3, [r7, #0]
     842:	f013 7380 	ands.w	r3, r3, #16777216	; 0x1000000
     846:	d1fb      	bne.n	840 <clock_start+0x40>

	/* temporarily set CPU clock divider to 1 */
	CCLKCFG = 0;
     848:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 940 <clock_start+0x140>
     84c:	f8c8 3000 	str.w	r3, [r8]

	/* configure CC2400 oscillator, output carrier sense on GIO6 */
	cc2400_reset();
     850:	f7ff ffc0 	bl	7d4 <cc2400_reset>
	cc2400_spi(24, out);
     854:	2018      	movs	r0, #24
     856:	4932      	ldr	r1, [pc, #200]	; (920 <clock_start+0x120>)
     858:	f7ff fec8 	bl	5ec <cc2400_spi>
	cc2400_set(IOCFG, (GIO_CARRIER_SENSE_N << 9) | (GIO_CLK_16M << 3));
	cc2400_strobe(SXOSCON);
     85c:	2060      	movs	r0, #96	; 0x60
     85e:	f7ff ffb2 	bl	7c6 <cc2400_strobe>
	while (!(cc2400_status() & XOSC16M_STABLE));
     862:	f7ff ffa9 	bl	7b8 <cc2400_status>
     866:	0641      	lsls	r1, r0, #25
     868:	d5fb      	bpl.n	862 <clock_start+0x62>

	/* activate main oscillator */
	SCS = SCS_OSCEN;
     86a:	2220      	movs	r2, #32
     86c:	4b2d      	ldr	r3, [pc, #180]	; (924 <clock_start+0x124>)
     86e:	601a      	str	r2, [r3, #0]
	while (!(SCS & SCS_OSCSTAT));
     870:	681a      	ldr	r2, [r3, #0]
     872:	0652      	lsls	r2, r2, #25
     874:	d5fc      	bpl.n	870 <clock_start+0x70>
#ifdef TC13BADGE
	PCLKSEL0  = (1 << 2); /* TIMER0 at cclk (30 MHz) */
	PCLKSEL1  = 0;
#else
        // XXX here
	PCLKSEL0  = (2 << 2) | (2 << 4); /* TIMER0 and TIMER1 at cclk/2 (50 MHz) */
     876:	2228      	movs	r2, #40	; 0x28
     878:	4b2b      	ldr	r3, [pc, #172]	; (928 <clock_start+0x128>)
	/* switch to main oscillator */
	CLKSRCSEL = 1;

	/* configure PLL0 */
	PLL0CFG = (MSEL0 << 0) | (NSEL0 << 16);
	PLL0FEED_SEQUENCE;
     87a:	21aa      	movs	r1, #170	; 0xaa
	PCLKSEL0  = (2 << 2) | (2 << 4); /* TIMER0 and TIMER1 at cclk/2 (50 MHz) */
     87c:	601a      	str	r2, [r3, #0]
	PCLKSEL1  = (2 << 12); /* TIMER2 at cclk/2 (50 MHz) */
     87e:	f44f 5200 	mov.w	r2, #8192	; 0x2000
     882:	605a      	str	r2, [r3, #4]
	CLKSRCSEL = 1;
     884:	2301      	movs	r3, #1
	PLL0CFG = (MSEL0 << 0) | (NSEL0 << 16);
     886:	4a29      	ldr	r2, [pc, #164]	; (92c <clock_start+0x12c>)
	CLKSRCSEL = 1;
     888:	6033      	str	r3, [r6, #0]
	PLL0CFG = (MSEL0 << 0) | (NSEL0 << 16);
     88a:	4b29      	ldr	r3, [pc, #164]	; (930 <clock_start+0x130>)
     88c:	601a      	str	r2, [r3, #0]
	PLL0FEED_SEQUENCE;
     88e:	2255      	movs	r2, #85	; 0x55
     890:	6021      	str	r1, [r4, #0]
     892:	6022      	str	r2, [r4, #0]

	/* turn on PLL0 */
	PLL0CON |= PLL0CON_PLLE0;
     894:	682b      	ldr	r3, [r5, #0]
     896:	f043 0301 	orr.w	r3, r3, #1
     89a:	602b      	str	r3, [r5, #0]
	PLL0FEED_SEQUENCE;
     89c:	6021      	str	r1, [r4, #0]
     89e:	6022      	str	r2, [r4, #0]
	while (!(PLL0STAT & PLL0STAT_PLLE0_STAT));
     8a0:	683b      	ldr	r3, [r7, #0]
     8a2:	01de      	lsls	r6, r3, #7
     8a4:	d5fc      	bpl.n	8a0 <clock_start+0xa0>

	/* set CPU clock divider */
	CCLKCFG = CCLKSEL;
     8a6:	2303      	movs	r3, #3
     8a8:	f8c8 3000 	str.w	r3, [r8]

	/* connect PLL0 */
	PLL0CON |= PLL0CON_PLLC0;
     8ac:	682b      	ldr	r3, [r5, #0]
     8ae:	f043 0302 	orr.w	r3, r3, #2
     8b2:	602b      	str	r3, [r5, #0]
	PLL0FEED_SEQUENCE;
     8b4:	23aa      	movs	r3, #170	; 0xaa
     8b6:	6023      	str	r3, [r4, #0]
     8b8:	2355      	movs	r3, #85	; 0x55
     8ba:	6023      	str	r3, [r4, #0]
	while (!(PLL0STAT & PLL0STAT_PLLC0_STAT));
     8bc:	683b      	ldr	r3, [r7, #0]
     8be:	019d      	lsls	r5, r3, #6
     8c0:	d5fc      	bpl.n	8bc <clock_start+0xbc>

	/* configure PLL1 */
	PLL1CFG = (MSEL1 << 0) | (PSEL1 << 5);
     8c2:	2222      	movs	r2, #34	; 0x22
	PLL1FEED_SEQUENCE;
     8c4:	2055      	movs	r0, #85	; 0x55
     8c6:	24aa      	movs	r4, #170	; 0xaa
	PLL1CFG = (MSEL1 << 0) | (PSEL1 << 5);
     8c8:	4b1a      	ldr	r3, [pc, #104]	; (934 <clock_start+0x134>)
     8ca:	601a      	str	r2, [r3, #0]

	/* turn on PLL1 */
	PLL1CON |= PLL1CON_PLLE1;
     8cc:	4a1a      	ldr	r2, [pc, #104]	; (938 <clock_start+0x138>)
	PLL1FEED_SEQUENCE;
     8ce:	609c      	str	r4, [r3, #8]
     8d0:	6098      	str	r0, [r3, #8]
	PLL1CON |= PLL1CON_PLLE1;
     8d2:	6811      	ldr	r1, [r2, #0]
	PLL1FEED_SEQUENCE;
     8d4:	3308      	adds	r3, #8
	PLL1CON |= PLL1CON_PLLE1;
     8d6:	f041 0101 	orr.w	r1, r1, #1
     8da:	6011      	str	r1, [r2, #0]
	PLL1FEED_SEQUENCE;
	while (!(PLL1STAT & PLL1STAT_PLLE1_STAT));
     8dc:	4917      	ldr	r1, [pc, #92]	; (93c <clock_start+0x13c>)
	PLL1FEED_SEQUENCE;
     8de:	601c      	str	r4, [r3, #0]
     8e0:	6018      	str	r0, [r3, #0]
	while (!(PLL1STAT & PLL1STAT_PLLE1_STAT));
     8e2:	4608      	mov	r0, r1
     8e4:	680c      	ldr	r4, [r1, #0]
     8e6:	05e4      	lsls	r4, r4, #23
     8e8:	d5fc      	bpl.n	8e4 <clock_start+0xe4>
	while (!(PLL1STAT & PLL1STAT_PLOCK1));
     8ea:	6801      	ldr	r1, [r0, #0]
     8ec:	0549      	lsls	r1, r1, #21
     8ee:	d5fc      	bpl.n	8ea <clock_start+0xea>

	/* connect PLL1 */
	PLL1CON |= PLL1CON_PLLC1;
     8f0:	6811      	ldr	r1, [r2, #0]
     8f2:	f041 0102 	orr.w	r1, r1, #2
     8f6:	6011      	str	r1, [r2, #0]
	PLL1FEED_SEQUENCE;
     8f8:	22aa      	movs	r2, #170	; 0xaa
     8fa:	601a      	str	r2, [r3, #0]
     8fc:	2255      	movs	r2, #85	; 0x55
     8fe:	601a      	str	r2, [r3, #0]
	while (!(PLL1STAT & PLL1STAT_PLLC1_STAT));
     900:	6803      	ldr	r3, [r0, #0]
     902:	059b      	lsls	r3, r3, #22
     904:	d5fc      	bpl.n	900 <clock_start+0x100>
}
     906:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     90a:	bf00      	nop
     90c:	400fc000 	.word	0x400fc000
     910:	400fc10c 	.word	0x400fc10c
     914:	400fc080 	.word	0x400fc080
     918:	400fc08c 	.word	0x400fc08c
     91c:	400fc088 	.word	0x400fc088
     920:	00081570 	.word	0x00081570
     924:	400fc1a0 	.word	0x400fc1a0
     928:	400fc1a8 	.word	0x400fc1a8
     92c:	00010018 	.word	0x00010018
     930:	400fc084 	.word	0x400fc084
     934:	400fc0a4 	.word	0x400fc0a4
     938:	400fc0a0 	.word	0x400fc0a0
     93c:	400fc0a8 	.word	0x400fc0a8
     940:	400fc104 	.word	0x400fc104

00000944 <ubertooth_init>:
{
     944:	b508      	push	{r3, lr}
	gpio_init();
     946:	f7ff fdf3 	bl	530 <gpio_init>
	cc2400_init();
     94a:	f7ff fe77 	bl	63c <cc2400_init>
}
     94e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	clock_start();
     952:	f7ff bf55 	b.w	800 <clock_start>
     956:	0000      	movs	r0, r0

00000958 <reset>:

/* reset the LPC17xx, the cc2400 will be handled by the boot code */
void reset()
{
     958:	b508      	push	{r3, lr}
	all_pins_off();
     95a:	f7ff fdbf 	bl	4dc <all_pins_off>

	/* Enable the watchdog with reset enabled */
	USRLED_CLR;
     95e:	2202      	movs	r2, #2
     960:	4b08      	ldr	r3, [pc, #32]	; (984 <reset+0x2c>)
	wait_us(seconds * 1000000);
     962:	4809      	ldr	r0, [pc, #36]	; (988 <reset+0x30>)
	USRLED_CLR;
     964:	601a      	str	r2, [r3, #0]
	WDMOD |= WDMOD_WDEN | WDMOD_WDRESET;
     966:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
     96a:	6813      	ldr	r3, [r2, #0]
     96c:	f043 0303 	orr.w	r3, r3, #3
     970:	6013      	str	r3, [r2, #0]
	WDFEED_SEQUENCE;
     972:	22aa      	movs	r2, #170	; 0xaa
     974:	4b05      	ldr	r3, [pc, #20]	; (98c <reset+0x34>)
     976:	601a      	str	r2, [r3, #0]
     978:	2255      	movs	r2, #85	; 0x55
     97a:	601a      	str	r2, [r3, #0]
	
	/* Set watchdog timeout to 256us (minimum) */
	
	/* sleep for 1s (minimum) */
	wait(1);
}
     97c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	wait_us(seconds * 1000000);
     980:	f7ff bd8a 	b.w	498 <wait_us>
     984:	2009c03c 	.word	0x2009c03c
     988:	000f4240 	.word	0x000f4240
     98c:	40000008 	.word	0x40000008

00000990 <cc2400_tune_rx>:
 * Tune the CC2400 to a frequency in MHz for RX.  The calling function should
 * ensure that the CC2400 is in the IDLE state.
 */
void cc2400_tune_rx(uint16_t channel)
{
	cc2400_set(FSDIV, channel - 1);
     990:	1e41      	subs	r1, r0, #1
     992:	b289      	uxth	r1, r1
     994:	2002      	movs	r0, #2
     996:	f7ff be76 	b.w	686 <cc2400_set>

0000099a <cc2400_tune_tx>:
/*
 * Tune the CC2400 to a frequency in MHz for TX.  The calling function should
 * ensure that the CC2400 is in the IDLE state.
 */
void cc2400_tune_tx(uint16_t channel)
{
     99a:	4601      	mov	r1, r0
	cc2400_set(FSDIV, channel);
     99c:	2002      	movs	r0, #2
     99e:	f7ff be72 	b.w	686 <cc2400_set>

000009a2 <cc2400_hop_rx>:
}

/* Hop to a new RX frequency in MHz.  Assumes starting from RX or TX state. */
void cc2400_hop_rx(uint16_t channel)
{
     9a2:	b510      	push	{r4, lr}
     9a4:	4604      	mov	r4, r0
	cc2400_strobe(SRFOFF);
     9a6:	2064      	movs	r0, #100	; 0x64
     9a8:	f7ff ff0d 	bl	7c6 <cc2400_strobe>
	while ((cc2400_status() & FS_LOCK));
     9ac:	f7ff ff04 	bl	7b8 <cc2400_status>
     9b0:	0741      	lsls	r1, r0, #29
     9b2:	d4fb      	bmi.n	9ac <cc2400_hop_rx+0xa>
	cc2400_tune_rx(channel);
     9b4:	4620      	mov	r0, r4
     9b6:	f7ff ffeb 	bl	990 <cc2400_tune_rx>
	while (!(cc2400_status() & XOSC16M_STABLE));
     9ba:	f7ff fefd 	bl	7b8 <cc2400_status>
     9be:	0642      	lsls	r2, r0, #25
     9c0:	d5fb      	bpl.n	9ba <cc2400_hop_rx+0x18>
	cc2400_strobe(SFSON);
     9c2:	2061      	movs	r0, #97	; 0x61
     9c4:	f7ff feff 	bl	7c6 <cc2400_strobe>
	while (!(cc2400_status() & FS_LOCK));
     9c8:	f7ff fef6 	bl	7b8 <cc2400_status>
     9cc:	0743      	lsls	r3, r0, #29
     9ce:	d5fb      	bpl.n	9c8 <cc2400_hop_rx+0x26>
	cc2400_strobe(SRX);
}
     9d0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	cc2400_strobe(SRX);
     9d4:	2062      	movs	r0, #98	; 0x62
     9d6:	f7ff bef6 	b.w	7c6 <cc2400_strobe>

000009da <cc2400_hop_tx>:
     9da:	f7ff bfe2 	b.w	9a2 <cc2400_hop_rx>
     9de:	0000      	movs	r0, r0

000009e0 <get_part_num>:
	while (!(cc2400_status() & FS_LOCK));
	cc2400_strobe(SRX);
}

void get_part_num(uint8_t *buffer, int *len)
{
     9e0:	b530      	push	{r4, r5, lr}
     9e2:	b08b      	sub	sp, #44	; 0x2c
	u32 command[5];
	u32 result[5];
	command[0] = 54; /* read part number */
     9e4:	2336      	movs	r3, #54	; 0x36
{
     9e6:	4604      	mov	r4, r0
     9e8:	460d      	mov	r5, r1
	command[0] = 54; /* read part number */
     9ea:	9300      	str	r3, [sp, #0]
	iap_entry(command, result);
     9ec:	4668      	mov	r0, sp
     9ee:	4b08      	ldr	r3, [pc, #32]	; (a10 <get_part_num+0x30>)
     9f0:	a905      	add	r1, sp, #20
     9f2:	4798      	blx	r3
	buffer[0] = result[0] & 0xFF; /* status */
     9f4:	9b05      	ldr	r3, [sp, #20]
     9f6:	7023      	strb	r3, [r4, #0]
	buffer[1] = result[1] & 0xFF;
     9f8:	9b06      	ldr	r3, [sp, #24]
	buffer[2] = (result[1] >> 8) & 0xFF;
     9fa:	0a1a      	lsrs	r2, r3, #8
	buffer[1] = result[1] & 0xFF;
     9fc:	7063      	strb	r3, [r4, #1]
	buffer[2] = (result[1] >> 8) & 0xFF;
     9fe:	70a2      	strb	r2, [r4, #2]
	buffer[3] = (result[1] >> 16) & 0xFF;
     a00:	0c1a      	lsrs	r2, r3, #16
	buffer[4] = (result[1] >> 24) & 0xFF;
     a02:	0e1b      	lsrs	r3, r3, #24
     a04:	7123      	strb	r3, [r4, #4]
	*len = 5;
     a06:	2305      	movs	r3, #5
	buffer[3] = (result[1] >> 16) & 0xFF;
     a08:	70e2      	strb	r2, [r4, #3]
	*len = 5;
     a0a:	602b      	str	r3, [r5, #0]
	
}
     a0c:	b00b      	add	sp, #44	; 0x2c
     a0e:	bd30      	pop	{r4, r5, pc}
     a10:	1fff1ff1 	.word	0x1fff1ff1

00000a14 <get_device_serial>:

void get_device_serial(uint8_t *buffer, int *len)
{
     a14:	b530      	push	{r4, r5, lr}
     a16:	b08b      	sub	sp, #44	; 0x2c
	u32 command[5];
	u32 result[5];
	command[0] = 58; /* read device serial number */
     a18:	233a      	movs	r3, #58	; 0x3a
{
     a1a:	4604      	mov	r4, r0
     a1c:	460d      	mov	r5, r1
	command[0] = 58; /* read device serial number */
     a1e:	9300      	str	r3, [sp, #0]
	iap_entry(command, result);
     a20:	4668      	mov	r0, sp
     a22:	4b14      	ldr	r3, [pc, #80]	; (a74 <get_device_serial+0x60>)
     a24:	a905      	add	r1, sp, #20
     a26:	4798      	blx	r3
	buffer[0] = result[0] & 0xFF; /* status */
     a28:	9b05      	ldr	r3, [sp, #20]
     a2a:	7023      	strb	r3, [r4, #0]
	buffer[1] = result[1] & 0xFF;
     a2c:	9b06      	ldr	r3, [sp, #24]
	buffer[2] = (result[1] >> 8) & 0xFF;
     a2e:	0a1a      	lsrs	r2, r3, #8
	buffer[1] = result[1] & 0xFF;
     a30:	7063      	strb	r3, [r4, #1]
	buffer[2] = (result[1] >> 8) & 0xFF;
     a32:	70a2      	strb	r2, [r4, #2]
	buffer[3] = (result[1] >> 16) & 0xFF;
     a34:	0c1a      	lsrs	r2, r3, #16
	buffer[4] = (result[1] >> 24) & 0xFF;
     a36:	0e1b      	lsrs	r3, r3, #24
     a38:	7123      	strb	r3, [r4, #4]
	buffer[5] = result[2] & 0xFF;
     a3a:	9b07      	ldr	r3, [sp, #28]
	buffer[3] = (result[1] >> 16) & 0xFF;
     a3c:	70e2      	strb	r2, [r4, #3]
	buffer[6] = (result[2] >> 8) & 0xFF;
     a3e:	0a1a      	lsrs	r2, r3, #8
	buffer[5] = result[2] & 0xFF;
     a40:	7163      	strb	r3, [r4, #5]
	buffer[6] = (result[2] >> 8) & 0xFF;
     a42:	71a2      	strb	r2, [r4, #6]
	buffer[7] = (result[2] >> 16) & 0xFF;
     a44:	0c1a      	lsrs	r2, r3, #16
	buffer[8] = (result[2] >> 24) & 0xFF;
     a46:	0e1b      	lsrs	r3, r3, #24
     a48:	7223      	strb	r3, [r4, #8]
	buffer[9] = result[3] & 0xFF;
     a4a:	9b08      	ldr	r3, [sp, #32]
	buffer[7] = (result[2] >> 16) & 0xFF;
     a4c:	71e2      	strb	r2, [r4, #7]
	buffer[10] = (result[3] >> 8) & 0xFF;
     a4e:	0a1a      	lsrs	r2, r3, #8
	buffer[9] = result[3] & 0xFF;
     a50:	7263      	strb	r3, [r4, #9]
	buffer[10] = (result[3] >> 8) & 0xFF;
     a52:	72a2      	strb	r2, [r4, #10]
	buffer[11] = (result[3] >> 16) & 0xFF;
     a54:	0c1a      	lsrs	r2, r3, #16
	buffer[12] = (result[3] >> 24) & 0xFF;
     a56:	0e1b      	lsrs	r3, r3, #24
     a58:	7323      	strb	r3, [r4, #12]
	buffer[13] = result[4] & 0xFF;
     a5a:	9b09      	ldr	r3, [sp, #36]	; 0x24
	buffer[11] = (result[3] >> 16) & 0xFF;
     a5c:	72e2      	strb	r2, [r4, #11]
	buffer[14] = (result[4] >> 8) & 0xFF;
     a5e:	0a1a      	lsrs	r2, r3, #8
	buffer[13] = result[4] & 0xFF;
     a60:	7363      	strb	r3, [r4, #13]
	buffer[14] = (result[4] >> 8) & 0xFF;
     a62:	73a2      	strb	r2, [r4, #14]
	buffer[15] = (result[4] >> 16) & 0xFF;
     a64:	0c1a      	lsrs	r2, r3, #16
	buffer[16] = (result[4] >> 24) & 0xFF;
     a66:	0e1b      	lsrs	r3, r3, #24
     a68:	7423      	strb	r3, [r4, #16]
	*len = 17;
     a6a:	2311      	movs	r3, #17
	buffer[15] = (result[4] >> 16) & 0xFF;
     a6c:	73e2      	strb	r2, [r4, #15]
	*len = 17;
     a6e:	602b      	str	r3, [r5, #0]
}
     a70:	b00b      	add	sp, #44	; 0x2c
     a72:	bd30      	pop	{r4, r5, pc}
     a74:	1fff1ff1 	.word	0x1fff1ff1

00000a78 <set_isp>:

void set_isp(void)
{
     a78:	b500      	push	{lr}
     a7a:	b08b      	sub	sp, #44	; 0x2c
	u32 command[5];
	u32 result[5];
	command[0] = 57;
     a7c:	2339      	movs	r3, #57	; 0x39
	iap_entry(command, result);
     a7e:	4668      	mov	r0, sp
	command[0] = 57;
     a80:	9300      	str	r3, [sp, #0]
	iap_entry(command, result);
     a82:	a905      	add	r1, sp, #20
     a84:	4b02      	ldr	r3, [pc, #8]	; (a90 <set_isp+0x18>)
     a86:	4798      	blx	r3
}
     a88:	b00b      	add	sp, #44	; 0x2c
     a8a:	f85d fb04 	ldr.w	pc, [sp], #4
     a8e:	bf00      	nop
     a90:	1fff1ff1 	.word	0x1fff1ff1

00000a94 <DataIn>:

/**
	Sends next chunk of data (possibly 0 bytes) to host
 */
static void DataIn(void)
{
     a94:	b538      	push	{r3, r4, r5, lr}
	int iChunk;

	iChunk = MIN(MAX_PACKET_SIZE0, iResidue);
     a96:	4c08      	ldr	r4, [pc, #32]	; (ab8 <DataIn+0x24>)
	USBHwEPWrite(0x80, pbData, iChunk);
     a98:	2080      	movs	r0, #128	; 0x80
	iChunk = MIN(MAX_PACKET_SIZE0, iResidue);
     a9a:	6825      	ldr	r5, [r4, #0]
	USBHwEPWrite(0x80, pbData, iChunk);
     a9c:	6861      	ldr	r1, [r4, #4]
	iChunk = MIN(MAX_PACKET_SIZE0, iResidue);
     a9e:	2d40      	cmp	r5, #64	; 0x40
     aa0:	bfa8      	it	ge
     aa2:	2540      	movge	r5, #64	; 0x40
	USBHwEPWrite(0x80, pbData, iChunk);
     aa4:	462a      	mov	r2, r5
     aa6:	f000 f95d 	bl	d64 <USBHwEPWrite>
	pbData += iChunk;
     aaa:	6863      	ldr	r3, [r4, #4]
	iResidue -= iChunk;
     aac:	6822      	ldr	r2, [r4, #0]
	pbData += iChunk;
     aae:	442b      	add	r3, r5
	iResidue -= iChunk;
     ab0:	1b52      	subs	r2, r2, r5
	pbData += iChunk;
     ab2:	6063      	str	r3, [r4, #4]
	iResidue -= iChunk;
     ab4:	6022      	str	r2, [r4, #0]
}
     ab6:	bd38      	pop	{r3, r4, r5, pc}
     ab8:	100005cc 	.word	0x100005cc

00000abc <_HandleRequest.constprop.0>:
static BOOL _HandleRequest(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
     abc:	b537      	push	{r0, r1, r2, r4, r5, lr}
	iType = REQTYPE_GET_TYPE(pSetup->bmRequestType);
     abe:	4810      	ldr	r0, [pc, #64]	; (b00 <_HandleRequest.constprop.0+0x44>)
     ac0:	7a04      	ldrb	r4, [r0, #8]
     ac2:	4605      	mov	r5, r0
     ac4:	f3c4 1441 	ubfx	r4, r4, #5, #2
	if(iType == REQTYPE_TYPE_VENDOR) {
     ac8:	2c02      	cmp	r4, #2
     aca:	d10c      	bne.n	ae6 <_HandleRequest.constprop.0+0x2a>
		BOOL fFilterStatus = FALSE;
     acc:	2300      	movs	r3, #0
		if(USBFilterOsVendorMessage(pSetup, &fFilterStatus, piLen, ppbData)) {
     ace:	f100 0210 	add.w	r2, r0, #16
		BOOL fFilterStatus = FALSE;
     ad2:	9301      	str	r3, [sp, #4]
		if(USBFilterOsVendorMessage(pSetup, &fFilterStatus, piLen, ppbData)) {
     ad4:	a901      	add	r1, sp, #4
     ad6:	1d03      	adds	r3, r0, #4
     ad8:	3008      	adds	r0, #8
     ada:	f000 fb17 	bl	110c <USBFilterOsVendorMessage>
     ade:	b110      	cbz	r0, ae6 <_HandleRequest.constprop.0+0x2a>
			return fFilterStatus;
     ae0:	9801      	ldr	r0, [sp, #4]
}
     ae2:	b003      	add	sp, #12
     ae4:	bd30      	pop	{r4, r5, pc}
	pfnHandler = apfnReqHandlers[iType];
     ae6:	eb05 0484 	add.w	r4, r5, r4, lsl #2
     aea:	6963      	ldr	r3, [r4, #20]
	if (pfnHandler == NULL) {
     aec:	b12b      	cbz	r3, afa <_HandleRequest.constprop.0+0x3e>
	return pfnHandler(pSetup, piLen, ppbData);
     aee:	4a05      	ldr	r2, [pc, #20]	; (b04 <_HandleRequest.constprop.0+0x48>)
     af0:	f102 010c 	add.w	r1, r2, #12
     af4:	1d10      	adds	r0, r2, #4
     af6:	4798      	blx	r3
     af8:	e7f3      	b.n	ae2 <_HandleRequest.constprop.0+0x26>
		return FALSE;
     afa:	4618      	mov	r0, r3
     afc:	e7f1      	b.n	ae2 <_HandleRequest.constprop.0+0x26>
     afe:	bf00      	nop
     b00:	100005cc 	.word	0x100005cc
     b04:	100005d0 	.word	0x100005d0

00000b08 <USBHandleControlTransfer>:
 *
 *	@param [in]	bEP		Endpoint address
 *	@param [in]	bEPStat	Endpoint status
 */
void USBHandleControlTransfer(U8 bEP, U8 bEPStat)
{
     b08:	b510      	push	{r4, lr}
	int iChunk, iType;

	if (bEP == 0x00) {
     b0a:	2800      	cmp	r0, #0
     b0c:	d147      	bne.n	b9e <USBHandleControlTransfer+0x96>
		// OUT transfer
		if (bEPStat & EP_STATUS_SETUP) {
     b0e:	f011 0104 	ands.w	r1, r1, #4
     b12:	4c24      	ldr	r4, [pc, #144]	; (ba4 <USBHandleControlTransfer+0x9c>)
     b14:	d023      	beq.n	b5e <USBHandleControlTransfer+0x56>
			// setup packet, reset request message state machine
			USBHwEPRead(0x00, (U8 *)&Setup, sizeof(Setup));
     b16:	2208      	movs	r2, #8
     b18:	18a1      	adds	r1, r4, r2
     b1a:	f000 f94b 	bl	db4 <USBHwEPRead>
			DBG("S%x", Setup.bRequest);

			// defaults for data pointer and residue
			iType = REQTYPE_GET_TYPE(Setup.bmRequestType);
     b1e:	7a22      	ldrb	r2, [r4, #8]
     b20:	f3c2 1341 	ubfx	r3, r2, #5, #2
			pbData = apbDataStore[iType];
     b24:	eb04 0383 	add.w	r3, r4, r3, lsl #2
     b28:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     b2a:	6063      	str	r3, [r4, #4]
			iResidue = Setup.wLength;
     b2c:	89e3      	ldrh	r3, [r4, #14]
     b2e:	6023      	str	r3, [r4, #0]
			iLen = Setup.wLength;
     b30:	6123      	str	r3, [r4, #16]

			if ((Setup.wLength == 0) ||
     b32:	b10b      	cbz	r3, b38 <USBHandleControlTransfer+0x30>
     b34:	09d3      	lsrs	r3, r2, #7
     b36:	d034      	beq.n	ba2 <USBHandleControlTransfer+0x9a>
				(REQTYPE_GET_DIR(Setup.bmRequestType) == REQTYPE_DIR_TO_HOST)) {
				// ask installed handler to process request
				if (!_HandleRequest(&Setup, &iLen, &pbData)) {
     b38:	f7ff ffc0 	bl	abc <_HandleRequest.constprop.0>
     b3c:	b928      	cbnz	r0, b4a <USBHandleControlTransfer+0x42>
		DataIn();
	}
	else {
		ASSERT(FALSE);
	}
}
     b3e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USBHwEPStall(0x80, TRUE);
     b42:	2101      	movs	r1, #1
     b44:	2080      	movs	r0, #128	; 0x80
     b46:	f000 b901 	b.w	d4c <USBHwEPStall>
				iResidue = MIN(iLen, Setup.wLength);
     b4a:	89e2      	ldrh	r2, [r4, #14]
     b4c:	6923      	ldr	r3, [r4, #16]
     b4e:	429a      	cmp	r2, r3
     b50:	bfd4      	ite	le
     b52:	6022      	strle	r2, [r4, #0]
     b54:	6023      	strgt	r3, [r4, #0]
}
     b56:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
					DataIn();
     b5a:	f7ff bf9b 	b.w	a94 <DataIn>
			if (iResidue > 0) {
     b5e:	6822      	ldr	r2, [r4, #0]
     b60:	2a00      	cmp	r2, #0
     b62:	dd17      	ble.n	b94 <USBHandleControlTransfer+0x8c>
				iChunk = USBHwEPRead(0x00, pbData, iResidue);
     b64:	6861      	ldr	r1, [r4, #4]
     b66:	f000 f925 	bl	db4 <USBHwEPRead>
				if (iChunk < 0) {
     b6a:	2800      	cmp	r0, #0
     b6c:	dbe7      	blt.n	b3e <USBHandleControlTransfer+0x36>
				pbData += iChunk;
     b6e:	6863      	ldr	r3, [r4, #4]
     b70:	4403      	add	r3, r0
     b72:	6063      	str	r3, [r4, #4]
				iResidue -= iChunk;
     b74:	6823      	ldr	r3, [r4, #0]
     b76:	1a18      	subs	r0, r3, r0
     b78:	6020      	str	r0, [r4, #0]
				if (iResidue == 0) {
     b7a:	b990      	cbnz	r0, ba2 <USBHandleControlTransfer+0x9a>
					iType = REQTYPE_GET_TYPE(Setup.bmRequestType);
     b7c:	7a23      	ldrb	r3, [r4, #8]
     b7e:	f3c3 1341 	ubfx	r3, r3, #5, #2
					pbData = apbDataStore[iType];
     b82:	eb04 0383 	add.w	r3, r4, r3, lsl #2
     b86:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     b88:	6063      	str	r3, [r4, #4]
					if (!_HandleRequest(&Setup, &iLen, &pbData)) {
     b8a:	f7ff ff97 	bl	abc <_HandleRequest.constprop.0>
     b8e:	2800      	cmp	r0, #0
     b90:	d1e1      	bne.n	b56 <USBHandleControlTransfer+0x4e>
     b92:	e7d4      	b.n	b3e <USBHandleControlTransfer+0x36>
				iChunk = USBHwEPRead(0x00, NULL, 0);
     b94:	460a      	mov	r2, r1
}
     b96:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				iChunk = USBHwEPRead(0x00, NULL, 0);
     b9a:	f000 b90b 	b.w	db4 <USBHwEPRead>
	else if (bEP == 0x80) {
     b9e:	2880      	cmp	r0, #128	; 0x80
     ba0:	d0d9      	beq.n	b56 <USBHandleControlTransfer+0x4e>
}
     ba2:	bd10      	pop	{r4, pc}
     ba4:	100005cc 	.word	0x100005cc

00000ba8 <USBRegisterRequestHandler>:
 */
void USBRegisterRequestHandler(int iType, TFnHandleRequest *pfnHandler, U8 *pbDataStore)
{
	ASSERT(iType >= 0);
	ASSERT(iType < 4);
	apfnReqHandlers[iType] = pfnHandler;
     ba8:	4b02      	ldr	r3, [pc, #8]	; (bb4 <USBRegisterRequestHandler+0xc>)
     baa:	eb03 0080 	add.w	r0, r3, r0, lsl #2
     bae:	6141      	str	r1, [r0, #20]
	apbDataStore[iType] = pbDataStore;
     bb0:	6242      	str	r2, [r0, #36]	; 0x24
}
     bb2:	4770      	bx	lr
     bb4:	100005cc 	.word	0x100005cc

00000bb8 <HandleUsbReset>:
static void HandleUsbReset(U8 bDevStatus)
{
	if (bDevStatus & DEV_STATUS_RESET) {
		DBG("\n!");
	}
}
     bb8:	4770      	bx	lr
     bba:	0000      	movs	r0, r0

00000bbc <USBInit>:
	installing default callbacks.
	
	@return TRUE if initialisation was successful
 */
BOOL USBInit(void)
{
     bbc:	b510      	push	{r4, lr}
	
	// register bus reset handler
	USBHwRegisterDevIntHandler(HandleUsbReset);
	
	// register control transfer handler on EP0
	USBHwRegisterEPIntHandler(0x00, USBHandleControlTransfer);
     bbe:	4c0e      	ldr	r4, [pc, #56]	; (bf8 <USBInit+0x3c>)
	USBHwInit();
     bc0:	f000 f9e0 	bl	f84 <USBHwInit>
	USBHwRegisterDevIntHandler(HandleUsbReset);
     bc4:	480d      	ldr	r0, [pc, #52]	; (bfc <USBInit+0x40>)
     bc6:	f000 f87f 	bl	cc8 <USBHwRegisterDevIntHandler>
	USBHwRegisterEPIntHandler(0x00, USBHandleControlTransfer);
     bca:	4621      	mov	r1, r4
     bcc:	2000      	movs	r0, #0
     bce:	f000 f861 	bl	c94 <USBHwRegisterEPIntHandler>
	USBHwRegisterEPIntHandler(0x80, USBHandleControlTransfer);
     bd2:	4621      	mov	r1, r4
     bd4:	2080      	movs	r0, #128	; 0x80
     bd6:	f000 f85d 	bl	c94 <USBHwRegisterEPIntHandler>
	
	// setup control endpoints
	USBHwEPConfig(0x00, MAX_PACKET_SIZE0);
     bda:	2140      	movs	r1, #64	; 0x40
     bdc:	2000      	movs	r0, #0
     bde:	f000 f83b 	bl	c58 <USBHwEPConfig>
	USBHwEPConfig(0x80, MAX_PACKET_SIZE0);
     be2:	2140      	movs	r1, #64	; 0x40
     be4:	2080      	movs	r0, #128	; 0x80
     be6:	f000 f837 	bl	c58 <USBHwEPConfig>
	
	// register standard request handler
	USBRegisterRequestHandler(REQTYPE_TYPE_STANDARD, USBHandleStandardRequest, abStdReqData);
     bea:	2000      	movs	r0, #0
     bec:	4a04      	ldr	r2, [pc, #16]	; (c00 <USBInit+0x44>)
     bee:	4905      	ldr	r1, [pc, #20]	; (c04 <USBInit+0x48>)
     bf0:	f7ff ffda 	bl	ba8 <USBRegisterRequestHandler>

	return TRUE;
}
     bf4:	2001      	movs	r0, #1
     bf6:	bd10      	pop	{r4, pc}
     bf8:	00000b09 	.word	0x00000b09
     bfc:	00000bb9 	.word	0x00000bb9
     c00:	10000600 	.word	0x10000600
     c04:	0000121d 	.word	0x0000121d

00000c08 <Wait4DevInt>:
    @param [in] dwIntr      Bitmask of interrupts to wait for   
 */
static void Wait4DevInt(U32 dwIntr)
{
    // wait for specific interrupt
    while ((USBDevIntSt & dwIntr) != dwIntr);
     c08:	4a03      	ldr	r2, [pc, #12]	; (c18 <Wait4DevInt+0x10>)
     c0a:	6813      	ldr	r3, [r2, #0]
     c0c:	ea30 0303 	bics.w	r3, r0, r3
     c10:	d1fb      	bne.n	c0a <Wait4DevInt+0x2>
    // clear the interrupt bits
    USBDevIntClr = dwIntr;
     c12:	4b02      	ldr	r3, [pc, #8]	; (c1c <Wait4DevInt+0x14>)
     c14:	6018      	str	r0, [r3, #0]
}
     c16:	4770      	bx	lr
     c18:	5000c200 	.word	0x5000c200
     c1c:	5000c208 	.word	0x5000c208

00000c20 <USBHwCmd>:
    @param [in] bCmd        Command to send
 */
static void USBHwCmd(U8 bCmd)
{
    // clear CDFULL/CCEMTY
    USBDevIntClr = CDFULL | CCEMTY;
     c20:	2230      	movs	r2, #48	; 0x30
     c22:	4b04      	ldr	r3, [pc, #16]	; (c34 <USBHwCmd+0x14>)
    // write command code
    USBCmdCode = 0x00000500 | (bCmd << 16);
     c24:	0400      	lsls	r0, r0, #16
     c26:	f440 60a0 	orr.w	r0, r0, #1280	; 0x500
    USBDevIntClr = CDFULL | CCEMTY;
     c2a:	601a      	str	r2, [r3, #0]
    USBCmdCode = 0x00000500 | (bCmd << 16);
     c2c:	6098      	str	r0, [r3, #8]
    Wait4DevInt(CCEMTY);
     c2e:	2010      	movs	r0, #16
     c30:	f7ff bfea 	b.w	c08 <Wait4DevInt>
     c34:	5000c208 	.word	0x5000c208

00000c38 <USBHwCmdWrite>:
        
    @param [in] bCmd        Command to send
    @param [in] bData       Data to send
 */
static void USBHwCmdWrite(U8 bCmd, U16 bData)
{
     c38:	b508      	push	{r3, lr}
    // write command code
    USBHwCmd(bCmd);
     c3a:	f7ff fff1 	bl	c20 <USBHwCmd>

    // write command data
    USBCmdCode = 0x00000100 | (bData << 16);
     c3e:	4b05      	ldr	r3, [pc, #20]	; (c54 <USBHwCmdWrite+0x1c>)
     c40:	0409      	lsls	r1, r1, #16
     c42:	f441 7180 	orr.w	r1, r1, #256	; 0x100
     c46:	6019      	str	r1, [r3, #0]
    Wait4DevInt(CCEMTY);
     c48:	2010      	movs	r0, #16
}
     c4a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Wait4DevInt(CCEMTY);
     c4e:	f7ff bfdb 	b.w	c08 <Wait4DevInt>
     c52:	bf00      	nop
     c54:	5000c210 	.word	0x5000c210

00000c58 <USBHwEPConfig>:
        
    @param [in] bEP             Endpoint number
    @param [in] wMaxPacketSize  Maximum packet size for this EP
 */
void USBHwEPConfig(U8 bEP, U16 wMaxPacketSize)
{
     c58:	b510      	push	{r4, lr}
    USBReEp |= (1 << idx);
     c5a:	2301      	movs	r3, #1
     c5c:	4a0b      	ldr	r2, [pc, #44]	; (c8c <USBHwEPConfig+0x34>)
    int idx;
    
    idx = EP2IDX(bEP);
     c5e:	0044      	lsls	r4, r0, #1
     c60:	f004 041e 	and.w	r4, r4, #30
     c64:	ea44 14d0 	orr.w	r4, r4, r0, lsr #7
    USBReEp |= (1 << idx);
     c68:	6810      	ldr	r0, [r2, #0]
     c6a:	40a3      	lsls	r3, r4
     c6c:	4303      	orrs	r3, r0
     c6e:	6013      	str	r3, [r2, #0]
    USBEpIn = idx;
     c70:	4b07      	ldr	r3, [pc, #28]	; (c90 <USBHwEPConfig+0x38>)
    Wait4DevInt(EP_RLZED);
     c72:	f44f 7080 	mov.w	r0, #256	; 0x100
    USBEpIn = idx;
     c76:	601c      	str	r4, [r3, #0]
    USBMaxPSize = wMaxPSize;
     c78:	6059      	str	r1, [r3, #4]
    Wait4DevInt(EP_RLZED);
     c7a:	f7ff ffc5 	bl	c08 <Wait4DevInt>
    USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fEnable ? 0 : EP_DA);
     c7e:	f044 0040 	orr.w	r0, r4, #64	; 0x40
     c82:	2100      	movs	r1, #0
    // realise EP
    USBHwEPRealize(idx, wMaxPacketSize);

    // enable EP
    USBHwEPEnable(idx, TRUE);
}
     c84:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fEnable ? 0 : EP_DA);
     c88:	f7ff bfd6 	b.w	c38 <USBHwCmdWrite>
     c8c:	5000c244 	.word	0x5000c244
     c90:	5000c248 	.word	0x5000c248

00000c94 <USBHwRegisterEPIntHandler>:
    idx = EP2IDX(bEP);

    ASSERT(idx<32);

    /* add handler to list of EP handlers */
    _apfnEPIntHandlers[idx / 2] = pfnHandler;
     c94:	4a0a      	ldr	r2, [pc, #40]	; (cc0 <USBHwRegisterEPIntHandler+0x2c>)
    idx = EP2IDX(bEP);
     c96:	0043      	lsls	r3, r0, #1
     c98:	f003 031e 	and.w	r3, r3, #30
    _apfnEPIntHandlers[idx / 2] = pfnHandler;
     c9c:	f842 1013 	str.w	r1, [r2, r3, lsl #1]
    idx = EP2IDX(bEP);
     ca0:	ea43 10d0 	orr.w	r0, r3, r0, lsr #7
    
    /* enable EP interrupt */
    USBEpIntEn |= (1 << idx);
     ca4:	2301      	movs	r3, #1
     ca6:	4a07      	ldr	r2, [pc, #28]	; (cc4 <USBHwRegisterEPIntHandler+0x30>)
     ca8:	fa03 f000 	lsl.w	r0, r3, r0
     cac:	6811      	ldr	r1, [r2, #0]
     cae:	4308      	orrs	r0, r1
     cb0:	6010      	str	r0, [r2, #0]
    USBDevIntEn |= EP_SLOW;
     cb2:	f852 3c30 	ldr.w	r3, [r2, #-48]
     cb6:	f043 0304 	orr.w	r3, r3, #4
     cba:	f842 3c30 	str.w	r3, [r2, #-48]
    
    DBG("Registered handler for EP 0x%x\n", bEP);
}
     cbe:	4770      	bx	lr
     cc0:	10000608 	.word	0x10000608
     cc4:	5000c234 	.word	0x5000c234

00000cc8 <USBHwRegisterDevIntHandler>:
        
    @param [in] pfnHandler  Callback function
 */
void USBHwRegisterDevIntHandler(TFnDevIntHandler *pfnHandler)
{
    _pfnDevIntHandler = pfnHandler;
     cc8:	4b03      	ldr	r3, [pc, #12]	; (cd8 <USBHwRegisterDevIntHandler+0x10>)
    
    // enable device interrupt
    USBDevIntEn |= DEV_STAT;
     cca:	4a04      	ldr	r2, [pc, #16]	; (cdc <USBHwRegisterDevIntHandler+0x14>)
    _pfnDevIntHandler = pfnHandler;
     ccc:	6418      	str	r0, [r3, #64]	; 0x40
    USBDevIntEn |= DEV_STAT;
     cce:	6813      	ldr	r3, [r2, #0]
     cd0:	f043 0308 	orr.w	r3, r3, #8
     cd4:	6013      	str	r3, [r2, #0]

    DBG("Registered handler for device status\n");
}
     cd6:	4770      	bx	lr
     cd8:	10000608 	.word	0x10000608
     cdc:	5000c204 	.word	0x5000c204

00000ce0 <USBHwRegisterFrameHandler>:
        
    @param [in] pfnHandler  Callback function
 */
void USBHwRegisterFrameHandler(TFnFrameHandler *pfnHandler)
{
    _pfnFrameHandler = pfnHandler;
     ce0:	4b03      	ldr	r3, [pc, #12]	; (cf0 <USBHwRegisterFrameHandler+0x10>)
    
    // enable device interrupt
    USBDevIntEn |= FRAME;
     ce2:	4a04      	ldr	r2, [pc, #16]	; (cf4 <USBHwRegisterFrameHandler+0x14>)
    _pfnFrameHandler = pfnHandler;
     ce4:	6458      	str	r0, [r3, #68]	; 0x44
    USBDevIntEn |= FRAME;
     ce6:	6813      	ldr	r3, [r2, #0]
     ce8:	f043 0301 	orr.w	r3, r3, #1
     cec:	6013      	str	r3, [r2, #0]

    DBG("Registered handler for frame\n");
}
     cee:	4770      	bx	lr
     cf0:	10000608 	.word	0x10000608
     cf4:	5000c204 	.word	0x5000c204

00000cf8 <USBHwSetAddress>:
        
    @param [in] bAddr       Device address to set
 */
void USBHwSetAddress(U8 bAddr)
{
    USBHwCmdWrite(CMD_DEV_SET_ADDRESS, DEV_EN | bAddr);
     cf8:	f040 0180 	orr.w	r1, r0, #128	; 0x80
     cfc:	20d0      	movs	r0, #208	; 0xd0
     cfe:	f7ff bf9b 	b.w	c38 <USBHwCmdWrite>

00000d02 <USBHwConnect>:
    FIO0CLR = (1<<14);
  else
    FIO0SET = (1<<14);
#endif
#endif
    USBHwCmdWrite(CMD_DEV_STATUS, fConnect ? CON : 0);
     d02:	1e01      	subs	r1, r0, #0
     d04:	bf18      	it	ne
     d06:	2101      	movne	r1, #1
     d08:	20fe      	movs	r0, #254	; 0xfe
     d0a:	f7ff bf95 	b.w	c38 <USBHwCmdWrite>

00000d0e <USBHwNakIntEnable>:
    from NAK interrupt by checking the bits in their bEPStatus argument.
    
    @param [in] bIntBits    Bitmap indicating which NAK interrupts to enable
 */
void USBHwNakIntEnable(U8 bIntBits)
{
     d0e:	4601      	mov	r1, r0
    USBHwCmdWrite(CMD_DEV_SET_MODE, bIntBits);
     d10:	20f3      	movs	r0, #243	; 0xf3
     d12:	f7ff bf91 	b.w	c38 <USBHwCmdWrite>
     d16:	0000      	movs	r0, r0

00000d18 <USBHwEPGetStatus>:
        
    @param [in] bEP     Endpoint number
    @return Endpoint status byte (containing EP_STATUS_xxx bits)
 */
U8  USBHwEPGetStatus(U8 bEP)
{
     d18:	b508      	push	{r3, lr}
    int idx = EP2IDX(bEP);
     d1a:	0043      	lsls	r3, r0, #1
     d1c:	f003 031e 	and.w	r3, r3, #30
     d20:	ea43 11d0 	orr.w	r1, r3, r0, lsr #7
    USBHwCmd(bCmd);
     d24:	4608      	mov	r0, r1
     d26:	f7ff ff7b 	bl	c20 <USBHwCmd>
    USBCmdCode = 0x00000200 | (bCmd << 16);
     d2a:	4b06      	ldr	r3, [pc, #24]	; (d44 <USBHwEPGetStatus+0x2c>)
     d2c:	0409      	lsls	r1, r1, #16
     d2e:	f441 7100 	orr.w	r1, r1, #512	; 0x200
     d32:	6019      	str	r1, [r3, #0]
    Wait4DevInt(CDFULL);
     d34:	2020      	movs	r0, #32
     d36:	f7ff ff67 	bl	c08 <Wait4DevInt>
    return USBCmdData;
     d3a:	4b03      	ldr	r3, [pc, #12]	; (d48 <USBHwEPGetStatus+0x30>)
     d3c:	6818      	ldr	r0, [r3, #0]

    return USBHwCmdRead(CMD_EP_SELECT | idx);
}
     d3e:	b2c0      	uxtb	r0, r0
     d40:	bd08      	pop	{r3, pc}
     d42:	bf00      	nop
     d44:	5000c210 	.word	0x5000c210
     d48:	5000c214 	.word	0x5000c214

00000d4c <USBHwEPStall>:
    @param [in] bEP     Endpoint number
    @param [in] fStall  TRUE to stall, FALSE to unstall
 */
void USBHwEPStall(U8 bEP, BOOL fStall)
{
    int idx = EP2IDX(bEP);
     d4c:	0043      	lsls	r3, r0, #1
     d4e:	f003 031e 	and.w	r3, r3, #30
     d52:	ea43 10d0 	orr.w	r0, r3, r0, lsr #7

    USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fStall ? EP_ST : 0);
     d56:	3900      	subs	r1, #0
     d58:	bf18      	it	ne
     d5a:	2101      	movne	r1, #1
     d5c:	f040 0040 	orr.w	r0, r0, #64	; 0x40
     d60:	f7ff bf6a 	b.w	c38 <USBHwCmdWrite>

00000d64 <USBHwEPWrite>:
    @param [in] iLen    Number of bytes to write
            
    @return number of bytes written into the endpoint buffer
*/
int USBHwEPWrite(U8 bEP, U8 *pbBuf, U32 iLen)
{
     d64:	b538      	push	{r3, r4, r5, lr}
     d66:	4603      	mov	r3, r0
     d68:	4615      	mov	r5, r2
    U32 idx;
    
    idx = EP2IDX(bEP);
     d6a:	0040      	lsls	r0, r0, #1
     d6c:	f000 001e 	and.w	r0, r0, #30
     d70:	ea40 10d3 	orr.w	r0, r0, r3, lsr #7
    
    // set write enable for specific endpoint
    USBCtrl = WR_EN | ((bEP & 0xF) << 2);
     d74:	009b      	lsls	r3, r3, #2
     d76:	4c0d      	ldr	r4, [pc, #52]	; (dac <USBHwEPWrite+0x48>)
     d78:	f003 033c 	and.w	r3, r3, #60	; 0x3c
     d7c:	f043 0302 	orr.w	r3, r3, #2
     d80:	6023      	str	r3, [r4, #0]
    
    // set packet length
    USBTxPLen = iLen;
     d82:	4b0b      	ldr	r3, [pc, #44]	; (db0 <USBHwEPWrite+0x4c>)
     d84:	601a      	str	r2, [r3, #0]
    
    // write data
    while (USBCtrl & WR_EN) {
     d86:	4623      	mov	r3, r4
        USBTxData = (pbBuf[3] << 24) | (pbBuf[2] << 16) | (pbBuf[1] << 8) | pbBuf[0];
     d88:	3c0c      	subs	r4, #12
    while (USBCtrl & WR_EN) {
     d8a:	681a      	ldr	r2, [r3, #0]
     d8c:	f012 0202 	ands.w	r2, r2, #2
     d90:	d107      	bne.n	da2 <USBHwEPWrite+0x3e>
        pbBuf += 4;
    }

    USBCtrl = 0;
     d92:	601a      	str	r2, [r3, #0]

    // select endpoint and validate buffer
    USBHwCmd(CMD_EP_SELECT | idx);
     d94:	f7ff ff44 	bl	c20 <USBHwCmd>
    USBHwCmd(CMD_EP_VALIDATE_BUFFER);
     d98:	20fa      	movs	r0, #250	; 0xfa
     d9a:	f7ff ff41 	bl	c20 <USBHwCmd>
    
    return iLen;
}
     d9e:	4628      	mov	r0, r5
     da0:	bd38      	pop	{r3, r4, r5, pc}
        USBTxData = (pbBuf[3] << 24) | (pbBuf[2] << 16) | (pbBuf[1] << 8) | pbBuf[0];
     da2:	f851 2b04 	ldr.w	r2, [r1], #4
     da6:	6022      	str	r2, [r4, #0]
        pbBuf += 4;
     da8:	e7ef      	b.n	d8a <USBHwEPWrite+0x26>
     daa:	bf00      	nop
     dac:	5000c228 	.word	0x5000c228
     db0:	5000c224 	.word	0x5000c224

00000db4 <USBHwEPRead>:
            
    @return the number of bytes available in the EP (possibly more than iMaxLen),
    or <0 in case of error.
 */
int USBHwEPRead(U8 bEP, U8 *pbBuf, U32 iMaxLen)
{
     db4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     db6:	4603      	mov	r3, r0
    U32 i, idx;
    U32 dwData, dwLen;
    
    idx = EP2IDX(bEP);
     db8:	0040      	lsls	r0, r0, #1
     dba:	f000 001e 	and.w	r0, r0, #30
     dbe:	ea40 10d3 	orr.w	r0, r0, r3, lsr #7
    
    // set read enable bit for specific endpoint
    USBCtrl = RD_EN | ((bEP & 0xF) << 2);
     dc2:	009b      	lsls	r3, r3, #2
     dc4:	4e14      	ldr	r6, [pc, #80]	; (e18 <USBHwEPRead+0x64>)
     dc6:	f003 033c 	and.w	r3, r3, #60	; 0x3c
     dca:	f043 0301 	orr.w	r3, r3, #1
    
    // wait for PKT_RDY
    do {
        dwLen = USBRxPLen;
     dce:	4c13      	ldr	r4, [pc, #76]	; (e1c <USBHwEPRead+0x68>)
    USBCtrl = RD_EN | ((bEP & 0xF) << 2);
     dd0:	6033      	str	r3, [r6, #0]
        dwLen = USBRxPLen;
     dd2:	6823      	ldr	r3, [r4, #0]
    } while ((dwLen & PKT_RDY) == 0);
     dd4:	051d      	lsls	r5, r3, #20
     dd6:	d5fc      	bpl.n	dd2 <USBHwEPRead+0x1e>
    
    // packet valid?
    if ((dwLen & DV) == 0) {
     dd8:	055c      	lsls	r4, r3, #21
     dda:	d51a      	bpl.n	e12 <USBHwEPRead+0x5e>
    
    // get length
    dwLen &= PKT_LNGTH_MASK;
    
    // get data
    dwData = 0;
     ddc:	2500      	movs	r5, #0
    for (i = 0; i < dwLen; i++) {
     dde:	462c      	mov	r4, r5
        if ((i % 4) == 0) {
            dwData = USBRxData;
     de0:	4f0f      	ldr	r7, [pc, #60]	; (e20 <USBHwEPRead+0x6c>)
    dwLen &= PKT_LNGTH_MASK;
     de2:	f3c3 0309 	ubfx	r3, r3, #0, #10
    for (i = 0; i < dwLen; i++) {
     de6:	429c      	cmp	r4, r3
     de8:	d108      	bne.n	dfc <USBHwEPRead+0x48>
        }
        dwData >>= 8;
    }

    // make sure RD_EN is clear
    USBCtrl = 0;
     dea:	2300      	movs	r3, #0
     dec:	6033      	str	r3, [r6, #0]

    // select endpoint and clear buffer
    USBHwCmd(CMD_EP_SELECT | idx);
     dee:	f7ff ff17 	bl	c20 <USBHwCmd>
    USBHwCmd(CMD_EP_CLEAR_BUFFER);
     df2:	20f2      	movs	r0, #242	; 0xf2
     df4:	f7ff ff14 	bl	c20 <USBHwCmd>
    
    return dwLen;
     df8:	4620      	mov	r0, r4
}
     dfa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if ((i % 4) == 0) {
     dfc:	f014 0f03 	tst.w	r4, #3
            dwData = USBRxData;
     e00:	bf08      	it	eq
     e02:	683d      	ldreq	r5, [r7, #0]
        if ((pbBuf != NULL) && (i < iMaxLen)) {
     e04:	b111      	cbz	r1, e0c <USBHwEPRead+0x58>
     e06:	4294      	cmp	r4, r2
            pbBuf[i] = dwData & 0xFF;
     e08:	bf38      	it	cc
     e0a:	550d      	strbcc	r5, [r1, r4]
        dwData >>= 8;
     e0c:	0a2d      	lsrs	r5, r5, #8
    for (i = 0; i < dwLen; i++) {
     e0e:	3401      	adds	r4, #1
     e10:	e7e9      	b.n	de6 <USBHwEPRead+0x32>
        return -1;
     e12:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     e16:	e7f0      	b.n	dfa <USBHwEPRead+0x46>
     e18:	5000c228 	.word	0x5000c228
     e1c:	5000c220 	.word	0x5000c220
     e20:	5000c218 	.word	0x5000c218

00000e24 <USBHwISOCEPRead>:
#endif
}


int USBHwISOCEPRead(const U8 bEP, U8 *pbBuf, const U32 iMaxLen)
{
     e24:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
     e26:	4603      	mov	r3, r0
    U32 i, idx;
    U32 dwData, dwLen;

    idx = EP2IDX(bEP);
     e28:	0040      	lsls	r0, r0, #1
     e2a:	f000 001e 	and.w	r0, r0, #30
     e2e:	ea40 10d3 	orr.w	r0, r0, r3, lsr #7

    // set read enable bit for specific endpoint
    USBCtrl = RD_EN | ((bEP & 0xF) << 2);
     e32:	009b      	lsls	r3, r3, #2
     e34:	4e1a      	ldr	r6, [pc, #104]	; (ea0 <USBHwISOCEPRead+0x7c>)
     e36:	f003 033c 	and.w	r3, r3, #60	; 0x3c
     e3a:	f043 0301 	orr.w	r3, r3, #1
     e3e:	6033      	str	r3, [r6, #0]
    asm volatile("nop\n"); 
     e40:	bf00      	nop
    volatile uint32_t fast_wait = 1;
     e42:	2301      	movs	r3, #1
     e44:	9301      	str	r3, [sp, #4]
    while(--fast_wait);
     e46:	9b01      	ldr	r3, [sp, #4]
     e48:	3b01      	subs	r3, #1
     e4a:	9301      	str	r3, [sp, #4]
     e4c:	2b00      	cmp	r3, #0
     e4e:	d1fa      	bne.n	e46 <USBHwISOCEPRead+0x22>
    //Note: for some reason the USB perepherial needs a cycle to set bits in USBRxPLen before 
    //reading, if you remove this ISOC wont work. This may be a but in the chip, or due to 
    //a mis-understanding of how the perepherial is supposed to work.    
    fast_wait();
    
    dwLen = USBRxPLen;
     e50:	4c14      	ldr	r4, [pc, #80]	; (ea4 <USBHwISOCEPRead+0x80>)
     e52:	6824      	ldr	r4, [r4, #0]
    if( (dwLen & PKT_RDY) == 0 ) {
     e54:	f414 6500 	ands.w	r5, r4, #2048	; 0x800
     e58:	d104      	bne.n	e64 <USBHwISOCEPRead+0x40>
    }

    // packet valid?
    if ((dwLen & DV) == 0) {
        USBCtrl = 0;// make sure RD_EN is clear
        return -1;
     e5a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
        USBCtrl = 0;// make sure RD_EN is clear
     e5e:	6035      	str	r5, [r6, #0]
    // select endpoint and clear buffer
    USBHwCmd(CMD_EP_SELECT | idx);
    USBHwCmd(CMD_EP_CLEAR_BUFFER);

    return dwLen;
}
     e60:	b003      	add	sp, #12
     e62:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if ((dwLen & DV) == 0) {
     e64:	f414 6580 	ands.w	r5, r4, #1024	; 0x400
     e68:	d0f7      	beq.n	e5a <USBHwISOCEPRead+0x36>
    dwLen &= PKT_LNGTH_MASK;
     e6a:	f3c4 0509 	ubfx	r5, r4, #0, #10
    for (i = 0; i < dwLen; i++) {
     e6e:	461c      	mov	r4, r3
            dwData = USBRxData;
     e70:	4f0d      	ldr	r7, [pc, #52]	; (ea8 <USBHwISOCEPRead+0x84>)
    for (i = 0; i < dwLen; i++) {
     e72:	42ac      	cmp	r4, r5
     e74:	d108      	bne.n	e88 <USBHwISOCEPRead+0x64>
    USBCtrl = 0;
     e76:	2300      	movs	r3, #0
     e78:	6033      	str	r3, [r6, #0]
    USBHwCmd(CMD_EP_SELECT | idx);
     e7a:	f7ff fed1 	bl	c20 <USBHwCmd>
    USBHwCmd(CMD_EP_CLEAR_BUFFER);
     e7e:	20f2      	movs	r0, #242	; 0xf2
     e80:	f7ff fece 	bl	c20 <USBHwCmd>
    return dwLen;
     e84:	4620      	mov	r0, r4
     e86:	e7eb      	b.n	e60 <USBHwISOCEPRead+0x3c>
        if ((i % 4) == 0) {
     e88:	f014 0f03 	tst.w	r4, #3
            dwData = USBRxData;
     e8c:	bf08      	it	eq
     e8e:	683b      	ldreq	r3, [r7, #0]
        if ((pbBuf != NULL) && (i < iMaxLen)) {
     e90:	b111      	cbz	r1, e98 <USBHwISOCEPRead+0x74>
     e92:	4294      	cmp	r4, r2
            pbBuf[i] = dwData & 0xFF;
     e94:	bf38      	it	cc
     e96:	550b      	strbcc	r3, [r1, r4]
        dwData >>= 8;
     e98:	0a1b      	lsrs	r3, r3, #8
    for (i = 0; i < dwLen; i++) {
     e9a:	3401      	adds	r4, #1
     e9c:	e7e9      	b.n	e72 <USBHwISOCEPRead+0x4e>
     e9e:	bf00      	nop
     ea0:	5000c228 	.word	0x5000c228
     ea4:	5000c220 	.word	0x5000c220
     ea8:	5000c218 	.word	0x5000c218

00000eac <USBHwConfigDevice>:
    @param [in] fConfigured If TRUE, configure device, else unconfigure
 */
void USBHwConfigDevice(BOOL fConfigured)
{
    // set configured bit
    USBHwCmdWrite(CMD_DEV_CONFIG, fConfigured ? CONF_DEVICE : 0);
     eac:	1e01      	subs	r1, r0, #0
     eae:	bf18      	it	ne
     eb0:	2101      	movne	r1, #1
     eb2:	20d8      	movs	r0, #216	; 0xd8
     eb4:	f7ff bec0 	b.w	c38 <USBHwCmdWrite>

00000eb8 <USBHwISR>:
    @todo Get all 11 bits of frame number instead of just 8

    Endpoint interrupts are mapped to the slow interrupt
 */
void USBHwISR(void)
{
     eb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

// LED9 monitors total time in interrupt routine
DEBUG_LED_ON(9);

    // handle device interrupts
    dwStatus = USBDevIntSt;
     eba:	4b29      	ldr	r3, [pc, #164]	; (f60 <USBHwISR+0xa8>)
     ebc:	681c      	ldr	r4, [r3, #0]
    
    // frame interrupt
    if (dwStatus & FRAME) {
     ebe:	07e1      	lsls	r1, r4, #31
     ec0:	d511      	bpl.n	ee6 <USBHwISR+0x2e>
        // clear int
        USBDevIntClr = FRAME;
     ec2:	2201      	movs	r2, #1
     ec4:	609a      	str	r2, [r3, #8]
        // call handler
        if (_pfnFrameHandler != NULL) {
     ec6:	4b27      	ldr	r3, [pc, #156]	; (f64 <USBHwISR+0xac>)
     ec8:	6c59      	ldr	r1, [r3, #68]	; 0x44
     eca:	b161      	cbz	r1, ee6 <USBHwISR+0x2e>
    USBHwCmd(bCmd);
     ecc:	20f5      	movs	r0, #245	; 0xf5
     ece:	f7ff fea7 	bl	c20 <USBHwCmd>
    USBCmdCode = 0x00000200 | (bCmd << 16);
     ed2:	4b25      	ldr	r3, [pc, #148]	; (f68 <USBHwISR+0xb0>)
     ed4:	4a25      	ldr	r2, [pc, #148]	; (f6c <USBHwISR+0xb4>)
    Wait4DevInt(CDFULL);
     ed6:	2020      	movs	r0, #32
    USBCmdCode = 0x00000200 | (bCmd << 16);
     ed8:	601a      	str	r2, [r3, #0]
    Wait4DevInt(CDFULL);
     eda:	f7ff fe95 	bl	c08 <Wait4DevInt>
    return USBCmdData;
     ede:	4b24      	ldr	r3, [pc, #144]	; (f70 <USBHwISR+0xb8>)
     ee0:	6818      	ldr	r0, [r3, #0]
            wFrame = USBHwCmdRead(CMD_DEV_READ_CUR_FRAME_NR);
            _pfnFrameHandler(wFrame);
     ee2:	b2c0      	uxtb	r0, r0
     ee4:	4788      	blx	r1
        }
    }
    
    // device status interrupt
    if (dwStatus & DEV_STAT) {
     ee6:	0722      	lsls	r2, r4, #28
     ee8:	d517      	bpl.n	f1a <USBHwISR+0x62>
        /*  Clear DEV_STAT interrupt before reading DEV_STAT register.
            This prevents corrupted device status reads, see
            LPC2148 User manual revision 2, 25 july 2006.
        */
        USBDevIntClr = DEV_STAT;
     eea:	2208      	movs	r2, #8
     eec:	4b21      	ldr	r3, [pc, #132]	; (f74 <USBHwISR+0xbc>)
    USBHwCmd(bCmd);
     eee:	20fe      	movs	r0, #254	; 0xfe
        USBDevIntClr = DEV_STAT;
     ef0:	601a      	str	r2, [r3, #0]
    USBHwCmd(bCmd);
     ef2:	f7ff fe95 	bl	c20 <USBHwCmd>
    USBCmdCode = 0x00000200 | (bCmd << 16);
     ef6:	4b1c      	ldr	r3, [pc, #112]	; (f68 <USBHwISR+0xb0>)
     ef8:	4a1f      	ldr	r2, [pc, #124]	; (f78 <USBHwISR+0xc0>)
    Wait4DevInt(CDFULL);
     efa:	2020      	movs	r0, #32
    USBCmdCode = 0x00000200 | (bCmd << 16);
     efc:	601a      	str	r2, [r3, #0]
    Wait4DevInt(CDFULL);
     efe:	f7ff fe83 	bl	c08 <Wait4DevInt>
    return USBCmdData;
     f02:	4b1b      	ldr	r3, [pc, #108]	; (f70 <USBHwISR+0xb8>)
     f04:	681b      	ldr	r3, [r3, #0]
        bDevStat = USBHwCmdRead(CMD_DEV_STATUS);
        if (bDevStat & (CON_CH | SUS_CH | RST)) {
     f06:	f013 0f1a 	tst.w	r3, #26
    return USBCmdData;
     f0a:	b2d8      	uxtb	r0, r3
        if (bDevStat & (CON_CH | SUS_CH | RST)) {
     f0c:	d005      	beq.n	f1a <USBHwISR+0x62>
            // convert device status into something HW independent
            bStat = ((bDevStat & CON) ? DEV_STATUS_CONNECT : 0) |
                    ((bDevStat & SUS) ? DEV_STATUS_SUSPEND : 0) |
                    ((bDevStat & RST) ? DEV_STATUS_RESET : 0);
            // call handler
            if (_pfnDevIntHandler != NULL) {
     f0e:	4b15      	ldr	r3, [pc, #84]	; (f64 <USBHwISR+0xac>)
     f10:	6c1b      	ldr	r3, [r3, #64]	; 0x40
     f12:	b113      	cbz	r3, f1a <USBHwISR+0x62>
DEBUG_LED_ON(8);        
                _pfnDevIntHandler(bStat);
     f14:	f000 0015 	and.w	r0, r0, #21
     f18:	4798      	blx	r3
            }
        }
    }
    
    // endpoint interrupt
    if (dwStatus & EP_SLOW) {
     f1a:	0763      	lsls	r3, r4, #29
     f1c:	d51e      	bpl.n	f5c <USBHwISR+0xa4>
        // clear EP_SLOW
        USBDevIntClr = EP_SLOW;
     f1e:	2204      	movs	r2, #4
        // check all endpoints
        for (i = 0; i < 32; i++) {
     f20:	2400      	movs	r4, #0
        USBDevIntClr = EP_SLOW;
     f22:	4b14      	ldr	r3, [pc, #80]	; (f74 <USBHwISR+0xbc>)
            dwIntBit = (1 << i);
            if (USBEpIntSt & dwIntBit) {
     f24:	4d15      	ldr	r5, [pc, #84]	; (f7c <USBHwISR+0xc4>)
                // clear int (and retrieve status)
                USBEpIntClr = dwIntBit;
     f26:	4e16      	ldr	r6, [pc, #88]	; (f80 <USBHwISR+0xc8>)
                Wait4DevInt(CDFULL);
                bEPStat = USBCmdData;
     f28:	4f11      	ldr	r7, [pc, #68]	; (f70 <USBHwISR+0xb8>)
        USBDevIntClr = EP_SLOW;
     f2a:	601a      	str	r2, [r3, #0]
            dwIntBit = (1 << i);
     f2c:	2301      	movs	r3, #1
            if (USBEpIntSt & dwIntBit) {
     f2e:	682a      	ldr	r2, [r5, #0]
            dwIntBit = (1 << i);
     f30:	40a3      	lsls	r3, r4
            if (USBEpIntSt & dwIntBit) {
     f32:	421a      	tst	r2, r3
     f34:	d00f      	beq.n	f56 <USBHwISR+0x9e>
                Wait4DevInt(CDFULL);
     f36:	2020      	movs	r0, #32
                USBEpIntClr = dwIntBit;
     f38:	6033      	str	r3, [r6, #0]
                Wait4DevInt(CDFULL);
     f3a:	f7ff fe65 	bl	c08 <Wait4DevInt>
                        ((bEPStat & EPSTAT_ST) ? EP_STATUS_STALLED : 0) |
                        ((bEPStat & EPSTAT_STP) ? EP_STATUS_SETUP : 0) |
                        ((bEPStat & EPSTAT_EPN) ? EP_STATUS_NACKED : 0) |
                        ((bEPStat & EPSTAT_PO) ? EP_STATUS_ERROR : 0);
                // call handler
                if (_apfnEPIntHandlers[i / 2] != NULL) {
     f3e:	4b09      	ldr	r3, [pc, #36]	; (f64 <USBHwISR+0xac>)
     f40:	1060      	asrs	r0, r4, #1
     f42:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
                bEPStat = USBCmdData;
     f46:	6839      	ldr	r1, [r7, #0]
                if (_apfnEPIntHandlers[i / 2] != NULL) {
     f48:	b12b      	cbz	r3, f56 <USBHwISR+0x9e>
DEBUG_LED_ON(10);       
                    _apfnEPIntHandlers[i / 2](IDX2EP(i), bStat);
     f4a:	ea40 10c4 	orr.w	r0, r0, r4, lsl #7
     f4e:	f001 011f 	and.w	r1, r1, #31
     f52:	b2c0      	uxtb	r0, r0
     f54:	4798      	blx	r3
        for (i = 0; i < 32; i++) {
     f56:	3401      	adds	r4, #1
     f58:	2c20      	cmp	r4, #32
     f5a:	d1e7      	bne.n	f2c <USBHwISR+0x74>
            }
        }
    }
    
DEBUG_LED_OFF(9);       
}
     f5c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     f5e:	bf00      	nop
     f60:	5000c200 	.word	0x5000c200
     f64:	10000608 	.word	0x10000608
     f68:	5000c210 	.word	0x5000c210
     f6c:	00f50200 	.word	0x00f50200
     f70:	5000c214 	.word	0x5000c214
     f74:	5000c208 	.word	0x5000c208
     f78:	00fe0200 	.word	0x00fe0200
     f7c:	5000c230 	.word	0x5000c230
     f80:	5000c238 	.word	0x5000c238

00000f84 <USBHwInit>:
    acts as a pull-up and so prevents detection of USB disconnect.
        
    @return TRUE if the hardware was successfully initialised
 */
BOOL USBHwInit(void)
{
     f84:	b508      	push	{r3, lr}
#ifdef LPC17xx
	// P2.9 is USB_CONNECT
    PINSEL4 = (PINSEL4 & ~(3 << 18)) | (1 << 18);
     f86:	4a26      	ldr	r2, [pc, #152]	; (1020 <USBHwInit+0x9c>)
     f88:	6813      	ldr	r3, [r2, #0]
     f8a:	f423 2340 	bic.w	r3, r3, #786432	; 0xc0000
     f8e:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
     f92:	6013      	str	r3, [r2, #0]

	// P1.18 is USB_UP_LED
    PINSEL3 = (PINSEL3 & ~(3 << 4)) | (1 << 4);
     f94:	f852 3c04 	ldr.w	r3, [r2, #-4]
     f98:	f023 0330 	bic.w	r3, r3, #48	; 0x30
     f9c:	f043 0310 	orr.w	r3, r3, #16
     fa0:	f842 3c04 	str.w	r3, [r2, #-4]

	// P1.30 is VBUS
    PINSEL3 = (PINSEL3 & ~(3 << 28)) | (2 << 28);
     fa4:	f852 3c04 	ldr.w	r3, [r2, #-4]
     fa8:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
     fac:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
     fb0:	f842 3c04 	str.w	r3, [r2, #-4]

	// P0.29 is USB_D+
    PINSEL1 = (PINSEL1 & ~(3 << 26)) | (1 << 26);
     fb4:	f852 3c0c 	ldr.w	r3, [r2, #-12]
     fb8:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
     fbc:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
     fc0:	f842 3c0c 	str.w	r3, [r2, #-12]

	// P0.30 is USB_D-
    PINSEL1 = (PINSEL1 & ~(3 << 28)) | (1 << 28);
     fc4:	f852 3c0c 	ldr.w	r3, [r2, #-12]
     fc8:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
     fcc:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
     fd0:	f842 3c0c 	str.w	r3, [r2, #-12]

	// enable PUSB
	PCONP |= PCONP_PCUSB;
     fd4:	f502 2250 	add.w	r2, r2, #851968	; 0xd0000
     fd8:	f8d2 30b4 	ldr.w	r3, [r2, #180]	; 0xb4
     fdc:	32b4      	adds	r2, #180	; 0xb4
     fde:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
     fe2:	6013      	str	r3, [r2, #0]

	/* enable the USB controller clocks */
    USBClkCtrl |= (USBClkCtrl_DEV_CLK_EN | USBClkCtrl_AHB_CLK_EN);
     fe4:	4a0f      	ldr	r2, [pc, #60]	; (1024 <USBHwInit+0xa0>)
     fe6:	6813      	ldr	r3, [r2, #0]
     fe8:	f043 0312 	orr.w	r3, r3, #18
     fec:	6013      	str	r3, [r2, #0]
    while (!(USBClkSt & USBClkSt_DEV_CLK_ON));
     fee:	4b0e      	ldr	r3, [pc, #56]	; (1028 <USBHwInit+0xa4>)
     ff0:	461a      	mov	r2, r3
     ff2:	6819      	ldr	r1, [r3, #0]
     ff4:	0789      	lsls	r1, r1, #30
     ff6:	d5fc      	bpl.n	ff2 <USBHwInit+0x6e>
    while (!(USBClkSt & USBClkSt_AHB_CLK_ON));
     ff8:	6813      	ldr	r3, [r2, #0]
     ffa:	06db      	lsls	r3, r3, #27
     ffc:	d5fc      	bpl.n	ff8 <USBHwInit+0x74>
#endif

#endif
    
    // disable/clear all interrupts for now
    USBDevIntEn = 0;
     ffe:	2000      	movs	r0, #0
    1000:	4b0a      	ldr	r3, [pc, #40]	; (102c <USBHwInit+0xa8>)
    USBDevIntClr = 0xFFFFFFFF;
    1002:	4a0b      	ldr	r2, [pc, #44]	; (1030 <USBHwInit+0xac>)
    USBDevIntEn = 0;
    1004:	6018      	str	r0, [r3, #0]
    USBDevIntClr = 0xFFFFFFFF;
    1006:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    100a:	6013      	str	r3, [r2, #0]
    USBDevIntPri = 0;
    100c:	6250      	str	r0, [r2, #36]	; 0x24

    USBEpIntEn = 0;
    100e:	62d0      	str	r0, [r2, #44]	; 0x2c
    USBEpIntClr = 0xFFFFFFFF;
    1010:	6313      	str	r3, [r2, #48]	; 0x30
    USBEpIntPri = 0;
    1012:	4b08      	ldr	r3, [pc, #32]	; (1034 <USBHwInit+0xb0>)
    1014:	6018      	str	r0, [r3, #0]

    // by default, only ACKs generate interrupts
    USBHwNakIntEnable(0);
    1016:	f7ff fe7a 	bl	d0e <USBHwNakIntEnable>
    DEBUG_LED_INIT(8);
    DEBUG_LED_INIT(9);
    DEBUG_LED_INIT(10);

    return TRUE;
}
    101a:	2001      	movs	r0, #1
    101c:	bd08      	pop	{r3, pc}
    101e:	bf00      	nop
    1020:	4002c010 	.word	0x4002c010
    1024:	5000cff4 	.word	0x5000cff4
    1028:	5000cff8 	.word	0x5000cff8
    102c:	5000c204 	.word	0x5000c204
    1030:	5000c208 	.word	0x5000c208
    1034:	5000c240 	.word	0x5000c240

00001038 <USBSetupDMADescriptor>:
		const U8 isIsocFlag, 
		const U16 maxPacketSize, 
		const U16 dmaLengthIsocNumFrames,
		void *dmaBufferStartAddress,
		U32 *isocPacketSizeMemoryAddress ) 
{
    1038:	b570      	push	{r4, r5, r6, lr}
	dmaDescriptor[1] = 0;
    103a:	2400      	movs	r4, #0
    103c:	6044      	str	r4, [r0, #4]
	dmaDescriptor[0] = (U32) nextDdPtr;
	dmaDescriptor[1] |= ((maxPacketSize & 0x3FF) << 5);//Set maxPacketSize
    103e:	f647 74e0 	movw	r4, #32736	; 0x7fe0
	dmaDescriptor[0] = (U32) nextDdPtr;
    1042:	6001      	str	r1, [r0, #0]
	dmaDescriptor[1] |= ((maxPacketSize & 0x3FF) << 5);//Set maxPacketSize
    1044:	6846      	ldr	r6, [r0, #4]
    1046:	ea04 1443 	and.w	r4, r4, r3, lsl #5
    104a:	4334      	orrs	r4, r6
    104c:	6044      	str	r4, [r0, #4]
	dmaDescriptor[1] |= (dmaLengthIsocNumFrames << 16);//aka number of ISOC packets if in ISOC mode
    104e:	6843      	ldr	r3, [r0, #4]
    1050:	f8bd 4010 	ldrh.w	r4, [sp, #16]
{
    1054:	9d06      	ldr	r5, [sp, #24]
	dmaDescriptor[1] |= (dmaLengthIsocNumFrames << 16);//aka number of ISOC packets if in ISOC mode
    1056:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
    105a:	6043      	str	r3, [r0, #4]
	if( isIsocFlag ) {
    105c:	b11a      	cbz	r2, 1066 <USBSetupDMADescriptor+0x2e>
		dmaDescriptor[1] |= (1<<4);//enable isoc type
    105e:	6843      	ldr	r3, [r0, #4]
    1060:	f043 0310 	orr.w	r3, r3, #16
    1064:	6043      	str	r3, [r0, #4]
	}
	if( nextDdPtr != NULL ) {
    1066:	b119      	cbz	r1, 1070 <USBSetupDMADescriptor+0x38>
		dmaDescriptor[1] |= (1<<2); //mark next DD as valid
    1068:	6843      	ldr	r3, [r0, #4]
    106a:	f043 0304 	orr.w	r3, r3, #4
    106e:	6043      	str	r3, [r0, #4]
	}
	dmaDescriptor[2] = (U32) dmaBufferStartAddress;
    1070:	9b05      	ldr	r3, [sp, #20]
    1072:	6083      	str	r3, [r0, #8]
	
	if( isIsocFlag && isocPacketSizeMemoryAddress != NULL ) {
    1074:	b10a      	cbz	r2, 107a <USBSetupDMADescriptor+0x42>
    1076:	b105      	cbz	r5, 107a <USBSetupDMADescriptor+0x42>
		dmaDescriptor[4] = (U32) isocPacketSizeMemoryAddress;
    1078:	6105      	str	r5, [r0, #16]
	}
	dmaDescriptor[3] = 0; //mark DD as valid and reset all status bits
    107a:	2300      	movs	r3, #0
    107c:	60c3      	str	r3, [r0, #12]
}
    107e:	bd70      	pop	{r4, r5, r6, pc}

00001080 <USBDisableDMAForEndpoint>:
    @param [in] bEndpointNumber the endpoint number to be disabled.

    @return   void
 */
void USBDisableDMAForEndpoint(const U8 bEndpointNumber) {
	int idx = EP2IDX(bEndpointNumber);
    1080:	0043      	lsls	r3, r0, #1
    1082:	f003 031e 	and.w	r3, r3, #30
    1086:	ea43 10d0 	orr.w	r0, r3, r0, lsr #7
	USBEpDMADis = (1<<idx);
    108a:	2301      	movs	r3, #1
    108c:	fa03 f000 	lsl.w	r0, r3, r0
    1090:	4b01      	ldr	r3, [pc, #4]	; (1098 <USBDisableDMAForEndpoint+0x18>)
    1092:	6018      	str	r0, [r3, #0]
}
    1094:	4770      	bx	lr
    1096:	bf00      	nop
    1098:	5000c28c 	.word	0x5000c28c

0000109c <USBEnableDMAForEndpoint>:
    @param [in] bEndpontNumber The endpoint to to enable DMA for.

    @return 
 */
void USBEnableDMAForEndpoint(const U8 bEndpointNumber) {
	int idx = EP2IDX(bEndpointNumber);
    109c:	0043      	lsls	r3, r0, #1
    109e:	f003 031e 	and.w	r3, r3, #30
    10a2:	ea43 10d0 	orr.w	r0, r3, r0, lsr #7
	USBEpDMAEn = (1<<idx);
    10a6:	2301      	movs	r3, #1
    10a8:	fa03 f000 	lsl.w	r0, r3, r0
    10ac:	4b01      	ldr	r3, [pc, #4]	; (10b4 <USBEnableDMAForEndpoint+0x18>)
    10ae:	6018      	str	r0, [r3, #0]
}
    10b0:	4770      	bx	lr
    10b2:	bf00      	nop
    10b4:	5000c288 	.word	0x5000c288

000010b8 <USBInitializeISOCFrameArray>:
    @param [in] startFrameNumber        Number to start at for numbering each frame.
    @param [in] defaultFrameLength      The frame length to set all the frame descriptors to.

    @return  void
 */
void USBInitializeISOCFrameArray(U32 isocFrameArr[], const U32 numElements, const U16 startFrameNumber, const U16 defaultFrameLength) {
    10b8:	b570      	push	{r4, r5, r6, lr}
	U16 i;
	U16 frameNumber = startFrameNumber;
	
	for(i = 0; i < numElements; i++ ) {
    10ba:	2500      	movs	r5, #0
		isocFrameArr[i] = (frameNumber<<16) | (1<<15) | (defaultFrameLength & 0x3FF);
    10bc:	f3c3 0309 	ubfx	r3, r3, #0, #10
    10c0:	b2ae      	uxth	r6, r5
    10c2:	1954      	adds	r4, r2, r5
	for(i = 0; i < numElements; i++ ) {
    10c4:	428e      	cmp	r6, r1
    10c6:	b2a4      	uxth	r4, r4
    10c8:	f105 0501 	add.w	r5, r5, #1
    10cc:	d300      	bcc.n	10d0 <USBInitializeISOCFrameArray+0x18>
		frameNumber++;
	}
}
    10ce:	bd70      	pop	{r4, r5, r6, pc}
		isocFrameArr[i] = (frameNumber<<16) | (1<<15) | (defaultFrameLength & 0x3FF);
    10d0:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
    10d4:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
    10d8:	f840 4026 	str.w	r4, [r0, r6, lsl #2]
	for(i = 0; i < numElements; i++ ) {
    10dc:	e7f0      	b.n	10c0 <USBInitializeISOCFrameArray+0x8>

000010de <USBSetHeadDDForDMA>:
    @param [in|out] dmaDescriptorPtr   The address of the DMA descriptor that is to be the new head, it should point to some place in DMA RAM.

    @return 
 */
void USBSetHeadDDForDMA(const U8 bEp, volatile U32* udcaHeadArray[32], volatile U32 *dmaDescriptorPtr) {
	udcaHeadArray[EP2IDX(bEp)] = dmaDescriptorPtr;
    10de:	0043      	lsls	r3, r0, #1
    10e0:	f003 031e 	and.w	r3, r3, #30
    10e4:	ea43 10d0 	orr.w	r0, r3, r0, lsr #7
    10e8:	f841 2020 	str.w	r2, [r1, r0, lsl #2]
}
    10ec:	4770      	bx	lr
    10ee:	0000      	movs	r0, r0

000010f0 <USBInitializeUSBDMA>:
 */
void USBInitializeUSBDMA(volatile U32* udcaHeadArray[32]) {
	//set following 32 pointers to be null
	int i;
	for(i = 0; i < 32; i++ ) {
		udcaHeadArray[i] = NULL;
    10f0:	2100      	movs	r1, #0
    10f2:	1f03      	subs	r3, r0, #4
    10f4:	f100 027c 	add.w	r2, r0, #124	; 0x7c
    10f8:	f843 1f04 	str.w	r1, [r3, #4]!
	for(i = 0; i < 32; i++ ) {
    10fc:	4293      	cmp	r3, r2
    10fe:	d1fb      	bne.n	10f8 <USBInitializeUSBDMA+0x8>
	}
	USBUDCAH = (U32) udcaHeadArray;
    1100:	4b01      	ldr	r3, [pc, #4]	; (1108 <USBInitializeUSBDMA+0x18>)
    1102:	6018      	str	r0, [r3, #0]
}
    1104:	4770      	bx	lr
    1106:	bf00      	nop
    1108:	5000c280 	.word	0x5000c280

0000110c <USBFilterOsVendorMessage>:
	@param [out]	*ppbData	Descriptor data
	
	@return TRUE if the request was handled by this filter, FALSE otherwise
 */
BOOL USBFilterOsVendorMessage(TSetupPacket *pSetup, BOOL *pfSuccess, int *piLen, U8 **ppbData)
{
    110c:	b570      	push	{r4, r5, r6, lr}
    110e:	4604      	mov	r4, r0
	if(bMsVendorIndex == 0)	{
    1110:	4815      	ldr	r0, [pc, #84]	; (1168 <USBFilterOsVendorMessage+0x5c>)
    1112:	7805      	ldrb	r5, [r0, #0]
    1114:	2000      	movs	r0, #0
    1116:	b32d      	cbz	r5, 1164 <USBFilterOsVendorMessage+0x58>
		// Feature is disabled.
		return FALSE;
	}
	
	if(pSetup->bRequest == bMsVendorIndex) {
    1118:	7866      	ldrb	r6, [r4, #1]
    111a:	42ae      	cmp	r6, r5
    111c:	d11d      	bne.n	115a <USBFilterOsVendorMessage+0x4e>
		// Fail unless we make it to the end.
		*pfSuccess = FALSE;
	
		int iRequestLength = pSetup->wLength;
    111e:	88e6      	ldrh	r6, [r4, #6]
		*pfSuccess = FALSE;
    1120:	6008      	str	r0, [r1, #0]
		U8 bInterfaceNumber = GET_OS_DESC_INTERFACE(pSetup->wValue);
    1122:	8860      	ldrh	r0, [r4, #2]
		U8 bPageNumber = GET_OS_DESC_PAGE(pSetup->wValue);
	
		switch (pSetup->wIndex) {
    1124:	88a4      	ldrh	r4, [r4, #4]
    1126:	2c04      	cmp	r4, #4
    1128:	d003      	beq.n	1132 <USBFilterOsVendorMessage+0x26>
    112a:	2c05      	cmp	r4, #5
    112c:	d016      	beq.n	115c <USBFilterOsVendorMessage+0x50>
		
		// Decide what portion of the descriptor to return.
		int iPageOffset = bPageNumber*0x10000; // This will probably always be zero...
		if (*piLen < iPageOffset) {
			// Not enough data for the requested offset.
			return TRUE;
    112e:	2001      	movs	r0, #1
    1130:	e013      	b.n	115a <USBFilterOsVendorMessage+0x4e>
			*ppbData = (U8*)abExtendedOsFeatureDescriptor;
    1132:	4c0e      	ldr	r4, [pc, #56]	; (116c <USBFilterOsVendorMessage+0x60>)
    1134:	601c      	str	r4, [r3, #0]
			*piLen = sizeof(abExtendedOsFeatureDescriptor);
    1136:	2428      	movs	r4, #40	; 0x28
			*piLen = sizeof(abExtendedPropertiesFeatureDescriptor);			
    1138:	6014      	str	r4, [r2, #0]
		int iPageOffset = bPageNumber*0x10000; // This will probably always be zero...
    113a:	0a04      	lsrs	r4, r0, #8
		if (*piLen < iPageOffset) {
    113c:	6810      	ldr	r0, [r2, #0]
		int iPageOffset = bPageNumber*0x10000; // This will probably always be zero...
    113e:	0425      	lsls	r5, r4, #16
		if (*piLen < iPageOffset) {
    1140:	ebb0 4f04 	cmp.w	r0, r4, lsl #16
    1144:	dbf3      	blt.n	112e <USBFilterOsVendorMessage+0x22>
		}
		*ppbData += iPageOffset;
    1146:	681c      	ldr	r4, [r3, #0]
		*piLen -= iPageOffset;
    1148:	1b40      	subs	r0, r0, r5
		*ppbData += iPageOffset;
    114a:	442c      	add	r4, r5
    114c:	601c      	str	r4, [r3, #0]
		
		if (*piLen > iRequestLength) {
    114e:	42b0      	cmp	r0, r6
    1150:	bfd4      	ite	le
    1152:	6010      	strle	r0, [r2, #0]
    1154:	6016      	strgt	r6, [r2, #0]
			// Clip data longer than the requested length
			*piLen = iRequestLength;
		}
	
		*pfSuccess = TRUE;
    1156:	2001      	movs	r0, #1
    1158:	6008      	str	r0, [r1, #0]
		return TRUE;
	}
	
	// These are not the requests you are looking for
	return FALSE;
}
    115a:	bd70      	pop	{r4, r5, r6, pc}
			*ppbData = abExtendedPropertiesFeatureDescriptor;
    115c:	4c04      	ldr	r4, [pc, #16]	; (1170 <USBFilterOsVendorMessage+0x64>)
    115e:	601c      	str	r4, [r3, #0]
			*piLen = sizeof(abExtendedPropertiesFeatureDescriptor);			
    1160:	2492      	movs	r4, #146	; 0x92
    1162:	e7e9      	b.n	1138 <USBFilterOsVendorMessage+0x2c>
		return FALSE;
    1164:	4628      	mov	r0, r5
    1166:	e7f8      	b.n	115a <USBFilterOsVendorMessage+0x4e>
    1168:	10000650 	.word	0x10000650
    116c:	0000195c 	.word	0x0000195c
    1170:	10000458 	.word	0x10000458

00001174 <USBRegisterWinusbInterface>:
												Windows will use this as a 
												Device Interface GUID
 */
void USBRegisterWinusbInterface(U8 bVendorRequestIndex, const char* pcInterfaceGuid)
{
	bMsVendorIndex = bVendorRequestIndex;
    1174:	4b08      	ldr	r3, [pc, #32]	; (1198 <USBRegisterWinusbInterface+0x24>)
    1176:	7018      	strb	r0, [r3, #0]
	
	if(!pcInterfaceGuid) {
    1178:	b161      	cbz	r1, 1194 <USBRegisterWinusbInterface+0x20>
		return; // Trust that caller is actually specifying this with nonzero RequestIndex.
	}
	
	// Copy GUID into Extended Properties feature descriptor.
	// Trust that the caller did the right thing, but ensure double null termination if string terminates early.
	U8* pbWriteCursor = abExtendedPropertiesFeatureDescriptor + EXTENDEDPROPERTIESFEATURE_GUIDSTRINGOFFSET;
    117a:	4b08      	ldr	r3, [pc, #32]	; (119c <USBRegisterWinusbInterface+0x28>)
    117c:	1e4a      	subs	r2, r1, #1
    117e:	3125      	adds	r1, #37	; 0x25
	const int ciMaxLength = 38;
	
	for(int i = 0; i < ciMaxLength; i++) {
		if(!pcInterfaceGuid[i]) break;
    1180:	f812 0f01 	ldrb.w	r0, [r2, #1]!
    1184:	b118      	cbz	r0, 118e <USBRegisterWinusbInterface+0x1a>
	for(int i = 0; i < ciMaxLength; i++) {
    1186:	428a      	cmp	r2, r1
		pbWriteCursor[0] = (U8) pcInterfaceGuid[i];
    1188:	f803 0b02 	strb.w	r0, [r3], #2
	for(int i = 0; i < ciMaxLength; i++) {
    118c:	d1f8      	bne.n	1180 <USBRegisterWinusbInterface+0xc>
		pbWriteCursor += 2;
	}
	// Double terminate
	pbWriteCursor[0] = 0;
    118e:	2200      	movs	r2, #0
    1190:	701a      	strb	r2, [r3, #0]
	pbWriteCursor[2] = 0;
    1192:	709a      	strb	r2, [r3, #2]
	
}
    1194:	4770      	bx	lr
    1196:	bf00      	nop
    1198:	10000650 	.word	0x10000650
    119c:	1000049a 	.word	0x1000049a

000011a0 <USBGetOsStringDescriptor>:
	@return TRUE if the descriptor was found, FALSE otherwise
 */
BOOL USBGetOsStringDescriptor(int *piLen, U8 **ppbData)
{
	// The last character in the OS String descriptor specifies the vendor request index to use.
	abOsStringDescriptor[sizeof(abOsStringDescriptor)-2] = bMsVendorIndex;
    11a0:	4a04      	ldr	r2, [pc, #16]	; (11b4 <USBGetOsStringDescriptor+0x14>)
    11a2:	4b05      	ldr	r3, [pc, #20]	; (11b8 <USBGetOsStringDescriptor+0x18>)
    11a4:	7812      	ldrb	r2, [r2, #0]
	
	*ppbData = abOsStringDescriptor;
    11a6:	3392      	adds	r3, #146	; 0x92
	abOsStringDescriptor[sizeof(abOsStringDescriptor)-2] = bMsVendorIndex;
    11a8:	741a      	strb	r2, [r3, #16]
	*ppbData = abOsStringDescriptor;
    11aa:	600b      	str	r3, [r1, #0]
	*piLen = sizeof(abOsStringDescriptor);
    11ac:	2312      	movs	r3, #18
    11ae:	6003      	str	r3, [r0, #0]
	return TRUE;
}
    11b0:	2001      	movs	r0, #1
    11b2:	4770      	bx	lr
    11b4:	10000650 	.word	0x10000650
    11b8:	10000458 	.word	0x10000458

000011bc <USBRegisterDescriptors>:

	@param [in]	pabDescriptors	The descriptor byte array
 */
void USBRegisterDescriptors(U8 *pabDescriptors)
{
	pabDescrip = pabDescriptors;
    11bc:	4b01      	ldr	r3, [pc, #4]	; (11c4 <USBRegisterDescriptors+0x8>)
    11be:	6058      	str	r0, [r3, #4]
}
    11c0:	4770      	bx	lr
    11c2:	bf00      	nop
    11c4:	10000650 	.word	0x10000650

000011c8 <USBGetDescriptor>:
	@param [out]	*ppbData	Descriptor data
	
	@return TRUE if the descriptor was found, FALSE otherwise
 */
BOOL USBGetDescriptor(U16 wTypeIndex, U16 wLangID, int *piLen, U8 **ppbData)
{
    11c8:	b5f0      	push	{r4, r5, r6, r7, lr}
	U8	*pab;
	int iCurIndex;
	
	ASSERT(pabDescrip != NULL);

	bType = GET_DESC_TYPE(wTypeIndex);
    11ca:	0a04      	lsrs	r4, r0, #8
	bIndex = GET_DESC_INDEX(wTypeIndex);
	
    if (bType == DESC_STRING &&
    11cc:	2c03      	cmp	r4, #3
	bIndex = GET_DESC_INDEX(wTypeIndex);
    11ce:	b2c1      	uxtb	r1, r0
	bType = GET_DESC_TYPE(wTypeIndex);
    11d0:	4626      	mov	r6, r4
    if (bType == DESC_STRING &&
    11d2:	4810      	ldr	r0, [pc, #64]	; (1214 <USBGetDescriptor+0x4c>)
    11d4:	d10a      	bne.n	11ec <USBGetDescriptor+0x24>
    11d6:	29ee      	cmp	r1, #238	; 0xee
    11d8:	d108      	bne.n	11ec <USBGetDescriptor+0x24>
	abOsStringDescriptor[sizeof(abOsStringDescriptor)-2] = bMsVendorIndex;
    11da:	490f      	ldr	r1, [pc, #60]	; (1218 <USBGetDescriptor+0x50>)
    11dc:	7800      	ldrb	r0, [r0, #0]
	*ppbData = abOsStringDescriptor;
    11de:	3192      	adds	r1, #146	; 0x92
	abOsStringDescriptor[sizeof(abOsStringDescriptor)-2] = bMsVendorIndex;
    11e0:	7408      	strb	r0, [r1, #16]
	*ppbData = abOsStringDescriptor;
    11e2:	6019      	str	r1, [r3, #0]
	*piLen = sizeof(abOsStringDescriptor);
    11e4:	2312      	movs	r3, #18
				}
				else {
					// normally length is at offset 0
					*piLen = pab[DESC_bLength];
				}
				return TRUE;
    11e6:	2001      	movs	r0, #1
					*piLen = pab[DESC_bLength];
    11e8:	6013      	str	r3, [r2, #0]
		pab += pab[DESC_bLength];
	}
	// nothing found
	DBG("Desc %x not found!\n", wTypeIndex);
	return FALSE;
}
    11ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
	iCurIndex = 0;
    11ec:	2500      	movs	r5, #0
	pab = (U8 *)pabDescrip;
    11ee:	6844      	ldr	r4, [r0, #4]
	while (pab[DESC_bLength] != 0) {
    11f0:	7820      	ldrb	r0, [r4, #0]
    11f2:	2800      	cmp	r0, #0
    11f4:	d0f9      	beq.n	11ea <USBGetDescriptor+0x22>
		if (pab[DESC_bDescriptorType] == bType) {
    11f6:	7867      	ldrb	r7, [r4, #1]
    11f8:	42b7      	cmp	r7, r6
    11fa:	d108      	bne.n	120e <USBGetDescriptor+0x46>
			if (iCurIndex == bIndex) {
    11fc:	42a9      	cmp	r1, r5
    11fe:	d105      	bne.n	120c <USBGetDescriptor+0x44>
				*ppbData = pab;
    1200:	601c      	str	r4, [r3, #0]
				if (bType == DESC_CONFIGURATION) {
    1202:	2e02      	cmp	r6, #2
					*piLen =	(pab[CONF_DESC_wTotalLength]) |
    1204:	bf0c      	ite	eq
    1206:	8863      	ldrheq	r3, [r4, #2]
					*piLen = pab[DESC_bLength];
    1208:	7823      	ldrbne	r3, [r4, #0]
    120a:	e7ec      	b.n	11e6 <USBGetDescriptor+0x1e>
			iCurIndex++;
    120c:	3501      	adds	r5, #1
		pab += pab[DESC_bLength];
    120e:	4404      	add	r4, r0
    1210:	e7ee      	b.n	11f0 <USBGetDescriptor+0x28>
    1212:	bf00      	nop
    1214:	10000650 	.word	0x10000650
    1218:	10000458 	.word	0x10000458

0000121c <USBHandleStandardRequest>:
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
BOOL USBHandleStandardRequest(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
    121c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	// try the custom request handler first
	if ((pfnHandleCustomReq != NULL) && pfnHandleCustomReq(pSetup, piLen, ppbData)) {
    1220:	4c55      	ldr	r4, [pc, #340]	; (1378 <USBHandleStandardRequest+0x15c>)
{
    1222:	4605      	mov	r5, r0
	if ((pfnHandleCustomReq != NULL) && pfnHandleCustomReq(pSetup, piLen, ppbData)) {
    1224:	68a3      	ldr	r3, [r4, #8]
{
    1226:	460f      	mov	r7, r1
    1228:	4690      	mov	r8, r2
    122a:	46a1      	mov	r9, r4
	if ((pfnHandleCustomReq != NULL) && pfnHandleCustomReq(pSetup, piLen, ppbData)) {
    122c:	b94b      	cbnz	r3, 1242 <USBHandleStandardRequest+0x26>
		return TRUE;
	}
	
	switch (REQTYPE_GET_RECIP(pSetup->bmRequestType)) {
    122e:	7828      	ldrb	r0, [r5, #0]
    1230:	f000 061f 	and.w	r6, r0, #31
    1234:	2e01      	cmp	r6, #1
    1236:	d069      	beq.n	130c <USBHandleStandardRequest+0xf0>
    1238:	2e02      	cmp	r6, #2
    123a:	d07b      	beq.n	1334 <USBHandleStandardRequest+0x118>
    123c:	b136      	cbz	r6, 124c <USBHandleStandardRequest+0x30>
			return FALSE;
    123e:	2000      	movs	r0, #0
    1240:	e037      	b.n	12b2 <USBHandleStandardRequest+0x96>
	if ((pfnHandleCustomReq != NULL) && pfnHandleCustomReq(pSetup, piLen, ppbData)) {
    1242:	4798      	blx	r3
    1244:	2800      	cmp	r0, #0
    1246:	d0f2      	beq.n	122e <USBHandleStandardRequest+0x12>
		return TRUE;
    1248:	2001      	movs	r0, #1
    124a:	e032      	b.n	12b2 <USBHandleStandardRequest+0x96>
	U8	*pbData = *ppbData;
    124c:	786a      	ldrb	r2, [r5, #1]
    124e:	f8d8 3000 	ldr.w	r3, [r8]
	switch (pSetup->bRequest) {
    1252:	2a09      	cmp	r2, #9
    1254:	d8f3      	bhi.n	123e <USBHandleStandardRequest+0x22>
    1256:	a101      	add	r1, pc, #4	; (adr r1, 125c <USBHandleStandardRequest+0x40>)
    1258:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
    125c:	00001285 	.word	0x00001285
    1260:	0000123f 	.word	0x0000123f
    1264:	0000123f 	.word	0x0000123f
    1268:	0000123f 	.word	0x0000123f
    126c:	0000123f 	.word	0x0000123f
    1270:	00001291 	.word	0x00001291
    1274:	00001299 	.word	0x00001299
    1278:	0000123f 	.word	0x0000123f
    127c:	000012a9 	.word	0x000012a9
    1280:	000012b7 	.word	0x000012b7
		pbData[0] = 0;
    1284:	2200      	movs	r2, #0
    1286:	701a      	strb	r2, [r3, #0]
		pbData[1] = 0;
    1288:	705a      	strb	r2, [r3, #1]
		*piLen = 2;
    128a:	2302      	movs	r3, #2
		*piLen = 0;
    128c:	603b      	str	r3, [r7, #0]
		break;
    128e:	e7db      	b.n	1248 <USBHandleStandardRequest+0x2c>
		USBHwSetAddress(pSetup->wValue);
    1290:	78a8      	ldrb	r0, [r5, #2]
    1292:	f7ff fd31 	bl	cf8 <USBHwSetAddress>
		break;
    1296:	e7d7      	b.n	1248 <USBHandleStandardRequest+0x2c>
		return USBGetDescriptor(pSetup->wValue, pSetup->wIndex, piLen, ppbData);
    1298:	4643      	mov	r3, r8
    129a:	463a      	mov	r2, r7
    129c:	88a9      	ldrh	r1, [r5, #4]
    129e:	8868      	ldrh	r0, [r5, #2]
	case REQTYPE_RECIP_DEVICE:		return HandleStdDeviceReq(pSetup, piLen, ppbData);
	case REQTYPE_RECIP_INTERFACE:	return HandleStdInterfaceReq(pSetup, piLen, ppbData);
	case REQTYPE_RECIP_ENDPOINT: 	return HandleStdEndPointReq(pSetup, piLen, ppbData);
	default: 						return FALSE;
	}
}
    12a0:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		return USBGetDescriptor(pSetup->wValue, pSetup->wIndex, piLen, ppbData);
    12a4:	f7ff bf90 	b.w	11c8 <USBGetDescriptor>
		*piLen = 1;
    12a8:	2001      	movs	r0, #1
		pbData[0] = bConfiguration;
    12aa:	f899 200c 	ldrb.w	r2, [r9, #12]
    12ae:	701a      	strb	r2, [r3, #0]
		*piLen = 1;
    12b0:	6038      	str	r0, [r7, #0]
}
    12b2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if (!USBSetConfiguration(pSetup->wValue & 0xFF, 0)) {
    12b6:	78ae      	ldrb	r6, [r5, #2]
	if (bConfigIndex == 0) {
    12b8:	b936      	cbnz	r6, 12c8 <USBHandleStandardRequest+0xac>
		USBHwConfigDevice(FALSE);
    12ba:	4630      	mov	r0, r6
		USBHwConfigDevice(TRUE);
    12bc:	f7ff fdf6 	bl	eac <USBHwConfigDevice>
		bConfiguration = pSetup->wValue & 0xFF;	
    12c0:	886b      	ldrh	r3, [r5, #2]
    12c2:	f889 300c 	strb.w	r3, [r9, #12]
		break;
    12c6:	e7bf      	b.n	1248 <USBHandleStandardRequest+0x2c>
		bCurAltSetting = 0xFF;
    12c8:	27ff      	movs	r7, #255	; 0xff
		bCurConfig = 0xFF;
    12ca:	46b8      	mov	r8, r7
		pab = (U8 *)pabDescrip;
    12cc:	f8d9 4004 	ldr.w	r4, [r9, #4]
		while (pab[DESC_bLength] != 0) {
    12d0:	7823      	ldrb	r3, [r4, #0]
    12d2:	b90b      	cbnz	r3, 12d8 <USBHandleStandardRequest+0xbc>
		USBHwConfigDevice(TRUE);
    12d4:	2001      	movs	r0, #1
    12d6:	e7f1      	b.n	12bc <USBHandleStandardRequest+0xa0>
			switch (pab[DESC_bDescriptorType]) {
    12d8:	7863      	ldrb	r3, [r4, #1]
    12da:	2b04      	cmp	r3, #4
    12dc:	d008      	beq.n	12f0 <USBHandleStandardRequest+0xd4>
    12de:	2b05      	cmp	r3, #5
    12e0:	d008      	beq.n	12f4 <USBHandleStandardRequest+0xd8>
    12e2:	2b02      	cmp	r3, #2
    12e4:	d101      	bne.n	12ea <USBHandleStandardRequest+0xce>
				bCurConfig = pab[CONF_DESC_bConfigurationValue];
    12e6:	f894 8005 	ldrb.w	r8, [r4, #5]
			pab += pab[DESC_bLength];
    12ea:	7823      	ldrb	r3, [r4, #0]
    12ec:	441c      	add	r4, r3
    12ee:	e7ef      	b.n	12d0 <USBHandleStandardRequest+0xb4>
				bCurAltSetting = pab[INTF_DESC_bAlternateSetting];
    12f0:	78e7      	ldrb	r7, [r4, #3]
				break;
    12f2:	e7fa      	b.n	12ea <USBHandleStandardRequest+0xce>
				if ((bCurConfig == bConfigIndex) &&
    12f4:	4546      	cmp	r6, r8
    12f6:	d1f8      	bne.n	12ea <USBHandleStandardRequest+0xce>
    12f8:	2f00      	cmp	r7, #0
    12fa:	d1f6      	bne.n	12ea <USBHandleStandardRequest+0xce>
									(pab[ENDP_DESC_wMaxPacketSize + 1] << 8);
    12fc:	7961      	ldrb	r1, [r4, #5]
					wMaxPktSize = 	(pab[ENDP_DESC_wMaxPacketSize]) |
    12fe:	7923      	ldrb	r3, [r4, #4]
					USBHwEPConfig(bEP, wMaxPktSize);
    1300:	78a0      	ldrb	r0, [r4, #2]
    1302:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
    1306:	f7ff fca7 	bl	c58 <USBHwEPConfig>
    130a:	e7ee      	b.n	12ea <USBHandleStandardRequest+0xce>
	switch (pSetup->bRequest) {
    130c:	786b      	ldrb	r3, [r5, #1]
	case REQTYPE_RECIP_INTERFACE:	return HandleStdInterfaceReq(pSetup, piLen, ppbData);
    130e:	f8d8 2000 	ldr.w	r2, [r8]
	switch (pSetup->bRequest) {
    1312:	2b0a      	cmp	r3, #10
    1314:	d006      	beq.n	1324 <USBHandleStandardRequest+0x108>
    1316:	2b0b      	cmp	r3, #11
    1318:	d008      	beq.n	132c <USBHandleStandardRequest+0x110>
    131a:	2b00      	cmp	r3, #0
    131c:	d18f      	bne.n	123e <USBHandleStandardRequest+0x22>
		pbData[0] = 0;
    131e:	7013      	strb	r3, [r2, #0]
		pbData[1] = 0;
    1320:	7053      	strb	r3, [r2, #1]
    1322:	e7b2      	b.n	128a <USBHandleStandardRequest+0x6e>
		pbData[0] = 0;
    1324:	2300      	movs	r3, #0
    1326:	7013      	strb	r3, [r2, #0]
		*piLen = 2;
    1328:	603e      	str	r6, [r7, #0]
		break;
    132a:	e78d      	b.n	1248 <USBHandleStandardRequest+0x2c>
		if (pSetup->wValue != 0) {
    132c:	886b      	ldrh	r3, [r5, #2]
    132e:	2b00      	cmp	r3, #0
    1330:	d0ac      	beq.n	128c <USBHandleStandardRequest+0x70>
    1332:	e784      	b.n	123e <USBHandleStandardRequest+0x22>
	switch (pSetup->bRequest) {
    1334:	786c      	ldrb	r4, [r5, #1]
    1336:	2c01      	cmp	r4, #1
    1338:	d010      	beq.n	135c <USBHandleStandardRequest+0x140>
    133a:	2c03      	cmp	r4, #3
    133c:	d016      	beq.n	136c <USBHandleStandardRequest+0x150>
    133e:	2c00      	cmp	r4, #0
    1340:	f47f af7d 	bne.w	123e <USBHandleStandardRequest+0x22>
		pbData[0] = (USBHwEPGetStatus(pSetup->wIndex) & EP_STATUS_STALLED) ? 1 : 0;
    1344:	7928      	ldrb	r0, [r5, #4]
	case REQTYPE_RECIP_ENDPOINT: 	return HandleStdEndPointReq(pSetup, piLen, ppbData);
    1346:	f8d8 8000 	ldr.w	r8, [r8]
		pbData[0] = (USBHwEPGetStatus(pSetup->wIndex) & EP_STATUS_STALLED) ? 1 : 0;
    134a:	f7ff fce5 	bl	d18 <USBHwEPGetStatus>
    134e:	f3c0 0040 	ubfx	r0, r0, #1, #1
    1352:	f888 0000 	strb.w	r0, [r8]
		pbData[1] = 0;
    1356:	f888 4001 	strb.w	r4, [r8, #1]
    135a:	e7e5      	b.n	1328 <USBHandleStandardRequest+0x10c>
		if (pSetup->wValue == FEA_ENDPOINT_HALT) {
    135c:	8869      	ldrh	r1, [r5, #2]
    135e:	2900      	cmp	r1, #0
    1360:	f47f af6d 	bne.w	123e <USBHandleStandardRequest+0x22>
			USBHwEPStall(pSetup->wIndex, TRUE);
    1364:	7928      	ldrb	r0, [r5, #4]
    1366:	f7ff fcf1 	bl	d4c <USBHwEPStall>
			break;
    136a:	e76d      	b.n	1248 <USBHandleStandardRequest+0x2c>
		if (pSetup->wValue == FEA_ENDPOINT_HALT) {
    136c:	886b      	ldrh	r3, [r5, #2]
    136e:	2b00      	cmp	r3, #0
    1370:	f47f af65 	bne.w	123e <USBHandleStandardRequest+0x22>
			USBHwEPStall(pSetup->wIndex, TRUE);
    1374:	2101      	movs	r1, #1
    1376:	e7f5      	b.n	1364 <USBHandleStandardRequest+0x148>
    1378:	10000650 	.word	0x10000650

0000137c <USBRegisterCustomReqHandler>:
		
	@param [in]	pfnHandler	Callback function pointer
 */
void USBRegisterCustomReqHandler(TFnHandleRequest *pfnHandler)
{
	pfnHandleCustomReq = pfnHandler;
    137c:	4b01      	ldr	r3, [pc, #4]	; (1384 <USBRegisterCustomReqHandler+0x8>)
    137e:	6098      	str	r0, [r3, #8]
}
    1380:	4770      	bx	lr
    1382:	bf00      	nop
    1384:	10000650 	.word	0x10000650

00001388 <_Z19dfu_request_handlerP12TSetupPacketPiPPh>:
static DFU dfu(flash);
static uint8_t dfu_buffer[DFU::transfer_size];
static uint32_t count = 0;
static bool use_timeout = false;

BOOL dfu_request_handler(TSetupPacket *pSetup, int *piLen, u8 **ppbData) {
    1388:	b508      	push	{r3, lr}
    138a:	4613      	mov	r3, r2
    return dfu.request_handler(pSetup, reinterpret_cast<uint32_t*>(piLen), ppbData) ? TRUE : FALSE;
    138c:	460a      	mov	r2, r1
    138e:	4601      	mov	r1, r0
    1390:	4801      	ldr	r0, [pc, #4]	; (1398 <_Z19dfu_request_handlerP12TSetupPacketPiPPh+0x10>)
    1392:	f000 f9dc 	bl	174e <_ZN3DFU15request_handlerEP12TSetupPacketPmPPh>
}
    1396:	bd08      	pop	{r3, pc}
    1398:	10000660 	.word	0x10000660

0000139c <_Z19bootloader_usb_initv>:

int bootloader_usb_init()
{
    139c:	b508      	push	{r3, lr}
	// initialise stack
	USBInit();
    139e:	f7ff fc0d 	bl	bbc <USBInit>

	// register device descriptors
	USBRegisterDescriptors(dfu_descriptors);
    13a2:	4806      	ldr	r0, [pc, #24]	; (13bc <_Z19bootloader_usb_initv+0x20>)
    13a4:	f7ff ff0a 	bl	11bc <USBRegisterDescriptors>

	// override standard request handler
	USBRegisterRequestHandler(REQTYPE_TYPE_CLASS, dfu_request_handler, dfu_buffer);
    13a8:	4a05      	ldr	r2, [pc, #20]	; (13c0 <_Z19bootloader_usb_initv+0x24>)
    13aa:	4906      	ldr	r1, [pc, #24]	; (13c4 <_Z19bootloader_usb_initv+0x28>)
    13ac:	2001      	movs	r0, #1
    13ae:	f7ff fbfb 	bl	ba8 <USBRegisterRequestHandler>

	// enable USB interrupts
	//ISER0 |= ISER0_ISE_USB;

	// connect to bus
	USBHwConnect(TRUE);
    13b2:	2001      	movs	r0, #1
    13b4:	f7ff fca5 	bl	d02 <USBHwConnect>

	return 0;
}
    13b8:	2000      	movs	r0, #0
    13ba:	bd08      	pop	{r3, pc}
    13bc:	100004fc 	.word	0x100004fc
    13c0:	10000668 	.word	0x10000668
    13c4:	00001389 	.word	0x00001389

000013c8 <_Z20bootloader_usb_closev>:

void bootloader_usb_close() {
    USBHwConnect(FALSE);
    13c8:	2000      	movs	r0, #0
    13ca:	f7ff bc9a 	b.w	d02 <USBHwConnect>

000013ce <_Z7leds_onv>:
}

void leds_on() {
		TXLED_SET;
    13ce:	f44f 7280 	mov.w	r2, #256	; 0x100
    13d2:	4b03      	ldr	r3, [pc, #12]	; (13e0 <_Z7leds_onv+0x12>)
    13d4:	601a      	str	r2, [r3, #0]
		RXLED_SET;
    13d6:	2210      	movs	r2, #16
    13d8:	601a      	str	r2, [r3, #0]
		USRLED_SET;
    13da:	2202      	movs	r2, #2
    13dc:	601a      	str	r2, [r3, #0]
}
    13de:	4770      	bx	lr
    13e0:	2009c038 	.word	0x2009c038

000013e4 <_Z8leds_offv>:

void leds_off() {
		TXLED_CLR;
    13e4:	f44f 7280 	mov.w	r2, #256	; 0x100
    13e8:	4b03      	ldr	r3, [pc, #12]	; (13f8 <_Z8leds_offv+0x14>)
    13ea:	601a      	str	r2, [r3, #0]
		RXLED_CLR;
    13ec:	2210      	movs	r2, #16
    13ee:	601a      	str	r2, [r3, #0]
		USRLED_CLR;
    13f0:	2202      	movs	r2, #2
    13f2:	601a      	str	r2, [r3, #0]
}
    13f4:	4770      	bx	lr
    13f6:	bf00      	nop
    13f8:	2009c03c 	.word	0x2009c03c

000013fc <_Z11update_ledsv>:

/* chasing pattern indicates bootloader activity */
void update_leds() {
	count += 1;
	const uint32_t led_state = (count >> 16) % 6;
    13fc:	2106      	movs	r1, #6
	count += 1;
    13fe:	4a14      	ldr	r2, [pc, #80]	; (1450 <_Z11update_ledsv+0x54>)
    1400:	f8d2 3108 	ldr.w	r3, [r2, #264]	; 0x108
    1404:	3301      	adds	r3, #1
    1406:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
	const uint32_t led_state = (count >> 16) % 6;
    140a:	0c1b      	lsrs	r3, r3, #16
    140c:	fbb3 f2f1 	udiv	r2, r3, r1
    1410:	fb01 3312 	mls	r3, r1, r2, r3
    1414:	3b01      	subs	r3, #1
    1416:	f44f 7280 	mov.w	r2, #256	; 0x100
    141a:	2110      	movs	r1, #16
    141c:	2b04      	cmp	r3, #4
    141e:	d810      	bhi.n	1442 <_Z11update_ledsv+0x46>
    1420:	e8df f003 	tbb	[pc, r3]
    1424:	0f030903 	.word	0x0f030903
    1428:	14          	.byte	0x14
    1429:	00          	.byte	0x00
		TXLED_SET;
		RXLED_CLR;
		USRLED_CLR;
		break;
	case 1:
		TXLED_SET;
    142a:	4b0a      	ldr	r3, [pc, #40]	; (1454 <_Z11update_ledsv+0x58>)
    142c:	601a      	str	r2, [r3, #0]
		RXLED_SET;
    142e:	6019      	str	r1, [r3, #0]
		USRLED_CLR;
    1430:	2202      	movs	r2, #2
    1432:	605a      	str	r2, [r3, #4]
		break;
    1434:	4770      	bx	lr
	case 2:
		TXLED_SET;
    1436:	4b07      	ldr	r3, [pc, #28]	; (1454 <_Z11update_ledsv+0x58>)
		TXLED_SET;
		RXLED_CLR;
		USRLED_CLR;
		break;
	case 5:
		TXLED_CLR;
    1438:	601a      	str	r2, [r3, #0]
		RXLED_CLR;
		USRLED_CLR;
    143a:	2202      	movs	r2, #2
		RXLED_CLR;
    143c:	6019      	str	r1, [r3, #0]
		USRLED_CLR;
    143e:	601a      	str	r2, [r3, #0]
		break;
	}
}
    1440:	4770      	bx	lr
		TXLED_SET;
    1442:	4b04      	ldr	r3, [pc, #16]	; (1454 <_Z11update_ledsv+0x58>)
    1444:	601a      	str	r2, [r3, #0]
		RXLED_CLR;
    1446:	2210      	movs	r2, #16
    1448:	605a      	str	r2, [r3, #4]
		USRLED_CLR;
    144a:	e7f1      	b.n	1430 <_Z11update_ledsv+0x34>
		TXLED_CLR;
    144c:	4b02      	ldr	r3, [pc, #8]	; (1458 <_Z11update_ledsv+0x5c>)
    144e:	e7f3      	b.n	1438 <_Z11update_ledsv+0x3c>
    1450:	10000660 	.word	0x10000660
    1454:	2009c038 	.word	0x2009c038
    1458:	2009c03c 	.word	0x2009c03c

0000145c <_ZL14run_bootloaderv>:

static void run_bootloader()
{
    145c:	b510      	push	{r4, lr}
	leds_on();
    145e:	f7ff ffb6 	bl	13ce <_Z7leds_onv>
	bootloader_usb_init();
    1462:	f7ff ff9b 	bl	139c <_Z19bootloader_usb_initv>

	while( dfu.in_dfu_mode() ) {
    1466:	4c0f      	ldr	r4, [pc, #60]	; (14a4 <_ZL14run_bootloaderv+0x48>)
    1468:	480e      	ldr	r0, [pc, #56]	; (14a4 <_ZL14run_bootloaderv+0x48>)
    146a:	f000 f866 	bl	153a <_ZNK3DFU11in_dfu_modeEv>
    146e:	b928      	cbnz	r0, 147c <_ZL14run_bootloaderv+0x20>
		update_leds();
		if (use_timeout && dfu.dfu_virgin() && (count > DFU_TIMEOUT))
			break;
	}

	bootloader_usb_close();
    1470:	f7ff ffaa 	bl	13c8 <_Z20bootloader_usb_closev>
	leds_off();
}
    1474:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	leds_off();
    1478:	f7ff bfb4 	b.w	13e4 <_Z8leds_offv>
		USBHwISR();
    147c:	f7ff fd1c 	bl	eb8 <USBHwISR>
		update_leds();
    1480:	f7ff ffbc 	bl	13fc <_Z11update_ledsv>
		if (use_timeout && dfu.dfu_virgin() && (count > DFU_TIMEOUT))
    1484:	f894 310c 	ldrb.w	r3, [r4, #268]	; 0x10c
    1488:	2b00      	cmp	r3, #0
    148a:	d0ed      	beq.n	1468 <_ZL14run_bootloaderv+0xc>
    148c:	4620      	mov	r0, r4
    148e:	f000 f85a 	bl	1546 <_ZNK3DFU10dfu_virginEv>
    1492:	2800      	cmp	r0, #0
    1494:	d0e8      	beq.n	1468 <_ZL14run_bootloaderv+0xc>
    1496:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
    149a:	f5b3 1fc0 	cmp.w	r3, #1572864	; 0x180000
    149e:	d9e3      	bls.n	1468 <_ZL14run_bootloaderv+0xc>
    14a0:	e7e6      	b.n	1470 <_ZL14run_bootloaderv+0x14>
    14a2:	bf00      	nop
    14a4:	10000660 	.word	0x10000660

000014a8 <main>:
        "ldr     pc, [r3, #4]\n\t"  // initial program counter
    );
}

int main(void)
{
    14a8:	b510      	push	{r4, lr}
	gpio_init();
    14aa:	f7ff f841 	bl	530 <gpio_init>

	if (VBUS) {
    14ae:	4b16      	ldr	r3, [pc, #88]	; (1508 <main+0x60>)
    14b0:	681b      	ldr	r3, [r3, #0]
    14b2:	005a      	lsls	r2, r3, #1
    14b4:	d50f      	bpl.n	14d6 <main+0x2e>
		if (bootloader_ctrl == DFU_MODE) {
    14b6:	4c15      	ldr	r4, [pc, #84]	; (150c <main+0x64>)
    14b8:	4b15      	ldr	r3, [pc, #84]	; (1510 <main+0x68>)
    14ba:	6822      	ldr	r2, [r4, #0]
    14bc:	429a      	cmp	r2, r3
    14be:	d114      	bne.n	14ea <main+0x42>
			ubertooth_init();
    14c0:	f7ff fa40 	bl	944 <ubertooth_init>
			run_bootloader();
    14c4:	f7ff ffca 	bl	145c <_ZL14run_bootloaderv>
			bootloader_ctrl = 0;
    14c8:	2300      	movs	r3, #0
			wait(1);
    14ca:	2001      	movs	r0, #1
			bootloader_ctrl = 0;
    14cc:	6023      	str	r3, [r4, #0]
			reset();
		} else if (ENTRY_PIN) {
			use_timeout = true;
			ubertooth_init();
			run_bootloader();
			wait(1);
    14ce:	f7fe fff9 	bl	4c4 <wait>
			reset();
    14d2:	f7ff fa41 	bl	958 <reset>
    );
    14d6:	f244 0300 	movw	r3, #16384	; 0x4000
    14da:	f2c0 0300 	movt	r3, #0
    14de:	f8d3 d000 	ldr.w	sp, [r3]
    14e2:	f8d3 f004 	ldr.w	pc, [r3, #4]
	}

	run_application();

	return 0;
}
    14e6:	2000      	movs	r0, #0
    14e8:	bd10      	pop	{r4, pc}
		} else if (ENTRY_PIN) {
    14ea:	4b0a      	ldr	r3, [pc, #40]	; (1514 <main+0x6c>)
    14ec:	681b      	ldr	r3, [r3, #0]
    14ee:	025b      	lsls	r3, r3, #9
    14f0:	d4f1      	bmi.n	14d6 <main+0x2e>
			use_timeout = true;
    14f2:	2401      	movs	r4, #1
    14f4:	4b08      	ldr	r3, [pc, #32]	; (1518 <main+0x70>)
    14f6:	f883 410c 	strb.w	r4, [r3, #268]	; 0x10c
			ubertooth_init();
    14fa:	f7ff fa23 	bl	944 <ubertooth_init>
			run_bootloader();
    14fe:	f7ff ffad 	bl	145c <_ZL14run_bootloaderv>
			wait(1);
    1502:	4620      	mov	r0, r4
    1504:	e7e3      	b.n	14ce <main+0x26>
    1506:	bf00      	nop
    1508:	2009c034 	.word	0x2009c034
    150c:	1000001c 	.word	0x1000001c
    1510:	4305bb21 	.word	0x4305bb21
    1514:	2009c014 	.word	0x2009c014
    1518:	10000660 	.word	0x10000660

0000151c <_GLOBAL__sub_I__Z19dfu_request_handlerP12TSetupPacketPiPPh>:
static DFU dfu(flash);
    151c:	4802      	ldr	r0, [pc, #8]	; (1528 <_GLOBAL__sub_I__Z19dfu_request_handlerP12TSetupPacketPiPPh+0xc>)
    151e:	f200 110d 	addw	r1, r0, #269	; 0x10d
    1522:	f000 b803 	b.w	152c <_ZN3DFUC1ER5Flash>
    1526:	bf00      	nop
    1528:	10000660 	.word	0x10000660

0000152c <_ZN3DFUC1ER5Flash>:

DFU::DFU(Flash& flash) :
    flash(flash),
    status(OK),
    state(DFUIDLE),
    virginity(true) {
    152c:	f44f 7200 	mov.w	r2, #512	; 0x200
    1530:	8082      	strh	r2, [r0, #4]
    1532:	2201      	movs	r2, #1
    1534:	6001      	str	r1, [r0, #0]
    1536:	7182      	strb	r2, [r0, #6]
}
    1538:	4770      	bx	lr

0000153a <_ZNK3DFU11in_dfu_modeEv>:
        return false;
    }
}

bool DFU::in_dfu_mode() const {
    return (get_state() >= DFUIDLE);
    153a:	7940      	ldrb	r0, [r0, #5]
}
    153c:	2801      	cmp	r0, #1
    153e:	bf94      	ite	ls
    1540:	2000      	movls	r0, #0
    1542:	2001      	movhi	r0, #1
    1544:	4770      	bx	lr

00001546 <_ZNK3DFU10dfu_virginEv>:

bool DFU::dfu_virgin() const {
    return virginity;
}
    1546:	7980      	ldrb	r0, [r0, #6]
    1548:	4770      	bx	lr

0000154a <_ZN3DFU9set_stateENS_5StateE>:

void DFU::set_state(const State new_state) {
    state = new_state;
    virginity = false;
    154a:	2300      	movs	r3, #0
    state = new_state;
    154c:	7141      	strb	r1, [r0, #5]
    virginity = false;
    154e:	7183      	strb	r3, [r0, #6]
}
    1550:	4770      	bx	lr

00001552 <_ZNK3DFU9get_stateEv>:

uint8_t DFU::get_state() const {
    return state;
}
    1552:	7940      	ldrb	r0, [r0, #5]
    1554:	4770      	bx	lr

00001556 <_ZN3DFU10set_statusENS_6StatusE>:

void DFU::set_status(const Status new_status) {
    status = new_status;
    1556:	7101      	strb	r1, [r0, #4]
}
    1558:	4770      	bx	lr

0000155a <_ZNK3DFU10get_statusEv>:

uint8_t DFU::get_status() const {
    return status;
}
    155a:	7900      	ldrb	r0, [r0, #4]
    155c:	4770      	bx	lr

0000155e <_ZN3DFU5errorENS_6StatusE>:

bool DFU::error(const Status new_status) {
    if( (get_state() != APPIDLE) &&
    155e:	7943      	ldrb	r3, [r0, #5]
    status = new_status;
    1560:	7101      	strb	r1, [r0, #4]
    if( (get_state() != APPIDLE) &&
    1562:	2b01      	cmp	r3, #1
    state = new_state;
    1564:	bf81      	itttt	hi
    1566:	230a      	movhi	r3, #10
    1568:	7143      	strbhi	r3, [r0, #5]
    virginity = false;
    156a:	2300      	movhi	r3, #0
    156c:	7183      	strbhi	r3, [r0, #6]
        (get_state() != APPDETACH) ) {
         set_state(DFUERROR);
    }
    set_status(new_status);
    return false;
}
    156e:	2000      	movs	r0, #0
    1570:	4770      	bx	lr

00001572 <_ZNK3DFU20get_status_string_idEv>:

uint8_t DFU::get_status_string_id() const {
    return 0;
}
    1572:	2000      	movs	r0, #0
    1574:	4770      	bx	lr

00001576 <_ZNK3DFU16get_poll_timeoutEv>:

uint32_t DFU::get_poll_timeout() const {
    return 20;  // milliseconds
}
    1576:	2014      	movs	r0, #20
    1578:	4770      	bx	lr

0000157a <_ZN3DFU14request_detachEP12TSetupPacketPmPh>:

bool DFU::request_detach(TSetupPacket *pSetup, uint32_t *piLen, uint8_t* pbData) {
    if( (pSetup->wLength == 0) && (pSetup->wValue <= detach_timeout_ms) ) {
    157a:	88ca      	ldrh	r2, [r1, #6]
    157c:	b922      	cbnz	r2, 1588 <_ZN3DFU14request_detachEP12TSetupPacketPmPh+0xe>
    157e:	f643 2398 	movw	r3, #15000	; 0x3a98
    1582:	8849      	ldrh	r1, [r1, #2]
    1584:	4299      	cmp	r1, r3
    1586:	d902      	bls.n	158e <_ZN3DFU14request_detachEP12TSetupPacketPmPh+0x14>
        // TODO: Check DFU vs. APP mode, and reboot device if in DFU mode?
        set_state(APPDETACH);
        return true;
    } else {
        return error(ERRUNKNOWN);
    1588:	210e      	movs	r1, #14
    158a:	f7ff bfe8 	b.w	155e <_ZN3DFU5errorENS_6StatusE>
    state = new_state;
    158e:	2301      	movs	r3, #1
    virginity = false;
    1590:	7182      	strb	r2, [r0, #6]
    state = new_state;
    1592:	7143      	strb	r3, [r0, #5]
    }
}
    1594:	4618      	mov	r0, r3
    1596:	4770      	bx	lr

00001598 <_ZN3DFU14request_dnloadEP12TSetupPacketPmPh>:

bool DFU::request_dnload(TSetupPacket *pSetup, uint32_t *piLen, uint8_t *pbData) {
    1598:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    159c:	4698      	mov	r8, r3
    if( pSetup->wLength == 0 ) {
    159e:	88cb      	ldrh	r3, [r1, #6]
bool DFU::request_dnload(TSetupPacket *pSetup, uint32_t *piLen, uint8_t *pbData) {
    15a0:	4604      	mov	r4, r0
    if( pSetup->wLength == 0 ) {
    15a2:	b983      	cbnz	r3, 15c6 <_ZN3DFU14request_dnloadEP12TSetupPacketPmPh+0x2e>
        if( get_state() != DFUDNLOAD_IDLE ) {
    15a4:	7942      	ldrb	r2, [r0, #5]
    15a6:	2a05      	cmp	r2, #5
    15a8:	d006      	beq.n	15b8 <_ZN3DFU14request_dnloadEP12TSetupPacketPmPh+0x20>
            return error(ERRSTALLEDPKT);
    15aa:	210f      	movs	r1, #15
        const uint32_t source_address = reinterpret_cast<uint32_t>(pbData);
        if( memory_policy::write_permitted(flash_address) ) {
            if( flash.write(flash_address, source_address, length) ) {
                set_state(DFUDNLOAD_SYNC);
            } else {
                return error(ERRPROG);
    15ac:	4620      	mov	r0, r4
            return error(ERRWRITE);
        }
    } else {
        return error(ERRUNKNOWN);
    }
}
    15ae:	b002      	add	sp, #8
    15b0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        return error(ERRUNKNOWN);
    15b4:	f7ff bfd3 	b.w	155e <_ZN3DFU5errorENS_6StatusE>
    state = new_state;
    15b8:	2206      	movs	r2, #6
    virginity = false;
    15ba:	7183      	strb	r3, [r0, #6]
    state = new_state;
    15bc:	7142      	strb	r2, [r0, #5]
}
    15be:	2001      	movs	r0, #1
    15c0:	b002      	add	sp, #8
    15c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    } else if( pSetup->wLength == transfer_size ) {
    15c6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    15ca:	d140      	bne.n	164e <_ZN3DFU14request_dnloadEP12TSetupPacketPmPh+0xb6>
    return state;
    15cc:	7943      	ldrb	r3, [r0, #5]
        if( (get_state() != DFUIDLE) && (get_state() != DFUDNLOAD_IDLE) ) {
    15ce:	2b02      	cmp	r3, #2
    15d0:	d001      	beq.n	15d6 <_ZN3DFU14request_dnloadEP12TSetupPacketPmPh+0x3e>
    15d2:	2b05      	cmp	r3, #5
    15d4:	d1e9      	bne.n	15aa <_ZN3DFU14request_dnloadEP12TSetupPacketPmPh+0x12>
        const uint32_t flash_address = pSetup->wValue * transfer_size;
    15d6:	884d      	ldrh	r5, [r1, #2]
    15d8:	022d      	lsls	r5, r5, #8
        if( memory_policy::write_permitted(flash_address) ) {
    15da:	f5b5 4f80 	cmp.w	r5, #16384	; 0x4000
    15de:	d334      	bcc.n	164a <_ZN3DFU14request_dnloadEP12TSetupPacketPmPh+0xb2>
            return 32768;
        }
    }
                              
    uint32_t sector_number(const uint32_t address) const {
        if( address < 0x10000 ) {
    15e0:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
            return 4096;
    15e4:	bf32      	itee	cc
    15e6:	f44f 5380 	movcc.w	r3, #4096	; 0x1000
            return 32768;
    15ea:	f44f 4300 	movcs.w	r3, #32768	; 0x8000
            return address >> 12;
        } else {
            return 14 + (address >> 15);
    15ee:	0bee      	lsrcs	r6, r5, #15
        return (address & (sector_size(address) - 1)) == 0;
    15f0:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
            return address >> 12;
    15f4:	bf34      	ite	cc
    15f6:	0b2e      	lsrcc	r6, r5, #12
            return 14 + (address >> 15);
    15f8:	360e      	addcs	r6, #14
        if( at_sector_boundary(flash_address) ) {
    15fa:	422b      	tst	r3, r5
            if( flash.write(flash_address, source_address, length) ) {
    15fc:	6827      	ldr	r7, [r4, #0]
    15fe:	d013      	beq.n	1628 <_ZN3DFU14request_dnloadEP12TSetupPacketPmPh+0x90>
            result = iap.prepare_sectors_for_write_operation(sector, sector);
    1600:	4632      	mov	r2, r6
    1602:	4631      	mov	r1, r6
    1604:	4638      	mov	r0, r7
    1606:	f000 f8c5 	bl	1794 <_ZN3IAP35prepare_sectors_for_write_operationEmm>
        if( result == IAP::CMD_SUCCESS ) {
    160a:	4606      	mov	r6, r0
    160c:	b990      	cbnz	r0, 1634 <_ZN3DFU14request_dnloadEP12TSetupPacketPmPh+0x9c>
            iap.copy_ram_to_flash(flash_address, source_address, length, cclk_khz);
    160e:	4b11      	ldr	r3, [pc, #68]	; (1654 <_ZN3DFU14request_dnloadEP12TSetupPacketPmPh+0xbc>)
    1610:	4642      	mov	r2, r8
    1612:	9300      	str	r3, [sp, #0]
    1614:	4629      	mov	r1, r5
    1616:	f44f 7380 	mov.w	r3, #256	; 0x100
    161a:	4638      	mov	r0, r7
    161c:	f000 f8cc 	bl	17b8 <_ZN3IAP17copy_ram_to_flashEmmmm>
    state = new_state;
    1620:	2303      	movs	r3, #3
    virginity = false;
    1622:	71a6      	strb	r6, [r4, #6]
    state = new_state;
    1624:	7163      	strb	r3, [r4, #5]
            return true;
    1626:	e7ca      	b.n	15be <_ZN3DFU14request_dnloadEP12TSetupPacketPmPh+0x26>
                result = iap.prepare_sectors_for_write_operation(sector, sector);
    1628:	4632      	mov	r2, r6
    162a:	4631      	mov	r1, r6
    162c:	4638      	mov	r0, r7
    162e:	f000 f8b1 	bl	1794 <_ZN3IAP35prepare_sectors_for_write_operationEmm>
            if( result == IAP::CMD_SUCCESS) {
    1632:	b108      	cbz	r0, 1638 <_ZN3DFU14request_dnloadEP12TSetupPacketPmPh+0xa0>
                return error(ERRPROG);
    1634:	2106      	movs	r1, #6
    1636:	e7b9      	b.n	15ac <_ZN3DFU14request_dnloadEP12TSetupPacketPmPh+0x14>
                result = iap.erase_sectors(sector, sector, cclk_khz);
    1638:	4632      	mov	r2, r6
    163a:	4631      	mov	r1, r6
    163c:	4638      	mov	r0, r7
    163e:	4b05      	ldr	r3, [pc, #20]	; (1654 <_ZN3DFU14request_dnloadEP12TSetupPacketPmPh+0xbc>)
    1640:	f000 f8d0 	bl	17e4 <_ZN3IAP13erase_sectorsEmmm>
        if( result == IAP::CMD_SUCCESS) {
    1644:	2800      	cmp	r0, #0
    1646:	d0db      	beq.n	1600 <_ZN3DFU14request_dnloadEP12TSetupPacketPmPh+0x68>
    1648:	e7f4      	b.n	1634 <_ZN3DFU14request_dnloadEP12TSetupPacketPmPh+0x9c>
            return error(ERRWRITE);
    164a:	2103      	movs	r1, #3
    164c:	e7ae      	b.n	15ac <_ZN3DFU14request_dnloadEP12TSetupPacketPmPh+0x14>
        return error(ERRUNKNOWN);
    164e:	210e      	movs	r1, #14
    1650:	e7ad      	b.n	15ae <_ZN3DFU14request_dnloadEP12TSetupPacketPmPh+0x16>
    1652:	bf00      	nop
    1654:	000186a0 	.word	0x000186a0

00001658 <_ZN3DFU14request_uploadEP12TSetupPacketPmPh>:

bool DFU::request_upload(TSetupPacket *pSetup, uint32_t *piLen, uint8_t* pbData) {
    1658:	b570      	push	{r4, r5, r6, lr}
    165a:	4615      	mov	r5, r2
    if( pSetup->wLength == transfer_size ) {
    165c:	88ca      	ldrh	r2, [r1, #6]
bool DFU::request_upload(TSetupPacket *pSetup, uint32_t *piLen, uint8_t* pbData) {
    165e:	4604      	mov	r4, r0
    if( pSetup->wLength == transfer_size ) {
    1660:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
    1664:	d112      	bne.n	168c <_ZN3DFU14request_uploadEP12TSetupPacketPmPh+0x34>
    return state;
    1666:	7942      	ldrb	r2, [r0, #5]
        if( (get_state() != DFUIDLE) && (get_state() != DFUUPLOAD_IDLE) ) {
    1668:	2a02      	cmp	r2, #2
    166a:	d006      	beq.n	167a <_ZN3DFU14request_uploadEP12TSetupPacketPmPh+0x22>
    166c:	2a09      	cmp	r2, #9
    166e:	d004      	beq.n	167a <_ZN3DFU14request_uploadEP12TSetupPacketPmPh+0x22>
            return error(ERRSTALLEDPKT);
    1670:	210f      	movs	r1, #15
            return error(ERRADDRESS);
        }
    } else {
        return error(ERRUNKNOWN);
    }
}
    1672:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        return error(ERRUNKNOWN);
    1676:	f7ff bf72 	b.w	155e <_ZN3DFU5errorENS_6StatusE>
        const uint32_t flash_address_start = pSetup->wValue * transfer_size;
    167a:	884a      	ldrh	r2, [r1, #2]
        if( flash.valid_address(flash_address_start) && flash.valid_address(flash_address_end - 1) ) {
    167c:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
        const uint32_t flash_address_start = pSetup->wValue * transfer_size;
    1680:	ea4f 2102 	mov.w	r1, r2, lsl #8
        if( flash.valid_address(flash_address_start) && flash.valid_address(flash_address_end - 1) ) {
    1684:	d304      	bcc.n	1690 <_ZN3DFU14request_uploadEP12TSetupPacketPmPh+0x38>
            return error(ERRADDRESS);
    1686:	2108      	movs	r1, #8
    1688:	4620      	mov	r0, r4
    168a:	e7f2      	b.n	1672 <_ZN3DFU14request_uploadEP12TSetupPacketPmPh+0x1a>
        return error(ERRUNKNOWN);
    168c:	210e      	movs	r1, #14
    168e:	e7f0      	b.n	1672 <_ZN3DFU14request_uploadEP12TSetupPacketPmPh+0x1a>
            memcpy(pbData, reinterpret_cast<const void*>(flash_address_start), length);
    1690:	f44f 7680 	mov.w	r6, #256	; 0x100
    1694:	4618      	mov	r0, r3
    1696:	4632      	mov	r2, r6
    1698:	f000 f8e4 	bl	1864 <memcpy>
    state = new_state;
    169c:	2302      	movs	r3, #2
            *piLen = length;
    169e:	602e      	str	r6, [r5, #0]
    state = new_state;
    16a0:	7163      	strb	r3, [r4, #5]
    virginity = false;
    16a2:	2300      	movs	r3, #0
}
    16a4:	2001      	movs	r0, #1
    virginity = false;
    16a6:	71a3      	strb	r3, [r4, #6]
}
    16a8:	bd70      	pop	{r4, r5, r6, pc}

000016aa <_ZN3DFU17request_getstatusEP12TSetupPacketPmPh>:

bool DFU::request_getstatus(TSetupPacket *pSetup, uint32_t *piLen, uint8_t* pbData) {
    16aa:	b510      	push	{r4, lr}
    if( (pSetup->wValue == 0) && (pSetup->wLength == 6) ) {
    16ac:	884c      	ldrh	r4, [r1, #2]
    16ae:	b9dc      	cbnz	r4, 16e8 <_ZN3DFU17request_getstatusEP12TSetupPacketPmPh+0x3e>
    16b0:	88c9      	ldrh	r1, [r1, #6]
    16b2:	2906      	cmp	r1, #6
    16b4:	d11a      	bne.n	16ec <_ZN3DFU17request_getstatusEP12TSetupPacketPmPh+0x42>
    return state;
    16b6:	7941      	ldrb	r1, [r0, #5]
        switch( get_state() ) {
    16b8:	2903      	cmp	r1, #3
    16ba:	d00f      	beq.n	16dc <_ZN3DFU17request_getstatusEP12TSetupPacketPmPh+0x32>
    16bc:	2906      	cmp	r1, #6
    16be:	d011      	beq.n	16e4 <_ZN3DFU17request_getstatusEP12TSetupPacketPmPh+0x3a>
    return status;
    16c0:	7901      	ldrb	r1, [r0, #4]
                
            default:
                break;
        }
        
        pbData[0] = get_status();
    16c2:	7019      	strb	r1, [r3, #0]
        pbData[1] = (get_poll_timeout() >>  0) & 0xFF;
    16c4:	2114      	movs	r1, #20
    16c6:	7059      	strb	r1, [r3, #1]
        pbData[2] = (get_poll_timeout() >>  8) & 0xFF;
    16c8:	2100      	movs	r1, #0
    16ca:	7099      	strb	r1, [r3, #2]
        pbData[3] = (get_poll_timeout() >> 16) & 0xFF;
    16cc:	70d9      	strb	r1, [r3, #3]
    return state;
    16ce:	7940      	ldrb	r0, [r0, #5]
        pbData[4] = get_state();
        pbData[5] = get_status_string_id();
    16d0:	7159      	strb	r1, [r3, #5]
        pbData[4] = get_state();
    16d2:	7118      	strb	r0, [r3, #4]
        *piLen = 6;
    16d4:	2306      	movs	r3, #6
    16d6:	2001      	movs	r0, #1
    16d8:	6013      	str	r3, [r2, #0]
        return true;
    } else {
        return false;
    }
}
    16da:	bd10      	pop	{r4, pc}
    state = new_state;
    16dc:	2105      	movs	r1, #5
    16de:	7141      	strb	r1, [r0, #5]
    virginity = false;
    16e0:	7184      	strb	r4, [r0, #6]
}
    16e2:	e7ed      	b.n	16c0 <_ZN3DFU17request_getstatusEP12TSetupPacketPmPh+0x16>
    state = new_state;
    16e4:	2102      	movs	r1, #2
    16e6:	e7fa      	b.n	16de <_ZN3DFU17request_getstatusEP12TSetupPacketPmPh+0x34>
        return false;
    16e8:	2000      	movs	r0, #0
    16ea:	e7f6      	b.n	16da <_ZN3DFU17request_getstatusEP12TSetupPacketPmPh+0x30>
    16ec:	4620      	mov	r0, r4
    16ee:	e7f4      	b.n	16da <_ZN3DFU17request_getstatusEP12TSetupPacketPmPh+0x30>

000016f0 <_ZN3DFU17request_clrstatusEP12TSetupPacketPmPh>:

bool DFU::request_clrstatus(TSetupPacket *pSetup, uint32_t *piLen, uint8_t* pbData) {
    if( (pSetup->wValue == 0) && (pSetup->wLength == 0) ) {
    16f0:	884b      	ldrh	r3, [r1, #2]
    16f2:	b923      	cbnz	r3, 16fe <_ZN3DFU17request_clrstatusEP12TSetupPacketPmPh+0xe>
    16f4:	88cb      	ldrh	r3, [r1, #6]
    16f6:	b913      	cbnz	r3, 16fe <_ZN3DFU17request_clrstatusEP12TSetupPacketPmPh+0xe>
        if( get_state() == DFUERROR ) {
    16f8:	7942      	ldrb	r2, [r0, #5]
    16fa:	2a0a      	cmp	r2, #10
    16fc:	d002      	beq.n	1704 <_ZN3DFU17request_clrstatusEP12TSetupPacketPmPh+0x14>
            set_status(OK);
            set_state(DFUIDLE);
            return true;
        } else {
            return error(ERRUNKNOWN);
    16fe:	210e      	movs	r1, #14
    1700:	f7ff bf2d 	b.w	155e <_ZN3DFU5errorENS_6StatusE>
    status = new_status;
    1704:	f44f 7200 	mov.w	r2, #512	; 0x200
    virginity = false;
    1708:	7183      	strb	r3, [r0, #6]
    status = new_status;
    170a:	8082      	strh	r2, [r0, #4]
        }
    } else {
        return error(ERRUNKNOWN);
    }
}
    170c:	2001      	movs	r0, #1
    170e:	4770      	bx	lr

00001710 <_ZN3DFU16request_getstateEP12TSetupPacketPmPh>:

bool DFU::request_getstate(TSetupPacket *pSetup, uint32_t *piLen, uint8_t* pbData) {
    1710:	b410      	push	{r4}
    if( (pSetup->wValue == 0) && (pSetup->wLength == 1) ) {
    1712:	884c      	ldrh	r4, [r1, #2]
    1714:	b914      	cbnz	r4, 171c <_ZN3DFU16request_getstateEP12TSetupPacketPmPh+0xc>
    1716:	88c9      	ldrh	r1, [r1, #6]
    1718:	2901      	cmp	r1, #1
    171a:	d003      	beq.n	1724 <_ZN3DFU16request_getstateEP12TSetupPacketPmPh+0x14>
        pbData[0] = get_state();
        *piLen = 1;
        return true;
    } else {
        return error(ERRUNKNOWN);
    171c:	210e      	movs	r1, #14
    }
}
    171e:	bc10      	pop	{r4}
        return error(ERRUNKNOWN);
    1720:	f7ff bf1d 	b.w	155e <_ZN3DFU5errorENS_6StatusE>
    return state;
    1724:	7940      	ldrb	r0, [r0, #5]
}
    1726:	bc10      	pop	{r4}
        pbData[0] = get_state();
    1728:	7018      	strb	r0, [r3, #0]
}
    172a:	4608      	mov	r0, r1
        *piLen = 1;
    172c:	6011      	str	r1, [r2, #0]
}
    172e:	4770      	bx	lr

00001730 <_ZN3DFU13request_abortEP12TSetupPacketPmPh>:

bool DFU::request_abort(TSetupPacket *pSetup, uint32_t *piLen, uint8_t* pbData) {
    if( (pSetup->wValue == 0) && (pSetup->wLength == 0) ) {
    1730:	884b      	ldrh	r3, [r1, #2]
    1732:	b923      	cbnz	r3, 173e <_ZN3DFU13request_abortEP12TSetupPacketPmPh+0xe>
    1734:	88cb      	ldrh	r3, [r1, #6]
    1736:	b913      	cbnz	r3, 173e <_ZN3DFU13request_abortEP12TSetupPacketPmPh+0xe>
        if( get_state() != DFUERROR ) {
    1738:	7942      	ldrb	r2, [r0, #5]
    173a:	2a0a      	cmp	r2, #10
    173c:	d102      	bne.n	1744 <_ZN3DFU13request_abortEP12TSetupPacketPmPh+0x14>
            return error(ERRUNKNOWN);
    173e:	210e      	movs	r1, #14
    1740:	f7ff bf0d 	b.w	155e <_ZN3DFU5errorENS_6StatusE>
    state = new_state;
    1744:	2202      	movs	r2, #2
    virginity = false;
    1746:	7183      	strb	r3, [r0, #6]
    state = new_state;
    1748:	7142      	strb	r2, [r0, #5]
            return error(ERRUNKNOWN);
        }
    } else {
        return error(ERRUNKNOWN);
    }
}
    174a:	2001      	movs	r0, #1
    174c:	4770      	bx	lr

0000174e <_ZN3DFU15request_handlerEP12TSetupPacketPmPPh>:
bool DFU::request_handler(TSetupPacket *pSetup, uint32_t *piLen, uint8_t **ppbData) {
    174e:	b410      	push	{r4}
    1750:	784c      	ldrb	r4, [r1, #1]
    uint8_t* pbData = *ppbData;
    1752:	681b      	ldr	r3, [r3, #0]
    switch( pSetup->bRequest ) {
    1754:	2c06      	cmp	r4, #6
    1756:	d81a      	bhi.n	178e <_ZN3DFU15request_handlerEP12TSetupPacketPmPPh+0x40>
    1758:	e8df f004 	tbb	[pc, r4]
    175c:	0d0a0704 	.word	0x0d0a0704
    1760:	1310      	.short	0x1310
    1762:	16          	.byte	0x16
    1763:	00          	.byte	0x00
}
    1764:	bc10      	pop	{r4}
        return request_detach(pSetup, piLen, pbData);
    1766:	f7ff bf08 	b.w	157a <_ZN3DFU14request_detachEP12TSetupPacketPmPh>
}
    176a:	bc10      	pop	{r4}
        return request_dnload(pSetup, piLen, pbData);
    176c:	f7ff bf14 	b.w	1598 <_ZN3DFU14request_dnloadEP12TSetupPacketPmPh>
}
    1770:	bc10      	pop	{r4}
        return request_upload(pSetup, piLen, pbData);
    1772:	f7ff bf71 	b.w	1658 <_ZN3DFU14request_uploadEP12TSetupPacketPmPh>
}
    1776:	bc10      	pop	{r4}
        return request_getstatus(pSetup, piLen, pbData);
    1778:	f7ff bf97 	b.w	16aa <_ZN3DFU17request_getstatusEP12TSetupPacketPmPh>
}
    177c:	bc10      	pop	{r4}
        return request_clrstatus(pSetup, piLen, pbData);
    177e:	f7ff bfb7 	b.w	16f0 <_ZN3DFU17request_clrstatusEP12TSetupPacketPmPh>
}
    1782:	bc10      	pop	{r4}
        return request_getstate(pSetup, piLen, pbData);
    1784:	f7ff bfc4 	b.w	1710 <_ZN3DFU16request_getstateEP12TSetupPacketPmPh>
}
    1788:	bc10      	pop	{r4}
        return request_abort(pSetup, piLen, pbData);
    178a:	f7ff bfd1 	b.w	1730 <_ZN3DFU13request_abortEP12TSetupPacketPmPh>
}
    178e:	2000      	movs	r0, #0
    1790:	bc10      	pop	{r4}
    1792:	4770      	bx	lr

00001794 <_ZN3IAP35prepare_sectors_for_write_operationEmm>:
 */

#include "iap.h"

IAP::ReturnCode IAP::prepare_sectors_for_write_operation(const uint32_t start_sector_number,
                                               const uint32_t end_sector_number) {
    1794:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    uint32_t input[] = {
    1796:	2332      	movs	r3, #50	; 0x32
        50,
        start_sector_number,
        end_sector_number
    };
    1798:	e9cd 3101 	strd	r3, r1, [sp, #4]
    uint32_t output[] = {
    179c:	2301      	movs	r3, #1
        INVALID_COMMAND
    };
    
    entry_point(input, output);
    179e:	a801      	add	r0, sp, #4
    uint32_t output[] = {
    17a0:	9300      	str	r3, [sp, #0]
    entry_point(input, output);
    17a2:	4669      	mov	r1, sp
    17a4:	4b03      	ldr	r3, [pc, #12]	; (17b4 <_ZN3IAP35prepare_sectors_for_write_operationEmm+0x20>)
    };
    17a6:	9203      	str	r2, [sp, #12]
    entry_point(input, output);
    17a8:	4798      	blx	r3
    
    return static_cast<ReturnCode>(output[0]);
}
    17aa:	f89d 0000 	ldrb.w	r0, [sp]
    17ae:	b005      	add	sp, #20
    17b0:	f85d fb04 	ldr.w	pc, [sp], #4
    17b4:	1fff1ff1 	.word	0x1fff1ff1

000017b8 <_ZN3IAP17copy_ram_to_flashEmmmm>:

IAP::ReturnCode IAP::copy_ram_to_flash(const uint32_t destination_flash_address,
                             const uint32_t source_ram_address,
                             const uint32_t number_of_bytes_to_write,
                             const uint32_t cpu_clock_frequency_khz) {
    17b8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
        51,
        destination_flash_address,
        source_ram_address,
        number_of_bytes_to_write,
        cpu_clock_frequency_khz
    };
    17ba:	e9cd 2303 	strd	r2, r3, [sp, #12]
    17be:	9b08      	ldr	r3, [sp, #32]
    uint32_t input[] = {
    17c0:	2033      	movs	r0, #51	; 0x33
    };
    17c2:	9305      	str	r3, [sp, #20]
    uint32_t output[] = {
    17c4:	2301      	movs	r3, #1
    };
    17c6:	e9cd 0101 	strd	r0, r1, [sp, #4]
    uint32_t output[] = {
    17ca:	9300      	str	r3, [sp, #0]
        INVALID_COMMAND
    };
    
    entry_point(input, output);
    17cc:	a801      	add	r0, sp, #4
    17ce:	4669      	mov	r1, sp
    17d0:	4b03      	ldr	r3, [pc, #12]	; (17e0 <_ZN3IAP17copy_ram_to_flashEmmmm+0x28>)
    17d2:	4798      	blx	r3
    
    return static_cast<ReturnCode>(output[0]);
}
    17d4:	f89d 0000 	ldrb.w	r0, [sp]
    17d8:	b007      	add	sp, #28
    17da:	f85d fb04 	ldr.w	pc, [sp], #4
    17de:	bf00      	nop
    17e0:	1fff1ff1 	.word	0x1fff1ff1

000017e4 <_ZN3IAP13erase_sectorsEmmm>:

IAP::ReturnCode IAP::erase_sectors(const uint32_t start_sector_number,
                         const uint32_t end_sector_number,
                         const uint32_t cpu_clock_frequency_khz) {
    17e4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    uint32_t input[] = {
    17e6:	2034      	movs	r0, #52	; 0x34
        52,
        start_sector_number,
        end_sector_number,
        cpu_clock_frequency_khz
    };
    17e8:	e9cd 2304 	strd	r2, r3, [sp, #16]
    uint32_t output[] = {
    17ec:	2301      	movs	r3, #1
    };
    17ee:	e9cd 0102 	strd	r0, r1, [sp, #8]
    uint32_t output[] = {
    17f2:	9301      	str	r3, [sp, #4]
        INVALID_COMMAND
    };
    
    entry_point(input, output);
    17f4:	a802      	add	r0, sp, #8
    17f6:	4b04      	ldr	r3, [pc, #16]	; (1808 <_ZN3IAP13erase_sectorsEmmm+0x24>)
    17f8:	a901      	add	r1, sp, #4
    17fa:	4798      	blx	r3
    
    return static_cast<ReturnCode>(output[0]);
}
    17fc:	f89d 0004 	ldrb.w	r0, [sp, #4]
    1800:	b007      	add	sp, #28
    1802:	f85d fb04 	ldr.w	pc, [sp], #4
    1806:	bf00      	nop
    1808:	1fff1ff1 	.word	0x1fff1ff1

0000180c <_ZN3IAP19blank_check_sectorsEmm>:

IAP::ReturnCode IAP::blank_check_sectors(const uint32_t start_sector_number,
                               const uint32_t end_sector_number) {
    180c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    uint32_t input[] = {
    180e:	2335      	movs	r3, #53	; 0x35
        53,
        start_sector_number,
        end_sector_number
    };
    1810:	9202      	str	r2, [sp, #8]
    1812:	e9cd 3100 	strd	r3, r1, [sp]
    uint32_t output[] = {
    1816:	2201      	movs	r2, #1
    1818:	2300      	movs	r3, #0
        INVALID_COMMAND,
        0,
        0
    };
    
    entry_point(input, output);
    181a:	4668      	mov	r0, sp
    uint32_t output[] = {
    181c:	e9cd 2303 	strd	r2, r3, [sp, #12]
    1820:	9305      	str	r3, [sp, #20]
    entry_point(input, output);
    1822:	a903      	add	r1, sp, #12
    1824:	4b03      	ldr	r3, [pc, #12]	; (1834 <_ZN3IAP19blank_check_sectorsEmm+0x28>)
    1826:	4798      	blx	r3
    
    return static_cast<ReturnCode>(output[0]);
}
    1828:	f89d 000c 	ldrb.w	r0, [sp, #12]
    182c:	b007      	add	sp, #28
    182e:	f85d fb04 	ldr.w	pc, [sp], #4
    1832:	bf00      	nop
    1834:	1fff1ff1 	.word	0x1fff1ff1

00001838 <_ZN3IAP7compareEmmm>:

IAP::ReturnCode IAP::compare(const uint32_t destination_address,
                   const uint32_t source_address,
                   const uint32_t number_of_bytes_to_compare) {
    1838:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    uint32_t input[] = {
    183a:	2038      	movs	r0, #56	; 0x38
        56,
        destination_address,
        source_address,
        number_of_bytes_to_compare
    };
    183c:	e9cd 2304 	strd	r2, r3, [sp, #16]
    uint32_t output[] = {
    1840:	2201      	movs	r2, #1
    1842:	2300      	movs	r3, #0
    };
    1844:	e9cd 0102 	strd	r0, r1, [sp, #8]
    uint32_t output[] = {
    1848:	e9cd 2300 	strd	r2, r3, [sp]
        INVALID_COMMAND,
        0
    };
    
    entry_point(input, output);
    184c:	a802      	add	r0, sp, #8
    184e:	4669      	mov	r1, sp
    1850:	4b03      	ldr	r3, [pc, #12]	; (1860 <_ZN3IAP7compareEmmm+0x28>)
    1852:	4798      	blx	r3
    
    return static_cast<ReturnCode>(output[0]);
}
    1854:	f89d 0000 	ldrb.w	r0, [sp]
    1858:	b007      	add	sp, #28
    185a:	f85d fb04 	ldr.w	pc, [sp], #4
    185e:	bf00      	nop
    1860:	1fff1ff1 	.word	0x1fff1ff1

00001864 <memcpy>:
    1864:	4684      	mov	ip, r0
    1866:	ea41 0300 	orr.w	r3, r1, r0
    186a:	f013 0303 	ands.w	r3, r3, #3
    186e:	d149      	bne.n	1904 <memcpy+0xa0>
    1870:	3a40      	subs	r2, #64	; 0x40
    1872:	d323      	bcc.n	18bc <memcpy+0x58>
    1874:	680b      	ldr	r3, [r1, #0]
    1876:	6003      	str	r3, [r0, #0]
    1878:	684b      	ldr	r3, [r1, #4]
    187a:	6043      	str	r3, [r0, #4]
    187c:	688b      	ldr	r3, [r1, #8]
    187e:	6083      	str	r3, [r0, #8]
    1880:	68cb      	ldr	r3, [r1, #12]
    1882:	60c3      	str	r3, [r0, #12]
    1884:	690b      	ldr	r3, [r1, #16]
    1886:	6103      	str	r3, [r0, #16]
    1888:	694b      	ldr	r3, [r1, #20]
    188a:	6143      	str	r3, [r0, #20]
    188c:	698b      	ldr	r3, [r1, #24]
    188e:	6183      	str	r3, [r0, #24]
    1890:	69cb      	ldr	r3, [r1, #28]
    1892:	61c3      	str	r3, [r0, #28]
    1894:	6a0b      	ldr	r3, [r1, #32]
    1896:	6203      	str	r3, [r0, #32]
    1898:	6a4b      	ldr	r3, [r1, #36]	; 0x24
    189a:	6243      	str	r3, [r0, #36]	; 0x24
    189c:	6a8b      	ldr	r3, [r1, #40]	; 0x28
    189e:	6283      	str	r3, [r0, #40]	; 0x28
    18a0:	6acb      	ldr	r3, [r1, #44]	; 0x2c
    18a2:	62c3      	str	r3, [r0, #44]	; 0x2c
    18a4:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    18a6:	6303      	str	r3, [r0, #48]	; 0x30
    18a8:	6b4b      	ldr	r3, [r1, #52]	; 0x34
    18aa:	6343      	str	r3, [r0, #52]	; 0x34
    18ac:	6b8b      	ldr	r3, [r1, #56]	; 0x38
    18ae:	6383      	str	r3, [r0, #56]	; 0x38
    18b0:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
    18b2:	63c3      	str	r3, [r0, #60]	; 0x3c
    18b4:	3040      	adds	r0, #64	; 0x40
    18b6:	3140      	adds	r1, #64	; 0x40
    18b8:	3a40      	subs	r2, #64	; 0x40
    18ba:	d2db      	bcs.n	1874 <memcpy+0x10>
    18bc:	3230      	adds	r2, #48	; 0x30
    18be:	d30b      	bcc.n	18d8 <memcpy+0x74>
    18c0:	680b      	ldr	r3, [r1, #0]
    18c2:	6003      	str	r3, [r0, #0]
    18c4:	684b      	ldr	r3, [r1, #4]
    18c6:	6043      	str	r3, [r0, #4]
    18c8:	688b      	ldr	r3, [r1, #8]
    18ca:	6083      	str	r3, [r0, #8]
    18cc:	68cb      	ldr	r3, [r1, #12]
    18ce:	60c3      	str	r3, [r0, #12]
    18d0:	3010      	adds	r0, #16
    18d2:	3110      	adds	r1, #16
    18d4:	3a10      	subs	r2, #16
    18d6:	d2f3      	bcs.n	18c0 <memcpy+0x5c>
    18d8:	320c      	adds	r2, #12
    18da:	d305      	bcc.n	18e8 <memcpy+0x84>
    18dc:	f851 3b04 	ldr.w	r3, [r1], #4
    18e0:	f840 3b04 	str.w	r3, [r0], #4
    18e4:	3a04      	subs	r2, #4
    18e6:	d2f9      	bcs.n	18dc <memcpy+0x78>
    18e8:	3204      	adds	r2, #4
    18ea:	d008      	beq.n	18fe <memcpy+0x9a>
    18ec:	07d2      	lsls	r2, r2, #31
    18ee:	bf1c      	itt	ne
    18f0:	f811 3b01 	ldrbne.w	r3, [r1], #1
    18f4:	f800 3b01 	strbne.w	r3, [r0], #1
    18f8:	d301      	bcc.n	18fe <memcpy+0x9a>
    18fa:	880b      	ldrh	r3, [r1, #0]
    18fc:	8003      	strh	r3, [r0, #0]
    18fe:	4660      	mov	r0, ip
    1900:	4770      	bx	lr
    1902:	bf00      	nop
    1904:	2a08      	cmp	r2, #8
    1906:	d313      	bcc.n	1930 <memcpy+0xcc>
    1908:	078b      	lsls	r3, r1, #30
    190a:	d0b1      	beq.n	1870 <memcpy+0xc>
    190c:	f010 0303 	ands.w	r3, r0, #3
    1910:	d0ae      	beq.n	1870 <memcpy+0xc>
    1912:	f1c3 0304 	rsb	r3, r3, #4
    1916:	1ad2      	subs	r2, r2, r3
    1918:	07db      	lsls	r3, r3, #31
    191a:	bf1c      	itt	ne
    191c:	f811 3b01 	ldrbne.w	r3, [r1], #1
    1920:	f800 3b01 	strbne.w	r3, [r0], #1
    1924:	d3a4      	bcc.n	1870 <memcpy+0xc>
    1926:	f831 3b02 	ldrh.w	r3, [r1], #2
    192a:	f820 3b02 	strh.w	r3, [r0], #2
    192e:	e79f      	b.n	1870 <memcpy+0xc>
    1930:	3a04      	subs	r2, #4
    1932:	d3d9      	bcc.n	18e8 <memcpy+0x84>
    1934:	3a01      	subs	r2, #1
    1936:	f811 3b01 	ldrb.w	r3, [r1], #1
    193a:	f800 3b01 	strb.w	r3, [r0], #1
    193e:	d2f9      	bcs.n	1934 <memcpy+0xd0>
    1940:	780b      	ldrb	r3, [r1, #0]
    1942:	7003      	strb	r3, [r0, #0]
    1944:	784b      	ldrb	r3, [r1, #1]
    1946:	7043      	strb	r3, [r0, #1]
    1948:	788b      	ldrb	r3, [r1, #2]
    194a:	7083      	strb	r3, [r0, #2]
    194c:	4660      	mov	r0, ip
    194e:	4770      	bx	lr

00001950 <_exit>:
    1950:	e7fe      	b.n	1950 <_exit>
    1952:	bf00      	nop

00001954 <_global_impure_ptr>:
    1954:	0030 1000                                   0...

00001958 <iap_entry>:
    1958:	1ff1 1fff                                   ....

0000195c <abExtendedOsFeatureDescriptor>:
    195c:	0028 0000 0100 0004 0001 0000 0000 0000     (...............
    196c:	0100 4957 554e 4253 0000 0000 0000 0000     ..WINUSB........
    197c:	0000 0000 0000 0000                         ........

00001984 <_ZN3IAP11entry_pointE>:
    1984:	1ff1 1fff                                   ....

00001988 <__EH_FRAME_BEGIN__>:
    1988:	0000 0000                                   ....

0000198c <_init>:
    198c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    198e:	bf00      	nop
    1990:	bcf8      	pop	{r3, r4, r5, r6, r7}
    1992:	bc08      	pop	{r3}
    1994:	469e      	mov	lr, r3
    1996:	4770      	bx	lr

00001998 <__init_array_start>:
    1998:	0000040d 	.word	0x0000040d

0000199c <__frame_dummy_init_array_entry>:
    199c:	00000135 0000151d                       5.......

000019a4 <_fini>:
    19a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    19a6:	bf00      	nop
    19a8:	bcf8      	pop	{r3, r4, r5, r6, r7}
    19aa:	bc08      	pop	{r3}
    19ac:	469e      	mov	lr, r3
    19ae:	4770      	bx	lr

000019b0 <__do_global_dtors_aux_fini_array_entry>:
    19b0:	010d 0000                                   ....

000019b4 <__fini_array_end>:
    19b4:	00000000 	.word	0x00000000
